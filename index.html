<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.png" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.20/fancybox/fancybox.css" integrity="sha256-RvRHGSuWAxZpXKV9lLDt2e+rZ+btzn48Wp4ueS3NZKs=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"ancao96.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.18.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":true,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"algolia":{"appID":"ZQDKLA2K5M","indexName":"ZQDKLA2K5M","hits":{"per_page":10}},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":true,"preload":true,"path":"search.xml","field":"post","content":true,"format":"html"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="SCY SPACE">
<meta property="og:url" content="https://ancao96.github.io/index.html">
<meta property="og:site_name" content="SCY SPACE">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="SCY">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://ancao96.github.io/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>SCY SPACE</title>
    







<link rel="dns-prefetch" href="https://waline-server-nxpj3ksyo-scy.vercel.app">
    <noscript>
      <link rel="stylesheet" href="/css/noscript.css">
    </noscript>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.0.0/style.css" />
    <style>
      body,div.post-body,h1,h2,h3,h4 {
        font-family: "LXGW WenKai LITE", sans-serif;
        font-size: 108%;
      }
    </style>
  </head>
  <body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
    <div class="headband"></div>
    <main class="main">
      <div class="column">
        <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">SCY SPACE</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">4</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">4</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">17</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container">
  <div class="algolia-stats"><hr></div>
  <div class="algolia-hits"></div>
  <div class="algolia-pagination"></div>
</div>

    </div>
  </div>

</header>
          
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="SCY"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">SCY</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/AnCao96" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;AnCao96" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:ancao.cugb@gmail.com" title="E-Mail → mailto:ancao.cugb@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
        <div class="pjax">
        </div>
  </aside>


      </div>
      <div class="main-inner index posts-expand">

    


<div class="post-block">
    
    

    <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
        <link itemprop="mainEntityOfPage" href="https://ancao96.github.io/2023/08/25/2023-8-25-16-%E7%BB%93%E8%AE%BA/">

        <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
            <meta itemprop="image" content="/images/avatar.gif">
            <meta itemprop="name" content="SCY">
        </span>

        <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
            <meta itemprop="name" content="SCY SPACE">
            <meta itemprop="description" content="">
        </span>

        <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
            <meta itemprop="name" content="undefined | SCY SPACE">
            <meta itemprop="description" content="">
        </span>
        <header class="post-header">
            <h2 class="post-title" itemprop="name headline">
                <a href="/2023/08/25/2023-8-25-16-%E7%BB%93%E8%AE%BA/" class="post-title-link" itemprop="url">(16)结论</a>
            </h2>

            <div class="post-meta-container">
                <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-08-25 17:21:20" itemprop="dateCreated datePublished" datetime="2023-08-25T17:21:20+08:00">2023-08-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-09-05 19:12:53" itemprop="dateModified" datetime="2023-09-05T19:12:53+08:00">2023-09-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/R/" itemprop="url" rel="index"><span itemprop="name">R</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/R/Geocomputaion/" itemprop="url" rel="index"><span itemprop="name">Geocomputaion</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2023/08/25/2023-8-25-16-%E7%BB%93%E8%AE%BA/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2023/08/25/2023-8-25-16-%E7%BB%93%E8%AE%BA/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>7.4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>27 分钟</span>
    </span>
</div>

            </div>
        </header>

        
        
        
        <div class="post-body" itemprop="articleBody">
            <h1 id="引言">引言</h1>
<p>与引言一样，这个结尾章节也包含了很少的代码块。其目的是综合本书的内容，引用重复出现的主题/概念，并激发未来应用和发展的方向。本章不需要先修知识。然而，如果您已经阅读并尝试了第一部分（基础）中的练习，并考虑了地理计算如何帮助您解决工作、研究或其他问题，参考了第三部分（应用）中的章节，那么您可能会从中获得更多收益。</p>
<p>本章的组织如下。<em>选择包</em>节讨论了在R中处理地理数据的各种选择。选择是开源软件的一个关键特性；本节提供了在不同选项之间进行选择的指导。<em>空缺</em>节描述了本书内容的不足之处，并解释了为什么一些研究领域被有意省略，而其他领域受到强调。这个讨论引出了一个问题（<em>下一步</em>节中得到解答）：在阅读了本书之后，下一步去哪里？<em>开源方法</em>节回到了<em>引言</em>章中提出的更广泛问题。在这一部分中，我们将地理计算视为更广泛的“开源方法”的一部分，确保方法是公开可访问、可复现并受到协作社区的支持。本书的最后一节还提供了一些参与的指导。</p>
<h1 id="选择包">选择包</h1>
<p>R以及开源软件的一个一般特点是，通常有多种方法可以实现相同的结果。下面的代码块通过使用三个函数，这些函数在<em>属性操作</em>和<em>几何操作</em>章中有介绍，将新西兰的16个地区合并为一个单一的几何图形：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">library<span class="punctuation">(</span>spData<span class="punctuation">)</span></span><br><span class="line">nz_u1 <span class="operator">=</span> sf<span class="operator">::</span>st_union<span class="punctuation">(</span>nz<span class="punctuation">)</span></span><br><span class="line">nz_u2 <span class="operator">=</span> aggregate<span class="punctuation">(</span>nz<span class="punctuation">[</span><span class="string">&quot;Population&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="built_in">list</span><span class="punctuation">(</span><span class="built_in">rep</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span> nrow<span class="punctuation">(</span>nz<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">sum</span><span class="punctuation">)</span></span><br><span class="line">nz_u3 <span class="operator">=</span> dplyr<span class="operator">::</span>summarise<span class="punctuation">(</span>nz<span class="punctuation">,</span> t <span class="operator">=</span> <span class="built_in">sum</span><span class="punctuation">(</span>Population<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">identical<span class="punctuation">(</span>nz_u1<span class="punctuation">,</span> nz_u2<span class="operator">$</span>geometry<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] TRUE</span></span><br><span class="line">identical<span class="punctuation">(</span>nz_u1<span class="punctuation">,</span> nz_u3<span class="operator">$</span>geom<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] TRUE</span></span><br></pre></td></tr></table></figure>
<p>虽然结果对象 <code>nz_u1</code> 到 <code>nz_u3</code>
的类、属性和列名不同，但它们的几何图形是相同的，可以通过使用基本的R函数
<code>identical()</code> 来验证。<a href="#fn1" class="footnote-ref"
id="fnref1"
role="doc-noteref"><sup>1</sup></a>应该选择哪个呢？这取决于情况：前者仅处理包含在
<code>nz</code>
中的几何数据，因此速度更快，而其他选项执行了属性操作，这对于后续步骤可能有用。在使用基本的
R 函数 <code>aggregate()</code> 还是 <strong>dplyr</strong> 函数
<code>summarise()</code>
时，取决于个人偏好，后者在许多情况下更易读。</p>
<p>更重要的是，在R中处理地理数据时，通常有多种选择，甚至在单个包内也是如此。在考虑更多R包时，选择范围会进一步增加：例如，您可以使用较旧的
<strong>sp</strong>
包来实现相同的结果。然而，基于我们提供良好建议的目标，我们建议使用更近期、更高性能且未来可靠的
<strong>sf</strong>
包。在本书中展示的所有包都适用于同样的原则，尽管了解替代方案并能够为自己选择的软件进行合理的辩解可能会有所帮助（当不会分散注意力时）。</p>
<p>一个常见的选择，没有简单的答案，就是在地理计算中选择
<strong>tidyverse</strong>还是基本的R。例如，下面的代码块展示了在
<strong>tidyverse</strong> 和基本的R中从 <code>nz</code> 对象中提取
<code>Name</code> 列的方法，正如在<em>属性操作</em>章中描述的：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">library<span class="punctuation">(</span>dplyr<span class="punctuation">)</span>                          <span class="comment"># attach tidyverse package</span></span><br><span class="line">nz_name1 <span class="operator">=</span> nz<span class="punctuation">[</span><span class="string">&quot;Name&quot;</span><span class="punctuation">]</span>                   <span class="comment"># base R approach</span></span><br><span class="line">nz_name2 <span class="operator">=</span> nz <span class="operator">|&gt;</span>                        <span class="comment"># tidyverse approach</span></span><br><span class="line">  select<span class="punctuation">(</span>Name<span class="punctuation">)</span></span><br><span class="line">identical<span class="punctuation">(</span>nz_name1<span class="operator">$</span>Name<span class="punctuation">,</span> nz_name2<span class="operator">$</span>Name<span class="punctuation">)</span> <span class="comment"># check results</span></span><br><span class="line"><span class="comment">#&gt; [1] TRUE</span></span><br></pre></td></tr></table></figure>
<p>这引出了一个问题：该选择哪个呢？答案是：取决于情况。每种方法都有其优势：基本的
R
往往是稳定、众所周知的，且依赖性较小，因此在软件（包）开发中通常更受欢迎。另一方面，<strong>tidyverse</strong>
方法通常更适用于交互式编程。因此，在这两种方法之间做出选择是一种个人偏好和应用问题。</p>
<p>虽然本书涵盖了常常需要的函数，例如基本的 R <code>[</code>
子集运算符和上面代码块中演示的 <strong>dplyr</strong> 函数
<code>select()</code>，但还有许多其他用于处理地理数据的函数，来自其他包，尚未提及。<em>引言</em>章提到了适用于处理地理数据的
20
多个有影响力的包，但在本书中只涵盖了其中几个。数以百计的其他包可用于在 R
中处理地理数据，并且每年都有更多的包在不断发展。截至 2023 年中，Spatial
<a target="_blank" rel="noopener" href="https://cran.r-project.org/web/views/">Task View</a>
中提到的包超过 160 个，每年都会开发出无数用于地理数据分析的函数。</p>
<p>R
的空间生态系统的发展速度可能很快，但有许多策略可以处理多样的选择。我们的建议是从深入学习一种方法开始，但要对现有选项的<em>广度</em>有一个普遍的了解。这个建议同样适用于使用
R
解决地理问题，就像适用于其他领域的知识和应用一样。<em>下一步</em>章节涵盖了其他语言的发展。</p>
<p>当然，对于<em>相同</em>的任务，有些包的性能优于其他包，这种情况下了解哪个包更合适是很重要的。在本书中，我们的目标是专注于那些具有未来性（它们将在很长时间内工作）、高性能（相对于其他
R
包）的、得到很好维护的（拥有用户和开发者社区的支持）以及互补性的包。尽管我们使用的包存在重叠，就像在<em>高级制图</em>章中强调的制作地图的多样性包一样。</p>
<p>重叠的功能是有好处的。一个具有与现有包类似（但不完全相同）功能的新包可以增强韧性、性能（部分是由开发者之间的友好竞争和相互学习推动的）和选择性，这都是使用开源软件进行地理计算的关键优势。在这种情况下，决定使用
<strong>sf</strong>、<strong>tidyverse</strong>、<strong>terra</strong>
或其他包的组合应该是在了解替代方案的基础上做出的。例如，<strong>sf</strong>
旨在替代的 <strong>sp</strong>
生态系统可以执行本书中涵盖的许多操作，由于其年龄较长，许多其他包都在其基础上构建。截至
2023 年 5 月，463 个包 <code>Depend</code> 或 <code>Import</code>
<strong>sp</strong>，略高于 2018 年的 452
个，显示其数据结构被广泛使用，并且在许多方向上得到了扩展。<strong>sf</strong>
的相应数字分别为 2018 年的 69 个和 2023 年的 431
个，这突显了该包具有未来性，拥有不断增长的用户群和开发者社区。尽管以点模式分析而闻名，<strong>spatstat</strong>
包也支持栅格和其他矢量几何，提供了强大的空间统计功能等。如果您的需求在已建立的包中无法满足，还值得研究正在开发中的新替代方案。</p>
<h1 id="空缺和重叠">空缺和重叠</h1>
<p>地理计算是一个庞大的领域，因此这本书中不可避免地有一些空白。我们进行了选择，故意强调某些主题、技术和包，同时省略了其他内容。我们试图强调在实际应用中最常需要的主题，例如地理数据操作、坐标参考系统的基础知识、读/写数据操作和可视化技术。有些主题和主题会反复出现，目的是建立地理计算的基础技能，并向您展示如何进一步深入更高级的主题和特定应用。</p>
<p>我们故意省略了一些在其他地方有深入讨论的主题。例如，空间数据的统计建模，如点模式分析、空间插值（克里金法）和空间回归，在<em>统计学习</em>章的机器学习背景下有提及，但没有详细介绍。关于这些方法已有优秀的资源，包括统计导向章节，以及关于点模式分析、应用于空间数据的贝叶斯技术，以及特定应用方面的书籍，如健康和<a
target="_blank" rel="noopener" href="https://bookdown.org/mcwimberly/gdswr-book/application---wildfire-severity-analysis.html">野火严重性分析</a>。受到有限关注的其他主题包括遥感以及使用R与（而不是作为桥接到）专用GIS软件。关于这些主题有很多资源，包括@wegmann_remote_2016和来自<a
target="_blank" rel="noopener" href="https://moc.online.uni-marburg.de/doku.php">马尔堡大学</a>的GIS相关教学材料。</p>
<p>在<em>统计学习</em>和<em>生态</em>章中，我们更关注机器学习而非空间统计推断，因为有关这个主题的高质量资源很多。这些资源包括@zuur_mixed_2009、<span
class="citation"
data-cites="zuur_beginners_2017">@zuur_beginners_2017</span>，它们专注于生态学用例，以及在<a
target="_blank" rel="noopener" href="http://www.css.cornell.edu/faculty/dgr2/teach/">css.cornell.edu/faculty/dgr2</a>托管的<em>Geostatistics
&amp; Open-source Statistical Computing</em>的免费教学材料和代码。<a
target="_blank" rel="noopener" href="https://sdesabbata.github.io/r-for-geographic-data-science/"><em>R
for Geographic Data
Science</em></a>提供了R用于地理数据科学和建模的入门。</p>
<p>我们基本上没有涉及到'大数据'地理计算，也就是那些不适合在高配置笔记本上运行的数据集。这一决定是基于大多数用于常见研究或政策应用的地理数据集<em>确实</em>适合在消费级硬件上运行，大型高分辨率遥感数据集是一个值得注意的例外（参见<em>云服务</em>节）。您可以在计算机上增加更多RAM，或者暂时在像<a
target="_blank" rel="noopener" href="https://github.com/codespaces/new?hide_repo_select=true&amp;ref=main&amp;repo=84222786&amp;machine=basicLinux32gb&amp;devcontainer_path=.devcontainer.json&amp;location=WestEurope">GitHub
Codespaces这样的平台上</a>“租用”计算能力，以运行本书中的代码。此外，学习如何在小数据集上解决问题是解决大数据集问题的先决条件，本书的重点是入门，您在这里学到的技能在您转向更大的数据集时也将是有用的。'大数据'分析通常涉及从数据库中提取少量数据进行特定的统计分析。<em>GIS</em>章涵盖的空间数据库可以帮助分析不适合在内存中运行的数据集。'地球观测云后端'可以通过<strong>openeo</strong>包从R中访问，如<a
target="_blank" rel="noopener" href="https://openeo.org/">openeo.org</a>网站所述。如果您需要处理大型地理数据集，我们建议探索像<a
target="_blank" rel="noopener" href="https://sedona.apache.org/">Apache
Sedona</a>这样的项目以及新兴的文件格式，如<a
target="_blank" rel="noopener" href="https://paleolimbot.github.io/geoarrow/">GeoParquet</a>。</p>
<h1 id="获取帮助">获取帮助</h1>
<!-- 现在我在思考这应该是一个附录，还是甚至应该是一个新的章节？-->
<!-- 在章节*引言*中，我们指出本书主张的方法“可以帮助你去除软件对你创造力的限制”。-->
<!-- 我们已经涵盖了许多技巧，这些应该能让你将很多创意转化为可复制和可扩展的代码，用于研究和应用地理计算。 -->
<!-- 然而，创造力涉及到提出*新的*想法，这些还没有被实施，这就提出了一个问题：当软件*确实*因为你不确定如何实施你的创意而产生限制时，会发生什么？-->
<!-- 在章节*引言*中，我们明确了我们的目标，即提供坚实的基础，以便可以在此基础上进行广泛的数据分析、研究以及方法论和软件开发项目。-->
<!-- 地理计算不仅仅是关于使用现有技术，而且是关于开发新工具，这涉及到生成新知识。 -->
<p>地理计算是一个庞大而具有挑战性的领域，几乎不可避免地会出现问题和暂时的工作障碍。在许多情况下，你可能会在数据分析流程的某个特定点“卡住”，面对难以调试的神秘错误信息。或者你可能会得到意外的结果，却鲜有线索来了解发生了什么。本节提供了一些指导，以帮助你通过明确地定义问题、搜索现有解决方案的知识，以及（如果这些方法没有解决问题）通过提出好问题来克服这些问题。
<!-- 通过与社群的互动生成新的公开知识。 --></p>
<p>当你在某一特定点遇到困难时，首先值得退一步思考哪种方法最有可能解决这个问题。尝试以下列出的步骤——跳过已经尝试过的步骤——提供了一种结构化的问题解决方法：</p>
<ol type="1">
<li>确切地定义你试图实现的目标，从最基本的原则开始（通常如下所述，从一个草图开始）</li>
<li>通过运行和探索代码的单独行及其各个组件的输出，确切地诊断出代码中哪里出现了意外的结果（例如，在RStudio中，你可以通过用光标选择它们并按Ctrl+Enter来运行复杂命令的单个部分）</li>
<li>阅读在上一步被诊断为‘失败点’的函数的文档。仅仅通过了解函数所需的输入，以及运行通常在帮助页面底部提供的示例，就可以解决相当大比例的问题（例如，运行命令
<code>?terra::rast</code>
并向下滚动到值得在开始使用该函数时复制的示例）</li>
<li>如果阅读R内置的文档，如上一步所述，没有帮助解决问题，那么可能是时候在网上进行更广泛的搜索，看看是否有其他人写过你所遇到的问题。以下列出了寻找帮助的地方</li>
<li>如果上面所有的步骤都失败了，并且你从在线搜索中也找不到解决方案，那么可能是时候用一个可复现的示例来组织一个问题，并在适当的地方发布了</li>
</ol>
<p>以上概述的1到3步相对容易理解，但由于互联网的广阔和多种多样的搜索选项，值得在决定提出问题之前考虑有效的搜索策略。</p>
<h2 id="在线搜索解决方案">在线搜索解决方案</h2>
<p>搜索引擎是解决许多问题的合理起点。'Google一下'在某些情况下可能会发现关于你所遇到的确切问题的博客文章、论坛消息和其他在线内容。在这里简单地输入问题/问题的清晰描述是一个有效的方法，但重要的是要具体（例如，如果问题特定于数据集，则参考函数和软件包名称以及输入数据集来源）。您还可以通过包括额外的细节来提高在线搜索的效果：
<!-- 为了提供一个具体的例子，假设你想知道如何在交互式地图中使用自定义符号。 --></p>
<ul>
<li>使用引号来最大化与您所遇到的确切问题有关的“命中”的机会，从而减少返回的结果数量。例如，如果你尝试并未能在已存在的位置保存一个GeoJSON文件，你会收到一个包含"GDAL
Error 6: DeleteLayer() not supported by this
dataset"的错误消息。具体的搜索查询，如<code>"GDAL Error 6" sf</code>，比不带引号的<code>GDAL Error 6</code>更有可能找到一个解决方案。</li>
<li>设置<a
target="_blank" rel="noopener" href="https://uk.pcmag.com/software-services/138320/21-google-search-tips-youll-want-to-learn">时间限制</a>，例如，仅返回在过去一年内创建的内容，在搜索关于不断演变的软件包的帮助时可能很有用。</li>
<li>利用额外的<a
target="_blank" rel="noopener" href="https://www.makeuseof.com/tag/6-ways-to-search-by-date-on-google/">搜索引擎功能</a>，例如限制搜索内容只来自CRAN，使用site:r-project.org。</li>
</ul>
<h2 id="寻找和提问帮助的地方">寻找（和提问）帮助的地方</h2>
<p>在在线搜索没有找到解决方案的情况下，值得寻求帮助。有很多论坛可以做到这一点，包括：</p>
<ul>
<li>R地理数据特别兴趣组邮件列表（<a
target="_blank" rel="noopener" href="https://stat.ethz.ch/mailman/listinfo/r-sig-geo">R-SIG-GEO</a>）</li>
<li>GIS Stackexchange网站 <a
target="_blank" rel="noopener" href="https://gis.stackexchange.com/">gis.stackexchange.com</a></li>
<li>大型和通用编程问答网站 <a
target="_blank" rel="noopener" href="https://stackoverflow.com/">stackoverflow.com</a></li>
<li>与特定实体关联的在线论坛，例如 <a
target="_blank" rel="noopener" href="https://community.rstudio.com/">RStudio Community</a>，<a
target="_blank" rel="noopener" href="https://discuss.ropensci.org/">rOpenSci
Discuss</a>网络论坛，以及与特定软件工具关联的论坛，例如 <a
target="_blank" rel="noopener" href="https://discourse.mc-stan.org/">Stan</a> 论坛</li>
<li>软件开发平台，如GitHub，它托管了大多数R-空间软件包的问题跟踪器，而且越来越多地有内置的讨论页面，例如为了鼓励围绕
<strong>sfnetworks</strong> 软件包（参见 <a
target="_blank" rel="noopener" href="https://github.com/luukvdmeer/sfnetworks/discussions/">luukvdmeer/sfnetworks/discussions</a>）的讨论（而不仅仅是报告bug）而创建的。</li>
<li>与如 <a
target="_blank" rel="noopener" href="https://ropensci.org/blog/2022/09/13/contributing-ropensci/">rOpenSci</a>
和 <a target="_blank" rel="noopener" href="https://geocompx.org">geocompx</a> 社区（该社区有一个 <a
target="_blank" rel="noopener" href="https://discord.gg/PMztXYgNxp">Discord
服务器</a>，您可以在那里提问）相关联的在线聊天室和论坛，这本书也是其中的一部分。</li>
</ul>
<h2 id="使用-reprex-创建可复现的示例">使用 <strong>reprex</strong>
创建可复现的示例</h2>
<p>在提出一个好问题方面，一个明确陈述的问题并由一个易于获取和完全可复现的示例支持是关键（也可参见
https://r4ds.hadley.nz/workflow-help.html）。在展示了从用户角度看“不起作用”的代码后，解释您希望看到什么也是有帮助的。用于创建可复现示例的一个非常有用的工具是
<strong>reprex</strong>
包。要突出显示意外行为，您可以编写完全可复现的代码来演示问题，然后使用
<code>reprex()</code>
函数创建一个可以粘贴到论坛或其他在线空间的代码副本。</p>
<p>假设你正试图用蓝色的海和绿色的陆地创建一个世界地图。您可以简单地在上一节中概述的某个地方询问如何做到这一点。然而，如果您提供了到目前为止您尝试的可复现示例，您很可能会得到更好的回应。以下代码创建了一个带有蓝色海洋和绿色陆地的世界地图，但陆地没有填充：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">library<span class="punctuation">(</span>sf<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>spData<span class="punctuation">)</span></span><br><span class="line">plot<span class="punctuation">(</span>st_geometry<span class="punctuation">(</span>world<span class="punctuation">)</span><span class="punctuation">,</span> col <span class="operator">=</span> <span class="string">&quot;green&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>如果您在论坛上发布了这段代码，您很可能会得到更具体和有用的回应。例如，有人可能会用以下代码作为回应，这段代码可以明显地解决问题，如下图所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">library<span class="punctuation">(</span>sf<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>spData<span class="punctuation">)</span></span><br><span class="line"><span class="comment"># use the bg argument to fill in the land</span></span><br><span class="line">plot<span class="punctuation">(</span>st_geometry<span class="punctuation">(</span>world<span class="punctuation">)</span><span class="punctuation">,</span> col <span class="operator">=</span> <span class="string">&quot;green&quot;</span><span class="punctuation">,</span> bg <span class="operator">=</span> <span class="string">&quot;lightblue&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309051851873.png" />
A map of the world with green land, illustrating a question with a
reproducible example (left) and the solution (right).</p>
<p>给读者的练习：复制上面的代码，运行命令
<code>reprex::reprex()</code>（或将命令粘贴到 <code>reprex()</code>
函数调用中），并将输出粘贴到论坛或其他在线空间。</p>
<p>地理计算的开源和协作方法的一个优点是它们生成了一个庞大且不断发展的知识体系，本书就是其中的一部分。展示你自己解决问题的努力，并提供问题的可复现示例，是对这一知识体系做出贡献的一种方式。</p>
<h2 id="定义和草绘问题">定义和草绘问题</h2>
<p>在某些情况下，您可能无法在线找到解决问题的方案，或者您可能无法构建一个可以通过搜索引擎回答的问题。在这种情况下，或者在开发新的地理计算方法时，最好的起点可能是一支笔和一张纸（或相当于数字草图工具，如
<a target="_blank" rel="noopener" href="https://excalidraw.com/">Excalidraw</a> 和 <a
target="_blank" rel="noopener" href="https://www.tldraw.com/">tldraw</a>，它们允许协作式草图和快速分享思想）。在方法开发工作的最具创造性的早期阶段，<em>任何类型</em>的软件都可能减缓您的思维速度，并使您的思考偏离重要的抽象思想。强烈推荐用数学来构建问题，并参考一个您可以数字化地草绘“前后”版本的最小示例。如果您具备相关技能并且问题需要这样做，用代数方式描述方法在某些情况下可能有助于开发有效的实现。</p>
<h1 id="where-to-go-next">Where to go next?</h1>
<p>As indicated in Section @ref(gaps), the book has covered only a
fraction of the R's geographic ecosystem, and there is much more to
discover. We have progressed quickly, from geographic data models in
Chapter @ref(spatial-class), to advanced applications in Chapter
@ref(eco). Consolidation of skills learned, discovery of new packages
and approaches for handling geographic data, and application of the
methods to new datasets and domains are suggested future directions.
This section expands on this general advice by suggesting specific 'next
steps', highlighted in <strong>bold</strong> below.</p>
<p>In addition to learning about further geographic methods and
applications with R, for example with reference to the work cited in the
previous section, deepening your understanding of <strong>R
itself</strong> is a logical next step. R's fundamental classes such as
<code>data.frame</code> and <code>matrix</code> are the foundation of
<code>sf</code> and <code>raster</code> classes, so studying them will
improve your understanding of geographic data. This can be done with
reference to documents that are part of R, and which can be found with
the command <code>help.start()</code> and additional resources on the
subject such as those by <span class="citation"
data-cites="wickham_advanced_2019">@wickham_advanced_2019</span> and
<span class="citation"
data-cites="chambers_extending_2016">@chambers_extending_2016</span>.</p>
<p>Another software-related direction for future learning is
<strong>discovering geocomputation with other languages</strong>. There
are good reasons for learning R as a language for geocomputation, as
described in Chapter @ref(intro), but it is not the only option.<a
href="#fn2" class="footnote-ref" id="fnref2"
role="doc-noteref"><sup>2</sup></a> It would be possible to study
<em>Geocomputation with: Python</em>, <em>C++</em>, <em>JavaScript</em>,
<em>Scala</em> or <em>Rust</em> in equal depth. Each has evolving
geospatial capabilities. <a
target="_blank" rel="noopener" href="https://github.com/mapbox/rasterio"><strong>rasterio</strong></a>,
for example, is a Python package with similar functionality as the
<strong>terra</strong> package used in this book. See <a
target="_blank" rel="noopener" href="https://py.geocompx.org/"><em>Geocomputation with Python</em></a>,
for an introduction to geocomputation with Python.</p>
<p>Dozens of geospatial libraries have been developed in C++, including
well known libraries such as GDAL and GEOS, and less well known
libraries such as the <strong><a
target="_blank" rel="noopener" href="https://github.com/orfeotoolbox/OTB">Orfeo Toolbox</a></strong>
for processing remote sensing (raster) data. <a
target="_blank" rel="noopener" href="https://github.com/Turfjs/turf"><strong>Turf.js</strong></a> is an
example of the potential for doing geocomputation with JavaScript. <a
target="_blank" rel="noopener" href="https://geotrellis.io/">GeoTrellis</a> provides functions for
working with raster and vector data in the Java-based language Scala.
And <a
target="_blank" rel="noopener" href="https://github.com/jblindsay/whitebox-tools">WhiteBoxTools</a>
provides an example of a rapidly evolving command-line GIS implemented
in Rust. Each of these packages/libraries/languages has advantages for
geocomputation and there are many more to discover, as documented in the
curated list of open source geospatial resources <a
target="_blank" rel="noopener" href="https://github.com/sacridini/Awesome-Geospatial">Awesome-Geospatial</a>.</p>
<p>There is more to geocomputation than software, however. We can
recommend <strong>exploring and learning new research topics and
methods</strong> from academic and theoretical perspectives. Many
methods that have been written about have yet to be implemented.
Learning about geographic methods and potential applications can
therefore be rewarding, before writing any code. An example of
geographic methods that are increasingly implemented in R is sampling
strategies for scientific applications. A next step in this case is to
read-up on relevant articles in the area such as <span class="citation"
data-cites="brus_sampling_2018">@brus_sampling_2018</span>, which is
accompanied by reproducible code and tutorial content hosted at <a
target="_blank" rel="noopener" href="https://github.com/DickBrus/TutorialSampling4DSM">github.com/DickBrus/TutorialSampling4DSM</a>.
## 接下来去哪里？</p>
<p>正如<em>空缺</em>节所指出的，本书仅涵盖了R地理生态系统的一部分，还有更多需要发现的内容。我们已经迅速前进，从<em>空间数据</em>章的地理数据模型到<em>生态</em>章的高级应用。建议的未来方向是巩固所学技能，发现用于处理地理数据的新包和方法，并将这些方法应用于新数据集和领域。本节通过提出以下<strong>粗体</strong>突出显示的具体“下一步”来扩展这一通用建议。</p>
<p>除了通过参考前一节中引用的作品来进一步了解R中的地理方法和应用外，加深对
<strong>R本身</strong> 的理解是一个合乎逻辑的下一步。R的基础类，如
<code>data.frame</code> 和 <code>matrix</code>，是 <code>sf</code> 和
<code>raster</code>
类的基础，因此学习它们将提高您对地理数据的理解。这可以通过参考R的一部分文档来完成，这些文档可以通过
<code>help.start()</code> 命令以及 <span class="citation"
data-cites="wickham_advanced_2019">@wickham_advanced_2019</span> 和
<span class="citation"
data-cites="chambers_extending_2016">@chambers_extending_2016</span>
等主题的其他资源来找到。</p>
<p>未来学习的另一个与软件相关的方向是
<strong>用其他语言发现地理计算</strong>。学习R作为地理计算的语言有很好的理由，如<em>引言</em>章所述，但这不是唯一的选项。例如，<a
target="_blank" rel="noopener" href="https://github.com/mapbox/rasterio"><strong>rasterio</strong></a>
是一个具有与本书中使用的 <strong>terra</strong>
包类似功能的Python包。参见 <a
target="_blank" rel="noopener" href="https://py.geocompx.org/"><em>Geocomputation with
Python</em></a>，以了解用Python进行地理计算的介绍。</p>
<p>数十个地理空间库已经用C++开发出来，包括众所周知的库，如GDAL和GEOS，以及不太为人知的库，如用于处理遥感（栅格）数据的<strong><a
target="_blank" rel="noopener" href="https://github.com/orfeotoolbox/OTB">Orfeo
Toolbox</a></strong>。<a
target="_blank" rel="noopener" href="https://github.com/Turfjs/turf"><strong>Turf.js</strong></a>
是用JavaScript进行地理计算潜力的一个例子。<a
target="_blank" rel="noopener" href="https://geotrellis.io/">GeoTrellis</a>
提供了用基于Java的语言Scala处理栅格和矢量数据的函数。<a
target="_blank" rel="noopener" href="https://github.com/jblindsay/whitebox-tools">WhiteBoxTools</a>
是用Rust实现的快速发展的命令行GIS的一个例子。这些包/库/语言各有其地理计算的优点，还有更多等待你去发现，如在开源地理空间资源的策划列表
<a
target="_blank" rel="noopener" href="https://github.com/sacridini/Awesome-Geospatial">Awesome-Geospatial</a>
中有文档。</p>
<p>然而，地理计算不仅仅是软件。我们推荐<strong>探索和学习新的研究主题和方法</strong>，从学术和理论的角度出发。许多已经被写过的方法尚未实施。因此，在编写任何代码之前，了解地理方法和潜在的应用可能是有益的。一个地理方法越来越多地在R中实现的例子是用于科学应用的抽样策略。接下来的一步是阅读该领域的相关文章，如@brus_sampling_2018，它附带有可复制的代码和存放在<a
target="_blank" rel="noopener" href="https://github.com/DickBrus/TutorialSampling4DSM">github.com/DickBrus/TutorialSampling4DSM</a>
的教程内容。</p>
<h1 id="开源方法">开源方法</h1>
<p>这是一本技术性的书，因此在前一节中概述的下一步也应是技术性的。然而，在这最后一节中，还有更广泛的问题值得考虑，这将回到我们对地理计算的定义。在<em>引言</em>章介绍的术语元素之一是地理方法应具有积极的影响。当然，如何定义和衡量'积极'是一个主观的、哲学的问题，超出了本书的范围。不论你的世界观如何，考虑地理计算工作的影响是一个有用的练习：积极影响的潜力可以为未来的学习提供强有力的动力，相反地，新方法可以开放许多可能的应用领域。这些考虑导致了一个结论：地理计算是更广泛的“开源方法”的一部分。</p>
<p><em>什么是地理计算</em>节介绍了与地理计算大致意义相同的其他术语，包括地理数据科学（GDS）和'GIScience'。两者都捕捉到了使用地理数据的实质，但地理计算有优势：它简洁地捕捉到了这本书所倡导的用地理数据进行'计算'的工作方式——在代码中实现，因此鼓励可重复性——并基于其早期定义的有益成分：</p>
<ul>
<li>地理数据的<em>创造性</em>使用</li>
<li>应用于<em>实际问题</em></li>
<li>构建'科学'工具</li>
<li>可重复性</li>
</ul>
<p>我们增加了最后一个成分：早期关于地理计算的工作几乎没有提到可重复性，但可以为它是前两个成分的重要组成部分提出有力的理由。可重复性</p>
<ul>
<li>通过将焦点从基础（通过共享代码容易获得）转向应用，鼓励<em>创造性</em>；</li>
<li>阻止人们'重复造轮子'：如果其他人的方法可以被其他人使用，就没有必要重新做；</li>
<li>使研究更有利于实际应用，通过使任何行业的任何人都能在新的领域应用你的方法。</li>
</ul>
<p>如果可重复性是地理计算（或命令行GIS）的定义资产，那么值得考虑的是什么使它可重复。
这引导我们到'开源方法'，它有三个主要组成部分：</p>
<ul>
<li>命令行界面（CLI），鼓励分享和重现地理工作的脚本</li>
<li>开源软件，可以被世界上的任何人检查和可能改进</li>
<li>一个活跃的开发者社区，合作和自组织来构建互补和模块化的工具</li>
</ul>
<p>像地理计算这个术语一样，开源方法不仅仅是一个技术实体。它是一个由人组成的社群，每天都在与共享目标进行互动：生产高性能的工具，没有商业或法律限制，任何人都可以使用。与地理数据一起工作的开源方法具有超越软件工作技术性的优点，鼓励学习、合作和劳动力的有效划分。</p>
<p>有很多方式可以参与这个社群，尤其是随着代码托管网站（如GitHub）的出现，这些网站鼓励沟通和合作。一个好的开始就是简单地浏览一些感兴趣的地理包的源代码、'问题'和'提交'。在<code>r-spatial/sf</code>
GitHub仓库快速查看，该仓库托管了<strong>sf</strong>包的底层代码，显示有100+人对代码库和文档做出了贡献。更多人通过提问和对<strong>sf</strong>使用的'上游'包做出贡献。在其<a
target="_blank" rel="noopener" href="https://github.com/r-spatial/sf/issues">问题追踪器</a>上已经关闭了超过1,600个问题，代表了大量的工作，使<strong>sf</strong>更快、更稳定和用户友好。这个例子，仅仅是数十个包中的一个，显示了为使R成为一个高效且不断发展的地理计算语言所进行的知识操作的规模。</p>
<p>观察公共论坛（如GitHub）上不断发展的开发活动是有教育意义的，但成为一个活跃的参与者更加有益。这是开源方法的最大特点之一：它鼓励人们参与。这本书本身就是开源方法的一个结果：它是由R在过去二十年里地理能力的惊人发展所激发的，但是通过对合作平台上的对话和代码共享而实际可能。我们希望，除了传播与地理数据一起工作的有用方法外，这本书还能激励你采取更开源的方法。</p>
<aside id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>第一个操作由函数 <code>st_union()</code>
执行，创建了一个 <code>sfc</code>
类的对象（一个简单要素列）。后两个操作创建了 <code>sf</code>
对象，每个对象都<em>包含</em>一个简单要素列。因此，相同的是包含在简单要素列中的几何图形，而不是对象本身。<a
href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p> R's strengths are particularly relevant to our
definition of geocomputation due to its emphasis on scientific
reproducibility, widespread use in academic research and unparalleled
support for statistical modeling of geographic data. Furthermore, we
advocate learning one language for geocomputation in depth before
delving into other languages/frameworks because of the costs associated
with context switching, and R is an excellent starting point on your
geocomputational journey.<a href="#fnref2" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>

            
        </div>

        
        
        

        <div>
            
        </div>

        <footer class="post-footer">
            <div class="post-eof"></div>
            
        </footer>
    </article>
</div>




    


<div class="post-block">
    
    

    <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
        <link itemprop="mainEntityOfPage" href="https://ancao96.github.io/2023/08/24/2023-8-24-15-%E7%94%9F%E6%80%81/">

        <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
            <meta itemprop="image" content="/images/avatar.gif">
            <meta itemprop="name" content="SCY">
        </span>

        <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
            <meta itemprop="name" content="SCY SPACE">
            <meta itemprop="description" content="">
        </span>

        <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
            <meta itemprop="name" content="undefined | SCY SPACE">
            <meta itemprop="description" content="">
        </span>
        <header class="post-header">
            <h2 class="post-title" itemprop="name headline">
                <a href="/2023/08/24/2023-8-24-15-%E7%94%9F%E6%80%81/" class="post-title-link" itemprop="url">(1)介绍</a>
            </h2>

            <div class="post-meta-container">
                <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-08-24 01:49:20" itemprop="dateCreated datePublished" datetime="2023-08-24T01:49:20+08:00">2023-08-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-09-04 11:11:27" itemprop="dateModified" datetime="2023-09-04T11:11:27+08:00">2023-09-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/R/" itemprop="url" rel="index"><span itemprop="name">R</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/R/Geocomputaion/" itemprop="url" rel="index"><span itemprop="name">Geocomputaion</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2023/08/24/2023-8-24-15-%E7%94%9F%E6%80%81/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2023/08/24/2023-8-24-15-%E7%94%9F%E6%80%81/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>7.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>26 分钟</span>
    </span>
</div>

            </div>
        </header>

        
        
        
        <div class="post-body" itemprop="articleBody">
            <p>本章通过模拟雾绿洲（也叫<em>lomas</em>）的植被分布，揭示了明显受到水源供应控制的不同植被区域。这个案例研究不仅整合了前几章中的核心观点，还拓展了这些观点，帮助你更全面地掌握使用R进行地理计算的相关技能。
            <!--noindex-->
            <div class="post-button">
                <a class="btn" href="/2023/08/24/2023-8-24-15-%E7%94%9F%E6%80%81/#more" rel="contents">
                    阅读全文 &raquo;
                </a>
            </div>
            <!--/noindex-->
            
            
        </div>

        
        
        

        <div>
            
        </div>

        <footer class="post-footer">
            <div class="post-eof"></div>
            
        </footer>
    </article>
</div>




    


<div class="post-block">
    
    

    <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
        <link itemprop="mainEntityOfPage" href="https://ancao96.github.io/2023/08/23/2023-8-23-14-%E5%9C%B0%E7%90%86%E8%90%A5%E9%94%80/">

        <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
            <meta itemprop="image" content="/images/avatar.gif">
            <meta itemprop="name" content="SCY">
        </span>

        <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
            <meta itemprop="name" content="SCY SPACE">
            <meta itemprop="description" content="">
        </span>

        <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
            <meta itemprop="name" content="undefined | SCY SPACE">
            <meta itemprop="description" content="">
        </span>
        <header class="post-header">
            <h2 class="post-title" itemprop="name headline">
                <a href="/2023/08/23/2023-8-23-14-%E5%9C%B0%E7%90%86%E8%90%A5%E9%94%80/" class="post-title-link" itemprop="url">(14)地理营销</a>
            </h2>

            <div class="post-meta-container">
                <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-08-23 15:33:20" itemprop="dateCreated datePublished" datetime="2023-08-23T15:33:20+08:00">2023-08-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-09-05 18:02:26" itemprop="dateModified" datetime="2023-09-05T18:02:26+08:00">2023-09-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/R/" itemprop="url" rel="index"><span itemprop="name">R</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/R/Geocomputaion/" itemprop="url" rel="index"><span itemprop="name">Geocomputaion</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2023/08/23/2023-8-23-14-%E5%9C%B0%E7%90%86%E8%90%A5%E9%94%80/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2023/08/23/2023-8-23-14-%E5%9C%B0%E7%90%86%E8%90%A5%E9%94%80/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>19 分钟</span>
    </span>
</div>

            </div>
        </header>

        
        
        
        <div class="post-body" itemprop="articleBody">
            <ul>
<li>T本章要求使用下列包 (<strong>tmaptools</strong> 必须安装）:</li>
</ul>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">library<span class="punctuation">(</span>sf<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>dplyr<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>purrr<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>terra<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>osmdata<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>spDataLarge<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>必要的数据将会在适当的时候下载。</li>
</ul>
<p>为了方便读者并确保易于复现，我们已将下载的数据放在
<strong>spDataLarge</strong> 包中供使用。</p>
<h1 id="引言">引言</h1>
<p>本章展示了在第一部分和第二部分学到的技能如何应用于特定领域：地理营销（有时也称为位置分析或位置智能）。这是一个广泛的研究和商业应用领域。地理营销的典型例子是如何选择一个新店的位置。这里的目标是吸引最多的顾客，最终实现最大的利润。此外，还有许多非商业应用可以利用这种技术来造福公众，例如选择新的卫生服务设施的位置。</p>
<p>人类对于位置分析来说是基本要素，特别是人们可能会在哪里花费时间和其他资源。有趣的是，生态学的概念和模型与用于店铺选址分析的概念和模型非常相似。动植物可以在某些“最优”位置最好地满足其需求，这些位置是基于随空间变化的变量确定的。这是地理计算和地理信息科学的一个重要优势：概念和方法可以转移到其他领域。例如，北极熊更喜欢气温较低且食物（海豹和海狮）丰富的北纬地区。同样地，人类倾向于聚集在某些地方，创造出类似于北极地区的生态位的经济位。位置分析的主要任务是基于现有数据找出这些特定服务的“最优位置”在哪里。典型的研究问题包括：</p>
<ul>
<li>目标群体居住在哪里，他们经常去哪些地区？</li>
<li>竞争的商店或服务位于哪里？</li>
<li>有多少人可以轻松到达特定的商店？</li>
<li>现有的服务是否过度或不足地利用了市场潜力？</li>
<li>公司在特定地区的市场份额是多少？</li>
</ul>
<p>本章通过一个基于实际数据的假设案例研究，演示了地理计算如何回答这些问题。</p>
<h1 id="案例研究德国自行车商店">案例研究：德国自行车商店</h1>
<p>假设您正在德国开设一家自行车连锁店。这些店铺应该位于尽可能多的潜在顾客所在的城市地区。此外，一个虚构的调查（仅用于本章，非商业用途！）表明，单身年轻男性（年龄在20到40岁之间）最有可能购买您的产品：这就是<em>目标受众</em>。幸运的是，您有足够的资本来开设多家店铺。但是，它们应该放在哪里呢？咨询公司（雇佣地理营销分析师的公司）通常会收取高额费用来回答此类问题。幸运的是，借助开放数据和开源软件，我们可以自己解决这些问题。以下几节将演示如何将本书前几章学到的技术应用于执行服务位置分析中的常见步骤：</p>
<ul>
<li>整理来自德国人口普查的输入数据</li>
<li>将表格化的人口普查数据转换为栅格对象</li>
<li>识别人口密度较高的大都市地区</li>
<li>为这些地区下载详细的地理数据（使用<strong>osmdata</strong>从OpenStreetMap下载）</li>
<li>使用地图代数创建评分栅格，以评估不同位置的相对吸引力</li>
</ul>
<p>尽管我们将这些步骤应用于一个特定的案例研究，但它们可以推广到许多店铺选址或公共服务提供的情景。</p>
<h1 id="整理数据">整理数据</h1>
<p>德国政府提供了分辨率为1公里或100米的栅格化人口普查数据。下面的代码块用于下载、解压缩和读取1公里分辨率的数据。
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">download.file<span class="punctuation">(</span><span class="string">&quot;https://tinyurl.com/ybtpkwxz&quot;</span><span class="punctuation">,</span> </span><br><span class="line">              destfile <span class="operator">=</span> <span class="string">&quot;census.zip&quot;</span><span class="punctuation">,</span> mode <span class="operator">=</span> <span class="string">&quot;wb&quot;</span><span class="punctuation">)</span></span><br><span class="line">unzip<span class="punctuation">(</span><span class="string">&quot;census.zip&quot;</span><span class="punctuation">)</span> <span class="comment"># unzip the files</span></span><br><span class="line">census_de <span class="operator">=</span> readr<span class="operator">::</span>read_csv2<span class="punctuation">(</span>list.files<span class="punctuation">(</span>pattern <span class="operator">=</span> <span class="string">&quot;Gitter.csv&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure></p>
<p>请注意，<code>census_de</code> 数据也可以从
<strong>spDataLarge</strong> 包中获取：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data<span class="punctuation">(</span><span class="string">&quot;census_de&quot;</span><span class="punctuation">,</span> package <span class="operator">=</span> <span class="string">&quot;spDataLarge&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><code>census_de</code>
对象是一个包含13个变量的数据框，涵盖德国境内超过360,000个栅格单元。对于我们的工作，我们只需要其中的一个子集：东向坐标
(<code>x</code>)、北向坐标
(<code>y</code>)、居民数量（人口；<code>pop</code>）、平均年龄（<code>mean_age</code>）、女性比例（<code>women</code>）和平均家庭规模（<code>hh_size</code>）。下面的代码块从这些变量中选择并将其从德文重命名为英文，并在表格
@ref(tab:census-desc) 中进行了总结。此外，<code>mutate()</code>
函数被用于将值-1和-9（表示“未知”）转换为 <code>NA</code>。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pop = population, hh_size = household size</span></span><br><span class="line">input <span class="operator">=</span> select<span class="punctuation">(</span>census_de<span class="punctuation">,</span> x <span class="operator">=</span> x_mp_1km<span class="punctuation">,</span> y <span class="operator">=</span> y_mp_1km<span class="punctuation">,</span> pop <span class="operator">=</span> Einwohner<span class="punctuation">,</span></span><br><span class="line">                      women <span class="operator">=</span> Frauen_A<span class="punctuation">,</span> mean_age <span class="operator">=</span> Alter_D<span class="punctuation">,</span> hh_size <span class="operator">=</span> HHGroesse_D<span class="punctuation">)</span></span><br><span class="line"><span class="comment"># set -1 and -9 to NA</span></span><br><span class="line">input_tidy <span class="operator">=</span> dplyr<span class="operator">::</span>mutate<span class="punctuation">(</span>input<span class="punctuation">,</span></span><br><span class="line">  dplyr<span class="operator">::</span>across<span class="punctuation">(</span>.cols <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span>pop<span class="punctuation">,</span> women<span class="punctuation">,</span> mean_age<span class="punctuation">,</span> hh_size<span class="punctuation">)</span><span class="punctuation">,</span> </span><br><span class="line">                .fns <span class="operator">=</span>  <span class="operator">~</span>ifelse<span class="punctuation">(</span>.x <span class="operator">%in%</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="operator">-</span><span class="number">1</span><span class="punctuation">,</span> <span class="operator">-</span><span class="number">9</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="literal">NA</span><span class="punctuation">,</span> .x<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<table>
<caption>Categories for each variable in census data from
Datensatzbeschreibung...xlsx located in the downloaded file census.zip
(see Figure @ref(fig:census-stack) for their spatial
distribution).</caption>
<thead>
<tr class="header">
<th style="text-align: center;">Class</th>
<th style="text-align: center;">Population</th>
<th style="text-align: center;">% female</th>
<th style="text-align: center;">Mean age</th>
<th style="text-align: center;">Household size</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">3-250</td>
<td style="text-align: center;">0-40</td>
<td style="text-align: center;">0-40</td>
<td style="text-align: center;">1-2</td>
</tr>
<tr class="even">
<td style="text-align: center;">2</td>
<td style="text-align: center;">250-500</td>
<td style="text-align: center;">40-47</td>
<td style="text-align: center;">40-42</td>
<td style="text-align: center;">2-2.5</td>
</tr>
<tr class="odd">
<td style="text-align: center;">3</td>
<td style="text-align: center;">500-2000</td>
<td style="text-align: center;">47-53</td>
<td style="text-align: center;">42-44</td>
<td style="text-align: center;">2.5-3</td>
</tr>
<tr class="even">
<td style="text-align: center;">4</td>
<td style="text-align: center;">2000-4000</td>
<td style="text-align: center;">53-60</td>
<td style="text-align: center;">44-47</td>
<td style="text-align: center;">3-3.5</td>
</tr>
<tr class="odd">
<td style="text-align: center;">5</td>
<td style="text-align: center;">4000-8000</td>
<td style="text-align: center;">&gt;60</td>
<td style="text-align: center;">&gt;47</td>
<td style="text-align: center;">&gt;3.5</td>
</tr>
<tr class="even">
<td style="text-align: center;">6</td>
<td style="text-align: center;">&gt;8000</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<h1 id="创建人口普查栅格">创建人口普查栅格</h1>
<p>在预处理之后，可以使用<code>rast()</code>函数将数据转换为<code>SpatRaster</code>对象。当将其
<code>type</code> 参数设置为 <code>xyz</code> 时，输入数据框的
<code>x</code> 和 <code>y</code>
列应该对应于正规栅格上的坐标。所有其余列（在这里是
<code>pop</code>、<code>women</code>、<code>mean_age</code>、<code>hh_size</code>）将用作栅格图层的值（请参阅图
@ref(fig:census-stack)；还可以在我们的 GitHub
存储库中的<code>code/14-location-figures.R</code>
文件中找到相关代码）。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">input_ras <span class="operator">=</span> terra<span class="operator">::</span>rast<span class="punctuation">(</span>input_tidy<span class="punctuation">,</span> type <span class="operator">=</span> <span class="string">&quot;xyz&quot;</span><span class="punctuation">,</span> crs <span class="operator">=</span> <span class="string">&quot;EPSG:3035&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">input_ras</span><br><span class="line"><span class="comment">#&gt; class       : SpatRaster </span></span><br><span class="line"><span class="comment">#&gt; dimensions  : 868, 642, 4  (nrow, ncol, nlyr)</span></span><br><span class="line"><span class="comment">#&gt; resolution  : 1000, 1000  (x, y)</span></span><br><span class="line"><span class="comment">#&gt; extent      : 4031000, 4673000, 2684000, 3552000  (xmin, xmax, ymin, ymax)</span></span><br><span class="line"><span class="comment">#&gt; coord. ref. : ETRS89-extended / LAEA Europe (EPSG:3035) </span></span><br><span class="line"><span class="comment">#&gt; source(s)   : memory</span></span><br><span class="line"><span class="comment">#&gt; names       : pop, women, mean_age, hh_size </span></span><br><span class="line"><span class="comment">#&gt; min values  :   1,     1,        1,       1 </span></span><br><span class="line"><span class="comment">#&gt; max values  :   6,     5,        5,       5</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>📌请注意，我们使用的是等面积投影（EPSG:3035；欧洲兰伯特等面积投影），即每个栅格单元的面积相同，这里是1000
x
1000平方米。由于我们主要使用诸如每个栅格单元的居民数量或女性比例等密度数据，因此每个栅格单元的面积相同非常重要，以避免“苹果与橙子比较”。请注意，在地理坐标系（CRS）中，栅格单元的面积在向极地方向不断减小，因此需要谨慎处理。</p>
</blockquote>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309051728640.png" />
Gridded German census data of 2011 (see Table @ref(tab:census-desc) for
a description of the classes).</p>
<p>下一步是根据前面章节提到的调查，使用 <strong>terra</strong> 函数
<code>classify()</code> 对存储在 <code>input_ras</code>
中的栅格图层的值进行重新分类。对于人口数据，我们使用类均值将类别转换为数值数据类型。假设栅格单元的值为1（'class
1'
中的单元包含3到250名居民），则栅格单元的人口被假定为127；如果值为2（包含250到500名居民的单元），则人口被假定为375，依此类推（请参阅上表）。对于'类别6'，栅格单元的值被选为8000名居民，因为这些单元包含的人口超过8000人。当然，这些都是对真实人口的近似值，而不是精确值。<a
href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a>然而，这个详细级别足以划定大都市区域（请参阅下一节）。</p>
<p>与变量 <code>pop</code>
不同，该变量表示总人口的绝对估计，其他变量被重新分类为与调查中使用的权重相对应的权重。例如，变量
<code>women</code>
中的'类别1'代表的是人口中女性占0到40%的地区；这些地区被重新分类为较高的权重3，因为目标人群主要是男性。同样地，包含最年轻人口和最高比例的单身家庭的类别被重新分类为高权重。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rcl_pop <span class="operator">=</span> matrix<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">127</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">,</span> <span class="number">375</span><span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">,</span> <span class="number">1250</span><span class="punctuation">,</span> </span><br><span class="line">                   <span class="number">4</span><span class="punctuation">,</span> <span class="number">4</span><span class="punctuation">,</span> <span class="number">3000</span><span class="punctuation">,</span> <span class="number">5</span><span class="punctuation">,</span> <span class="number">5</span><span class="punctuation">,</span> <span class="number">6000</span><span class="punctuation">,</span> <span class="number">6</span><span class="punctuation">,</span> <span class="number">6</span><span class="punctuation">,</span> <span class="number">8000</span><span class="punctuation">)</span><span class="punctuation">,</span> </span><br><span class="line">                 ncol <span class="operator">=</span> <span class="number">3</span><span class="punctuation">,</span> byrow <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br><span class="line">rcl_women <span class="operator">=</span> matrix<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">4</span><span class="punctuation">,</span> <span class="number">5</span><span class="punctuation">,</span> <span class="number">0</span><span class="punctuation">)</span><span class="punctuation">,</span> </span><br><span class="line">                   ncol <span class="operator">=</span> <span class="number">3</span><span class="punctuation">,</span> byrow <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br><span class="line">rcl_age <span class="operator">=</span> matrix<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">,</span> <span class="number">0</span><span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">,</span> <span class="number">5</span><span class="punctuation">,</span> <span class="number">0</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">                 ncol <span class="operator">=</span> <span class="number">3</span><span class="punctuation">,</span> byrow <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br><span class="line">rcl_hh <span class="operator">=</span> rcl_women</span><br><span class="line">rcl <span class="operator">=</span> <span class="built_in">list</span><span class="punctuation">(</span>rcl_pop<span class="punctuation">,</span> rcl_women<span class="punctuation">,</span> rcl_age<span class="punctuation">,</span> rcl_hh<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>请注意，我们确保了列表中重新分类矩阵的顺序与 <code>input_ras</code>
的元素顺序相同。例如，第一个元素在两种情况下都对应于人口。随后，<code>for</code>
循环 将重新分类矩阵应用于相应的栅格图层。最后，下面的代码块确保
<code>reclass</code> 图层与 <code>input_ras</code>
的图层具有相同的名称。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">reclass <span class="operator">=</span> input_ras</span><br><span class="line"><span class="keyword">for</span> <span class="punctuation">(</span>i <span class="keyword">in</span> <span class="built_in">seq_len</span><span class="punctuation">(</span>terra<span class="operator">::</span>nlyr<span class="punctuation">(</span>reclass<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="punctuation">&#123;</span></span><br><span class="line">  reclass<span class="punctuation">[[</span>i<span class="punctuation">]</span><span class="punctuation">]</span> <span class="operator">=</span> terra<span class="operator">::</span>classify<span class="punctuation">(</span>x <span class="operator">=</span> reclass<span class="punctuation">[[</span>i<span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">,</span> rcl <span class="operator">=</span> rcl<span class="punctuation">[[</span>i<span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">,</span> right <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="built_in">names</span><span class="punctuation">(</span>reclass<span class="punctuation">)</span> <span class="operator">=</span> <span class="built_in">names</span><span class="punctuation">(</span>input_ras<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">reclass</span><br><span class="line"><span class="comment">#&gt; ... (full output not shown)</span></span><br><span class="line"><span class="comment">#&gt; names       :  pop, women, mean_age, hh_size </span></span><br><span class="line"><span class="comment">#&gt; min values  :  127,     0,        0,       0 </span></span><br><span class="line"><span class="comment">#&gt; max values  : 8000,     3,        3,       3</span></span><br></pre></td></tr></table></figure>
<h1 id="定义都市区">定义都市区</h1>
<p>我们特意将大都市区域定义为面积为20平方公里且居住人口超过500,000人的像素。在这种粗分辨率下，可以通过使用
<code>aggregate()</code>快速创建像素。下面的命令使用参数
<code>fact = 20</code>
将结果的分辨率降低了20倍（回想一下，原始栅格的分辨率是1平方公里）：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pop_agg <span class="operator">=</span> terra<span class="operator">::</span>aggregate<span class="punctuation">(</span>reclass<span class="operator">$</span>pop<span class="punctuation">,</span> fact <span class="operator">=</span> <span class="number">20</span><span class="punctuation">,</span> fun <span class="operator">=</span> <span class="built_in">sum</span><span class="punctuation">,</span> na.rm <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br><span class="line">summary<span class="punctuation">(</span>pop_agg<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt;       pop         </span></span><br><span class="line"><span class="comment">#&gt;  Min.   :    127  </span></span><br><span class="line"><span class="comment">#&gt;  1st Qu.:  39886  </span></span><br><span class="line"><span class="comment">#&gt;  Median :  66008  </span></span><br><span class="line"><span class="comment">#&gt;  Mean   :  99503  </span></span><br><span class="line"><span class="comment">#&gt;  3rd Qu.: 105696  </span></span><br><span class="line"><span class="comment">#&gt;  Max.   :1204870  </span></span><br><span class="line"><span class="comment">#&gt;  NA&#x27;s   :447</span></span><br></pre></td></tr></table></figure>
<p>接下来的步骤是仅保留居住人口超过500,000人的单元格。您可以使用以下代码来实现：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pop_agg <span class="operator">=</span> pop_agg<span class="punctuation">[</span>pop_agg <span class="operator">&gt;</span> <span class="number">500000</span><span class="punctuation">,</span> drop <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">]</span> </span><br></pre></td></tr></table></figure>
<p>绘制这些数据将显示出八个大都市区域。每个区域由一个或多个栅格单元组成。如果我们能够将属于同一区域的所有单元格连接起来，那将会很好。<strong>terra</strong>
的 <code>patches()</code>
命令正是这样的功能。随后，<code>as.polygons()</code>
将栅格对象转换为空间多边形，而 <code>st_as_sf()</code> 将其转换为
<code>sf</code> 对象。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">metros <span class="operator">=</span> pop_agg <span class="operator">|&gt;</span> </span><br><span class="line">  terra<span class="operator">::</span>patches<span class="punctuation">(</span>directions <span class="operator">=</span> <span class="number">8</span><span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">  terra<span class="operator">::</span>as.polygons<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">  sf<span class="operator">::</span>st_as_sf<span class="punctuation">(</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309051739055.png" />
The aggregated population raster (resolution: 20 km) with the identified
metropolitan areas (golden polygons) and the corresponding names.</p>
<p>生成的八个适合自行车店的大都市区域；请参阅
<code>code/14-location-figures.R</code>
以创建图表）仍然缺少名称。逆地理编码方法可以解决这个问题：根据坐标找到对应的地址。因此，提取每个大都市区域的中心坐标可以作为逆地理编码API的输入。这正是
<strong>tmaptools</strong> 包中的 <code>rev_geocode_OSM()</code>
函数所期望的。此外，将 <code>as.data.frame</code> 设置为
<code>TRUE</code> 将返回一个包含多列关于位置的
<code>data.frame</code>，包括街道名称、门牌号和城市。然而，在这里，我们只关注城市的名称。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">metro_names <span class="operator">=</span> sf<span class="operator">::</span>st_centroid<span class="punctuation">(</span>metros<span class="punctuation">,</span> of_largest_polygon <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">  tmaptools<span class="operator">::</span>rev_geocode_OSM<span class="punctuation">(</span>as.data.frame <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">  select<span class="punctuation">(</span>city<span class="punctuation">,</span> town<span class="punctuation">,</span> state<span class="punctuation">)</span></span><br><span class="line"><span class="comment"># smaller cities are returned in column town. To have all names in one column,</span></span><br><span class="line"><span class="comment"># we move the town name to the city column in case it is NA</span></span><br><span class="line">metro_names <span class="operator">=</span> dplyr<span class="operator">::</span>mutate<span class="punctuation">(</span>metro_names<span class="punctuation">,</span> city <span class="operator">=</span> ifelse<span class="punctuation">(</span><span class="built_in">is.na</span><span class="punctuation">(</span>city<span class="punctuation">)</span><span class="punctuation">,</span> town<span class="punctuation">,</span> city<span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>为了确保读者使用完全相同的结果，我们已将它们存储在
<strong>spDataLarge</strong> 中，对象名称为
<code>metro_names</code>。</p>
<table>
<caption>Result of the reverse geocoding.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">city</th>
<th style="text-align: left;">state</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Hamburg</td>
<td style="text-align: left;">NA</td>
</tr>
<tr class="even">
<td style="text-align: left;">Berlin</td>
<td style="text-align: left;">NA</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Velbert</td>
<td style="text-align: left;">Nordrhein-Westfalen</td>
</tr>
<tr class="even">
<td style="text-align: left;">Leipzig</td>
<td style="text-align: left;">Sachsen</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Frankfurt am Main</td>
<td style="text-align: left;">Hessen</td>
</tr>
<tr class="even">
<td style="text-align: left;">Nürnberg</td>
<td style="text-align: left;">Bayern</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Stuttgart</td>
<td style="text-align: left;">Baden-Württemberg</td>
</tr>
<tr class="even">
<td style="text-align: left;">München</td>
<td style="text-align: left;">Bayern</td>
</tr>
</tbody>
</table>
<p>总体而言，我们对 <code>city</code>
列作为大都市名称（上表）感到满意，除了一个例外，即属于杜塞尔多夫大区的费尔伯特。因此，我们将
Velbert 替换为 Düsseldorf（上图）。像 <code>ü</code>
这样的特殊字符可能会在后续的操作中引起问题，例如在使用
<code>opq()</code>
确定大都市区域的边界框时（请参见下面的内容），因此我们避免使用它们。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">metro_names <span class="operator">=</span> metro_names<span class="operator">$</span>city <span class="operator">|&gt;</span> </span><br><span class="line">  <span class="built_in">as.character</span><span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">  <span class="punctuation">&#123;</span><span class="punctuation">\</span><span class="punctuation">(</span>x<span class="punctuation">)</span> ifelse<span class="punctuation">(</span>x <span class="operator">==</span> <span class="string">&quot;Velbert&quot;</span><span class="punctuation">,</span> <span class="string">&quot;Düsseldorf&quot;</span><span class="punctuation">,</span> x<span class="punctuation">)</span><span class="punctuation">&#125;</span><span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">  <span class="punctuation">&#123;</span><span class="punctuation">\</span><span class="punctuation">(</span>x<span class="punctuation">)</span> gsub<span class="punctuation">(</span><span class="string">&quot;ü&quot;</span><span class="punctuation">,</span> <span class="string">&quot;ue&quot;</span><span class="punctuation">,</span> x<span class="punctuation">)</span><span class="punctuation">&#125;</span><span class="punctuation">(</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<h1 id="兴趣点">兴趣点</h1>
<p><strong>osmdata</strong>包提供了易于使用的访问OSM数据的方法。我们不是下载整个德国的商店数据，而是将查询限制在了定义好的大都市区域，以减少计算负担并且只获取感兴趣区域内的商店位置。下面的代码块使用了许多函数，包括：</p>
<ul>
<li><code>map()</code>（<strong>tidyverse</strong> 中的
<code>lapply()</code>等效函数），它遍历了八个大都市名称，随后在OSM查询函数
<code>opq()</code> 中定义了边界框。</li>
<li><code>add_osm_feature()</code> 用于指定带有键值为 <code>shop</code>
的OSM元素（请参阅 <a
target="_blank" rel="noopener" href="http://wiki.openstreetmap.org/wiki/Map_Features">wiki.openstreetmap.org</a>
以获取常见的键值对列表）。</li>
<li><code>osmdata_sf()</code> 将OSM数据转换为空间对象（<code>sf</code>
类）。</li>
<li><code>while()</code>，如果第一次下载失败，将重复尝试（在本例中为三次）。<a
href="#fn2" class="footnote-ref" id="fnref2"
role="doc-noteref"><sup>2</sup></a></li>
</ul>
<p>在运行此代码之前，请考虑它将下载近2GB的数据。为了节省时间和资源，我们已将名为
<code>shops</code> 的输出放入 <strong>spDataLarge</strong>
包中。要在您的环境中使用它，请运行
<code>data("shops", package = "spDataLarge")</code>。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">shops <span class="operator">=</span> purrr<span class="operator">::</span>map<span class="punctuation">(</span>metro_names<span class="punctuation">,</span> <span class="keyword">function</span><span class="punctuation">(</span>x<span class="punctuation">)</span> <span class="punctuation">&#123;</span></span><br><span class="line">  message<span class="punctuation">(</span><span class="string">&quot;Downloading shops of: &quot;</span><span class="punctuation">,</span> x<span class="punctuation">,</span> <span class="string">&quot;\n&quot;</span><span class="punctuation">)</span></span><br><span class="line">  <span class="comment"># give the server a bit time</span></span><br><span class="line">  Sys.sleep<span class="punctuation">(</span>sample<span class="punctuation">(</span>seq<span class="punctuation">(</span><span class="number">5</span><span class="punctuation">,</span> <span class="number">10</span><span class="punctuation">,</span> <span class="number">0.1</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">  query <span class="operator">=</span> osmdata<span class="operator">::</span>opq<span class="punctuation">(</span>x<span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">    osmdata<span class="operator">::</span>add_osm_feature<span class="punctuation">(</span>key <span class="operator">=</span> <span class="string">&quot;shop&quot;</span><span class="punctuation">)</span></span><br><span class="line">  points <span class="operator">=</span> osmdata<span class="operator">::</span>osmdata_sf<span class="punctuation">(</span>query<span class="punctuation">)</span></span><br><span class="line">  <span class="comment"># request the same data again if nothing has been downloaded</span></span><br><span class="line">  iter <span class="operator">=</span> <span class="number">2</span></span><br><span class="line">  <span class="keyword">while</span> <span class="punctuation">(</span>nrow<span class="punctuation">(</span>points<span class="operator">$</span>osm_points<span class="punctuation">)</span> <span class="operator">==</span> <span class="number">0</span> <span class="operator">&amp;&amp;</span> iter <span class="operator">&gt;</span> <span class="number">0</span><span class="punctuation">)</span> <span class="punctuation">&#123;</span></span><br><span class="line">    points <span class="operator">=</span> osmdata_sf<span class="punctuation">(</span>query<span class="punctuation">)</span></span><br><span class="line">    iter <span class="operator">=</span> iter <span class="operator">-</span> <span class="number">1</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="comment"># return only the point features</span></span><br><span class="line">  points<span class="operator">$</span>osm_points</span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>在我们定义的任何大都市区域中几乎不可能没有商店。以下的
<code>if</code>
条件仅仅检查每个区域是否至少有一家商店。如果没有的话，我们建议尝试再次为该/这些特定区域下载商店数据。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># checking if we have downloaded shops for each metropolitan area</span></span><br><span class="line">ind <span class="operator">=</span> purrr<span class="operator">::</span>map_dbl<span class="punctuation">(</span>shops<span class="punctuation">,</span> nrow<span class="punctuation">)</span> <span class="operator">==</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> <span class="punctuation">(</span><span class="built_in">any</span><span class="punctuation">(</span>ind<span class="punctuation">)</span><span class="punctuation">)</span> <span class="punctuation">&#123;</span></span><br><span class="line">  message<span class="punctuation">(</span><span class="string">&quot;There are/is still (a) metropolitan area/s without any features:\n&quot;</span><span class="punctuation">,</span></span><br><span class="line">          paste<span class="punctuation">(</span>metro_names<span class="punctuation">[</span>ind<span class="punctuation">]</span><span class="punctuation">,</span> collapse <span class="operator">=</span> <span class="string">&quot;, &quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="string">&quot;\nPlease fix it!&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>为确保每个列表元素（一个 <code>sf</code> 数据框）具有相同的列<a
href="#fn3" class="footnote-ref" id="fnref3"
role="doc-noteref"><sup>3</sup></a>，我们只保留 <code>osm_id</code> 和
<code>shop</code> 列，使用 <code>map_dfr</code>
循环将所有商店合并为一个大的 <code>sf</code> 对象。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># select only specific columns</span></span><br><span class="line">shops <span class="operator">=</span> purrr<span class="operator">::</span>map_dfr<span class="punctuation">(</span>shops<span class="punctuation">,</span> select<span class="punctuation">,</span> osm_id<span class="punctuation">,</span> shop<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>注意：<code>shops</code> 已经在 <code>spDataLarge</code>
中提供，并且可以通过以下方式访问：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data<span class="punctuation">(</span><span class="string">&quot;shops&quot;</span><span class="punctuation">,</span> package <span class="operator">=</span> <span class="string">&quot;spDataLarge&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>唯一剩下的任务是将空间点对象转换为栅格。<code>sf</code> 对象
<code>shops</code> 将被转换为一个栅格，其参数（维度、分辨率、CRS）与
<code>reclass</code> 对象相同。重要的是，在此处使用
<code>length()</code> 函数来计算每个单元格中的商店数量。</p>
<p>因此，下面的代码块的结果是商店密度的估计（商店/平方公里）。在使用
<code>rasterize()</code> 之前，使用 <code>st_transform()</code>
来确保两个输入的CRS匹配。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shops <span class="operator">=</span> sf<span class="operator">::</span>st_transform<span class="punctuation">(</span>shops<span class="punctuation">,</span> st_crs<span class="punctuation">(</span>reclass<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># create poi raster</span></span><br><span class="line">poi <span class="operator">=</span> terra<span class="operator">::</span>rasterize<span class="punctuation">(</span>x <span class="operator">=</span> shops<span class="punctuation">,</span> y <span class="operator">=</span> reclass<span class="punctuation">,</span> field <span class="operator">=</span> <span class="string">&quot;osm_id&quot;</span><span class="punctuation">,</span> fun <span class="operator">=</span> <span class="string">&quot;length&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>与其他栅格图层（人口、女性、平均年龄、户籍人口）一样，<code>poi</code>
栅格也被重新分类为四个类别。在一定程度上，定义类别间隔是一个主观的任务。可以使用等距断点、分位数断点、固定值或其他方法。在这里，我们选择了费舍尔-詹金斯自然断点法，该方法最小化了类内方差，其结果为重新分类矩阵提供了一个输入。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># construct reclassification matrix</span></span><br><span class="line">int <span class="operator">=</span> classInt<span class="operator">::</span>classIntervals<span class="punctuation">(</span>terra<span class="operator">::</span>values<span class="punctuation">(</span>poi<span class="punctuation">)</span><span class="punctuation">,</span> n <span class="operator">=</span> <span class="number">4</span><span class="punctuation">,</span> style <span class="operator">=</span> <span class="string">&quot;fisher&quot;</span><span class="punctuation">)</span></span><br><span class="line">int <span class="operator">=</span> <span class="built_in">round</span><span class="punctuation">(</span>int<span class="operator">$</span>brks<span class="punctuation">)</span></span><br><span class="line">rcl_poi <span class="operator">=</span> matrix<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span>int<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="built_in">rep</span><span class="punctuation">(</span>int<span class="punctuation">[</span><span class="operator">-</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span> <span class="built_in">length</span><span class="punctuation">(</span>int<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">]</span><span class="punctuation">,</span> each <span class="operator">=</span> <span class="number">2</span><span class="punctuation">)</span><span class="punctuation">,</span> </span><br><span class="line">                   int<span class="punctuation">[</span><span class="built_in">length</span><span class="punctuation">(</span>int<span class="punctuation">)</span><span class="punctuation">]</span> <span class="operator">+</span> <span class="number">1</span><span class="punctuation">)</span><span class="punctuation">,</span> ncol <span class="operator">=</span> <span class="number">2</span><span class="punctuation">,</span> byrow <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br><span class="line">rcl_poi <span class="operator">=</span> cbind<span class="punctuation">(</span>rcl_poi<span class="punctuation">,</span> <span class="number">0</span><span class="operator">:</span><span class="number">3</span><span class="punctuation">)</span>  </span><br><span class="line"><span class="comment"># reclassify</span></span><br><span class="line">poi <span class="operator">=</span> terra<span class="operator">::</span>classify<span class="punctuation">(</span>poi<span class="punctuation">,</span> rcl <span class="operator">=</span> rcl_poi<span class="punctuation">,</span> right <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">)</span> </span><br><span class="line"><span class="built_in">names</span><span class="punctuation">(</span>poi<span class="punctuation">)</span> <span class="operator">=</span> <span class="string">&quot;poi&quot;</span></span><br></pre></td></tr></table></figure>
<h1 id="明确合适的位置">明确合适的位置</h1>
<p>在将所有图层组合在一起之前，只剩下几个步骤：将 <code>poi</code>
添加到 <code>reclass</code>
栅格堆叠中，并将人口图层从中移除。后者的原因有两点。首先，我们已经勾勒出了大都市区域，即人口密度高于德国其他地区平均水平的地区。其次，虽然在特定的服务区域内有许多潜在的顾客可能是有优势的，但仅仅数量本身可能并不真正代表所需的目标群体。例如，高层住宅区是人口密度较高的地区，但不一定具有购买昂贵自行车配件的高购买力。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># remove population raster and add poi raster</span></span><br><span class="line">reclass <span class="operator">=</span> reclass<span class="punctuation">[[</span><span class="built_in">names</span><span class="punctuation">(</span>reclass<span class="punctuation">)</span> <span class="operator">!=</span> <span class="string">&quot;pop&quot;</span><span class="punctuation">]</span><span class="punctuation">]</span> <span class="operator">|&gt;</span></span><br><span class="line">  <span class="built_in">c</span><span class="punctuation">(</span>poi<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>与其他数据科学项目一样，数据检索和“整理”在整个工作量中占据了很大一部分。有了干净的数据，最后一步——通过将所有栅格图层相加来计算最终得分——可以在一行代码中完成。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># calculate the total score</span></span><br><span class="line">result <span class="operator">=</span> <span class="built_in">sum</span><span class="punctuation">(</span>reclass<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>例如，得分大于9的分数可能是一个适当的阈值，表示可以放置自行车店的栅格单元格；请参阅
<code>code/14-location-figures.R</code>）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#&gt; The legacy packages maptools, rgdal, and rgeos, underpinning the sp package,</span><br><span class="line">#&gt; which was just loaded, will retire in October 2023.</span><br><span class="line">#&gt; Please refer to R-spatial evolution reports for details, especially</span><br><span class="line">#&gt; https://r-spatial.org/r/2023/05/15/evolution4.html.</span><br><span class="line">#&gt; It may be desirable to make the sf package available;</span><br><span class="line">#&gt; package maintainers should consider adding sf to Suggests:.</span><br><span class="line">#&gt; The sp package is now running under evolution status 2</span><br><span class="line">#&gt;      (status 2 uses the sf package in place of rgdal)</span><br></pre></td></tr></table></figure>
<div class="figure" style="text-align: center">
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;leaflet html-widget html-fill-item-overflow-hidden html-fill-item&quot; id=&quot;htmlwidget-841de324d41155df19a0&quot; style=&quot;width:100%;height:415.296px;&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;script type=&quot;application/json&quot; data-for=&quot;htmlwidget-841de324d41155df19a0&quot;&gt;&#123;&quot;x&quot;:&#123;&quot;options&quot;:&#123;&quot;crs&quot;:&#123;&quot;crsClass&quot;:&quot;L.CRS.EPSG3857&quot;,&quot;code&quot;:null,&quot;proj4def&quot;:null,&quot;projectedBounds&quot;:null,&quot;options&quot;:&#123;&#125;&#125;&#125;,&quot;calls&quot;:[&#123;&quot;method&quot;:&quot;addTiles&quot;,&quot;args&quot;:[&quot;https://&#123;s&#125;.tile.openstreetmap.org/&#123;z&#125;/&#123;x&#125;/&#123;y&#125;.png&quot;,null,null,&#123;&quot;minZoom&quot;:0,&quot;maxZoom&quot;:18,&quot;tileSize&quot;:256,&quot;subdomains&quot;:&quot;abc&quot;,&quot;errorTileUrl&quot;:&quot;&quot;,&quot;tms&quot;:false,&quot;noWrap&quot;:false,&quot;zoomOffset&quot;:0,&quot;zoomReverse&quot;:false,&quot;opacity&quot;:1,&quot;zIndex&quot;:1,&quot;detectRetina&quot;:false,&quot;attribution&quot;:&quot;&amp;copy; &lt;a href=\&quot;https://openstreetmap.org/copyright/\&quot;&gt;OpenStreetMap&lt;\/a&gt;,  &lt;a href=\&quot;https://opendatacommons.org/licenses/odbl/\&quot;&gt;ODbL&lt;\/a&gt;&quot;&#125;]&#125;,&#123;&quot;method&quot;:&quot;addRasterImage&quot;,&quot;args&quot;:[&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAoCAYAAACM/rhtAAAAM0lEQVRYhe3SMQ0AMAwEsQcb/hTSuQSaVLIR3HAJAADfqfR0wm1dEC9VevcCq+MAAIBhB20vBvBK3JZrAAAAAElFTkSuQmCC&quot;,[[52.69660085729196,13.08200261479863],[52.32107408861835,13.69815913809763]],0.8,null,null,null]&#125;,&#123;&quot;method&quot;:&quot;addLegend&quot;,&quot;args&quot;:[&#123;&quot;colors&quot;:[&quot;darkgreen&quot;],&quot;labels&quot;:[&quot;potential locations&quot;],&quot;na_color&quot;:null,&quot;na_label&quot;:&quot;NA&quot;,&quot;opacity&quot;:0.5,&quot;position&quot;:&quot;bottomright&quot;,&quot;type&quot;:&quot;unknown&quot;,&quot;title&quot;:&quot;Legend&quot;,&quot;extra&quot;:null,&quot;layerId&quot;:null,&quot;className&quot;:&quot;info legend&quot;,&quot;group&quot;:null&#125;]&#125;],&quot;limits&quot;:&#123;&quot;lat&quot;:[52.32107408861835,52.69660085729196],&quot;lng&quot;:[13.08200261479863,13.69815913809763]&#125;&#125;,&quot;evals&quot;:[],&quot;jsHooks&quot;:[]&#125;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p class="caption">
Suitable areas (i.e., raster cells with a score &gt; 9) in accordance
with our hypothetical survey for bike stores in Berlin.
</p>
</div>
<h1 id="讨论和下一步">讨论和下一步</h1>
<p>所呈现的方法是GIS的典型应用示例。我们将调查数据与基于专家知识和假设的方法相结合（定义大都市区域，定义类别间隔，定义最终得分阈值）。这种方法不如应用分析适用于科学研究，因为它可以提供基于证据的适合自行车店的区域，应该与其他信息来源进行比较。对方法的一些变更可以改进分析：</p>
<ul>
<li>在计算最终得分时，我们使用了相等的权重，但其他因素，如户籍人口，可能与女性比例或平均年龄一样重要。</li>
<li>我们使用了所有兴趣点，但只有与自行车店相关的兴趣点，如自行车店、五金店、自行车、钓鱼、狩猎、摩托车、户外和运动用品店（请参阅
<a target="_blank" rel="noopener" href="http://wiki.openstreetmap.org/wiki/Map_Features#Shop">OSM
Wiki</a> 上可用的店铺值范围）可能会产生更精细的结果。</li>
<li>更高分辨率的数据可能会改善输出（请参阅练习）。</li>
<li>我们仅使用了有限的变量集和来自其他来源的数据，如 <a
target="_blank" rel="noopener" href="http://inspire-geoportal.ec.europa.eu/discovery/">INSPIRE
geoportal</a> 或来自 OpenStreetMap 的自行车路径数据，可以丰富分析。</li>
<li>未考虑交互作用，如男性比例和单身户之间可能存在的关系。</li>
</ul>
<p>简而言之，分析可以在多个方向上进行扩展。然而，它应该给您对如何在geomarketing背景下在R中获取和处理空间数据的第一印象和理解。</p>
<p>最后，我们必须指出，所呈现的分析仅仅是找到合适位置的第一步。到目前为止，我们已经确定了大小为1x1公里的区域，代表根据我们的调查可能适合自行车店的位置。分析的后续步骤可以是：</p>
<ul>
<li>基于特定服务区域内的居民数量找到最佳位置。例如，在骑自行车的15分钟行程范围内，店铺应该为尽可能多的人提供可达性（服务区域路由）。在此过程中，我们应该考虑到远离店铺的人越远，他们实际访问店铺的可能性就越小（距离衰减函数）。</li>
<li>此外，考虑竞争对手也是一个好主意。也就是说，如果已经有一家自行车店在所选位置附近，可能的顾客（或销售潜力）应该在竞争对手之间分配。</li>
<li>我们需要找到适合并且价格合理的房地产，例如在可访问性、停车位的可用性、过路人的期望频率、有大窗户等方面。</li>
</ul>
<h1 id="练习">练习</h1>
<p>E1. Download the csv file containing inhabitant information for a 100
m cell resolution
(https://www.zensus2011.de/SharedDocs/Downloads/DE/Pressemitteilung/DemografischeGrunddaten/csv_Bevoelkerung_100m_Gitter.zip?__blob=publicationFile&amp;v=3).
Please note that the unzipped file has a size of 1.23 GB. To read it
into R you can use <code>readr::read_csv</code>. This takes 30 seconds
on a machine with 16 GB RAM. <code>data.table::fread()</code> might be
even faster, and returns an object of class <code>data.table()</code>.
Use <code>dplyr::as_tibble()</code> to convert it into a tibble. Build
an inhabitant raster, aggregate it to a cell resolution of 1 km, and
compare the difference with the inhabitant raster (<code>inh</code>) we
have created using class mean values.</p>
<p>E2. Suppose our bike shop predominantly sold electric bikes to older
people. Change the age raster accordingly, repeat the remaining analyses
and compare the changes with our original result.</p>
<aside id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>在这个重新分类阶段引入的潜在误差将在练习中进行探讨。<a
href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>有时在第一次尝试下载OSM数据时可能会失败。<a
href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li
id="fn3"><p>这并不是一定的，因为OSM的贡献者在收集数据时并不总是一样仔细。<a
href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>

            
        </div>

        
        
        

        <div>
            
        </div>

        <footer class="post-footer">
            <div class="post-eof"></div>
            
        </footer>
    </article>
</div>




    


<div class="post-block">
    
    

    <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
        <link itemprop="mainEntityOfPage" href="https://ancao96.github.io/2023/08/22/2023-8-22-13-%E5%BA%94%E7%94%A8-%E8%BF%90%E8%BE%93/">

        <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
            <meta itemprop="image" content="/images/avatar.gif">
            <meta itemprop="name" content="SCY">
        </span>

        <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
            <meta itemprop="name" content="SCY SPACE">
            <meta itemprop="description" content="">
        </span>

        <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
            <meta itemprop="name" content="undefined | SCY SPACE">
            <meta itemprop="description" content="">
        </span>
        <header class="post-header">
            <h2 class="post-title" itemprop="name headline">
                <a href="/2023/08/22/2023-8-22-13-%E5%BA%94%E7%94%A8-%E8%BF%90%E8%BE%93/" class="post-title-link" itemprop="url">(13)（应用）运输</a>
            </h2>

            <div class="post-meta-container">
                <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-08-22 05:26:20" itemprop="dateCreated datePublished" datetime="2023-08-22T05:26:20+08:00">2023-08-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-09-05 17:04:40" itemprop="dateModified" datetime="2023-09-05T17:04:40+08:00">2023-09-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/R/" itemprop="url" rel="index"><span itemprop="name">R</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/R/Geocomputaion/" itemprop="url" rel="index"><span itemprop="name">Geocomputaion</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2023/08/22/2023-8-22-13-%E5%BA%94%E7%94%A8-%E8%BF%90%E8%BE%93/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2023/08/22/2023-8-22-13-%E5%BA%94%E7%94%A8-%E8%BF%90%E8%BE%93/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>13k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>48 分钟</span>
    </span>
</div>

            </div>
        </header>

        
        
        
        <div class="post-body" itemprop="articleBody">
            <h1 id="前提条件">前提条件</h1>
<ul>
<li>本章使用下列包：[^13-transport-1]</li>
</ul>
<p>[^13-transport-1]：<strong>nabor</strong> 必须安装。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">library<span class="punctuation">(</span>sf<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>dplyr<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>spDataLarge<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>stplanr<span class="punctuation">)</span>      <span class="comment"># for processing geographic transport data</span></span><br><span class="line">library<span class="punctuation">(</span>tmap<span class="punctuation">)</span>         <span class="comment"># map making (see Chapter 9)</span></span><br><span class="line">library<span class="punctuation">(</span>ggplot2<span class="punctuation">)</span>      <span class="comment"># data visualization package</span></span><br><span class="line">library<span class="punctuation">(</span>sfnetworks<span class="punctuation">)</span>   <span class="comment"># spatial network classes and functions </span></span><br></pre></td></tr></table></figure>
<h1 id="引言">引言</h1>
<p>很少有其他部门的地理空间比交通更有形。移动(克服距离)的努力是地理学“第一定律”的核心，Waldo
Tobler 在1970年定义如下(Tobler 1970) :</p>
<blockquote>
<p>一切事物都与其他事物相关，但是近的事物比远的事物更相关。</p>
</blockquote>
<p>这个“定律”是空间自相关和其他关键地理概念的基础。它适用于各种各样的现象，如友谊网络和生态多样性，可以用交通成本来解释——在时间、精力和金钱方面——这些构成了“距离摩擦”。从这个角度来看，运输技术具有颠覆性，改变了包括移动人员和货物在内的地理实体之间的空间关系:
“运输的目的是克服空间”(Rodrigue，Comtois，and Slack 2013)。</p>
<p>运输是一个固有的空间活动，包括从一个起点‘ A’到目的地‘
B’，通过无限的位置之间。因此，交通运输研究人员长期以来一直采用地理和计算方法来理解运动模式，以及干预措施如何能够提高他们的表现，这并不令人惊讶(Lovelace
2021)。</p>
<p>本章介绍了不同地理层次运输系统的地理分析:</p>
<ul>
<li><strong>Areal units</strong>:
交通模式可以通过参考区域总量来理解，比如主要的出行方式(例如，汽车、自行车或步行)
，以及生活在特定区域的人们的平均出行距离(见第13.3节)</li>
<li><strong>Desire lines</strong>:
表示“起点-目的地”数据的直线，记录有多少人在地理空间的不同地点(点或区域)之间旅行(或可能旅行)
，这是第13.4节的主题</li>
<li><strong>Nodes</strong>:
这些是交通系统中可以代表共同起点和目的地的点，以及公共交通站点，如公共汽车站和火车站，这是第13.5节的主题</li>
<li><strong>Routes</strong>:
这些线路表示沿着路由网络沿着所需的线路和节点之间的路径。路由(可以表示为单行字符串或多个<em>短段</em>)和生成它们的<em>路由引擎</em>，在第13.6节中介绍</li>
<li><strong>Route networks</strong>:
这些代表了一个区域内的道路、路径和其他线性特征的系统，在第13.6节中有介绍。
它们可以表示为地理特征（通常是组成完整网络的短路段）或结构化为一个相互连接的图，不同段上的交通流量被运输模型师称为“流量”(Hollander
2016)。</li>
</ul>
<p>This highlights an important feature of transport systems: they are
closely linked to broader phenomena and land-use patterns.
另一个关键层次是<strong>代理</strong>，如你我以及使我们能够移动的交通工具，比如自行车和公交车。这些可以在像<a
target="_blank" rel="noopener" href="http://www.matsim.org/">MATSim</a>和<a
target="_blank" rel="noopener" href="https://github.com/a-b-street/abstreet">A/B
Street</a>这样的软件中以计算方式表示，它们使用基于代理的建模（ABM）框架，通常具有很高的空间和时间分辨率，来表示交通系统的动态性(Horni，Nagel
和 Axhausen
2016)。尽管ABM是一种具有很大整合潜力的强大的交通研究方法，尤其是与R的空间类(Thiele
2014; Lovelace and Dumont 2016)
，但它不在本章的范围内。除了地理层次和代理之外，许多交通模型中的基本分析单位是<strong>行程</strong>，即从一个起点'A'到一个终点'B'的单一目的地之旅(Hollander
2016)。行程连接了交通系统的不同层次，并可以简单地表示为连接<em>区域</em>质心（<em>节点</em>）的地理<em>需求线</em>，或作为遵循交通<em>路线网络</em>的路线。在这种情况下，<em>代理人</em>通常是在交通网络内移动的点实体。</p>
<p>交通系统是动态的(Xie and Levinson
2011)。尽管本章的重点是交通系统的<em>地理</em>分析，但它也提供了如何使用这种方法来模拟变化情景的见解，在第13.8节中有介绍。地理交通建模的目的可以理解为以捕捉其本质的方式简化这些时空系统的复杂性。选择适当的地理分析层次可以在不失去其最重要的特征和变量的情况下，简化这种复杂性，从而实现更好的决策和更有效的干预(Hollander
2016)。</p>
<p>通常，模型被设计用来解决特定问题，比如如何提高交通系统的安全性或环境性能。因此，本章围绕一个政策情境展开，将在下一节中介绍，即：如何增加布里斯托尔市的自行车使用？第14章演示了地理计算的一个相关应用：优先考虑新自行车店的位置。章节之间有一个联系：新的和有效定位的自行车基础设施可以使人们开始骑自行车，从而增加对自行车店和当地经济活动的需求。这突出了交通系统的一个重要特点：它们与更广泛的现象和土地利用模式密切相关。</p>
<h1 id="布里斯托尔案例研究">布里斯托尔案例研究</h1>
<p>本章使用的案例研究位于英格兰西部的布里斯托尔市，距离威尔士首都加的夫约30公里以东。该地区的交通网络概览在下图中展示，图中展示了多样的交通基础设施，包括自行车、公共交通和私家车。</p>
<p>布里斯托尔是一个充满活力和多样性的城市，拥有各种各样的交通选项。从自行车道到公交线路，再到繁忙的高速公路，布里斯托尔的交通网络反映了其居民多样化的出行需求。这为进行地理和交通研究提供了一个极为丰富的背景。</p>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309051448576.png" />
Bristol's transport network represented by colored lines for active
(green), public (railways, black) and private motor (red) modes of
travel. Black border lines represent the inner city boundary
(highlighted in yellow) and the larger Travel To Work Area (TTWA).</p>
<p>布里斯托尔是英格兰第十大的市议会，拥有50万人口，尽管其交通服务覆盖区域更广泛（参见13.3节）。该市拥有一个充满活力的经济体，包括航空航天、媒体、金融服务和旅游公司，以及两所主要大学。尽管布里斯托尔的人均收入较高，但也有严重贫困的地区(布里斯托尔市议会2015年)。</p>
<p>从交通角度看，布里斯托尔的铁路和公路连接非常便利，活跃出行的水平相对较高。根据<a
target="_blank" rel="noopener" href="https://www.gov.uk/government/statistical-data-sets/how-often-and-time-spent-walking-and-cycling-at-local-authority-level-cw010#table-cw0103">Active
People
Survey</a>，19%的市民每月至少骑一次自行车，88%的人每月至少走一次路（全国平均分别为15%和81%）。2011年的人口普查数据显示，8%的人口自行车上班，而全国平均仅为3%。</p>
<p>与许多城市一样，布里斯托尔面临严重的交通拥堵、空气质量和体力不活跃的问题。自行车出行能有效地解决这些问题：与步行相比，自行车更有可能替代汽车出行，因为其典型<a
target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Bicycle_performance">速度</a>为15-20
km/h，而步行为4-6 km/h。因此，布里斯托尔的<a
target="_blank" rel="noopener" href="https://www.bristol.gov.uk/council-and-mayor/policies-plans-and-strategies/bristol-transport-strategy">交通战略</a>对自行车出行有着雄心勃勃的计划。</p>
<p>为了强调政策考虑在交通研究中的重要性，本章旨在为那些负责让人们从汽车转向更可持续出行方式（特别是步行和自行车）的人（如交通规划师、政治家和其他利益相关者）提供证据。更广泛的目标是演示地理计算如何支持基于证据的交通规划。</p>
<p>在本章中，你将学习如何：</p>
<ul>
<li>描述城市交通行为的地理模式</li>
<li>识别支持多模式出行的关键公共交通节点</li>
<li>分析旅行"愿望线"，找出哪里有许多人驾车短途出行</li>
<li>识别鼓励少开车、多骑自行车的自行车路线位置</li>
</ul>
<p>为了在实践方面展开本章的内容，下一节将开始加载关于旅行模式的区域数据。这些区域级别的数据集虽小，但对于获取对城市整体交通系统的基本了解至关重要。</p>
<h1 id="交通区域">交通区域</h1>
<p>尽管交通系统主要基于线性特征和节点——包括路径和车站——从面数据开始通常更有意义，以将连续空间划分为可触及的单位
(Hollander
2016)。除了定义研究区域的边界（在这种情况下是布里斯托尔）之外，对交通研究人员尤为感兴趣的两种区域类型是：起源区域和目的区域。通常，相同的地理单位用于起点和目的地。然而，不同的分区系统，例如
'<a
target="_blank" rel="noopener" href="https://data.gov.uk/dataset/workplace-zones-a-new-geography-for-workplace-statistics3">工作区</a>'，可能更适合代表在有许多'旅行吸引点'的区域内旅行目的地的增加密度
(国家统计局2014年)。</p>
<p>最简单定义研究区域的方式通常是第一个由OpenStreetMap返回的匹配边界。这可以通过诸如
<code>osmdata::getbb("Bristol", format_out = "sf_polygon",  limit = 1)</code>
的命令来完成。这返回一个 <code>sf</code> 对象（或者如果没有指定
<code>limit = 1</code>，则返回一组 <code>sf</code>
对象），代表最大匹配城市区域的范围，要么是边界框的矩形多边形，要么是一个详细的多边形边界。<a
href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a>对于布里斯托尔，返回了一个详细的多边形，由
<strong>spDataLarge</strong> 包中的 <code>bristol_region</code>
对象表示。请参见上图中的内部蓝色边界：这种方法有几个问题：</p>
<ul>
<li>第一个由OSM返回的OSM边界可能不是当地政府使用的官方边界</li>
<li>即使OSM返回官方边界，这也可能不适合交通研究，因为它们与人们的旅行路线关系不大</li>
</ul>
<p>工作通勤区域（TTWAs）通过创建一个类似于水文流域的分区系统来解决这些问题。TTWAs最初被定义为连续区域，在其中75%的人口前往工作(Coombes,
Green, and Openshaw
1986)，这是本章使用的定义。由于布里斯托尔是一个主要的雇主，吸引了周边城镇的旅行，因此其TTWA比城市界限要大得多（见上图）。代表这一以交通为导向的边界的多边形存储在由章节开始时加载的
<strong>spDataLarge</strong> 包提供的 <code>bristol_ttwa</code>
对象中。</p>
<p>本章使用的起点和终点区域是相同的：官方定义的中等地理分辨率区域（它们的<a
target="_blank" rel="noopener" href="https://www.ons.gov.uk/peoplepopulationandcommunity/populationandmigration/populationestimates/bulletins/annualsmallareapopulationestimates/2014-10-23">官方</a>名称是中层超级输出区域或MSOAs）。
每个区域大约有8,000人。这种行政区域可以为交通分析提供重要的背景信息，例如可能最受特定干预措施影响的人群类型(例如,
Moreno-Monroy, Lovelace, and Ramos 2017)。</p>
<p>这些区域的地理分辨率很重要：小区域具有高地理分辨率通常更可取，但它们在大区域中的高数量可能对处理（尤其是对于起点-终点分析，在其中可能性作为区域数量的非线性函数增加）有影响
(Hollander 2016)。</p>
<blockquote>
<p>📌与小区域相关的另一个问题与匿名规则有关。为了使在区域内无法推断个人身份，详细社会人口统计变量通常仅在低地理分辨率下可用。例如，旅行方式的年龄和性别细分在英国的地方当局层面上可用，但不在更高的输出区域层面上，其中每个区域大约包含100户家庭。有关更多详细信息，请参阅
www.ons.gov.uk/methodology/geography。</p>
</blockquote>
<p>本章中使用的102个区域存储在 <code>bristol_zones</code>
中，如下图所示。注意，在人口密集地区，区域变得更小：每个区域都有类似数量的人。<code>bristol_zones</code>
不包含关于交通的属性数据，只有每个区域的名称和代码：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">names</span><span class="punctuation">(</span>bristol_zones<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] &quot;geo_code&quot; &quot;name&quot;     &quot;geometry&quot;</span></span><br></pre></td></tr></table></figure>
<p>为了添加旅行数据，我们将执行<em>属性连接</em>，这是在<em>矢量属性连接</em>节中描述的常见任务。我们将使用来自英国2011年人口普查关于工作通勤的问题的旅行数据，该数据存储在
<code>bristol_od</code> 中，由 <a
target="_blank" rel="noopener" href="https://www.ons.gov.uk/help/localstatistics">ons.gov.uk</a>
数据门户提供。<code>bristol_od</code>
是一个关于英国2011年人口普查中各区域间通勤旅行的起点-终点（OD）数据集。第一列是起始区域的ID，第二列是目的区域。<code>bristol_od</code>
的行数比 <code>bristol_zones</code>
多，代表的是区域<em>之间</em>的旅行，而不是区域本身：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nrow<span class="punctuation">(</span>bristol_od<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] 2910</span></span><br><span class="line">nrow<span class="punctuation">(</span>bristol_zones<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] 102</span></span><br></pre></td></tr></table></figure>
<p>前一个代码块的结果显示，每个区域有超过10个起点-终点（OD）对，这意味着在将其与
<code>bristol_zones</code>
进行连接之前，我们需要对起点-终点数据进行聚合，如下图所示 ：
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zones_attr <span class="operator">=</span> bristol_od <span class="operator">|&gt;</span> </span><br><span class="line">  group_by<span class="punctuation">(</span>o<span class="punctuation">)</span> <span class="operator">|&gt;</span> </span><br><span class="line">  summarize<span class="punctuation">(</span>across<span class="punctuation">(</span>where<span class="punctuation">(</span><span class="built_in">is.numeric</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">sum</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">|&gt;</span> </span><br><span class="line">  dplyr<span class="operator">::</span>rename<span class="punctuation">(</span>geo_code <span class="operator">=</span> o<span class="punctuation">)</span></span><br></pre></td></tr></table></figure></p>
<p>前面的代码块执行了以下操作：</p>
<ul>
<li>按照起点区域（包含在<code>o</code>列中）对数据进行了分组</li>
<li><em>如果</em>在<code>bristol_od</code>
数据集中的变量是数值型的，就对它们进行了聚合，以找出每个区域中按交通方式分布的人口总数<a
href="#fn2" class="footnote-ref" id="fnref2"
role="doc-noteref"><sup>2</sup></a></li>
<li>将分组变量<code>o</code>重命名，使其与<code>bristol_zones</code>对象中的ID列<code>geo_code</code>匹配</li>
</ul>
<p>由此产生的对象<code>zones_attr</code>是一个数据框，其行代表各个区域和一个ID变量。我们可以使用<code>%in%</code>操作符验证这些ID是否与<code>zones</code>数据集中的ID匹配，操作如下：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">summary<span class="punctuation">(</span>zones_attr<span class="operator">$</span>geo_code <span class="operator">%in%</span> bristol_zones<span class="operator">$</span>geo_code<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt;    Mode    TRUE </span></span><br><span class="line"><span class="comment">#&gt; logical     102</span></span><br></pre></td></tr></table></figure>
<p>结果显示，新对象中包含所有102个区域，而<code>zone_attr</code>具有可以与区域连接的形式<a
href="#fn3" class="footnote-ref" id="fnref3"
role="doc-noteref"><sup>3</sup></a>。这是通过使用连接函数
<code>left_join()</code>
来完成的（注意，在这里<code>inner_join()</code>也会产生相同的结果）。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">zones_joined <span class="operator">=</span> left_join<span class="punctuation">(</span>bristol_zones<span class="punctuation">,</span> zones_attr<span class="punctuation">,</span> by <span class="operator">=</span> <span class="string">&quot;geo_code&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="built_in">sum</span><span class="punctuation">(</span>zones_joined<span class="operator">$</span><span class="built_in">all</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] 238805</span></span><br><span class="line"><span class="built_in">names</span><span class="punctuation">(</span>zones_joined<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] &quot;geo_code&quot;   &quot;name&quot;       &quot;all&quot;        &quot;bicycle&quot;    &quot;foot&quot;      </span></span><br><span class="line"><span class="comment">#&gt; [6] &quot;car_driver&quot; &quot;train&quot;      &quot;geometry&quot;</span></span><br></pre></td></tr></table></figure>
<p>结果是<code>zones_joined</code>，它包含新的列，代表研究区域内每个区域起始的总出行次数（接近四分之一百万次）以及它们的出行方式（自行车、步行、汽车和火车）。出行起点的地理分布在下图的左侧地图中有所体现。这显示了大多数区域在研究区内有0至4000次的出行起始。生活在布里斯托尔市中心附近的人进行的出行次数更多，而在城市边缘的则较少。这是为什么呢？记住我们只在研究区域内处理出行：边缘区域低出行次数可以归因于这些周边区域的许多人会前往研究区域之外的其他地区。通过一个特殊的目的地ID，研究区域之外的出行可以被包括在区域模型中，该ID涵盖了任何前往模型中未表示的区域的出行(Hollander
2016)。然而，<code>bristol_od</code>中的数据简单地忽略了这样的出行：它是一个“区域内”的模型。</p>
<p>与OD（出发-目的地）数据集可以聚合到出发区域的方式相同，它们也可以被聚合以提供关于目的地区域的信息。人们倾向于聚集在中心地区。这解释了为什么下图右侧面板中表示的空间分布相对不均匀，最常见的目的地区域集中在布里斯托尔市中心。结果是<code>zones_od</code>，其中包含一个新列，报告了任何出行方式的目的地数量，如下所创建：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">zones_destinations <span class="operator">=</span> bristol_od <span class="operator">|&gt;</span> </span><br><span class="line">  group_by<span class="punctuation">(</span>d<span class="punctuation">)</span> <span class="operator">|&gt;</span> </span><br><span class="line">  summarize<span class="punctuation">(</span>across<span class="punctuation">(</span>where<span class="punctuation">(</span><span class="built_in">is.numeric</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">sum</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">|&gt;</span> </span><br><span class="line">  select<span class="punctuation">(</span>geo_code <span class="operator">=</span> d<span class="punctuation">,</span> all_dest <span class="operator">=</span> <span class="built_in">all</span><span class="punctuation">)</span></span><br><span class="line">zones_od <span class="operator">=</span> inner_join<span class="punctuation">(</span>zones_joined<span class="punctuation">,</span> zones_destinations<span class="punctuation">,</span> by <span class="operator">=</span> <span class="string">&quot;geo_code&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>下面的代码创建了一个简化版本的下图（参见书籍GitHub仓库的 <a
target="_blank" rel="noopener" href="https://github.com/geocompx/geocompr/tree/main/code"><code>code</code></a>
文件夹中的 <code>12-zones.R</code>
文件以重现该图，以及有关使用<strong>tmap</strong>创建分面地图的详细信息）：
<!-- toDo: rl   --> <!-- qtm does not exist... --></p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">qtm<span class="punctuation">(</span>zones_od<span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;all&quot;</span><span class="punctuation">,</span> <span class="string">&quot;all_dest&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  tm_layout<span class="punctuation">(</span>panel.labels <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;Origin&quot;</span><span class="punctuation">,</span> <span class="string">&quot;Destination&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309051544306.png" />
Number of trips (commuters) living and working in the region. The left
map shows zone of origin of commute trips; the right map shows zone of
destination (generated by the script 13-zones.R).</p>
<h1 id="欲望线">欲望线</h1>
<p>欲望线连接起点和终点，表示人们<em>想要</em>去的地方，通常是在各个区域之间。它们代表了从A点到B点最快的“直线”或“鸟飞”路线，如果没有建筑物和弯曲道路的阻碍的话（我们将在下一节看到如何将欲望线转化为实际路线）。通常，欲望线在地理上表示为每个区域的地理（或人口加权）中心的起点和终点。这是我们将在本节中创建和使用的欲望线类型，尽管值得注意的是，“抖动”技术能够增加多个起点和终点，以提高基于OD数据构建的分析的空间覆盖和准确性
(Lovelace，Félix 和 Carlino 2022)。</p>
<p>我们已经在数据集<code>bristol_od</code>中加载了代表欲望线的数据。这个起点-终点（OD）数据框对象表示在<code>o</code>和<code>d</code>所代表的区域之间旅行的人数，如下表所示。要按所有旅行对OD数据进行排序，然后只过滤出前5名，请输入：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">od_top5 <span class="operator">=</span> bristol_od <span class="operator">|&gt;</span> </span><br><span class="line">  slice_max<span class="punctuation">(</span><span class="built_in">all</span><span class="punctuation">,</span> n <span class="operator">=</span> <span class="number">5</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<table>
<caption>Sample of the top 5 origin-destination pairs in the Bristol OD
data frame, representing travel desire lines between zones in the study
area.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">o</th>
<th style="text-align: left;">d</th>
<th style="text-align: right;">all</th>
<th style="text-align: right;">bicycle</th>
<th style="text-align: right;">foot</th>
<th style="text-align: right;">car_driver</th>
<th style="text-align: right;">train</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">E02003043</td>
<td style="text-align: left;">E02003043</td>
<td style="text-align: right;">1493</td>
<td style="text-align: right;">66</td>
<td style="text-align: right;">1296</td>
<td style="text-align: right;">64</td>
<td style="text-align: right;">8</td>
</tr>
<tr class="even">
<td style="text-align: left;">E02003047</td>
<td style="text-align: left;">E02003043</td>
<td style="text-align: right;">1300</td>
<td style="text-align: right;">287</td>
<td style="text-align: right;">751</td>
<td style="text-align: right;">148</td>
<td style="text-align: right;">8</td>
</tr>
<tr class="odd">
<td style="text-align: left;">E02003031</td>
<td style="text-align: left;">E02003043</td>
<td style="text-align: right;">1221</td>
<td style="text-align: right;">305</td>
<td style="text-align: right;">600</td>
<td style="text-align: right;">176</td>
<td style="text-align: right;">7</td>
</tr>
<tr class="even">
<td style="text-align: left;">E02003037</td>
<td style="text-align: left;">E02003043</td>
<td style="text-align: right;">1186</td>
<td style="text-align: right;">88</td>
<td style="text-align: right;">908</td>
<td style="text-align: right;">110</td>
<td style="text-align: right;">3</td>
</tr>
<tr class="odd">
<td style="text-align: left;">E02003034</td>
<td style="text-align: left;">E02003043</td>
<td style="text-align: right;">1177</td>
<td style="text-align: right;">281</td>
<td style="text-align: right;">711</td>
<td style="text-align: right;">100</td>
<td style="text-align: right;">7</td>
</tr>
</tbody>
</table>
<p>生成的表格提供了关于布里斯托尔通勤（上班往返）出行模式的快照。它表明，在前5大起点-终点（OD）组合中，步行是最受欢迎的出行方式，而<code>E02003043</code>
区域是一个受欢迎的目的地（布里斯托尔市中心，所有前5大OD组合的目的地），并且<em>区内</em>
出行，从<code>E02003043</code>
区域的一个部分到另一个部分（表的第一行），是数据集中出行最多的OD组合。但从政策角度看，表中呈现的原始数据用处有限：除了它仅包含了2,910个OD组合中的一小部分之外，它几乎没有告诉我们<em>在哪里</em>需要政策措施，或者<em>有多少比例</em>的出行是通过步行和骑自行车完成的。
以下命令计算了由这些积极模式完成的每条欲望线的百分比：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bristol_od<span class="operator">$</span>Active <span class="operator">=</span> <span class="punctuation">(</span>bristol_od<span class="operator">$</span>bicycle <span class="operator">+</span> bristol_od<span class="operator">$</span>foot<span class="punctuation">)</span> <span class="operator">/</span></span><br><span class="line">  bristol_od<span class="operator">$</span><span class="built_in">all</span> <span class="operator">*</span> <span class="number">100</span></span><br></pre></td></tr></table></figure>
<p>有两种主要类型的OD（起点-终点）组合：<em>区间（Interzonal）</em> 和
<em>区内（Intrazonal）</em>。区间的OD组合代表了目的地与起点不同区域之间的出行。区内的OD组合代表了在同一区域内的出行（参见表的顶行）。以下代码块将
<code>od_bristol</code> 分为这两种类型：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">od_intra <span class="operator">=</span> filter<span class="punctuation">(</span>bristol_od<span class="punctuation">,</span> o <span class="operator">==</span> d<span class="punctuation">)</span></span><br><span class="line">od_inter <span class="operator">=</span> filter<span class="punctuation">(</span>bristol_od<span class="punctuation">,</span> o <span class="operator">!=</span> d<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>下一步是将区间（interzonal）的OD组合转换为一个表示“欲望线（desire
lines）”的<code>sf</code>对象，这可以通过使用 <strong>stplanr</strong>
函数 <code>od2line()</code> 来在地图上进行绘制。<a href="#fn4"
class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a></p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">desire_lines <span class="operator">=</span> od2line<span class="punctuation">(</span>od_inter<span class="punctuation">,</span> zones_od<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; Creating centroids representing desire line start and end points.</span></span><br></pre></td></tr></table></figure>
<p>下图展示了结果的示例，其简化版本可以通过以下命令创建（要完全复制该图形，请查看
<code>13-desire.R</code> 中的代码，有关使用 <strong>tmap</strong>
进行可视化的详细信息，请参见章节<em>高级制图</em>）：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qtm<span class="punctuation">(</span>desire_lines<span class="punctuation">,</span> lines.lwd <span class="operator">=</span> <span class="string">&quot;all&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309051558946.png" />
Desire lines representing trip patterns in Bristol, with width
representing number of trips and color representing the percentage of
trips made by active modes (walking and cycling). The four black lines
represent the interzonal OD pairs in Table 7.1.</p>
<p>该地图显示，市中心主导了该地区的交通模式，这暗示政策应当优先考虑这里，尽管也可以看到一些边缘的次中心。欲望线是交通系统中重要的概括性组成部分。更具体的组成部分包括节点，这些节点有特定的目的地（而不是欲望线中所表示的假设直线）。下一节将涵盖节点。</p>
<h1 id="节点">节点</h1>
<p>在地理交通数据集中，节点是组成交通网络的主要线性特征之间的点。大致上，有两种主要类型的交通节点：</p>
<ol type="1">
<li>不直接位于网络上的节点，例如区域质心或个体的起点和终点（如住宅和工作场所）。</li>
<li>是交通网络一部分的节点。
从技术上讲，一个节点可以位于交通网络上的任何点，但实际上它们通常是特殊类型的顶点，例如路径（交叉口）之间的交点和进入或退出交通网络的点，如公交站和火车站[^13-transport-6]。</li>
</ol>
<p>交通网络可以表示为图形，其中每个段通过地理线（代表边）与网络中的一个或多个其他边相连。可以通过“质心连接器”添加网络之外的节点，这些新的路线段连接到网络上附近的节点(Hollander
2016)[^13-transport-7]。网络中的每个节点然后通过一个或多个代表网络上个别段的“边”进行连接。我们将在<em>路线网络</em>节中看到如何将交通网络表示为图。</p>
<p>公共交通站点是特别重要的节点，可以表示为两种类型的节点：是道路的一部分的公交站，或由距离铁路轨道数百米的行人入口点代表的大型铁路站。我们将使用火车站来说明与布里斯托尔市增加自行车使用相关的公共交通节点。这些站由
<strong>spDataLarge</strong> 在 <code>bristol_stations</code>
中提供。</p>
<p>一个常见的障碍是，从家到工作的距离太远，无法步行或骑自行车。公共交通可以通过为进入城市的常见路线提供快速和高容量的选择来减少这一障碍。从积极出行的角度来看，长途旅行的公共交通“腿”将旅行分为三部分：</p>
<ul>
<li>起点腿，通常从住宅区到公共交通站</li>
<li>公共交通腿，通常从离旅行起点最近的站到离目的地最近的站</li>
<li>目的地腿，从下车站到目的地</li>
</ul>
<p>在<em>欲望线</em>节进行的分析的基础上，公共交通节点可用于为可乘坐公共汽车和（在本例中使用的）火车的旅行构建三部分欲望线。第一阶段是确定具有最多公共交通出行的欲望线，在我们的情况下这很容易，因为我们之前创建的数据集
<code>desire_lines</code> 已经包含了描述火车旅行数量的变量（也可以使用如
<a target="_blank" rel="noopener" href="http://www.opentripplanner.org/">OpenTripPlanner</a>
等公共交通路线服务来估计公共交通潜力）。为了使该方法更容易遵循，我们将仅选择关于铁路使用方面的前三条欲望线。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">desire_rail <span class="operator">=</span> top_n<span class="punctuation">(</span>desire_lines<span class="punctuation">,</span> n <span class="operator">=</span> <span class="number">3</span><span class="punctuation">,</span> wt <span class="operator">=</span> train<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>现在的挑战是将每一条这样的线分解为三部分，代表通过公共交通节点的出行。这可以通过将一条欲望线转换为一个由三个线几何体组成的多线字符串对象来实现，这三个线几何体分别代表行程的起点、公共交通和终点阶段。这个操作可以分为三个阶段：矩阵创建（代表起点、终点和表示铁路站的“途经”点）、最近邻标识和转换为多线字符串。这些都由<code>line_via()</code>函数来完成。这个<strong>stplanr</strong>函数接受输入线和点，并返回一份欲望线的副本——具体细节请参见<a
target="_blank" rel="noopener" href="https://docs.ropensci.org/stplanr/reference/line_via.html"><code>?line_via()</code></a>。
输出与输入线相同，只不过它有新的几何列，代表通过公共交通节点的行程，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ncol<span class="punctuation">(</span>desire_rail<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] 9</span></span><br><span class="line">desire_rail <span class="operator">=</span> line_via<span class="punctuation">(</span>desire_rail<span class="punctuation">,</span> bristol_stations<span class="punctuation">)</span></span><br><span class="line">ncol<span class="punctuation">(</span>desire_rail<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] 12</span></span><br></pre></td></tr></table></figure>
<p>如下图所示，初始的 <code>desire_rail</code>
线现在有三个额外的几何列表列，分别代表从家到起点站、从那里到目的地，以及最后从目的地站到目的地的旅行。在这种情况下，目的地段非常短（步行距离），但起点段可能足够远，以证明需要在骑行基础设施上进行投资，以鼓励人们在上班途中到居住区周围的三个起点站骑自行车，如下图所示。</p>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309051613261.png" />
Station nodes (red dots) used as intermediary points that convert
straight desire lines with high rail usage (thin green lines) into three
legs: to the origin station (orange) via public transport (blue) and to
the destination (pink, not visible because it is so short).</p>
<h1 id="路线">路线</h1>
<p>从地理角度看，路线是不再直线的需求线：起点和终点与旅行的需求线表示相同，但从A到B的路径更为复杂。路线的几何形状通常（但不总是）由交通网络决定。</p>
<p>虽然需求线仅包含两个顶点（其起点和终点），但路线可以包含任意数量的顶点，代表由直线连接的A和B之间的点：这就是linestring几何形状的定义。覆盖大距离或遵循复杂网络的路线可能有数百个顶点；基于网格或简化道路网络的路线通常较少。</p>
<p>路线是由需求线生成的，或更常见地，由包含代表需求线的坐标对的矩阵生成。这个路由过程是由一系列广义定义的<em>路由引擎</em>完成的：软件和Web服务，它们返回描述如何从起点到终点的几何形状和属性。根据它们相对于R运行的<em>位置</em>，路由引擎可以被分类为：</p>
<ul>
<li>内存路由，使用使路线计算成为可能的R包</li>
<li>本地托管的、外部于R的路由引擎，可以从R中调用</li>
<li>由外部实体远程托管的路由引擎，提供一个可以从R中调用的Web API</li>
</ul>
<p>在描述每一个之前，值得概述分类路由引擎的其他方式。路由引擎可以是多模式的，意味着它们可以计算由多种交通方式组成的行程，或者不是。多模式路由引擎可以返回由不同交通方式组成的多个<em>段</em>的结果。从住宅区到商业区的最佳路线可能涉及1）步行到最近的公交车站，2）乘公交车到离目的地最近的节点，以及3）步行到目的地，给定一组输入参数。这三段之间的转换点通常被称为“进入”和“出口”，意味着上下公共交通工具。像R5这样的多模式路由引擎比如OSRM这样的'单一模式'路由引擎更为复杂，并且有更大的输入数据要求。</p>
<p>多模式引擎的一个主要优势是它们能够表示由火车、公共汽车等组成的“公共交通”行程。多模型路由引擎需要代表公共交通网络的输入数据集，通常以General
Transit Feed Specification（<a
target="_blank" rel="noopener" href="https://developers.google.com/transit/gtfs">GTFS</a>）文件形式，这些可以用<a
target="_blank" rel="noopener" href="https://r-transit.github.io/tidytransit/index.html"><strong>tidytransit</strong></a>和<a
target="_blank" rel="noopener" href="https://ipeagit.github.io/gtfstools/"><strong>gtfstools</strong></a>包（也有其他用于处理GTFS文件的包和工具）中的函数进行处理。对于专注于特定（非公共）交通方式的项目，单一模式路由引擎可能就足够了。另一种分类路由引擎（或设置）的方式是通过输出的地理级别：路线、段和环节。</p>
<h2 id="路线段和环节">路线、段和环节</h2>
<p>路由引擎可以在三个地理级别生成输出：路线、段和环节：</p>
<ul>
<li><strong>路线</strong>级别的输出每个起点-终点对包含一个单一特征（通常是数据框表示中的多线几何和关联行），意味着每次行程的数据有一行。</li>
<li><strong>段</strong>级别的输出在每个起点-终点对内的每个<em>模式</em>都包含一个单一特征和相关属性。对于仅涉及一种模式的行程（例如，从家到工作的驾驶，忽略走到汽车的短距离），段与路线相同：即汽车行程。对于涉及公共交通的行程，段提供关键信息。<strong>r5r</strong>函数<code>detailed_itineraries()</code>返回的段有时令人困惑地被称为“环节”。</li>
<li>环节级别的输出提供了有关路线的最详细信息，具有交通网络的每个小段的记录。通常，环节在长度上类似于，或与，OpenStreetMap中的道路相同。<strong>cyclestreets</strong>函数<code>journey()</code>返回在环节级别的数据，这些数据可以通过对<strong>stplanr</strong>中<code>route()</code>函数返回的起点和终点级别数据进行分组而聚合。</li>
</ul>
<p>大多数路由引擎默认返回路线级别的输出，尽管多模式引擎通常在段级别提供输出（每个连续运动的单一交通模式一个特征）。
环节级别的输出有提供更多细节的优点。
<strong>cyclestreets</strong>包返回每条路线的多个“安静度”级别，使得可以识别自行车网络中的“最薄弱环节”。
环节级别输出的劣势包括增加的文件大小和与额外细节相关的复杂性。</p>
<p>使用函数<code>stplanr::overline()</code><span class="citation"
data-cites="morgan_travel_2020">[@morgan_travel_2020]</span>，路线级别的结果可以转换为环节级别的结果。在使用环节或段级别的数据时，通过对表示行程起点和终点的列进行分组，并汇总/聚合包含环节级别数据的列，可以返回路线级别的统计数据。</p>
<h2 id="使用r进行内存内路由">使用R进行内存内路由</h2>
<p>R中的路由引擎允许将存储为R对象的<em>内存内</em>路由网络用作路由计算的基础。选项包括<a
target="_blank" rel="noopener" href="https://luukvdmeer.github.io/sfnetworks/"><strong>sfnetworks</strong></a>、<a
target="_blank" rel="noopener" href="https://atfutures.github.io/dodgr/"><strong>dodgr</strong></a> 和
<a
target="_blank" rel="noopener" href="https://github.com/vlarmet/cppRouting"><strong>cppRouting</strong></a>
包，每个包都提供了它们自己的类系统来表示路由网络，这是下一节的主题。</p>
<p>尽管快速和灵活，使用原生R的路由选项通常比用于现实路由计算的专用路由引擎更难设置。路由是一个复杂问题，开源路由引擎已经投入了很多时间，这些引擎可以下载并在本地主机上运行。另一方面，基于R的路由引擎可能非常适用于模型实验和网络上变化影响的统计分析。在单一语言中更改路由网络特性（或与不同路由段类型相关联的权重）、重新计算路由和分析多个场景下的结果对研究应用有益。</p>
<h2 id="本地托管的专用路由引擎">本地托管的专用路由引擎</h2>
<p><strong>本地托管</strong>的路由引擎包括OpenTripPlanner、<a
target="_blank" rel="noopener" href="https://github.com/valhalla/valhalla">Valhalla</a>
和R5（它们是多模式的），以及OpenStreetMap路由机器（OSRM）（它是“单模式”的）。这些可以通过<strong>opentripplanner</strong>、<a
target="_blank" rel="noopener" href="https://github.com/chris31415926535/valhallr"><strong>valhalla</strong></a>、<strong>r5r</strong>
和 <a target="_blank" rel="noopener" href="https://github.com/riatelab/osrm"><strong>osrm</strong></a>
包从R中访问(Morgan 等，2019; Pereira
等，2021)。本地托管的路由引擎在用户的计算机上运行，但在一个与R分开的进程中。它们的优点包括执行速度和对不同运输模式的权重配置文件的控制。劣势包括在本地表示复杂网络的困难；时间动态（主要是由于交通）；以及需要专用外部软件。</p>
<h2 id="远程托管的专用路由引擎">远程托管的专用路由引擎</h2>
<p><strong>远程托管</strong>的路由引擎使用web
API发送有关起点和终点的查询并返回结果。基于开源路由引擎的路由服务，例如OSRM的公开可用服务，在从R调用时与本地托管实例的工作方式相同，只需更新指定“基础URL”的参数即可。然而，由于外部路由服务托管在专用机器上（通常由有激励生成准确路由的商业公司资助），这可能给它们带来优势，包括：</p>
<ul>
<li>提供全球（或通常至少在大区域内）的路由服务</li>
<li>已建立的路由服务通常会定期更新，并且经常能够响应交通水平</li>
<li>路由服务通常在专用硬件和软件上运行，包括像负载均衡器这样的系统以确保性能稳定</li>
</ul>
<p>远程路由服务的劣势包括批量作业不可能时的速度（它们通常依赖于一条条路由的基础上通过互联网进行数据传输）、价格（例如，谷歌路由API限制了免费查询的数量）和许可问题。</p>
<p><a
target="_blank" rel="noopener" href="http://symbolixau.github.io/googleway/"><strong>googleway</strong></a>
和 <a
target="_blank" rel="noopener" href="https://walker-data.com/mapboxapi/articles/navigation.html"><strong>mapbox</strong></a>
包通过提供对Google和Mapbox的路由服务的访问来展示这种方法。免费（但有速率限制）的路由服务包括
<a target="_blank" rel="noopener" href="http://project-osrm.org/">OSRM</a> 和 <a
target="_blank" rel="noopener" href="https://openrouteservice.org/">openrouteservice.org</a>，它们可以通过
<a
target="_blank" rel="noopener" href="https://rgeomatic.hypotheses.org/category/osrm"><strong>osrm</strong></a>
和 <a
target="_blank" rel="noopener" href="https://github.com/GIScience/openrouteservice-r"><strong>openrouteservice</strong></a>
包从R中访问，后者不在CRAN上。还有更具体的路由服务，例如由 <a
target="_blank" rel="noopener" href="https://www.cyclestreets.net/">CycleStreets.net</a>
提供的，这是一个自行车旅行规划器和非营利性交通技术公司“为骑自行车者，由骑自行车者”。虽然R用户可以通过
<a
target="_blank" rel="noopener" href="https://rpackage.cyclestreets.net/"><strong>cyclestreets</strong></a>
包访问CycleStreets路由，但许多路由服务缺乏R接口，这代表了一个巨大的软件包开发机会：构建一个R包以提供一个接口到web
API可能是一种有益的经历。</p>
<p>R包用于计算和导入代表交通网络上路由的数据的广泛范围是一种优势，这意味着该语言近年来越来越多地用于交通研究。然而，这种包和方法的激增的一个小缺点是有很多包和函数名称需要记住。
<strong>stplanr</strong> 包通过提供一个用于生成路由的统一接口
<code>route()</code>
函数来解决这个问题。该函数接受广泛的输入，包括地理欲望线（使用
<code>l =</code>
参数）、坐标甚至表示独特地址的文本字符串，并返回作为一致 <code>sf</code>
对象的路由数据。</p>
<!-- TODO: 在某个时候我希望创建一个专用的路由包，如果它被创建了，请提及（RL 2022-07） -->
<h2 id="路径规划一个实际示例">路径规划：一个实际示例</h2>
<p>与其对部分生成的<em>所有</em>期望线进行路径规划，我们专注于高度政策相关的一个子集。在尝试处理整个数据集之前，先对一个子集进行计算密集型操作通常是明智的，这同样适用于路径规划。路径规划可能需要消耗大量时间和内存，并生成大型对象，这是因为路线对象的详细几何形状和额外属性。因此，我们将在本节中过滤期望线，然后计算路径。</p>
<p>当骑行替代开车出行时，效益最大。短距离（大约5公里，以20公里/小时的速度可以在15分钟内骑完）有相对较高的被骑行的概率，当使用<a
target="_blank" rel="noopener" href="https://www.sciencedirect.com/science/article/pii/S0967070X21003401">电动自行车</a>进行出行时，最大距离会增加(Lovelace
等，2017)。以下代码片段考虑了这些因素，过滤了期望线，并返回了表示OD对（起点到终点对）的对象
<code>desire_lines_short</code>，在这些OD对之间有很多（100+）短距离（2.5至5公里的欧几里得距离）的车程：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">desire_lines<span class="operator">$</span>distance_km <span class="operator">=</span> <span class="built_in">as.numeric</span><span class="punctuation">(</span>st_length<span class="punctuation">(</span>desire_lines<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">/</span> <span class="number">1000</span></span><br><span class="line">desire_lines_short <span class="operator">=</span> desire_lines <span class="operator">|&gt;</span> </span><br><span class="line">  filter<span class="punctuation">(</span>car_driver <span class="operator">&gt;=</span> <span class="number">100</span><span class="punctuation">,</span> distance_km <span class="operator">&lt;=</span> <span class="number">5</span><span class="punctuation">,</span> distance_km <span class="operator">&gt;=</span> <span class="number">2.5</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，<code>st_length()</code>
计算了每个期望线的长度。<strong>dplyr</strong> 的 <code>filter()</code>
函数基于上述标准过滤了 <code>desire_lines</code>
数据集。下一步是将这些期望线转换为路线。这是通过下面的代码块中使用公开可用的OSRM服务和
<strong>stplanr</strong> 的 <code>route()</code> 和
<code>route_osrm()</code> 函数来完成的：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">routes_short <span class="operator">=</span> route<span class="punctuation">(</span>l <span class="operator">=</span> desire_lines_short<span class="punctuation">,</span> route_fun <span class="operator">=</span> route_osrm<span class="punctuation">,</span></span><br><span class="line">                     osrm.profile <span class="operator">=</span> <span class="string">&quot;bike&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>输出是
<code>routes_short</code>，一个代表适用于骑自行车的交通网络上的路线的
<code>sf</code> 对象（至少根据 OSRM
路由引擎是这样），每个期望线对应一个。注意：像上面的命令中那样调用外部路由引擎只有在有互联网连接的情况下才能工作（有时还需要存储在环境变量中的
API 密钥，尽管在这种情况下不需要）。除了 <code>desire_lines</code>
对象中包含的列之外，新的路线数据集还包含
<code>distance</code>（这次是指路线距离）和
<code>duration</code>（以秒为单位）列，这些提供了有关每条路线性质的潜在有用额外信息。我们将绘制沿着这些线路进行许多短途汽车行驶的期望线和骑行路线。通过使路线的宽度与可能被替换的汽车行驶数量成比例，提供了一种有效的方式来优先考虑对道路网络进行干预(Lovelace
等 2017)。
下面的代码块绘制了期望线和路线，该图显示了人们驾驶短距离的路线：<a
href="#fn5" class="footnote-ref" id="fnref5"
role="doc-noteref"><sup>5</sup></a></p>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309051636508.png" />
Routes along which many (100+) short (&lt;5km Euclidean distance) car
journeys are made (red) overlaying desire lines representing the same
trips (black) and zone centroids (dots).</p>
<p>通过在交互式地图上绘制结果，例如使用
<code>mapview::mapview(st_geometry(routes_short))</code>，可以看到许多短途汽车行程发生在布拉德利斯托克（Bradley
Stoke）及其周围，距离布里斯托尔（Bristol）市中心大约10公里以北。找出该地区高度依赖汽车的原因很容易：根据<a
target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Bradley_Stoke">维基百科</a>，布拉德利斯托克是“欧洲最大的由私人投资建设的新城镇”，这暗示了有限的公共交通供应。此外，该城镇被包括M4和M5高速公路在内的大型（对自行车不友好）的道路结构所环绕（tallon
2007)。</p>
<p>将旅行需求线转换为路线有很多好处。重要的是要记住，我们不能确定有多少（如果有的话）行程会沿着路由引擎计算出的确切路线进行。然而，路线和街道/道路/段级别的结果可能具有很高的政策相关性。路段结果可以根据可用数据(Lovelace
等 2017)，实现在最需要的地方优先进行投资。</p>
<h1 id="路线网络">路线网络</h1>
<p>虽然路线通常包含有关旅行<em>行为</em>的数据，在与需求线和OD（起点-终点）对相同的地理层级上，路线网络数据集通常代表物理交通网络。路线网络中的每个<em>段</em>大致对应于交叉口之间的连续街道段，并且只出现一次，尽管段的平均长度取决于数据源（本节中使用的由OSM（开放街道地图）派生的<code>bristol_ways</code>数据集中的段平均长度刚好超过200米，标准差接近500米）。段长度的可变性可以由这样一个事实来解释：在一些农村地区，交叉口相距很远，而在密集的城市区域，每隔几米就有交叉口和其他段的断点。</p>
<p>路线网络可以是交通数据分析项目的输入或输出，或者两者都是。任何涉及路线计算的交通研究都需要内部或外部路由引擎中的路线网络数据集（在后一种情况下，路线网络数据不一定需要导入到R中）。然而，路线网络在许多交通研究项目中也是重要的输出：总结诸如特定段上可能进行的潜在行程数量的数据，并以路线网络的形式表示，可以帮助在最需要的地方优先进行投资。</p>
<p>为了演示如何从路线级别的数据中创建路线网络作为输出，想象一个简单的模式转移场景。假设0到3公里的路线距离之间的50%的汽车行程被自行车取代，这一百分比每增加1公里的路线距离就减少10个百分点，以至于6公里的汽车行程有20%被自行车取代，而8公里或更长的汽车行程没有被自行车取代。当然，这是一个不现实的情景(Lovelace
等 2017)，但它是一个有用的起点。
在这种情况下，我们可以按照以下方式模拟从汽车到自行车的模式转移：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">uptake <span class="operator">=</span> <span class="keyword">function</span><span class="punctuation">(</span>x<span class="punctuation">)</span> <span class="punctuation">&#123;</span></span><br><span class="line">  case_when<span class="punctuation">(</span></span><br><span class="line">    x <span class="operator">&lt;=</span> <span class="number">3</span> <span class="operator">~</span> <span class="number">0.5</span><span class="punctuation">,</span></span><br><span class="line">    x <span class="operator">&gt;=</span> <span class="number">8</span> <span class="operator">~</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="literal">TRUE</span> <span class="operator">~</span> <span class="punctuation">(</span><span class="number">8</span> <span class="operator">-</span> x<span class="punctuation">)</span> <span class="operator">/</span> <span class="punctuation">(</span><span class="number">8</span> <span class="operator">-</span> <span class="number">3</span><span class="punctuation">)</span> <span class="operator">*</span> <span class="number">0.5</span></span><br><span class="line">  <span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line">routes_short_scenario <span class="operator">=</span> routes_short <span class="operator">|&gt;</span> </span><br><span class="line">  mutate<span class="punctuation">(</span>uptake <span class="operator">=</span> uptake<span class="punctuation">(</span>distance <span class="operator">/</span> <span class="number">1000</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">|&gt;</span> </span><br><span class="line">  mutate<span class="punctuation">(</span>bicycle <span class="operator">=</span> bicycle <span class="operator">+</span> car_driver <span class="operator">*</span> uptake<span class="punctuation">,</span></span><br><span class="line">         car_driver <span class="operator">=</span> car_driver <span class="operator">*</span> <span class="punctuation">(</span><span class="number">1</span> <span class="operator">-</span> uptake<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="built_in">sum</span><span class="punctuation">(</span>routes_short_scenario<span class="operator">$</span>bicycle<span class="punctuation">)</span> <span class="operator">-</span> <span class="built_in">sum</span><span class="punctuation">(</span>routes_short<span class="operator">$</span>bicycle<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] 3733</span></span><br></pre></td></tr></table></figure>
<p>在创建了一个大约有4000次行程从驾驶转向骑自行车的场景后，我们现在可以模拟这个更新后的模拟自行车活动将在哪里发生。为此，我们将使用<strong>stplanr</strong>包中的<code>overline()</code>函数。该函数在交叉口（两条或更多的折线几何相交的地方）处断开折线，并计算每个唯一路段的聚合统计信息(Morgan
和 Lovelace
2020)，它将包含路线的对象和要汇总的属性的名称作为第一和第二个参数：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route_network_scenario <span class="operator">=</span> overline<span class="punctuation">(</span>routes_short_scenario<span class="punctuation">,</span> attrib <span class="operator">=</span> <span class="string">&quot;bicycle&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>前面两个代码块的输出总结如下面的图所示。</p>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309051646384.png" />
Illustration of the percentage of car trips switching to cycling as a
function of distance (left) and route network level results of this
function (right).</p>
<p>具有在路段级别的记录的交通网络，通常带有诸如道路类型和宽度之类的属性，构成了一种常见的路线网络。这种路线网络数据集在全球范围内都可以从OpenStreetMap获得，并可以使用诸如<strong>osmdata</strong>和<strong>osmextract</strong>这样的软件包进行下载。为了节省下载和准备OSM的时间，我们将使用来自<strong>spDataLarge</strong>包的<code>bristol_ways</code>对象，这是一个带有LINESTRING几何图形和属性的<code>sf</code>对象，代表了案例研究区域内交通网络的一个样本（详见<code>?bristol_ways</code>以获取详细信息），如下面的输出所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">summary<span class="punctuation">(</span>bristol_ways<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt;      highway       maxspeed             ref                     geometry   </span></span><br><span class="line"><span class="comment">#&gt;  cycleway:1721   Length:6160        Length:6160        LINESTRING   :6160  </span></span><br><span class="line"><span class="comment">#&gt;  rail    :1017   Class :character   Class :character   epsg:4326    :   0  </span></span><br><span class="line"><span class="comment">#&gt;  road    :3422   Mode  :character   Mode  :character   +proj=long...:   0</span></span><br></pre></td></tr></table></figure>
<p>输出显示<code>bristol_ways</code>代表了交通网络上刚刚超过6千个路段。这种和其他地理网络可以表示为数学图，网络上的节点由边连接。一些R软件包已经为处理这样的图而开发，尤其是<strong>igraph</strong>。您可以手动将路线网络转换为<code>igraph</code>对象，但地理属性将会丢失。为了克服<strong>igraph</strong>的这一局限性，开发了<strong>sfnetworks</strong>软件包，该软件包能够同时将路线网络表示为图<em>和</em>地理线。我们将在<code>bristol_ways</code>对象上演示<strong>sfnetworks</strong>的功能。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bristol_ways<span class="operator">$</span>lengths <span class="operator">=</span> st_length<span class="punctuation">(</span>bristol_ways<span class="punctuation">)</span></span><br><span class="line">ways_sfn <span class="operator">=</span> as_sfnetwork<span class="punctuation">(</span>bristol_ways<span class="punctuation">)</span></span><br><span class="line"><span class="built_in">class</span><span class="punctuation">(</span>ways_sfn<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] &quot;sfnetwork&quot; &quot;tbl_graph&quot; &quot;igraph&quot;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ways_sfn</span><br><span class="line"><span class="comment">#&gt; # A sfnetwork with 5728 nodes and 4915 edges</span></span><br><span class="line"><span class="comment">#&gt; # A directed multigraph with 1013 components with spatially explicit edges</span></span><br><span class="line"><span class="comment">#&gt; # Node Data:     5,728 × 1 (active)</span></span><br><span class="line"><span class="comment">#&gt; # Edge Data:     4,915 × 7</span></span><br><span class="line"><span class="comment">#&gt;    from    to highway maxspeed ref                              geometry lengths</span></span><br><span class="line"><span class="comment">#&gt;   &lt;int&gt; &lt;int&gt; &lt;fct&gt;   &lt;fct&gt;    &lt;fct&gt;                    &lt;LINESTRING [°]&gt;     [m]</span></span><br><span class="line"><span class="comment">#&gt; 1     1     2 road    &lt;NA&gt;     B3130 (-2.61 51.4, -2.61 51.4, -2.61 51.…    218.</span></span><br><span class="line"><span class="comment">#&gt; # … </span></span><br></pre></td></tr></table></figure>
<p>由于空间考虑，前一个代码块的输出（最后的输出被缩短，仅包含最重要的8行）显示<code>ways_sfn</code>是一个复合对象，以图和空间形式包含节点和边。<code>ways_sfn</code>是<code>sfnetwork</code>类，该类基于<strong>igraph</strong>包中的<code>igraph</code>类。在下面的示例中，计算了'边介数'，也就是经过每条边的最短路径的数量（有关更多详细信息，请参见<code>?igraph::betweenness</code>）。边介数计算的输出显示在下图，该图以用<code>overline()</code>函数计算的自行车路线网络数据集作为叠加层进行比较。结果表明，每个图的边代表一个路段：靠近道路网络中心的路段具有最高的介数值，而靠近布里斯托尔中心的路段基于这些简单数据集具有更高的自行车潜力。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ways_centrality <span class="operator">=</span> ways_sfn <span class="operator">|&gt;</span> </span><br><span class="line">  activate<span class="punctuation">(</span><span class="string">&quot;edges&quot;</span><span class="punctuation">)</span> <span class="operator">|&gt;</span>  </span><br><span class="line">  mutate<span class="punctuation">(</span>betweenness <span class="operator">=</span> tidygraph<span class="operator">::</span>centrality_edge_betweenness<span class="punctuation">(</span>lengths<span class="punctuation">)</span><span class="punctuation">)</span> </span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309051653021.png" />
Illustration of route network datasets. The grey lines represent a
simplified road network, with segment thickness proportional to
betweenness. The green lines represent potential cycling flows (one way)
calculated with the code above</p>
<p>人们还可以使用<strong>sfnetworks</strong>包中的这种路由网络的图表示法来找到起点和终点之间的最短路线。<!-- TODO: 如果时间允许，基于这一点制作一个练习（RL 2022-07） -->与可能的情况相比，本节介绍的方法相对简单。<strong>sfnetworks</strong>开放的双重图/空间功能使得许多新的强大技术得以实现，这些在本节中无法完全涵盖。然而，本节确实为进一步探索和研究该领域提供了一个坚实的起点。最后一点是，我们上面使用的示例数据集相对较小。也可能值得考虑如何将工作适应到更大的网络：在数据的子集上测试方法，并确保您有足够的RAM将有所帮助，尽管也值得探索其他优化用于大型网络的交通网络分析工具，比如R5
(Alessandretti 等 2022)。</p>
<h1 id="优先考虑新基础设施">优先考虑新基础设施</h1>
<p>本节演示了地理计算如何在交通规划领域创造与政策相关的成果。我们将使用一个简单的方法（出于教育目的）来识别可持续交通基础设施投资的有希望的地点。</p>
<p>本章概述的数据驱动方法的一个优点是其模块性：每个方面本身就很有用，并可以融入更广泛的分析中。使我们达到这一阶段的步骤包括在<em>路线</em>节中识别短途但依赖汽车的通勤路线（由欲望线生成），以及使用<strong>sfnetworks</strong>包在<em>路线网络</em>中分析路由网络特性。本章的最后一个代码块将这些分析纵向结合，通过在代表距离自行车基础设施很近的区域的新数据集上覆盖上一节中的自行车潜力估计。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">existing_cycleways_buffer <span class="operator">=</span> bristol_ways <span class="operator">|&gt;</span> </span><br><span class="line">  filter<span class="punctuation">(</span>highway <span class="operator">==</span> <span class="string">&quot;cycleway&quot;</span><span class="punctuation">)</span> <span class="operator">|&gt;</span>    <span class="comment"># 1) filter out cycleways</span></span><br><span class="line">  st_union<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">|&gt;</span>                       <span class="comment"># 2) unite geometries</span></span><br><span class="line">  st_buffer<span class="punctuation">(</span>dist <span class="operator">=</span> <span class="number">100</span><span class="punctuation">)</span>               <span class="comment"># 3) create buffer</span></span><br></pre></td></tr></table></figure>
<p>下一步是创建一个数据集，该数据集代表网络上存在高自行车潜力但几乎没有为自行车提供便利设施的点：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">route_network_no_infra <span class="operator">=</span> st_difference<span class="punctuation">(</span></span><br><span class="line">  route_network_scenario<span class="punctuation">,</span></span><br><span class="line">  route_network_scenario <span class="operator">|&gt;</span> st_set_crs<span class="punctuation">(</span>st_crs<span class="punctuation">(</span>existing_cycleways_buffer<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">  existing_cycleways_buffer</span><br><span class="line"><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#&gt; Warning: attribute variables are assumed to be spatially constant throughout</span><br><span class="line">#&gt; all geometries</span><br></pre></td></tr></table></figure>
<p>前面代码块的结果显示在下图中，该图显示了具有高度依赖汽车、具有高自行车潜力但没有自行车道的路线。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tmap_mode<span class="punctuation">(</span><span class="string">&quot;view&quot;</span><span class="punctuation">)</span></span><br><span class="line">qtm<span class="punctuation">(</span>route_network_no_infra<span class="punctuation">,</span> basemaps <span class="operator">=</span> leaflet<span class="operator">::</span>providers<span class="operator">$</span>Esri.WorldTopoMap<span class="punctuation">,</span></span><br><span class="line">    lines.lwd <span class="operator">=</span> <span class="number">5</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<!-- toDo: rl -->
<!-- the next figure must be updated -->
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#&gt; Warning: Some legend items or map compoments do not fit well (e.g. due to the</span><br><span class="line">#&gt; specified font size).</span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309051701347.png" />
Potential routes along which to prioritise cycle infrastructure in
Bristol to reduce car dependency. The static map provides an overview of
the overlay between existing infrastructure and routes with high
car-bike switching potential (left). The screenshot the interactive map
generated from the <code>qtm()</code> function highlights Whiteladies
Road as somewhere that would benefit from a new cycleway (right).</p>
<p>该方法存在一些局限性：实际上，人们并不总是前往区域中心或始终使用特定模式的最短路径算法。然而，结果展示了如何使用地理数据分析来突出可能特别有益于新投资自行车道的地方，尽管这种方法很简单。为了在实践中指导交通规划设计，这种分析需要大幅扩展——包括使用更大的输入数据集。</p>
<h1 id="旅行的未来方向">旅行的未来方向</h1>
<p>这一章提供了使用地理计算进行交通研究的可能性的一个概览，并使用开放数据和可复制代码探讨了构成城市交通系统的一些关键地理元素。这些结果有助于规划需要投资的地方。</p>
<p>交通系统在多个相互作用的层面上运行，这意味着地理计算方法有很大的潜力，可以生成有关它们如何运作以及不同干预措施可能产生的影响的见解。在这一领域还有更多可以做的事情：基于本章提供的基础，有很多方向可以进行拓展。</p>
<p>交通是许多国家温室气体排放增长最快的来源，并将成为“尤其是在发达国家中最大的温室气体排放部门”。交通相关的排放在社会上分布不均，但（与食物和供暖不同）对幸福来说并非必需品。通过需求减少、车队电气化以及积极采取像步行和骑自行车这样的活动出行方式，该部门有很大的快速减碳潜力。新技术可以通过更多的汽车共享来减少对汽车的依赖。诸如无桩自行车和电动滑板车方案这样的“微移动”系统也正在出现，以General
Bikeshare Feed Specification（GBFS）格式创建有价值的数据集，可以用<a
target="_blank" rel="noopener" href="https://github.com/simonpcouch/gbfs"><strong>gbfs</strong></a>包进行导入和处理。</p>
<p>从方法论的角度看，本章提供的基础可以通过在分析中包括更多变量来进行扩展。例如，通过使用R语言的统计建模能力，这可以用来预测当前和未来的自行车使用水平。</p>
<p>这种类型的分析是Propensity to Cycle
Tool（PCT）的基础，这是一个用R语言开发的，用于优先考虑英格兰各地自行车投资的公开可访问的映射工具（lovelace
2017）。类似的工具可以用于鼓励与空气污染和公共交通准入等其他主题相关的基于证据的交通政策。</p>
<h1 id="练习">练习</h1>
<p>E1. In much of the analysis presented in the chapter we focused on
active modes, but what about driving trips?</p>
<ul>
<li>What proportion of trips in the <code>desire_lines</code> object are
made by driving?</li>
<li>What proportion of <code>desire_lines</code> have a straight line
length of 5 km or more in distance?</li>
<li>What proportion of trips in desire lines that are longer than 5 km
in length are made by driving?</li>
<li>Plot the desire lines that are both less than 5 km in length and
along which more than 50% of trips are made by car.</li>
<li>What do you notice about the location of these car dependent yet
short desire lines?</li>
</ul>
<p>E2. What additional length of cycleways would result if all the
routes presented in the last Figure, on sections beyond 100 m from
existing cycleways, were constructed?</p>
<p>E3. What proportion of trips represented in the
<code>desire_lines</code> are accounted for in the
<code>routes_short_scenario</code> object?</p>
<ul>
<li>Bonus: what proportion of all trips happen on desire lines that
cross <code>routes_short_scenario</code>?</li>
</ul>
<p>E4. The analysis presented in this chapter is designed for teaching
how geocomputation methods can be applied to transport research. If you
were doing this for real, in government or for a transport consultancy,
what top 3 things would you do differently?</p>
<p>E5. Clearly, the routes identified in the last Figure only provide
part of the picture. How would you extend the analysis?</p>
<p>E6. Imagine that you want to extend the scenario by creating key
<em>areas</em> (not routes) for investment in place-based cycling
policies such as car-free zones, cycle parking points and reduced car
parking strategy. How could raster datasets assist with this work?</p>
<ul>
<li>Bonus: develop a raster layer that divides the Bristol region into
100 cells (10 by 10) and estimate the average speed limit of roads in
each, from the <code>bristol_ways</code> dataset (see Chapter
@ref(location)).</li>
</ul>
<aside id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li
id="fn1"><p>在第一个匹配没有提供正确名称的情况下，应指定国家或地区，例如位于美国的布里斯托尔应为
<code>Bristol Tennessee</code>。<a href="#fnref1" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p><code>_if</code> 后缀要求对变量提出一个
<code>TRUE</code>/<code>FALSE</code>
的问题，在这个情况下是'是否为数值型?' 只有返回 true 的变量会被汇总。<a
href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li
id="fn3"><p>在实际数据中，检查ID在反方向上是否匹配也同样重要。这可以通过改变<code>summary()</code>命令中ID的顺序来完成——<code>summary(bristol_zones$geo_code %in% zones_attr$geo_code)</code>——或者通过如下使用<code>setdiff()</code>：<code>setdiff(bristol_zones$geo_code, zones_attr$geo_code)</code>。<a
href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p><code>od2line()</code> 的工作方式是通过匹配
<code>bristol_od</code> 对象的前两列中的ID与地理 <code>zones_od</code>
对象中的 <code>zone_code</code>
ID列。需要注意的是，该操作会发出一个警告，因为 <code>od2line()</code>
是通过将每一对起点-终点分配给其起源和目的地区域的<em>质心</em>来工作的。对于实际应用，人们会使用由投影数据生成的质心值，或者更好地使用<em>基于人口加权</em>的质心<span
class="citation"
data-cites="lovelace_propensity_2017">[@lovelace_propensity_2017]</span>。<a
href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li
id="fn5"><p>注意，红色的路线和黑色的期望线的起点并不完全相同。这是因为区域质心很少位于路线网络上：相反，路线起源于距离质心最近的交通网络节点。还要注意，假设路线起源于区域质心，这是一个简化假设，用于减少计算所有可能起点和终点组合之间的最短路径所需的计算资源<span
class="citation"
data-cites="hollander_transport_2016">[@hollander_transport_2016]</span>。<a
href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>

            
        </div>

        
        
        

        <div>
            
        </div>

        <footer class="post-footer">
            <div class="post-eof"></div>
            
        </footer>
    </article>
</div>




    


<div class="post-block">
    
    

    <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
        <link itemprop="mainEntityOfPage" href="https://ancao96.github.io/2023/08/21/2023-8-21-12-%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0/">

        <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
            <meta itemprop="image" content="/images/avatar.gif">
            <meta itemprop="name" content="SCY">
        </span>

        <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
            <meta itemprop="name" content="SCY SPACE">
            <meta itemprop="description" content="">
        </span>

        <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
            <meta itemprop="name" content="undefined | SCY SPACE">
            <meta itemprop="description" content="">
        </span>
        <header class="post-header">
            <h2 class="post-title" itemprop="name headline">
                <a href="/2023/08/21/2023-8-21-12-%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">(12)统计学习</a>
            </h2>

            <div class="post-meta-container">
                <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-08-21 03:36:20" itemprop="dateCreated datePublished" datetime="2023-08-21T03:36:20+08:00">2023-08-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-09-05 12:40:07" itemprop="dateModified" datetime="2023-09-05T12:40:07+08:00">2023-09-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/R/" itemprop="url" rel="index"><span itemprop="name">R</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/R/Geocomputaion/" itemprop="url" rel="index"><span itemprop="name">Geocomputaion</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2023/08/21/2023-8-21-12-%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2023/08/21/2023-8-21-12-%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>8.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>32 分钟</span>
    </span>
</div>

            </div>
        </header>

        
        
        
        <div class="post-body" itemprop="articleBody">
            <h1 id="前提条件">前提条件</h1>
<p>本章假设您已经具备地理数据分析的熟练技能，例如通过学习并完成章节<em>空间数据</em>至<em>地理数据重投影</em>中的练习来获得。强烈推荐熟悉广义线性模型（GLM）和机器学习[例如来自@zuur_mixed_2009;<span
class="citation"
data-cites="james_introduction_2013">@james_introduction_2013</span>]。</p>
<p>本章使用以下的R包：<a href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a></p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">library<span class="punctuation">(</span>sf<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>terra<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>dplyr<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>future<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>lgr<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>mlr3<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>mlr3learners<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>mlr3extralearners<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>mlr3spatiotempcv<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>mlr3tuning<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>mlr3viz<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>progressr<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>当然，所需数据将在适当的时候附上。</p>
<h1 id="引言">引言</h1>
<p>统计学习主要关注使用统计和计算模型来识别数据中的模式，并根据这些模式进行预测。由于其起源，统计学习是
R 语言的一大优势（见章节<em>地理计算软件</em>）。<a href="#fn2"
class="footnote-ref" id="fnref2"
role="doc-noteref"><sup>2</sup></a>统计学习结合了统计和机器学习的方法，并可分为监督和无监督技术。这两者越来越多地应用于从物理学、生物学和生态学到地理学和经济学等各个学科<span
class="citation"
data-cites="james_introduction_2013">[@james_introduction_2013]</span>。</p>
<p>本章重点介绍有训练数据集的监督技术，而非像聚类这样的无监督技术。响应变量可以是二元的（如山体滑坡发生与否）、分类的（土地利用）、整数（物种丰富度计数）或数值的（以
pH
衡量的土壤酸度）。监督技术用于建模——响应与一个或多个预测变量之间的关系——这些响应是基于一组观测样本而已知的。</p>
<p>大多数机器学习研究的主要目的是进行良好的预测。机器学习在“大数据”时代蓬勃发展，因为其方法对输入变量几乎没有假设，并且能处理巨大的数据集。机器学习适用于预测未来客户行为、推荐服务（音乐、电影、接下来购买什么）、面部识别、自动驾驶、文本分类和预测性维护（基础设施、产业）等任务。</p>
<p>本章基于一个案例研究：（空间）预测山体滑坡。
该应用与定义在<em>引言</em>章中的地理计算的应用性有关，并说明了机器学习在唯一目的是预测时如何借鉴统计学领域。因此，本章首先使用广义线性模型<span
class="citation"
data-cites="zuur_mixed_2009">[@zuur_mixed_2009]</span>介绍建模和交叉验证的概念。在此基础上，该章实施了一个更典型的机器学习算法，即支持向量机（SVM）。模型的<strong>预测性能</strong>将使用空间交叉验证（CV）进行评估，该方法考虑到地理数据是特殊的。</p>
<p>CV确定模型泛化到新数据的能力，通过将数据集（反复）分割为训练集和测试集。它使用训练数据来拟合模型，并检查其在对测试数据进行预测时的性能。CV
有助于检测过拟合，因为过于紧密地预测训练数据（噪声）的模型通常会在测试数据上表现不佳。</p>
<p>随机分割空间数据可能导致训练点与测试点在空间上是邻近的。由于空间自相关，在这种情况下，测试数据集和训练数据集将不是独立的，因此交叉验证无法检测出可能的过拟合。空间交叉验证缓解了这个问题，并且是本章的<strong>核心</strong>主题。</p>
<h1 id="案例-滑坡敏感性">案例: 滑坡敏感性</h1>
<p>本案例研究基于南厄瓜多尔滑坡地点的一个数据集，如下图所示，并在@muenchow_geomorphic_2012中详细描述。该论文中使用的数据集的一个子集提供在<strong>spDataLarge</strong>包中，可以如下加载：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data<span class="punctuation">(</span><span class="string">&quot;lsl&quot;</span><span class="punctuation">,</span> <span class="string">&quot;study_mask&quot;</span><span class="punctuation">,</span> package <span class="operator">=</span> <span class="string">&quot;spDataLarge&quot;</span><span class="punctuation">)</span></span><br><span class="line">ta <span class="operator">=</span> terra<span class="operator">::</span>rast<span class="punctuation">(</span>system.file<span class="punctuation">(</span><span class="string">&quot;raster/ta.tif&quot;</span><span class="punctuation">,</span> package <span class="operator">=</span> <span class="string">&quot;spDataLarge&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>T上面的代码加载了三个对象：一个名为<code>lsl</code>的<code>data.frame</code>，一个名为<code>study_mask</code>的<code>sf</code>对象，以及一个名为<code>ta</code>的<code>SpatRaster</code>，其中包含地形属性栅格。<code>lsl</code>包含一个因子列<code>lslpts</code>，其中<code>TRUE</code>对应于观察到的滑坡'发起点'，坐标存储在列<code>x</code>和<code>y</code>中。<a
href="#fn3" class="footnote-ref" id="fnref3"
role="doc-noteref"><sup>3</sup></a>
有175个滑坡点和175个非滑坡点，如<code>summary(lsl$lslpts)</code>所示。这175个非滑坡点是从研究区域随机抽样的，但必须落在滑坡多边形周围的小缓冲区之外。</p>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309051146030.png" />
Landslide initiation points (red) and points unaffected by landsliding
(blue) in Southern Ecuador.</p>
<p><code>lsl</code>的前三行，四舍五入为两位有效数字，可以在下表中找到。</p>
<table class="table" style="margin-left: auto; margin-right: auto;">
<caption>
Structure of the lsl dataset.
</caption>
<thead>
<tr>
<th style="text-align:left;">
</th>
<th style="text-align:right;">
x
</th>
<th style="text-align:right;">
y
</th>
<th style="text-align:left;">
lslpts
</th>
<th style="text-align:right;">
slope
</th>
<th style="text-align:right;">
cplan
</th>
<th style="text-align:right;">
cprof
</th>
<th style="text-align:right;">
elev
</th>
<th style="text-align:right;">
log10_carea
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
1
</td>
<td style="text-align:right;">
713888
</td>
<td style="text-align:right;">
9558537
</td>
<td style="text-align:left;">
FALSE
</td>
<td style="text-align:right;">
34
</td>
<td style="text-align:right;">
0.023
</td>
<td style="text-align:right;">
0.003
</td>
<td style="text-align:right;">
2400
</td>
<td style="text-align:right;">
2.8
</td>
</tr>
<tr>
<td style="text-align:left;">
2
</td>
<td style="text-align:right;">
712788
</td>
<td style="text-align:right;">
9558917
</td>
<td style="text-align:left;">
FALSE
</td>
<td style="text-align:right;">
39
</td>
<td style="text-align:right;">
-0.039
</td>
<td style="text-align:right;">
-0.017
</td>
<td style="text-align:right;">
2100
</td>
<td style="text-align:right;">
4.1
</td>
</tr>
<tr>
<td style="text-align:left;">
350
</td>
<td style="text-align:right;">
713826
</td>
<td style="text-align:right;">
9559078
</td>
<td style="text-align:left;">
TRUE
</td>
<td style="text-align:right;">
35
</td>
<td style="text-align:right;">
0.020
</td>
<td style="text-align:right;">
-0.003
</td>
<td style="text-align:right;">
2400
</td>
<td style="text-align:right;">
3.2
</td>
</tr>
</tbody>
</table>
<p>要对滑坡易发性进行建模，我们需要一些预测因子。由于地形属性经常与滑坡有关<span
class="citation"
data-cites="muenchow_geomorphic_2012">[@muenchow_geomorphic_2012]</span>，我们已经从<code>ta</code>提取到<code>lsl</code>中以下的地形属性：</p>
<ul>
<li><code>slope</code>：坡度角（°）</li>
<li><code>cplan</code>：平面曲率（rad
m<sup>−1</sup>）表示坡度的汇聚或发散，从而表示水流</li>
<li><code>cprof</code>：剖面曲率（rad
m<sup>-1</sup>）作为流速加速的衡量标准，也称为坡度角的下坡变化</li>
<li><code>elev</code>：海拔高度（m
a.s.l.）作为研究区不同海拔带植被和降水的表示</li>
<li><code>log10_carea</code>：集水区面积（log10
m<sup>2</sup>）的常用对数，表示流向某个位置的水量</li>
</ul>
<p>使用R-GIS桥计算地形属性并将其提取到滑坡点（参见本章末尾的练习部分）可能是一个值得尝试的练习。</p>
<h1 id="在r中的传统建模方法">在R中的传统建模方法</h1>
<p>在介绍<strong>mlr3</strong>包之前，这是一个提供统一接口以访问数十种学习算法的
umbrella
包，值得先看一下R传统的建模接口。这一介绍到有监督的统计学习为进行空间CV提供了基础，并有助于更好地理解随后呈现的<strong>mlr3</strong>方法。</p>
<p>监督学习涉及将响应变量作为预测因子的函数进行预测。在R中，建模函数通常使用公式来指定（有关R公式的更多详细信息，请参阅<code>?formula</code>）。以下命令指定并运行一个广义线性模型：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fit <span class="operator">=</span> glm<span class="punctuation">(</span>lslpts <span class="operator">~</span> slope <span class="operator">+</span> cplan <span class="operator">+</span> cprof <span class="operator">+</span> elev <span class="operator">+</span> log10_carea<span class="punctuation">,</span></span><br><span class="line">          family <span class="operator">=</span> binomial<span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">          data <span class="operator">=</span> lsl<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>理解这三个输入参数各自的意义是非常有价值的：</p>
<ul>
<li>一个公式，用于指定由预测因子决定的滑坡发生（<code>lslpts</code>）</li>
<li>一个家族（family），用于指定模型的类型，在这个例子中是<code>binomial</code>，因为响应是二元的（见<code>?family</code>）</li>
<li>包含响应和预测因子（作为列）的数据框</li>
</ul>
<p>可以如下打印这个模型的结果（<code>summary(fit)</code>提供了关于结果的更详细的描述）：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">class</span><span class="punctuation">(</span>fit<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] &quot;glm&quot; &quot;lm&quot;</span></span><br><span class="line">fit</span><br><span class="line"><span class="comment">#&gt; </span></span><br><span class="line"><span class="comment">#&gt; Call:  glm(formula = lslpts ~ slope + cplan + cprof + elev + log10_carea, </span></span><br><span class="line"><span class="comment">#&gt;     family = binomial(), data = lsl)</span></span><br><span class="line"><span class="comment">#&gt; </span></span><br><span class="line"><span class="comment">#&gt; Coefficients:</span></span><br><span class="line"><span class="comment">#&gt; (Intercept)        slope        cplan        cprof         elev  log10_carea  </span></span><br><span class="line"><span class="comment">#&gt;    2.511364     0.079011   -28.941961   -17.563601     0.000179    -2.274877  </span></span><br><span class="line"><span class="comment">#&gt; </span></span><br><span class="line"><span class="comment">#&gt; Degrees of Freedom: 349 Total (i.e. Null);  344 Residual</span></span><br><span class="line"><span class="comment">#&gt; Null Deviance:	    485 </span></span><br><span class="line"><span class="comment">#&gt; Residual Deviance: 373 	AIC: 385</span></span><br></pre></td></tr></table></figure>
<p>模型对象<code>fit</code>，其类别为<code>glm</code>，包含了定义响应和预测因子之间拟合关系的系数。这个对象也可以用于预测。这是通过通用的<code>predict()</code>方法来完成的，在这个案例中，它调用了<code>predict.glm()</code>函数。将<code>type</code>设置为<code>response</code>会返回<code>lsl</code>中每个观测的预测概率（即滑坡发生的概率），如下图所示（见<code>?predict.glm</code>）：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pred_glm <span class="operator">=</span> predict<span class="punctuation">(</span>object <span class="operator">=</span> fit<span class="punctuation">,</span> type <span class="operator">=</span> <span class="string">&quot;response&quot;</span><span class="punctuation">)</span></span><br><span class="line">head<span class="punctuation">(</span>pred_glm<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt;      1      2      3      4      5      6 </span></span><br><span class="line"><span class="comment">#&gt; 0.1901 0.1172 0.0952 0.2503 0.3382 0.1575</span></span><br></pre></td></tr></table></figure>
<p>通过将系数应用于预测因子的栅格数据，可以创建空间分布图。这可以手动完成，也可以使用<code>terra::predict()</code>来完成。除了一个模型对象（<code>fit</code>）外，这个函数还需要一个具有预测因子（栅格层）的<code>SpatRaster</code>，这些预测因子的名称应与模型输入数据框中的名称相同（见下图）。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># making the prediction</span></span><br><span class="line">pred <span class="operator">=</span> terra<span class="operator">::</span>predict<span class="punctuation">(</span>ta<span class="punctuation">,</span> model <span class="operator">=</span> fit<span class="punctuation">,</span> type <span class="operator">=</span> <span class="string">&quot;response&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309051151962.png" />
Spatial distribution mapping of landslide susceptibility using a
GLM.</p>
<p>在进行预测时，我们忽略了空间自相关，因为我们假设平均预测准确性在有或没有空间自相关结构的情况下保持不变。然而，也可以将空间自相关结构纳入模型和预测中。
尽管这超出了本书的范围，但我们为感兴趣的读者提供了一些查阅的方向：</p>
<ol type="1">
<li>回归克里金（Regression
Kriging）的预测结合了回归的预测和回归残差的克里金 <span class="citation"
data-cites="goovaerts_geostatistics_1997 hengl_practical_2007 bivand_applied_2013">[@goovaerts_geostatistics_1997;
@hengl_practical_2007; @bivand_applied_2013]</span>。</li>
<li>人们还可以向广义最小二乘模型 [<code>nlme::gls()</code>; <span
class="citation" data-cites="zuur_mixed_2009">@zuur_mixed_2009</span>;
<span class="citation"
data-cites="zuur_beginners_2017">@zuur_beginners_2017</span>]
添加空间相关（依赖）结构。</li>
<li>人们也可以使用混合效应建模方法。</li>
</ol>
<p>基本上，随机效应对响应变量施加了依赖结构，从而使某一类的观察结果与另一类的观察结果更相似
<span class="citation"
data-cites="zuur_mixed_2009">[@zuur_mixed_2009]</span>。类别可以是蜜蜂巢、猫头鹰巢、植被样带或高度分层。这种混合建模方法假设随机截距是正态和独立分布的。这甚至可以通过使用正态和空间依赖的随机截距来扩展。然而，为此，你可能需要采用贝叶斯建模方法，因为频率论软件工具在这方面尤其有限，尤其是对于更复杂的模型
<span class="citation"
data-cites="blangiardo_spatial_2015 zuur_beginners_2017">[@blangiardo_spatial_2015;
@zuur_beginners_2017]</span>。</p>
<p>空间分布图是模型（上图）的一个非常重要的结果。更重要的是，基础模型在制作这些图时有多好，因为如果模型的预测性能差，预测图就毫无用处。评估二项模型预测性能的最流行指标是接收器操作特性曲线下的面积（AUROC）。这是一个介于0.5和1.0之间的值，其中0.5表示模型不比随机模型好，1.0表示两个类的完美预测。因此，AUROC越高，模型的预测能力越好。以下代码块使用<code>roc()</code>计算模型的AUROC值，该函数将响应和预测值作为输入。<code>auc()</code>返回曲线下的面积。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pROC<span class="operator">::</span>auc<span class="punctuation">(</span>pROC<span class="operator">::</span>roc<span class="punctuation">(</span>lsl<span class="operator">$</span>lslpts<span class="punctuation">,</span> fitted<span class="punctuation">(</span>fit<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; Area under the curve: 0.8216</span></span><br></pre></td></tr></table></figure>
<p>AUROC 值为
<!-- `r # round(pROC::auc(pROC::roc(lsl$lslpts, fitted(fit))), 2)` -->
0.82
代表了一个良好的拟合。然而，这是一个过于乐观的估计，因为我们是在完整数据集上进行的计算。为了得到一个偏差较小的评估，我们需要使用交叉验证，并且在处理空间数据的情况下，应使用空间CV。</p>
<h2 id="介绍空间交叉验证">介绍（空间）交叉验证</h2>
<p>交叉验证属于重采样方法的家族 <span class="citation"
data-cites="james_introduction_2013">[@james_introduction_2013]</span>。基本思想是将数据集（反复）分为训练集和测试集，其中训练数据用于拟合模型，然后将该模型应用于测试集。通过使用如二项式案例中的AUROC这样的性能度量，将预测值与测试集中已知的响应值进行比较，从而得到模型将学习到的关系泛化到独立数据的能力的偏差较小的评估。例如，100次重复的5折交叉验证意味着将数据随机分为五个部分（折叠），每个折叠都被用作一次测试集（见下图的上行）。这保证了每个观测值都在测试集中使用一次，并需要拟合五个模型。随后，这一过程重复100次。当然，每次重复中的数据分割都会有所不同。总体而言，这合计为500个模型，而所有模型的平均性能度量（AUROC）即为模型的整体预测能力。</p>
<p>然而，地理数据是特殊的。正如我们将在<em>运输</em>章节中看到的，地理学的“第一定律”指出，彼此靠近的点通常比远离的点更相似
<span class="citation"
data-cites="miller_tobler_2004">[@miller_tobler_2004]</span>。这意味着这些点在统计上并不独立，因为在传统的CV中，训练点和测试点通常过于靠近（见下图的第一行）。靠近“测试”观测值的“训练”观测值可能提供一种“偷窥预览”：这些信息本应对训练数据集不可用。为了缓解这一问题，“空间划分”被用于将观测值分为空间上不相交的子集（使用观测值的坐标进行<em>k</em>-均值聚类；<span
class="citation"
data-cites="brenning_spatial_2012">@brenning_spatial_2012</span>；见下图的第二行）。这种划分策略是空间CV和传统CV之间的<strong>唯一</strong>差异。因此，空间CV导致了对模型预测性能的偏差较小的评估，从而有助于避免过拟合。</p>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309051156779.png" />
Spatial visualization of selected test and training observations for
cross-validation of one repetition. Random (upper row) and spatial
partitioning (lower row).</p>
<h1
id="使用mlr3进行空间交叉验证">使用<strong>mlr3</strong>进行空间交叉验证</h1>
<p>如<a target="_blank" rel="noopener" href="https://CRAN.R-project.org/view=MachineLearning">CRAN
机器学习任务视图</a>所描述的，有数十个用于统计学的包。熟悉其中每一个包，包括如何进行交叉验证和超参数调整，可能是一个耗时的过程。比较来自不同包的模型结果可能更为繁琐。<strong>mlr3</strong>
包和生态系统是为了解决这些问题而开发的。它充当一个“元包”，为包括分类、回归、生存分析和聚类在内的流行的有监督和无监督统计学习技术提供统一的接口
<span class="citation"
data-cites="lang_mlr3_2019 becker_mlr3_2022">[@lang_mlr3_2019;
@becker_mlr3_2022]</span>。标准化的 <strong>mlr3</strong>
接口基于八个“构建块”。 如下图所示，这些构建块有明确的顺序。</p>
<p>(ref:building-blocks) mlr3包的基础构建块。来源：<span
class="citation"
data-cites="becker_mlr3_2022">@becker_mlr3_2022</span>。（得到了友好地重新使用此图的许可。）</p>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309051206276.png" />
(ref:building-blocks)</p>
<p><strong>mlr3</strong> 建模过程包含三个主要阶段。
首先，<strong>任务（task）</strong>指定了数据（包括响应变量和预测变量）和模型类型（如回归或分类）。
其次，<strong>学习器（learner）</strong>
定义了应用于创建的任务的特定学习算法。
第三，<strong>重采样（resampling）</strong>方法评估了模型的预测性能，即其泛化到新数据的能力。</p>
<h2 id="广义线性模型">广义线性模型</h2>
<p>要在
<strong>mlr3</strong>中实现GLM，我们必须创建一个包含滑坡数据的<strong>任务（task）</strong>。由于响应是二元（两类变量）且具有空间维度，我们使用
<strong>mlr3spatiotempcv</strong>
包的<code>TaskClassifST$new()</code>创建一个分类任务<span
class="citation"
data-cites="schratz_mlr3spatiotempcv_2021">[@schratz_mlr3spatiotempcv_2021，对于非空间任务，使用
`mlr3::TaskClassif$new()`
或对于回归任务使用`mlr3::TaskRegr$new()`，其他任务类型请参见
`?Task`]</span>。<a href="#fn4" class="footnote-ref" id="fnref4"
role="doc-noteref"><sup>4</sup></a> 这些 <code>Task*$new()</code>
函数的第一个重要参数是 <code>backend</code>。<code>backend</code>
期望输入数据包括响应变量和预测变量。<code>target</code>
参数指示响应变量的名称（在我们的例子中是 <code>lslpts</code>），而
<code>positive</code>
决定响应变量的两个因子水平中哪一个表示滑坡起点（在我们的例子中是
<code>TRUE</code>）。<code>lsl</code>
数据集的所有其他变量将作为预测因子。对于空间交叉验证，我们需要提供一些额外的参数。<code>coordinate_names</code>
参数期望坐标列的名称（参见<em>空间交叉验证</em>章节和图3）。另外，我们应该指示使用的坐标参考系统（<code>crs</code>）并决定是否希望在建模中使用坐标作为预测因子（<code>coords_as_features</code>）。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># create task</span></span><br><span class="line">task <span class="operator">=</span> mlr3spatiotempcv<span class="operator">::</span>TaskClassifST<span class="operator">$</span>new<span class="punctuation">(</span></span><br><span class="line">  id <span class="operator">=</span> <span class="string">&quot;ecuador_lsl&quot;</span><span class="punctuation">,</span></span><br><span class="line">  backend <span class="operator">=</span> mlr3<span class="operator">::</span>as_data_backend<span class="punctuation">(</span>lsl<span class="punctuation">)</span><span class="punctuation">,</span> </span><br><span class="line">  target <span class="operator">=</span> <span class="string">&quot;lslpts&quot;</span><span class="punctuation">,</span> </span><br><span class="line">  positive <span class="operator">=</span> <span class="string">&quot;TRUE&quot;</span><span class="punctuation">,</span></span><br><span class="line">  coordinate_names <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;x&quot;</span><span class="punctuation">,</span> <span class="string">&quot;y&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">  coords_as_features <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">,</span></span><br><span class="line">  crs <span class="operator">=</span> <span class="string">&quot;EPSG:32717&quot;</span></span><br><span class="line">  <span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>注意，<code>mlr3spatiotempcv::as_task_classif_st()</code> 也接受一个
<code>sf</code>-对象作为 <code>backend</code>
参数的输入。在这种情况下，你可能只想额外指定
<code>coords_as_features</code> 参数。我们没有将 <code>lsl</code>
转换为一个 <code>sf</code>-对象，因为 <code>TaskClassifST$new()</code>
在背景中会将其转换回一个非空间的 <code>data.table</code>
对象。对于简短的数据探索，<strong>mlr3viz</strong> 包的
<code>autoplot()</code>
函数可能会很方便，因为它会绘制响应与所有预测因子的关系，以及所有预测因子之间的关系（未显示）。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># plot response against each predictor</span></span><br><span class="line">mlr3viz<span class="operator">::</span>autoplot<span class="punctuation">(</span>task<span class="punctuation">,</span> type <span class="operator">=</span> <span class="string">&quot;duo&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># plot all variables against each other</span></span><br><span class="line">mlr3viz<span class="operator">::</span>autoplot<span class="punctuation">(</span>task<span class="punctuation">,</span> type <span class="operator">=</span> <span class="string">&quot;pairs&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>创建了任务之后，我们需要选择一个<strong>学习器（learner）</strong>，以确定要使用的统计学方法。所有分类的<strong>学习器</strong>以
<code>classif.</code> 开头，所有回归的学习器以 <code>regr.</code>
开头（详见
<code>?Learner</code>）。<code>mlr3extralearners::list_mlr3learners()</code>
列出了所有可用的学习器以及 <strong>mlr3</strong>
从哪个软件包中导入了它们（表
@ref(tab:lrns)）。要了解能够对二元响应变量进行建模的学习器，我们可以运行：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mlr3extralearners<span class="operator">::</span>list_mlr3learners<span class="punctuation">(</span></span><br><span class="line">  filter <span class="operator">=</span> <span class="built_in">list</span><span class="punctuation">(</span><span class="built_in">class</span> <span class="operator">=</span> <span class="string">&quot;classif&quot;</span><span class="punctuation">,</span> properties <span class="operator">=</span> <span class="string">&quot;twoclass&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> </span><br><span class="line">  select <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;id&quot;</span><span class="punctuation">,</span> <span class="string">&quot;mlr3_package&quot;</span><span class="punctuation">,</span> <span class="string">&quot;required_packages&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">  head<span class="punctuation">(</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<table>
<caption>
Sample of available learners for binomial tasks in the mlr3 package.
</caption>
<thead>
<tr>
<th style="text-align:left;">
Class
</th>
<th style="text-align:left;">
Name
</th>
<th style="text-align:left;">
Short name
</th>
<th style="text-align:left;">
Package
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
classif.adaboostm1
</td>
<td style="text-align:left;">
ada Boosting M1
</td>
<td style="text-align:left;">
adaboostm1
</td>
<td style="text-align:left;">
RWeka
</td>
</tr>
<tr>
<td style="text-align:left;">
classif.binomial
</td>
<td style="text-align:left;">
Binomial Regression
</td>
<td style="text-align:left;">
binomial
</td>
<td style="text-align:left;">
stats
</td>
</tr>
<tr>
<td style="text-align:left;">
classif.featureless
</td>
<td style="text-align:left;">
Featureless classifier
</td>
<td style="text-align:left;">
featureless
</td>
<td style="text-align:left;">
mlr
</td>
</tr>
<tr>
<td style="text-align:left;">
classif.fnn
</td>
<td style="text-align:left;">
Fast k-Nearest Neighbour
</td>
<td style="text-align:left;">
fnn
</td>
<td style="text-align:left;">
FNN
</td>
</tr>
<tr>
<td style="text-align:left;">
classif.gausspr
</td>
<td style="text-align:left;">
Gaussian Processes
</td>
<td style="text-align:left;">
gausspr
</td>
<td style="text-align:left;">
kernlab
</td>
</tr>
<tr>
<td style="text-align:left;">
classif.IBk
</td>
<td style="text-align:left;">
k-Nearest Neighbours
</td>
<td style="text-align:left;">
ibk
</td>
<td style="text-align:left;">
RWeka
</td>
</tr>
</tbody>
</table>
<p>这将产生所有能够处理两类问题（有或没有滑坡）的学习器。我们选择在<em>传统建模</em>节中使用的二项分类方法，该方法在
<strong>mlr3learners</strong> 中实现为
<code>classif.log_reg</code>。另外，我们需要指定
<code>predict.type</code>，它决定了预测的类型，<code>prob</code>
会得出滑坡发生概率在0到1之间的预测值（这对应于 <code>predict.glm</code>
中的 <code>type = response</code>）。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">learner <span class="operator">=</span> mlr3<span class="operator">::</span>lrn<span class="punctuation">(</span><span class="string">&quot;classif.log_reg&quot;</span><span class="punctuation">,</span> predict_type <span class="operator">=</span> <span class="string">&quot;prob&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>要访问学习器的帮助页面并找出它来自哪个包，我们可以运行：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">learner<span class="operator">$</span>help<span class="punctuation">(</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<!--
Having specified a learner and a task, we can train our model which basically executes the `glm()` command in the background for our task. 

<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">learner<span class="operator">$</span>train<span class="punctuation">(</span>task<span class="punctuation">)</span></span><br><span class="line">learner<span class="operator">$</span>model</span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fit <span class="operator">=</span> glm<span class="punctuation">(</span>lslpts <span class="operator">~</span> .<span class="punctuation">,</span> family <span class="operator">=</span> binomial<span class="punctuation">(</span>link <span class="operator">=</span> <span class="string">&quot;logit&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> </span><br><span class="line">          data <span class="operator">=</span> select<span class="punctuation">(</span>lsl<span class="punctuation">,</span> <span class="operator">-</span>x<span class="punctuation">,</span> <span class="operator">-</span>y<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">identical<span class="punctuation">(</span>fit<span class="operator">$</span>coefficients<span class="punctuation">,</span> learner<span class="operator">$</span>model<span class="operator">$</span>coefficients<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>--&gt;</p>
<p>使用
<strong>mlr3</strong>进行建模的设置步骤可能看似繁琐。但请记住，这个单一的接口提供了访问
<code>mlr3extralearners::list_mlr3learners()</code>
显示的130多个学习器的途径；学习每个学习器的接口将会更加繁琐！其他优点包括简单的重采样技术的并行化和调整机器学习超参数的能力。最重要的是，<strong>mlr3spatiotempcv</strong>
<span class="citation"
data-cites="schratz_mlr3spatiotempcv_2021">[@schratz_mlr3spatiotempcv_2021]</span>
中的（空间）重采样非常直接，只需要两个额外的步骤：指定一个重采样方法并运行它。我们将使用100重复的5折空间CV：根据我们
<code>task</code> 中提供的坐标选择五个分区，并重复该划分100次：<a
href="#fn5" class="footnote-ref" id="fnref5"
role="doc-noteref"><sup>5</sup></a></p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resampling <span class="operator">=</span> mlr3<span class="operator">::</span>rsmp<span class="punctuation">(</span><span class="string">&quot;repeated_spcv_coords&quot;</span><span class="punctuation">,</span> folds <span class="operator">=</span> <span class="number">5</span><span class="punctuation">,</span> repeats <span class="operator">=</span> <span class="number">100</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>要执行空间重采样，我们运行<code>resample()</code>，使用之前指定的任务、学习器和重采样策略。这需要一些时间（在现代笔记本电脑上大约需要15秒），因为它计算了500个重采样分区和500个模型。
作为性能度量，我们再次选择AUROC。要获取它，我们使用重采样结果输出对象（<code>score_spcv_glm</code>）的<code>score()</code>方法。这将返回一个具有500行的<code>data.table</code>对象——每个模型一行。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># reduce verbosity</span></span><br><span class="line">lgr<span class="operator">::</span>get_logger<span class="punctuation">(</span><span class="string">&quot;mlr3&quot;</span><span class="punctuation">)</span><span class="operator">$</span>set_threshold<span class="punctuation">(</span><span class="string">&quot;warn&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># run spatial cross-validation and save it to resample result glm (rr_glm)</span></span><br><span class="line">rr_spcv_glm <span class="operator">=</span> mlr3<span class="operator">::</span>resample<span class="punctuation">(</span>task <span class="operator">=</span> task<span class="punctuation">,</span></span><br><span class="line">                             learner <span class="operator">=</span> learner<span class="punctuation">,</span></span><br><span class="line">                             resampling <span class="operator">=</span> resampling<span class="punctuation">)</span></span><br><span class="line"><span class="comment"># compute the AUROC as a data.table</span></span><br><span class="line">score_spcv_glm <span class="operator">=</span> rr_spcv_glm<span class="operator">$</span>score<span class="punctuation">(</span>measure <span class="operator">=</span> mlr3<span class="operator">::</span>msr<span class="punctuation">(</span><span class="string">&quot;classif.auc&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># keep only the columns you need</span></span><br><span class="line">score_spcv_glm <span class="operator">=</span> score_spcv_glm<span class="punctuation">[</span><span class="punctuation">,</span> .<span class="punctuation">(</span>task_id<span class="punctuation">,</span> learner_id<span class="punctuation">,</span> resampling_id<span class="punctuation">,</span> </span><br><span class="line">                                    classif.auc<span class="punctuation">)</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<p>前面代码块的输出是模型预测性能的偏差减少评估。我们已经将其保存为书籍GitHub仓库中的<code>extdata/12-bmr_score.rds</code>。如有需要，您可以按照以下方式读取它：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">score <span class="operator">=</span> readRDS<span class="punctuation">(</span><span class="string">&quot;extdata/12-bmr_score.rds&quot;</span><span class="punctuation">)</span></span><br><span class="line">score_spcv_glm <span class="operator">=</span> score<span class="punctuation">[</span>learner_id <span class="operator">==</span> <span class="string">&quot;classif.log_reg&quot;</span> <span class="operator">&amp;</span> </span><br><span class="line">                         resampling_id <span class="operator">==</span> <span class="string">&quot;repeated_spcv_coords&quot;</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<p>要计算所有500个模型的AUROC均值，我们运行：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mean<span class="punctuation">(</span>score_spcv_glm<span class="operator">$</span>classif.auc<span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">  <span class="built_in">round</span><span class="punctuation">(</span><span class="number">2</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] 0.77</span></span><br></pre></td></tr></table></figure>
<p>为了更全面地理解这些结果，让我们将它们与来自100次重复的5折非空间交叉验证的AUROC值进行比较；非空间交叉验证的代码在这里没有显示，但将在练习部分进行探讨）。
如预期，与传统的交叉验证方法相比，空间交叉验证的结果平均而言产生了较低的AUROC值，这强调了后者由于空间自相关而过于乐观的预测性能。</p>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309051217339.png" />
Boxplot showing the difference in GLM AUROC values on spatial and
conventional 100-repeated 5-fold cross-validation.</p>
<h2 id="机器学习超参数的空间调优">机器学习超参数的空间调优</h2>
<p><em>空间交叉验证</em>节绍了机器学习作为统计学习的一部分。回顾一下，我们遵循<a
target="_blank" rel="noopener" href="https://machinelearningmastery.com/linear-regression-for-machine-learning/">Jason
Brownlee</a>对机器学习的以下定义：</p>
<blockquote>
<p>机器学习，更具体地说是预测建模领域，主要关注的是最小化模型的错误或以解释性为代价做出尽可能准确的预测。在应用机器学习中，我们将从许多不同的领域借用、重用和窃取算法，包括统计学，并将它们用于这些目的。</p>
</blockquote>
<p>在节<em>广义线性模型</em>中，使用了广义线性模型（GLM）来预测滑坡敏感性。本节介绍了用于同一目的的支持向量机（SVM）。随机森林模型可能比SVM更受欢迎；然而，调整超参数对模型性能的积极影响在SVM的情况下更为明显<span
class="citation"
data-cites="probst_hyperparameters_2018">[@probst_hyperparameters_2018]</span>。由于（空间）超参数调整是本节的主要目标，我们将使用SVM。对于希望应用随机森林模型的人，我们建议阅读这一章，然后继续阅读章节<em>生态</em>，在其中我们将应用目前涵盖的概念和技术，基于随机森林模型制作空间分布图。</p>
<p>SVM（支持向量机）寻找最佳可能的'超平面'来分隔类别（在分类情况下）并估计具有特定超参数的'核'以在类别之间创建非线性边界<span
class="citation"
data-cites="james_introduction_2013">[@james_introduction_2013]</span>。
机器学习算法通常具有超参数和参数。参数可以从数据中估算，而超参数则在学习开始之前设置（另请参见<a
target="_blank" rel="noopener" href="https://machinelearningmastery.com/difference-between-a-parameter-and-a-hyperparameter/">machine
mastery blog</a>和mlr3书中的<a
target="_blank" rel="noopener" href="https://mlr3book.mlr-org.com/optimization.html">超参数优化章节</a>）。最优的超参数配置通常在特定的搜索空间内找到，并在交叉验证方法的帮助下确定。这称为超参数调优，是本节的主要话题。</p>
<p>一些SVM实现，如由<strong>kernlab</strong>提供的，允许自动调整超参数，通常基于随机抽样（见图3的上行）。这适用于非空间数据，但对于应进行'空间调优'的空间数据则用处不大。</p>
<p>在定义空间调优之前，我们将设置用于SVM的<strong>mlr3</strong>构建块，这些在<em>glm</em>节中已经介绍过。分类任务保持不变，因此我们可以简单地重用在节<em>glm</em>中创建的<code>task</code>对象。实现SVM的学习器可以使用<strong>mlr3extralearners</strong>的<code>list_mlr3learners()</code>命令找到。</p>
<p>在选项中，我们将使用<strong>kernlab</strong>软件包<span
class="citation"
data-cites="karatzoglou_kernlab_2004">[@karatzoglou_kernlab_2004]</span>的<code>ksvm()</code>。为了允许非线性关系，我们使用流行的径向基函数（或高斯）核（"rbfdot"），这也是<code>ksvm()</code>的默认设置。将<code>type</code>参数设置为<code>"C-svc"</code>确保<code>ksvm()</code>正在解决一个分类任务。为确保调优不会因一个失败的模型而停止，我们还定义了一个后备学习器（更多信息请参考https://mlr3book.mlr-org.com/technical.html#fallback-learners）。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lrn_ksvm <span class="operator">=</span> mlr3<span class="operator">::</span>lrn<span class="punctuation">(</span><span class="string">&quot;classif.ksvm&quot;</span><span class="punctuation">,</span> predict_type <span class="operator">=</span> <span class="string">&quot;prob&quot;</span><span class="punctuation">,</span> kernel <span class="operator">=</span> <span class="string">&quot;rbfdot&quot;</span><span class="punctuation">,</span></span><br><span class="line">                     type <span class="operator">=</span> <span class="string">&quot;C-svc&quot;</span><span class="punctuation">)</span></span><br><span class="line">lrn_ksvm<span class="operator">$</span>fallback <span class="operator">=</span> lrn<span class="punctuation">(</span><span class="string">&quot;classif.featureless&quot;</span><span class="punctuation">,</span> predict_type <span class="operator">=</span> <span class="string">&quot;prob&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>下一步是指定一个重采样策略。
我们再次将使用100次重复的5折空间交叉验证（CV）。</p>
<!-- 在我们的论文中，我们一致同意使用“性能估计级别”和“调优级别”，而不是说“外部和内部重采样” -->
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># performance estimation level</span></span><br><span class="line">perf_level <span class="operator">=</span> mlr3<span class="operator">::</span>rsmp<span class="punctuation">(</span><span class="string">&quot;repeated_spcv_coords&quot;</span><span class="punctuation">,</span> folds <span class="operator">=</span> <span class="number">5</span><span class="punctuation">,</span> repeats <span class="operator">=</span> <span class="number">100</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>请注意，这与节<em>glm</em>中用于GLM的重采样所用的代码完全相同；我们只是在这里重复它作为提醒。</p>
<p>到目前为止，这个过程与节<em>glm</em>中描述的过程相同。然而，下一步是新的：调整超参数。使用相同的数据进行性能评估和调优可能会导致过于乐观的结果<span
class="citation"
data-cites="cawley_overfitting_2010">[@cawley_overfitting_2010]</span>。这可以通过使用嵌套的空间交叉验证（CV）来避免。</p>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309051230694.png" />
Schematic of hyperparameter tuning and performance estimation levels in
CV. [Figure was taken from Schratz et al. (2019). Permission to reuse it
was kindly granted.]</p>
<p>这意味着我们将每个折叠再次分成五个空间上不重叠的子折叠，这些子折叠用于确定最佳的超参数（下面代码块中的<code>tune_level</code>对象；见上图以获取视觉表示）。为了找到最优的超参数组合，我们在这些子折叠中分别拟合50个模型（下面代码块中的<code>terminator</code>对象），并为超参数C和Sigma随机选择值。C和Sigma的随机选择值还受到预定义调优空间（<code>search_space</code>对象）的额外限制。调优空间的范围是根据文献中推荐的值来选择的<span
class="citation"
data-cites="schratz_hyperparameter_2019">[@schratz_hyperparameter_2019]</span>。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># five spatially disjoint partitions</span></span><br><span class="line">tune_level <span class="operator">=</span> mlr3<span class="operator">::</span>rsmp<span class="punctuation">(</span><span class="string">&quot;spcv_coords&quot;</span><span class="punctuation">,</span> folds <span class="operator">=</span> <span class="number">5</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># use 50 randomly selected hyperparameters</span></span><br><span class="line">terminator <span class="operator">=</span> mlr3tuning<span class="operator">::</span>trm<span class="punctuation">(</span><span class="string">&quot;evals&quot;</span><span class="punctuation">,</span> n_evals <span class="operator">=</span> <span class="number">50</span><span class="punctuation">)</span></span><br><span class="line">tuner <span class="operator">=</span> mlr3tuning<span class="operator">::</span>tnr<span class="punctuation">(</span><span class="string">&quot;random_search&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># define the outer limits of the randomly selected hyperparameters</span></span><br><span class="line">search_space <span class="operator">=</span> paradox<span class="operator">::</span>ps<span class="punctuation">(</span></span><br><span class="line">  C <span class="operator">=</span> paradox<span class="operator">::</span>p_dbl<span class="punctuation">(</span>lower <span class="operator">=</span> <span class="operator">-</span><span class="number">12</span><span class="punctuation">,</span> upper <span class="operator">=</span> <span class="number">15</span><span class="punctuation">,</span> trafo <span class="operator">=</span> <span class="keyword">function</span><span class="punctuation">(</span>x<span class="punctuation">)</span> <span class="number">2</span><span class="operator">^</span>x<span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">  sigma <span class="operator">=</span> paradox<span class="operator">::</span>p_dbl<span class="punctuation">(</span>lower <span class="operator">=</span> <span class="operator">-</span><span class="number">15</span><span class="punctuation">,</span> upper <span class="operator">=</span> <span class="number">6</span><span class="punctuation">,</span> trafo <span class="operator">=</span> <span class="keyword">function</span><span class="punctuation">(</span>x<span class="punctuation">)</span> <span class="number">2</span><span class="operator">^</span>x<span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>下一步是根据所有定义超参数调优的特性，使用<code>AutoTuner$new()</code>来修改学习器<code>lrn_ksvm</code>。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">at_ksvm <span class="operator">=</span> mlr3tuning<span class="operator">::</span>AutoTuner<span class="operator">$</span>new<span class="punctuation">(</span></span><br><span class="line">  learner <span class="operator">=</span> lrn_ksvm<span class="punctuation">,</span></span><br><span class="line">  resampling <span class="operator">=</span> tune_level<span class="punctuation">,</span></span><br><span class="line">  measure <span class="operator">=</span> mlr3<span class="operator">::</span>msr<span class="punctuation">(</span><span class="string">&quot;classif.auc&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">  search_space <span class="operator">=</span> search_space<span class="punctuation">,</span></span><br><span class="line">  terminator <span class="operator">=</span> terminator<span class="punctuation">,</span></span><br><span class="line">  tuner <span class="operator">=</span> tuner</span><br><span class="line"><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>现在调优设置已完成，用于确定一个折叠的最佳超参数将拟合250个模型。重复这个过程针对每个折叠，我们最终得到125,000（250
*
5）个模型用于每次重复。重复100次意味着拟合总共125,000个模型以确定最佳超参数（见图）。这些将用于性能评估，这需要拟合另外500个模型（5个折叠
* 100次重复；参见图。
为了更清晰地描述性能评估处理链，让我们记录下我们给计算机的命令：</p>
<ol type="1">
<li>性能层次（图的左上部分）-
将数据集分成五个空间上不交叠的（外部）子折叠。</li>
<li>调优层次（图的左下部分）-
使用性能层次的第一个折叠，并再次将其空间上分成五个（内部）子折叠进行超参数调优。在这些内部子折叠中使用50个随机选定的超参数，即拟合250个模型。</li>
<li>性能估计 -
使用上一步（调优层次）中的最佳超参数组合，并将其应用于性能层次中的第一个外部折叠以估计性能（AUROC）。</li>
<li>重复步骤2和3，针对其余四个外部折叠。</li>
<li>重复步骤2至4，共100次。</li>
</ol>
<p>超参数调优和性能估计的过程在计算上是非常密集的。为了减少模型运行时间，<strong>mlr3</strong>提供了使用<strong>future</strong>包进行并行化的可能性。由于我们即将进行嵌套交叉验证，我们可以决定是否希望并行化内部循环或外部循环（见图的左下部分）。由于前者将运行125,000个模型，而后者仅运行500个，很明显我们应该并行化内部循环。要设置内部循环的并行化，我们执行：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">library<span class="punctuation">(</span>future<span class="punctuation">)</span></span><br><span class="line"><span class="comment"># execute the outer loop sequentially and parallelize the inner loop</span></span><br><span class="line">future<span class="operator">::</span>plan<span class="punctuation">(</span><span class="built_in">list</span><span class="punctuation">(</span><span class="string">&quot;sequential&quot;</span><span class="punctuation">,</span> <span class="string">&quot;multisession&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> </span><br><span class="line">             workers <span class="operator">=</span> <span class="built_in">floor</span><span class="punctuation">(</span>availableCores<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">/</span> <span class="number">2</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>确实，我们指示<strong>future</strong>包仅使用可用核心的一半而非全部（默认设置），这样做是为了在使用高性能计算集群的情况下允许其他可能的用户也能在同一个集群上工作。</p>
<p>现在，我们已经为执行嵌套空间交叉验证做好了准备。指定<code>resample()</code>参数的过程与使用GLM时完全相同，唯一的区别是<code>store_models</code>和<code>encapsulate</code>参数。将前者设置为<code>TRUE</code>将允许我们提取超参数调优结果，这在我们计划对调优进行后续分析时非常重要。后者确保即使其中一个模型出错，处理过程也会继续。这避免了由于一个失败的模型而导致整个过程停止，这在大规模模型运行中是非常需要的。一旦处理完成，可以查看失败的模型。处理完成后，最好使用<code>future:::ClusterRegistry("stop")</code>明确地停止并行化。最后，我们将输出对象（<code>result</code>）保存到磁盘，以防我们希望在另一个R会话中使用它。</p>
<p>在运行以下代码之前，请注意，由于它将执行包括125,500个模型在内的空间交叉验证，所以这是一个耗时的过程。在现代笔记本电脑上轻松运行半天也是可能的。需要注意的是，运行时间取决于多个方面：CPU速度、所选算法、所选核心数以及数据集。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">progressr<span class="operator">::</span>with_progress<span class="punctuation">(</span>expr <span class="operator">=</span> <span class="punctuation">&#123;</span></span><br><span class="line">  rr_spcv_svm <span class="operator">=</span> mlr3<span class="operator">::</span>resample<span class="punctuation">(</span>task <span class="operator">=</span> task<span class="punctuation">,</span></span><br><span class="line">                               learner <span class="operator">=</span> at_ksvm<span class="punctuation">,</span> </span><br><span class="line">                               <span class="comment"># outer resampling (performance level)</span></span><br><span class="line">                               resampling <span class="operator">=</span> perf_level<span class="punctuation">,</span></span><br><span class="line">                               store_models <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">,</span></span><br><span class="line">                               encapsulate <span class="operator">=</span> <span class="string">&quot;evaluate&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># stop parallelization</span></span><br><span class="line">future<span class="operator">:::</span>ClusterRegistry<span class="punctuation">(</span><span class="string">&quot;stop&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># compute the AUROC values</span></span><br><span class="line">score_spcv_svm <span class="operator">=</span> rr_spcv_svm<span class="operator">$</span>score<span class="punctuation">(</span>measure <span class="operator">=</span> mlr3<span class="operator">::</span>msr<span class="punctuation">(</span><span class="string">&quot;classif.auc&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span> </span><br><span class="line"><span class="comment"># keep only the columns you need</span></span><br><span class="line">score_spcv_svm <span class="operator">=</span> score_spcv_svm<span class="punctuation">[</span><span class="punctuation">,</span> .<span class="punctuation">(</span>task_id<span class="punctuation">,</span> learner_id<span class="punctuation">,</span> resampling_id<span class="punctuation">,</span> classif.auc<span class="punctuation">)</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<p>如果你不想在本地运行代码，我们已经将 <a
target="_blank" rel="noopener" href="https://github.com/geocompx/geocompr/blob/main/extdata/12-bmr_score.rds">score_svm</a>
保存在本书的GitHub仓库中。你可以按照以下方式加载它们：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">score <span class="operator">=</span> readRDS<span class="punctuation">(</span><span class="string">&quot;extdata/12-bmr_score.rds&quot;</span><span class="punctuation">)</span></span><br><span class="line">score_spcv_svm <span class="operator">=</span> score<span class="punctuation">[</span>learner_id <span class="operator">==</span> <span class="string">&quot;classif.ksvm.tuned&quot;</span> <span class="operator">&amp;</span> </span><br><span class="line">                         resampling_id <span class="operator">==</span> <span class="string">&quot;repeated_spcv_coords&quot;</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<p>让我们看一下最终的AUROC：模型区分两个类别的能力。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># final mean AUROC</span></span><br><span class="line"><span class="built_in">round</span><span class="punctuation">(</span>mean<span class="punctuation">(</span>score_spcv_svm<span class="operator">$</span>classif.auc<span class="punctuation">)</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] 0.74</span></span><br></pre></td></tr></table></figure>
<p>在这个特定情况下，似乎GLM（汇总的AUROC是
<code>r score[resampling_id == "repeated_spcv_coords" &amp; learner_id == "classif.log_reg", round(mean(classif.auc), 2)]</code>）比SVM略好一些。为了保证一个绝对公平的比较，还应确保两个模型使用完全相同的划分——这是我们在这里没有展示，但在背后默默使用的（更多信息请参见本书GitHub仓库中的<code>code/12_cv.R</code>）。为此，<strong>mlr3</strong>提供了<code>benchmark_grid()</code>和<code>benchmark()</code>函数<span
class="citation"
data-cites="becker_mlr3_2022">[参见https://mlr3book.mlr-org.com/perf-eval-cmp.html#benchmarking，@becker_mlr3_2022]</span>。我们将在练习中更详细地探讨这些函数。还请注意，在SVM的随机搜索中使用超过50次迭代可能会产生导致模型具有更好AUROC的超参数
<span class="citation"
data-cites="schratz_hyperparameter_2019">[@schratz_hyperparameter_2019]</span>。另一方面，增加随机搜索迭代次数也会增加总模型数量，从而增加运行时间。</p>
<p>到目前为止，空间CV已被用于评估学习算法泛化到未见数据的能力。对于预测性制图目的，人们会在完整的数据集上调整超参数。这将在<em>生态</em>章中讨论。</p>
<h1 id="结论">结论</h1>
<p>重采样方法是数据科学家工具箱中的一个重要组成部分<span
class="citation"
data-cites="james_introduction_2013">[@james_introduction_2013]</span>。本章使用交叉验证来评估各种模型的预测性能。具有空间坐标的观测值可能由于空间自相关而不是统计上独立的，这违反了交叉验证的一个基本假设。空间CV通过减少空间自相引入的偏见来解决这个问题。</p>
<p><strong>mlr3</strong>软件包便于使用（空间）重采样技术，结合最受欢迎的统计学习技术，包括线性回归，如广义加性模型之类的半参数模型，以及如随机森林，SVMs和增强回归树<span
class="citation"
data-cites="bischl_mlr:_2016 schratz_hyperparameter_2019">[@bischl_mlr:_2016;@schratz_hyperparameter_2019]</span>等机器学习技术。机器学习算法通常需要超参数输入，其中最优的“调整”可能需要数千次模型运行，这需要大量的计算资源，消耗大量时间、RAM和/或核心。<strong>mlr3</strong>通过启用并行化来解决这个问题。</p>
<p>总体而言，机器学习及其用于理解空间数据是一个大领域，本章提供了基础知识，但还有更多需要学习。我们推荐以下方向的资源：</p>
<ul>
<li><strong>mlr3 book</strong> [<span class="citation"
data-cites="becker_mlr3_2022">@becker_mlr3_2022</span>;
https://mlr-org.github.io/mlr-tutorial/release/html/]，特别是<a
target="_blank" rel="noopener" href="https://mlr3book.mlr-org.com/spatiotemporal.html">关于处理时空数据的章节</a></li>
<li>关于超参数调整的学术论文<span class="citation"
data-cites="schratz_hyperparameter_2019">[@schratz_hyperparameter_2019]</span></li>
<li>关于如何使用<strong>mlr3spatiotempcv</strong>的学术论文<span
class="citation"
data-cites="schratz_mlr3spatiotempcv_2021">[@schratz_mlr3spatiotempcv_2021]</span></li>
<li>在处理时空数据的情况下，应当在进行CV时考虑空间和时间自相关<span
class="citation"
data-cites="meyer_improving_2018">[@meyer_improving_2018]</span></li>
</ul>
<h1 id="练习">练习</h1>
<p>E1. Compute the following terrain attributes from the
<code>elev</code> dataset loaded with
<code>terra::rast(system.file("raster/ta.tif", package = "spDataLarge"))$elev</code>
with the help of R-GIS bridges (see the bridges to GIS software
chapter):</p>
<ul>
<li>Slope</li>
<li>Plan curvature</li>
<li>Profile curvature</li>
<li>Catchment area</li>
</ul>
<p>E2. Extract the values from the corresponding output rasters to the
<code>lsl</code> data frame
(<code>data("lsl", package = "spDataLarge"</code>) by adding new
variables called <code>slope</code>, <code>cplan</code>,
<code>cprof</code>, <code>elev</code> and <code>log_carea</code>.</p>
<p>E3. Use the derived terrain attribute rasters in combination with a
GLM to make a spatial prediction map similar to that shown in Figure
12.2. Running <code>data("study_mask", package = "spDataLarge")</code>
attaches a mask of the study area.</p>
<p>E4. Compute a 100-repeated 5-fold non-spatial cross-validation and
spatial CV based on the GLM learner and compare the AUROC values from
both resampling strategies with the help of boxplots.</p>
<p>Hint: You need to specify a non-spatial resampling strategy.</p>
<p>Another hint: You might want to solve Excercises 4 to 6 in one go
with the help of <code>mlr3::benchmark()</code> and
<code>mlr3::benchmark_grid()</code> (for more information, please refer
to https://mlr3book.mlr-org.com/performance.html#benchmarking). When
doing so, keep in mind that the computation can take very long, probably
several days. This, of course, depends on your system. Computation time
will be shorter the more RAM and cores you have at your disposal.</p>
<p>E5. Model landslide susceptibility using a quadratic discriminant
analysis (QDA). Assess the predictive performance of the QDA. What is
the a difference between the spatially cross-validated mean AUROC value
of the QDA and the GLM?</p>
<p>E6. Run the SVM without tuning the hyperparameters. Use the
<code>rbfdot</code> kernel with <span
class="math inline">\(\sigma\)</span> = 1 and <em>C</em> = 1. Leaving
the hyperparameters unspecified in <strong>kernlab</strong>'s
<code>ksvm()</code> would otherwise initialize an automatic non-spatial
hyperparameter tuning.</p>
<aside id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li
id="fn1"><p>虽然不需要附加，但还必须安装<strong>GGally</strong>、<strong>lgr</strong>、<strong>kernlab</strong>、<strong>mlr3measures</strong>、<strong>paradox</strong>、<strong>pROC</strong>、<strong>progressr</strong>
和 <strong>spDataLarge</strong>包。<a href="#fnref1"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li
id="fn2"><p>几十年来，将统计技术应用于地理数据一直是地统计学、空间统计学和点模式分析领域中的一个活跃的研究课题<span
class="citation"
data-cites="diggle_modelbased_2007 gelfand_handbook_2010 baddeley_spatial_2015">[@diggle_modelbased_2007;
@gelfand_handbook_2010; @baddeley_spatial_2015]</span>。<a
href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li
id="fn3"><p>滑坡发起点位于滑坡多边形的断崖中。有关进一步的详细信息，请参见@muenchow_geomorphic_2012。<a
href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p><strong>mlr3</strong> 生态系统大量使用
<strong>data.table</strong> 和 <strong>R6</strong>
类。尽管你可能在不了解 <strong>data.table</strong> 或
<strong>R6</strong> 的具体情况下使用
<strong>mlr3</strong>，但了解它们可能相当有帮助。要了解更多关于
<strong>data.table</strong> 的信息，请参考
https://rdatatable.gitlab.io/data.table/index.html。要了解更多关于
<strong>R6</strong>，我们推荐阅读《Advanced R》书的<a
target="_blank" rel="noopener" href="https://adv-r.hadley.nz/fp.html">第14章</a> <span class="citation"
data-cites="wickham_advanced_2019">[@wickham_advanced_2019]</span>。<a
href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>请注意，<strong>sperrorest</strong>
包最初在R中实现了空间交叉验证 <span class="citation"
data-cites="brenning_spatial_2012">[@brenning_spatial_2012]</span>。其功能已经被集成到
<strong>mlr3</strong> 生态系统中，这就是为什么我们使用
<strong>mlr3</strong> <span class="citation"
data-cites="schratz_hyperparameter_2019">[@schratz_hyperparameter_2019]</span>。<strong>tidymodels</strong>
框架是R中另一个用于简化建模的 umbrella-package；然而，它最近才通过
<strong>spatialsample</strong>
集成了对空间交叉验证的支持，迄今为止只支持一种空间重采样方法。<a
href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>

            
        </div>

        
        
        

        <div>
            
        </div>

        <footer class="post-footer">
            <div class="post-eof"></div>
            
        </footer>
    </article>
</div>




    


<div class="post-block">
    
    

    <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
        <link itemprop="mainEntityOfPage" href="https://ancao96.github.io/2023/08/20/2023-8-20-11-%E8%84%9A%E6%9C%AC%E3%80%81%E7%AE%97%E6%B3%95%E5%92%8C%E5%87%BD%E6%95%B0/">

        <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
            <meta itemprop="image" content="/images/avatar.gif">
            <meta itemprop="name" content="SCY">
        </span>

        <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
            <meta itemprop="name" content="SCY SPACE">
            <meta itemprop="description" content="">
        </span>

        <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
            <meta itemprop="name" content="undefined | SCY SPACE">
            <meta itemprop="description" content="">
        </span>
        <header class="post-header">
            <h2 class="post-title" itemprop="name headline">
                <a href="/2023/08/20/2023-8-20-11-%E8%84%9A%E6%9C%AC%E3%80%81%E7%AE%97%E6%B3%95%E5%92%8C%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">(11)脚本、算法和函数</a>
            </h2>

            <div class="post-meta-container">
                <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-08-20 09:14:20" itemprop="dateCreated datePublished" datetime="2023-08-20T09:14:20+08:00">2023-08-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-09-05 11:12:27" itemprop="dateModified" datetime="2023-09-05T11:12:27+08:00">2023-09-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/R/" itemprop="url" rel="index"><span itemprop="name">R</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/R/Geocomputaion/" itemprop="url" rel="index"><span itemprop="name">Geocomputaion</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2023/08/20/2023-8-20-11-%E8%84%9A%E6%9C%AC%E3%80%81%E7%AE%97%E6%B3%95%E5%92%8C%E5%87%BD%E6%95%B0/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2023/08/20/2023-8-20-11-%E8%84%9A%E6%9C%AC%E3%80%81%E7%AE%97%E6%B3%95%E5%92%8C%E5%87%BD%E6%95%B0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>7.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>26 分钟</span>
    </span>
</div>

            </div>
        </header>

        
        
        
        <div class="post-body" itemprop="articleBody">
            <h1 id="前提条件">前提条件</h1>
<p>本章前提条件最小，因为它主要使用基础的R语言。<strong>sf</strong>包用于检查我们将开发的算法的结果，该算法用于计算多边形的面积。在先前知识方面，本章假设您了解在<em>空间数据</em>章中介绍的地理类以及它们如何用于表示各种各样的输入文件格式。</p>
<h1 id="引言">引言</h1>
<p><em>引言</em>章阐明了地理计算不仅仅是使用现有的工具，还包括以“可共享的R脚本和函数”的形式开发新工具。本章教授可复现代码的这些基础构件。它还介绍了低级几何算法，这种算法在<em>GIS</em>章中有应用。阅读本章应有助于您理解这类算法是如何工作的，并编写可多次、由多人、在多个数据集上使用的代码。然而，单凭本章自身无法使您成为一名熟练的程序员。编程是困难的，需要大量的实践<span
class="citation"
data-cites="abelson_structure_1996">[@abelson_structure_1996]</span>：</p>
<blockquote>
<p>要理解编程作为一种自成体系的智力活动，您必须转向计算机编程；您必须阅读和编写计算机程序——很多程序。</p>
</blockquote>
<p>有充分的理由去学习编程。虽然本章本身并未教授编程——参见像@wickham_advanced_2019、<span
class="citation"
data-cites="gillespie_efficient_2016">@gillespie_efficient_2016</span>
和 <span class="citation"
data-cites="xiao_gis_2016">@xiao_gis_2016</span>
这样的资源，它们教授R语言和其他语言的编程——但它确实提供了一些着眼于几何数据的起点，这些起点可能是发展编程技能的良好基础。</p>
<p>本章还演示并强调了可重复性的重要性。可重复性的优点不仅仅是允许其他人复制您的工作：相对于只运行一次的代码，可重复的代码在各方面通常都更优秀，包括计算效率、'可扩展性'（代码在大数据集上运行的能力）以及更容易进行适应和维护。</p>
<p>脚本是可重复R代码的基础，这一主题在<em>脚本</em>节中有覆盖。算法是一系列用于修改输入并得出输出的步骤的配方，如<em>几何算法</em>节所述。为了简化共享和可重复性，算法可以被放置在函数中。这是<em>函数</em>节的主题。找出多边形的质心的例子将用于整合这些概念。<em>几何操作</em>章已经介绍了一个质心函数<code>st_centroid()</code>，但这个例子突出显示了看似简单的操作其实是相对复杂代码的结果，这证实了以下的观察<span
class="citation"
data-cites="wise_gis_2001">[@wise_gis_2001]</span>：</p>
<blockquote>
<p>关于空间数据问题最吸引人的一点是，对人来说看似极其简单的事情，在计算机上可能出奇地困难。</p>
</blockquote>
<p>这个例子也反映了本章的次要目标，即按照@xiao_gis_2016的说法，不是“复制现有的内容，而是展示现有内容是如何工作的”。</p>
<h1 id="脚本">脚本</h1>
<p>如果说包中分发的函数是R代码的基础构件，那么脚本就是将它们粘合在一起的胶水。脚本应该按照逻辑顺序存储和执行，以创建可复现的工作流，这可以手动完成，也可以使用诸如<strong>targets</strong>
<span class="citation"
data-cites="landau_targets_2021">[@landau_targets_2021]</span>这样的工作流自动化工具来完成。</p>
<p>如果你是编程新手，当你第一次遇到脚本时，它们可能看起来很令人生畏，但实际上它们只是普通的文本文件。脚本通常保存为一个扩展名代表它们包含的语言的文件，例如，用Python编写的脚本使用<code>.py</code>扩展名，用Rust编写的脚本使用<code>.rs</code>扩展名。R脚本应该保存为<code>.R</code>扩展名，并且名字应该反映它们的功能。</p>
<p>一个例子是<a
target="_blank" rel="noopener" href="https://github.com/geocompx/geocompr/blob/main/code/11-hello.R"><code>11-hello.R</code></a>，这是一个存储在书籍仓库的<a
target="_blank" rel="noopener" href="https://github.com/geocompx/geocompr/blob/main/code/"><code>code</code></a>文件夹中的脚本文件。<code>11-hello.R</code>是一个非常简单的脚本，只包含两行代码，其中一行是注释。</p>
<p>这些脚本通常是科研过程中非常有用的组成部分，特别是当你需要对大量栅格和矢量数据进行处理和后续分析时，它们可以帮助你实现高度自动化和可复现的工作流程。而使用例如<strong>targets</strong>这样的工作流工具，可以进一步提高代码的结构性和可维护性。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Aim: provide a minimal R script</span></span><br><span class="line">print<span class="punctuation">(</span><span class="string">&quot;Hello geocompr&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>这个脚本的内容并不特别令人兴奋，但它说明了一点：脚本不需要复杂。保存的脚本可以通过R命令行中的<code>source()</code>函数完整地调用和执行，如下面所示。这个命令的输出显示，注释会被忽略，但<code>print()</code>命令会被执行：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">source<span class="punctuation">(</span><span class="string">&quot;code/11-hello.R&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] &quot;Hello geocompr&quot;</span></span><br></pre></td></tr></table></figure>
<p>你也可以从系统命令行shell，例如<code>bash</code>和<code>PowerShell</code>，调用R脚本，前提是<code>RScript</code>可执行文件已经<a
target="_blank" rel="noopener" href="https://www.reddit.com/r/Rlanguage/comments/zaovly/is_anybody_able_to_run_a_r_script_in_powershell/">配置</a>好，例如如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rscript code/11-hello.R</span><br></pre></td></tr></table></figure>
<p>关于脚本文件中可以和不能包含什么，并没有严格的规定，也没有什么能阻止你保存错误的、不可复制的代码。不包含有效R代码的代码行应该被注释掉，通过在行的开始处添加<code>#</code>，以防止错误，如<code>11-hello.R</code>脚本中的第一行所示。然而，有一些值得遵循的惯例：</p>
<ul>
<li>按顺序编写脚本：就像电影的剧本一样，脚本应该有一个明确的顺序，比如'设置'、'数据处理'和'保存结果'（大致相当于电影中的'开头'、'中间'和'结尾'）。</li>
<li>向脚本添加注释，以便其他人（以及你未来的自己）能够理解它。
至少，注释应该说明脚本的目的（见图@ref(fig:codecheck)）并（对于长脚本）将其划分为几个部分。
这可以在RStudio中通过快捷键<code>Ctrl+Shift+R</code>来完成，它会创建'可折叠'的代码段标题。</li>
<li>最重要的是，脚本应该是可复制的：能在任何计算机上运行的自包含脚本比只能在你的计算机上、在好天气下运行的脚本更有用。
这涉及到在开始时附加所需的包，从持久性来源（如可靠网站）读取数据，并确保已经采取了之前的步骤。<a
href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a></li>
</ul>
<p>在R脚本中强制可复制性是困难的，但有一些工具可以帮助。默认情况下，RStudio
会'代码检查' R脚本，并用红色波浪线标出有问题的代码，如下图所示：</p>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309051045079.png" />
Code checking in RStudio. This example, from the script
11-centroid-alg.R, highlights an unclosed curly bracket on line 19.</p>
<blockquote>
<p>📌A useful tool for reproducibility is the <strong>reprex</strong>
package. Its main function <code>reprex()</code> tests lines of R code
to check if they are reproducible, and provides markdown output to
facilitate communication on sites such as GitHub. See the web page
reprex.tidyverse.org for details.</p>
</blockquote>
<p>
本节的内容适用于任何类型的R脚本。对于地理计算脚本的特殊考虑是，它们往往具有外部依赖性，例如在第@ref(read-write)章中重度使用的用于处理地理数据的核心R包所需的GDAL依赖，用于数据导入和导出。运行更专业的地理算法可能需要GIS软件依赖，如第@ref(gis)章所概述。处理地理数据的脚本还常常要求输入数据集以特定格式提供。这种依赖应在脚本的注释中或其所属项目的其他地方进行说明，如脚本
<a
target="_blank" rel="noopener" href="https://github.com/geocompx/geocompr/blob/main/code/11-centroid-alg.R"><code>11-centroid-alg.R</code></a>
所示。'防御性'
编程技巧和良好的错误信息可以通过检查依赖性和与用户沟通（如果某些需求未得到满足）来节省时间。如果语句，用R中的<code>if ()</code>实现，可用于发送消息或运行代码行，只有在满足某些条件时才会这样做。例如，以下代码行会在缺少某个文件时向用户发送消息：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="punctuation">(</span><span class="operator">!</span>file.exists<span class="punctuation">(</span><span class="string">&quot;required_geo_data.gpkg&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="punctuation">&#123;</span></span><br><span class="line">  message<span class="punctuation">(</span><span class="string">&quot;No file, required_geo_data.gpkg is missing!&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">&#125;</span> </span><br><span class="line"><span class="comment">#&gt; No file, required_geo_data.gpkg is missing!</span></span><br></pre></td></tr></table></figure>
<p><code>11-centroid-alg.R</code>脚本所进行的工作在下面的可复制示例中有所展示，该示例创建了一个名为<code>poly_mat</code>的预备对象，代表一个边长为9单位的正方形。这个例子显示了<code>source()</code>可以与URLs一同工作，假设你有互联网连接。如果没有，相同的脚本可以通过<code>source("code/11-centroid-alg.R")</code>来调用，前提是你之前已经下载了<a
target="_blank" rel="noopener" href="https://github.com/geocompx/geocompr">github.com/geocompx/geocompr</a>仓库，并且你正在<code>geocompr</code>文件夹中运行R。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">poly_mat <span class="operator">=</span> cbind<span class="punctuation">(</span></span><br><span class="line">  x <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span> <span class="number">9</span><span class="punctuation">,</span> <span class="number">9</span><span class="punctuation">,</span> <span class="number">0</span><span class="punctuation">,</span> <span class="number">0</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">  y <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span> <span class="number">0</span><span class="punctuation">,</span> <span class="number">9</span><span class="punctuation">,</span> <span class="number">9</span><span class="punctuation">,</span> <span class="number">0</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># Short URL to code/11-centroid-alg.R in the geocompr repo</span></span><br><span class="line">source<span class="punctuation">(</span><span class="string">&quot;https://t.ly/0nzj&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#&gt; [1] &quot;The area is: 81&quot;</span><br><span class="line">#&gt; [1] &quot;The coordinates of the centroid are: 4.5, 4.5&quot;</span><br></pre></td></tr></table></figure>
<h1 id="几何算法">几何算法</h1>
<p>我们可以这么理解算法，它相当于烘焙食谱。它们是一整套指导方针，当对输入进行操作时，会得到有用/美味的结果。输入在烘焙的情况下是如面粉和糖的成分，在算法的情况下是数据和输入参数。而烘焙食谱可能导致美味的蛋糕，成功的算法应有带来环境/社会/其他利益的计算结果。在深入可复制示例之前，下面简短的历史将展示算法是如何与脚本（在<em>脚本</em>节中涉及）和函数（可以用来概括算法，使其更便携和易于使用，我们将在<em>函数</em>节中看到）相关联的。</p>
<p>"算法"这个词源自9世纪在巴格达出版的早期数学教科书 <em>Hisab al-jabr
w’al-muqabala</em>。这本书被译成拉丁文，并变得非常流行，以至于作者的姓氏，<a
target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Muhammad_ibn_Musa_al-Khwarizmi">al-Khwārizmī</a>，“被永久地当作一个科学术语来记忆：Al-Khwarizmi
变成了 Alchoarismi、Algorismi，最终变成了 algorithm” <span
class="citation"
data-cites="bellos_alex_2011">[@bellos_alex_2011]</span>。在计算时代，算法指的是解决问题的一系列步骤，从而得出预定义的输出。输入必须在适当的数据结构中正式定义<span
class="citation"
data-cites="wise_gis_2001">[@wise_gis_2001]</span>。算法通常从流程图或伪代码开始，展示过程的目标，然后在代码中实现。为了简化可用性，常见的算法通常被封装在函数内，这些函数可能会隐藏一些或所有已采取的步骤（除非你查看函数的源代码，参见<em>函数</em>节）。</p>
<p>地理算法，比如我们在<em>GIS</em>章节中遇到的，是接收地理数据并通常返回地理结果的算法（同样的东西还有其他术语，比如<em>GIS算法</em>和<em>几何算法</em>）。这可能听起来简单，但这是一个深刻的主题，有一个专门的学术领域，<em>计算几何</em>，致力于它们的研究<span
class="citation"
data-cites="berg_computational_2008">[@berg_computational_2008]</span>，以及关于该主题的大量书籍。<span
class="citation"
data-cites="orourke_computational_1998">@orourke_computational_1998</span>，例如，使用可复制和免费提供的C代码，以一系列逐渐复杂的几何算法介绍该主题。</p>
<p>几何算法的一个例子是找出多边形的质心的算法。有许多方法来计算质心，其中一些仅适用于特定类型的<a
target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Centroid">空间数据</a>。为了本节的目的，我们选择一种容易可视化的方法：将多边形分解成许多三角形，并找出每个三角形的质心，这种方法由
<span class="citation"
data-cites="kaiser_algorithms_1993">@kaiser_algorithms_1993</span>
讨论，还简短地在 <span class="citation"
data-cites="orourke_computational_1998">@orourke_computational_1998</span>
中提到。在编写任何代码之前，进一步将这种方法分解成离散任务会有所帮助（后来称为步骤1到步骤4，这些也可以以示意图或伪代码的形式呈现）：</p>
<ol type="1">
<li>将多边形分成相邻的三角形。</li>
<li>找出每个三角形的质心。</li>
<li>找出每个三角形的面积。</li>
<li>找出三角形质心的面积加权平均值。</li>
</ol>
<p>这些步骤可能听起来很简单，但将单词转换成工作代码需要一些工作和大量的反复试验，即使输入有限制：算法仅适用于<em>凸多边形</em>，它们不包含大于180°的内角，不允许星形（<strong>decido</strong>和<strong>sfdct</strong>软件包可以使用外部库对非凸多边形进行三角剖分，如<a
target="_blank" rel="noopener" href="https://geocompx.github.io/geocompkg/articles/algorithm.html">algorithm</a>
小册子中所示，该小册子托管在 <a
target="_blank" rel="noopener" href="https://geocompx.org/">geocompx.org</a> 上）。</p>
<p>表示多边形最简单的数据结构是一个矩阵，其中x和y坐标在每行表示一个顶点，以追踪多边形边界的顺序，其中第一行和最后一行是相同的<span
class="citation"
data-cites="wise_gis_2001">[@wise_gis_2001]</span>。在这种情况下，我们将用基础的R创建一个有五个顶点的多边形，该多边形建立在<em>GIS
Algorithms</em> <span class="citation"
data-cites="xiao_gis_2016参见">[@xiao_gis_2016参见[github.com/gisalgs](https://github.com/gisalgs/geom)
以获取 Python 代码]</span>的一个示例上，如下图所示。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># generate a simple matrix representation of a polygon:</span></span><br><span class="line">x_coords <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">10</span><span class="punctuation">,</span> <span class="number">20</span><span class="punctuation">,</span> <span class="number">12</span><span class="punctuation">,</span> <span class="number">0</span><span class="punctuation">,</span> <span class="number">0</span><span class="punctuation">,</span> <span class="number">10</span><span class="punctuation">)</span></span><br><span class="line">y_coords <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span> <span class="number">15</span><span class="punctuation">,</span> <span class="number">20</span><span class="punctuation">,</span> <span class="number">10</span><span class="punctuation">,</span> <span class="number">0</span><span class="punctuation">,</span> <span class="number">0</span><span class="punctuation">)</span></span><br><span class="line">poly_mat <span class="operator">=</span> cbind<span class="punctuation">(</span>x_coords<span class="punctuation">,</span> y_coords<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>现在我们有了一个示例数据集，我们准备进行上面概述的第1步。下面的代码展示了通过创建一个单一的三角形（<code>T1</code>）来实现这一点，该代码演示了该方法；它还通过基于<a
target="_blank" rel="noopener" href="https://math.stackexchange.com/a/1702606">公式</a><span
class="math inline">\(1/3(a + b + c)\)</span>
来计算其质心，从而演示了第2步，其中<span
class="math inline">\(a\)</span>到<span
class="math inline">\(c\)</span>是表示三角形顶点的坐标：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># create a point representing the origin:</span></span><br><span class="line">Origin <span class="operator">=</span> poly_mat<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span> <span class="punctuation">]</span></span><br><span class="line"><span class="comment"># create &#x27;triangle matrix&#x27;:</span></span><br><span class="line">T1 <span class="operator">=</span> rbind<span class="punctuation">(</span>Origin<span class="punctuation">,</span> poly_mat<span class="punctuation">[</span><span class="number">2</span><span class="operator">:</span><span class="number">3</span><span class="punctuation">,</span> <span class="punctuation">]</span><span class="punctuation">,</span> Origin<span class="punctuation">)</span> </span><br><span class="line">C1 <span class="operator">=</span> <span class="punctuation">(</span>T1<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="punctuation">]</span> <span class="operator">+</span> T1<span class="punctuation">[</span><span class="number">2</span><span class="punctuation">,</span><span class="punctuation">]</span> <span class="operator">+</span> T1<span class="punctuation">[</span><span class="number">3</span><span class="punctuation">,</span><span class="punctuation">]</span><span class="punctuation">)</span> <span class="operator">/</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309051050278.png" />
Illustration of polygon centroid calculation problem.</p>
<p>第3步是找出每个三角形的面积，以便计算一个<em>加权平均值</em>，该值会考虑到大三角形的不成比例影响。计算三角形面积的公式如下<span
class="citation"
data-cites="kaiser_algorithms_1993">[@kaiser_algorithms_1993]</span>：</p>
<p><span class="math display">\[
\frac{A_x ( B_y − C_y ) + B_x ( C_y − A_y ) + C_x ( A_y − B_y )}{ 2 }
\]</span></p>
<p>式中，<span class="math inline">\(A\)</span>到<span
class="math inline">\(C\)</span>是三角形的三个点，而<span
class="math inline">\(x\)</span>和<span
class="math inline">\(y\)</span>分别指代 x 和 y
的维度。将这个公式翻译成能够处理矩阵表示形式的三角形 <code>T1</code>
数据的 R 代码如下（函数 <code>abs()</code> 确保了结果为正）：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># calculate the area of the triangle represented by matrix T1:</span></span><br><span class="line"><span class="built_in">abs</span><span class="punctuation">(</span>T1<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">]</span> <span class="operator">*</span> <span class="punctuation">(</span>T1<span class="punctuation">[</span><span class="number">2</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span> <span class="operator">-</span> T1<span class="punctuation">[</span><span class="number">3</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">    T1<span class="punctuation">[</span><span class="number">2</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">]</span> <span class="operator">*</span> <span class="punctuation">(</span>T1<span class="punctuation">[</span><span class="number">3</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span> <span class="operator">-</span> T1<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">    T1<span class="punctuation">[</span><span class="number">3</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">]</span> <span class="operator">*</span> <span class="punctuation">(</span>T1<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span> <span class="operator">-</span> T1<span class="punctuation">[</span><span class="number">2</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">/</span> <span class="number">2</span></span><br><span class="line"><span class="comment">#&gt; [1] 85</span></span><br></pre></td></tr></table></figure>
<p>该代码块输出了正确的结果。<a href="#fn2" class="footnote-ref"
id="fnref2"
role="doc-noteref"><sup>2</sup></a>问题在于代码比较笨拙，如果我们想要在另一个三角形矩阵上运行它，就必须重新键入。为了使代码更具通用性，我们将在<em>函数</em>节中看到如何将其转换为一个函数。</p>
<p>第4步要求在所有三角形上（如上面所示），而不仅仅是一个三角形上，进行第2步和第3步。这就需要<em>迭代</em>以创建表示多边形的所有三角形，如下图所示。这里使用
<code>lapply()</code>和
<code>vapply()</code>来迭代每个三角形，因为它们在基础 R
中提供了一个简洁的解决方案：<a href="#fn3" class="footnote-ref"
id="fnref3" role="doc-noteref"><sup>3</sup></a></p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">i <span class="operator">=</span> <span class="number">2</span><span class="operator">:</span><span class="punctuation">(</span>nrow<span class="punctuation">(</span>poly_mat<span class="punctuation">)</span> <span class="operator">-</span> <span class="number">2</span><span class="punctuation">)</span></span><br><span class="line">T_all <span class="operator">=</span> lapply<span class="punctuation">(</span>i<span class="punctuation">,</span> <span class="keyword">function</span><span class="punctuation">(</span>x<span class="punctuation">)</span> <span class="punctuation">&#123;</span></span><br><span class="line">  rbind<span class="punctuation">(</span>Origin<span class="punctuation">,</span> poly_mat<span class="punctuation">[</span>x<span class="operator">:</span><span class="punctuation">(</span>x <span class="operator">+</span> <span class="number">1</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="punctuation">]</span><span class="punctuation">,</span> Origin<span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">C_list <span class="operator">=</span> lapply<span class="punctuation">(</span>T_all<span class="punctuation">,</span>  <span class="keyword">function</span><span class="punctuation">(</span>x<span class="punctuation">)</span> <span class="punctuation">(</span>x<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span> <span class="punctuation">]</span> <span class="operator">+</span> x<span class="punctuation">[</span><span class="number">2</span><span class="punctuation">,</span> <span class="punctuation">]</span> <span class="operator">+</span> x<span class="punctuation">[</span><span class="number">3</span><span class="punctuation">,</span> <span class="punctuation">]</span><span class="punctuation">)</span> <span class="operator">/</span> <span class="number">3</span><span class="punctuation">)</span></span><br><span class="line">C <span class="operator">=</span> do.call<span class="punctuation">(</span>rbind<span class="punctuation">,</span> C_list<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">A <span class="operator">=</span> vapply<span class="punctuation">(</span>T_all<span class="punctuation">,</span> <span class="keyword">function</span><span class="punctuation">(</span>x<span class="punctuation">)</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="built_in">abs</span><span class="punctuation">(</span>x<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">]</span> <span class="operator">*</span> <span class="punctuation">(</span>x<span class="punctuation">[</span><span class="number">2</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span> <span class="operator">-</span> x<span class="punctuation">[</span><span class="number">3</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">        x<span class="punctuation">[</span><span class="number">2</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">]</span> <span class="operator">*</span> <span class="punctuation">(</span>x<span class="punctuation">[</span><span class="number">3</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span> <span class="operator">-</span> x<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">        x<span class="punctuation">[</span><span class="number">3</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">]</span> <span class="operator">*</span> <span class="punctuation">(</span>x<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span> <span class="operator">-</span> x<span class="punctuation">[</span><span class="number">2</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span><span class="punctuation">)</span> <span class="punctuation">)</span> <span class="operator">/</span> <span class="number">2</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span> FUN.VALUE <span class="operator">=</span> double<span class="punctuation">(</span><span class="number">1</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309051055873.png" />
Illustration of iterative centroid algorithm with triangles. The X
represents the area-weighted centroid in iterations 2 and 3.</p>
<p>现在，我们有条件完成第4步，使用<code>sum(A)</code>来计算总面积，以及使用
<code>weighted.mean(C[, 1], A)</code> 和
<code>weighted.mean(C[, 2], A)</code>
来计算多边形的质心坐标（给警觉的读者一个练习：验证这些命令是否有效）。为了展示算法与脚本之间的联系，本节的内容已经被压缩成
<code>11-centroid-alg.R</code>。我们在<em>脚本</em>节末尾看到，这个脚本如何计算一个正方形的质心。<em>编写脚本</em>
的优点是，它适用于新的 <code>poly_mat</code> 对象（参见下面的练习，以
<code>st_centroid()</code> 为参考来验证这些结果）：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">source<span class="punctuation">(</span><span class="string">&quot;code/11-centroid-alg.R&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] &quot;The area is: 245&quot;</span></span><br><span class="line"><span class="comment">#&gt; [1] &quot;The coordinates of the centroid are: 8.83, 9.22&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面的示例表明，使用基础 R
从基础原理出发，<em>确实可以</em>开发出低级地理操作。它还表明，如果已经存在一个经过验证的解决方案，那么重新发明轮子可能是不值得的：如果我们的目标仅仅是找到多边形的质心，那么将<code>poly_mat</code>表示为一个<strong>sf</strong>对象并使用现有的<code>sf::st_centroid()</code>
函数可能会更快。然而，从1<sup>st</sup>
原理编写算法的巨大好处是，你将理解整个过程的每一个步骤，这是使用其他人代码时无法保证的。另一个需要考虑的因素是性能，与低级语言如C++相比，R在进行数字计算方面可能较慢（参见<em>地理计算软件</em>节），并且难以优化。如果目的是开发新方法，那么计算效率不应该是优先考虑的。这一点体现在“过早优化是编程中一切（或至少大部分）邪恶的根源”<span
class="citation"
data-cites="knuth_computer_1974">[@knuth_computer_1974]</span>这一说法中。</p>
<p>算法开发是困难的。这一点应该从开发一个仅仅是一种相对低效的解决方案、对实际问题（实际中凸多边形并不常见）具有有限应用的基础
R 的质心算法中显而易见。这种经验应该会让人更加重视像GEO（它是
<code>sf::st_centroid()</code>
的基础）和CGAL（计算几何算法库）这样的低级地理库，这些库不仅运行快，还适用于多种类型的输入几何。
这些库开源的一个重要优点是，其源代码便于学习、理解，并且（对于具备技能和信心的人）进行修改。<a
href="#fn4" class="footnote-ref" id="fnref4"
role="doc-noteref"><sup>4</sup></a></p>
<h1 id="函数">函数</h1>
<p>与算法类似，函数接收一个输入并返回一个输出。然而，函数是特定编程语言中实现的，而不是“配方”本身。在
R
中，函数本身就是对象，可以以模块化的方式创建和组合。例如，我们可以创建一个执行我们质心生成算法第二步的函数，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t_centroid <span class="operator">=</span> <span class="keyword">function</span><span class="punctuation">(</span>x<span class="punctuation">)</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="punctuation">(</span>x<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span> <span class="punctuation">]</span> <span class="operator">+</span> x<span class="punctuation">[</span><span class="number">2</span><span class="punctuation">,</span> <span class="punctuation">]</span> <span class="operator">+</span> x<span class="punctuation">[</span><span class="number">3</span><span class="punctuation">,</span> <span class="punctuation">]</span><span class="punctuation">)</span> <span class="operator">/</span> <span class="number">3</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>上面的示例演示了<a
target="_blank" rel="noopener" href="https://adv-r.hadley.nz/functions.html">函数</a>的两个关键组件：1）函数
<em>主体</em>，即定义函数如何处理输入的大括号内的代码；和 2）
<em>形式参数</em>，即函数使用的参数列表——在这种情况下是
<code>x</code>（第三个关键组件，环境，超出了本节的范围）。默认情况下，函数返回最后一个被计算的对象（在
<code>t_centroid()</code> 的情况下是质心的坐标）。<a href="#fn5"
class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a></p>
<p>该函数现在适用于你传递给它的任何输入，如下面的命令所示，该命令计算了上一节中示例多边形中第1个三角形的面积：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t_centroid<span class="punctuation">(</span>T1<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; x_coords y_coords </span></span><br><span class="line"><span class="comment">#&gt;     14.0     11.7</span></span><br></pre></td></tr></table></figure>
<p>我们还可以创建一个函数来计算三角形的面积，我们将其命名为
<code>t_area()</code>：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">t_area <span class="operator">=</span> <span class="keyword">function</span><span class="punctuation">(</span>x<span class="punctuation">)</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="built_in">abs</span><span class="punctuation">(</span></span><br><span class="line">    x<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">]</span> <span class="operator">*</span> <span class="punctuation">(</span>x<span class="punctuation">[</span><span class="number">2</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span> <span class="operator">-</span> x<span class="punctuation">[</span><span class="number">3</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">    x<span class="punctuation">[</span><span class="number">2</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">]</span> <span class="operator">*</span> <span class="punctuation">(</span>x<span class="punctuation">[</span><span class="number">3</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span> <span class="operator">-</span> x<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">    x<span class="punctuation">[</span><span class="number">3</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">]</span> <span class="operator">*</span> <span class="punctuation">(</span>x<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span> <span class="operator">-</span> x<span class="punctuation">[</span><span class="number">2</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span><span class="punctuation">)</span></span><br><span class="line">  <span class="punctuation">)</span> <span class="operator">/</span> <span class="number">2</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>注意，在创建函数之后，可以用一行代码计算三角形的面积，避免了冗长代码的重复：函数是一种
<em>泛化</em>
代码的机制。新创建的函数<code>t_area()</code>接受任何对象<code>x</code>，假设其具有与我们一直在使用的“三角形矩阵”数据结构相同的维度，并返回其面积，如下面在<code>T1</code>上的示例：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t_area<span class="punctuation">(</span>T1<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] 85</span></span><br></pre></td></tr></table></figure>
<p>我们可以通过使用它来找到一个新的三角形矩阵的面积来测试函数的泛化性，该三角形矩阵的高度为1，底边为3：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">t_new <span class="operator">=</span> cbind<span class="punctuation">(</span>x <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">,</span> <span class="number">0</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">              y <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span> <span class="number">0</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">0</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">t_area<span class="punctuation">(</span>t_new<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt;   x </span></span><br><span class="line"><span class="comment">#&gt; 1.5</span></span><br></pre></td></tr></table></figure>
<p>函数的一个有用特性是它们是模块化的。只要你知道输出会是什么，一个函数就可以用作另一个函数的构建块。因此，<code>t_centroid()</code>
和
<code>t_area()</code>可以用作更大的函数的子组件，以执行脚本<code>11-centroid-alg.R</code>的工作：计算任何凸多边形的面积。下面的代码块创建了
<code>poly_centroid()</code> 函数，以模仿针对凸多边形的
<code>sf::st_centroid()</code> 的行为：<a href="#fn6"
class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a></p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">poly_centroid <span class="operator">=</span> <span class="keyword">function</span><span class="punctuation">(</span>poly_mat<span class="punctuation">)</span> <span class="punctuation">&#123;</span></span><br><span class="line">  Origin <span class="operator">=</span> poly_mat<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span> <span class="punctuation">]</span> <span class="comment"># create a point representing the origin</span></span><br><span class="line">  i <span class="operator">=</span> <span class="number">2</span><span class="operator">:</span><span class="punctuation">(</span>nrow<span class="punctuation">(</span>poly_mat<span class="punctuation">)</span> <span class="operator">-</span> <span class="number">2</span><span class="punctuation">)</span></span><br><span class="line">  T_all <span class="operator">=</span> lapply<span class="punctuation">(</span>i<span class="punctuation">,</span> <span class="keyword">function</span><span class="punctuation">(</span>x<span class="punctuation">)</span> <span class="punctuation">&#123;</span>rbind<span class="punctuation">(</span>Origin<span class="punctuation">,</span> poly_mat<span class="punctuation">[</span>x<span class="operator">:</span><span class="punctuation">(</span>x <span class="operator">+</span> <span class="number">1</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="punctuation">]</span><span class="punctuation">,</span> Origin<span class="punctuation">)</span><span class="punctuation">&#125;</span><span class="punctuation">)</span></span><br><span class="line">  C_list <span class="operator">=</span> lapply<span class="punctuation">(</span>T_all<span class="punctuation">,</span> t_centroid<span class="punctuation">)</span></span><br><span class="line">  C <span class="operator">=</span> do.call<span class="punctuation">(</span>rbind<span class="punctuation">,</span> C_list<span class="punctuation">)</span></span><br><span class="line">  A <span class="operator">=</span> vapply<span class="punctuation">(</span>T_all<span class="punctuation">,</span> t_area<span class="punctuation">,</span> FUN.VALUE <span class="operator">=</span> double<span class="punctuation">(</span><span class="number">1</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">  <span class="built_in">c</span><span class="punctuation">(</span>weighted.mean<span class="punctuation">(</span>C<span class="punctuation">[</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">]</span><span class="punctuation">,</span> A<span class="punctuation">)</span><span class="punctuation">,</span> weighted.mean<span class="punctuation">(</span>C<span class="punctuation">[</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span><span class="punctuation">,</span> A<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">poly_centroid<span class="punctuation">(</span>poly_mat<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] 8.83 9.22</span></span><br></pre></td></tr></table></figure>
<p>像 <code>poly_centroid()</code>
这样的函数可以进一步扩展以提供不同类型的输出。例如，要将结果作为类
<code>sfg</code> 的对象返回，可以使用 '包装器' 函数来修改
<code>poly_centroid()</code> 的输出，然后返回结果：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">poly_centroid_sfg <span class="operator">=</span> <span class="keyword">function</span><span class="punctuation">(</span>x<span class="punctuation">)</span> <span class="punctuation">&#123;</span></span><br><span class="line">  centroid_coords <span class="operator">=</span> poly_centroid<span class="punctuation">(</span>x<span class="punctuation">)</span></span><br><span class="line">  sf<span class="operator">::</span>st_point<span class="punctuation">(</span>centroid_coords<span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>我们可以通过以下方式验证输出与 <code>sf::st_centroid()</code>
的输出相同：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">poly_sfc <span class="operator">=</span> sf<span class="operator">::</span>st_polygon<span class="punctuation">(</span><span class="built_in">list</span><span class="punctuation">(</span>poly_mat<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">identical<span class="punctuation">(</span>poly_centroid_sfg<span class="punctuation">(</span>poly_mat<span class="punctuation">)</span><span class="punctuation">,</span> sf<span class="operator">::</span>st_centroid<span class="punctuation">(</span>poly_sfc<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] FALSE</span></span><br></pre></td></tr></table></figure>
<h1 id="编程">编程</h1>
<p>在本章中，我们的速度很快，从脚本到函数，再到算法这个棘手的主题。我们不仅在抽象层面上讨论了它们，还创建了针对特定问题的工作示例：</p>
<ul>
<li>介绍并演示了在'多边形矩阵'上运行的脚本<code>11-centroid-alg.R</code></li>
<li>描述了允许此脚本工作的各个步骤，被称为算法，一个计算性的配方</li>
<li>为了通用化这个算法，我们将其转换成模块化的函数，最终组合成上一节中的函数<code>poly_centroid()</code></li>
</ul>
<p>每一个可能看似简单。然而，熟练的编程是复杂的，涉及将每个元素——脚本、算法和函数——<em>组合</em>成一个<em>系统</em>，具有效率和风格。最终的结果应该是健壮且用户友好的工具，供其他人使用。如我们预期本书的大多数读者将是编程新手，能够遵循并复现前面几节的结果是一个重大成就。编程需要许多小时的专门学习和实践才能熟练。</p>
<p>面对希望以有效方式实现新算法的开发者的挑战，可以通过考虑创建一个简单但并非用于生产的函数所付出的努力量来考虑：在当前状态下，<code>poly_centroid()</code>在大多数（非凸）多边形上失败！这提出了一个问题：如何通用化这个函数？两个选项是（1）找到三角化非凸多边形的方法（这是本章支持的在线<a
target="_blank" rel="noopener" href="https://geocompx.github.io/geocompkg/articles/algorithm.html">算法</a>文章所涵盖的主题）和（2）探索其他不依赖于三角网格的质心算法。</p>
<p>一个更广泛的问题是：当已经有高性能的算法被实现并打包成诸如<code>st_centroid()</code>这样的函数时，是否值得编程解决方案？在这个特定情况下，简单的答案是'否'。在更广泛的背景下，考虑到学习编程的好处，答案是'视情况而定'。在编程中，很容易浪费时间尝试实现一种方法，只有到最后才发现有人已经做了艰苦的工作。你可以把这一章看作是通往几何算法编程魔法的垫脚石。然而，它也可以被看作是何时尝试编程一个通用解决方案，以及何时使用现有的更高级解决方案的一堂课。肯定会有编写新函数是最佳方案的时候，但也会有使用已经存在的函数是最佳方案的时候。</p>
<p>“不要重复发明轮子”一样适用于编程，甚至更适用于生活中的其他方面。项目开始时进行一点研究和思考可以帮助决定编程时间最好如何使用。以下三个原则也可以帮助最大化编写代码时的努力，无论它是一个简单的脚本还是由数百个函数组成的包：</p>
<ol type="1">
<li><a
target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself">DRY</a>（不要重复自己）：尽量减少代码重复，并以更少的代码行解决特定问题。
这一原则在《R for Data Science》<span class="citation"
data-cites="grolemund_r_2016">[@grolemund_r_2016]</span>的函数章节中有解释。</li>
<li><a
target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/KISS_principle">KISS</a>（保持简单愚蠢）：这一原则建议首先尝试简单解决方案，优先于复杂解决方案，需要时使用依赖项，目标是保持脚本简洁。
这一原则是<a
target="_blank" rel="noopener" href="https://www.nature.com/articles/d41586-018-05004-4">名言</a>“事物应尽量简单，但不能更简单”的计算类比。</li>
<li>模块性：如果你的代码被划分成明确定义的片段，它将更容易维护。一个函数应该只做一件事，但要做得非常好。如果你的函数变得太长，考虑将其拆分成多个小函数，每个都可以用于其他目的，支持DRY和KISS原则。</li>
</ol>
<p>我们不能保证这一章会立即让你能够为你的工作创建完美的函数。然而，我们确信其内容将帮助你决定何时是适当的尝试时机（当没有其他现有的函数解决问题，当编程任务在你的能力范围内，当解决方案的好处可能大于开发它的时间成本）。通过使用上述原则，结合通过完成上面的实例获得的实践经验，你将建立你的脚本编写、包编写和编程技能。编程的第一步可能会很慢（下面的练习不应该匆忙完成），但长期的回报可能会很大。</p>
<h1 id="exercises">Exercises</h1>
<p>E1. Read the script <a
target="_blank" rel="noopener" href="https://github.com/geocompx/geocompr/blob/main/code/11-centroid-alg.R"><code>11-centroid-alg.R</code></a>
in the <code>code</code> folder of the book's GitHub repo.</p>
<ul>
<li>Which of the best practices covered in Section @ref(scripts) does it
follow?</li>
<li>Create a version of the script on your computer in an IDE such as
RStudio (preferably by typing-out the script line-by-line, in your own
coding style and with your own comments, rather than copy-pasting ---
this will help you learn how to type scripts). Using the example of a
square polygon (e.g., created with
<code>poly_mat = cbind(x = c(0, 9, 9, 0, 0), y = c(0, 0, 9, 9, 0))</code>)
execute the script line-by-line.</li>
<li>What changes could be made to the script to make it more
reproducible?</li>
<li>How could the documentation be improved?</li>
</ul>
<p>E2. In the geometric algorithms section we calculated that the area
and geographic centroid of the polygon represented by
<code>poly_mat</code> was 245 and 8.8, 9.2, respectively.</p>
<ul>
<li>Reproduce the results on your own computer with reference to the
script <a
target="_blank" rel="noopener" href="https://github.com/geocompx/geocompr/blob/main/code/11-centroid-alg.R"><code>11-centroid-alg.R</code></a>,
an implementation of this algorithm (bonus: type out the commands - try
to avoid copy-pasting).</li>
<li>Are the results correct? Verify them by converting
<code>poly_mat</code> into an <code>sfc</code> object (named
<code>poly_sfc</code>) with <code>st_polygon()</code> (hint: this
function takes objects of class <code>list()</code>) and then using
<code>st_area()</code> and <code>st_centroid()</code>.</li>
</ul>
<p>E3. It was stated that the algorithm we created only works for
<em>convex hulls</em>. Define convex hulls (see the geometry operations
chapter) and test the algorithm on a polygon that is <em>not</em> a
convex hull.</p>
<ul>
<li>Bonus 1: Think about why the method only works for convex hulls and
note changes that would need to be made to the algorithm to make it work
for other types of polygon.</li>
<li>Bonus 2: Building on the contents of <code>11-centroid-alg.R</code>,
write an algorithm only using base R functions that can find the total
length of linestrings represented in matrix form.</li>
</ul>
<!-- Todo: add example of matrix representing a linestring, demonstrate code to verify the answer, suggest alternative functions to decompose as a bonus. -->
<p>E4. In the functions section we created different versions of the
<code>poly_centroid()</code> function that generated outputs of class
<code>sfg</code> (<code>poly_centroid_sfg()</code>) and type-stable
<code>matrix</code> outputs (<code>poly_centroid_type_stable()</code>).
Further extend the function by creating a version (e.g., called
<code>poly_centroid_sf()</code>) that is type stable (only accepts
inputs of class <code>sf</code>) <em>and</em> returns <code>sf</code>
objects (hint: you may need to convert the object <code>x</code> into a
matrix with the command <code>sf::st_coordinates(x)</code>).</p>
<ul>
<li>Verify it works by running
<code>poly_centroid_sf(sf::st_sf(sf::st_sfc(poly_sfc)))</code></li>
<li>What error message do you get when you try to run
<code>poly_centroid_sf(poly_mat)</code>?</li>
</ul>
<aside id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>
之前的步骤可以用注释或者if语句来指出，比如<code>if (!exists("x")) source("x.R")</code>（如果对象<code>x</code>不存在，则会运行脚本文件<code>x.R</code>）。<a
href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li
id="fn2"><p>可以用以下公式（该公式假设底边是水平的）来验证结果：面积是底边宽度与高度乘积的一半，<span
class="math inline">\(A = B * H / 2\)</span>。在这种情况下 <span
class="math inline">\(10 * 10 / 2 = 50\)</span>。<a href="#fnref2"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>有关文档，请参见
<code>?lapply</code>，更多关于迭代的信息，请参见第@ref(location)章。<a
href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>事实上，CGAL函数 <code>CGAL::centroid()</code>
是由7个子函数组成的，如https://doc.cgal.org/latest/Kernel_23/group__centroid__grp.html
所描述，使其能够适用于多种类型的输入数据，而我们创建的解决方案仅适用于一种非常特定的输入数据类型。GEOS
函数 <code>Centroid::getCentroid()</code> 的底层源代码可以在
https://github.com/libgeos/geos/search?q=getCentroid 上找到。<a
href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>你也可以通过在函数主体中添加 <code>return(output)</code>
明确设置函数的输出，其中 <code>output</code> 是要返回的结果。<a
href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p>注意，我们创建的函数在 <code>lapply()</code>和
<code>vapply()</code> 函数调用中被迭代地调用。<a href="#fnref6"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>

            
        </div>

        
        
        

        <div>
            
        </div>

        <footer class="post-footer">
            <div class="post-eof"></div>
            
        </footer>
    </article>
</div>




    


<div class="post-block">
    
    

    <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
        <link itemprop="mainEntityOfPage" href="https://ancao96.github.io/2023/08/19/2023-8-19-10-%E8%BF%9E%E6%8E%A5%E5%88%B0GIS%E8%BD%AF%E4%BB%B6%E7%9A%84%E6%A1%A5%E6%A2%81/">

        <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
            <meta itemprop="image" content="/images/avatar.gif">
            <meta itemprop="name" content="SCY">
        </span>

        <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
            <meta itemprop="name" content="SCY SPACE">
            <meta itemprop="description" content="">
        </span>

        <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
            <meta itemprop="name" content="undefined | SCY SPACE">
            <meta itemprop="description" content="">
        </span>
        <header class="post-header">
            <h2 class="post-title" itemprop="name headline">
                <a href="/2023/08/19/2023-8-19-10-%E8%BF%9E%E6%8E%A5%E5%88%B0GIS%E8%BD%AF%E4%BB%B6%E7%9A%84%E6%A1%A5%E6%A2%81/" class="post-title-link" itemprop="url">(10)连接到GIS的桥梁</a>
            </h2>

            <div class="post-meta-container">
                <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-08-19 19:55:20" itemprop="dateCreated datePublished" datetime="2023-08-19T19:55:20+08:00">2023-08-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-09-04 22:52:37" itemprop="dateModified" datetime="2023-09-04T22:52:37+08:00">2023-09-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/R/" itemprop="url" rel="index"><span itemprop="name">R</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/R/Geocomputaion/" itemprop="url" rel="index"><span itemprop="name">Geocomputaion</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2023/08/19/2023-8-19-10-%E8%BF%9E%E6%8E%A5%E5%88%B0GIS%E8%BD%AF%E4%BB%B6%E7%9A%84%E6%A1%A5%E6%A2%81/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2023/08/19/2023-8-19-10-%E8%BF%9E%E6%8E%A5%E5%88%B0GIS%E8%BD%AF%E4%BB%B6%E7%9A%84%E6%A1%A5%E6%A2%81/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>14k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>49 分钟</span>
    </span>
</div>

            </div>
        </header>

        
        
        
        <div class="post-body" itemprop="articleBody">
            <p>R
等具有交互式控制台的语言的一个特点——严格来说是一个读取-求值-打印循环（REPL）——
是你与它们互动的方式。与其依赖于在屏幕的不同部分上指点和点击，你可以将命令键入控制台，并使用
<code>Enter</code> 键执行它们。使用像RStudio或VS
Code这样的交互式开发环境时，一个常见且有效的工作流程是将代码键入源文件的源编辑器中，并使用像<code>Ctrl+Enter</code>这样的快捷方式来控制代码的交互式执行。
            <!--noindex-->
            <div class="post-button">
                <a class="btn" href="/2023/08/19/2023-8-19-10-%E8%BF%9E%E6%8E%A5%E5%88%B0GIS%E8%BD%AF%E4%BB%B6%E7%9A%84%E6%A1%A5%E6%A2%81/#more" rel="contents">
                    阅读全文 &raquo;
                </a>
            </div>
            <!--/noindex-->
            
            
        </div>

        
        
        

        <div>
            
        </div>

        <footer class="post-footer">
            <div class="post-eof"></div>
            
        </footer>
    </article>
</div>




    


<div class="post-block">
    
    

    <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
        <link itemprop="mainEntityOfPage" href="https://ancao96.github.io/2023/08/18/2023-8-18-9-%E5%9C%B0%E7%90%86%E6%95%B0%E6%8D%AE%E5%88%B6%E5%9B%BE/">

        <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
            <meta itemprop="image" content="/images/avatar.gif">
            <meta itemprop="name" content="SCY">
        </span>

        <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
            <meta itemprop="name" content="SCY SPACE">
            <meta itemprop="description" content="">
        </span>

        <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
            <meta itemprop="name" content="undefined | SCY SPACE">
            <meta itemprop="description" content="">
        </span>
        <header class="post-header">
            <h2 class="post-title" itemprop="name headline">
                <a href="/2023/08/18/2023-8-18-9-%E5%9C%B0%E7%90%86%E6%95%B0%E6%8D%AE%E5%88%B6%E5%9B%BE/" class="post-title-link" itemprop="url">(9)地理数据制图</a>
            </h2>

            <div class="post-meta-container">
                <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-08-18 06:35:20" itemprop="dateCreated datePublished" datetime="2023-08-18T06:35:20+08:00">2023-08-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-09-03 22:14:00" itemprop="dateModified" datetime="2023-09-03T22:14:00+08:00">2023-09-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/R/" itemprop="url" rel="index"><span itemprop="name">R</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/R/Geocomputaion/" itemprop="url" rel="index"><span itemprop="name">Geocomputaion</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2023/08/18/2023-8-18-9-%E5%9C%B0%E7%90%86%E6%95%B0%E6%8D%AE%E5%88%B6%E5%9B%BE/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2023/08/18/2023-8-18-9-%E5%9C%B0%E7%90%86%E6%95%B0%E6%8D%AE%E5%88%B6%E5%9B%BE/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>12k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>45 分钟</span>
    </span>
</div>

            </div>
        </header>

        
        
        
        <div class="post-body" itemprop="articleBody">
            <h1 id="前提条件">前提条件</h1>
<ul>
<li>本章需要使用我们已经在使用的以下包：</li>
</ul>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">library<span class="punctuation">(</span>sf<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>terra<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>dplyr<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>spData<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>spDataLarge<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>此外，本章还使用以下可视化包（如果您想开发交互式地图应用程序，请安装shiny）：</li>
</ul>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># remotes::install_github(&quot;r-tmap/tmap@v4&quot;)</span></span><br><span class="line">library<span class="punctuation">(</span>tmap<span class="punctuation">)</span>    <span class="comment"># for static and interactive maps</span></span><br><span class="line">library<span class="punctuation">(</span>leaflet<span class="punctuation">)</span> <span class="comment"># for interactive maps</span></span><br><span class="line">library<span class="punctuation">(</span>ggplot2<span class="punctuation">)</span> <span class="comment"># tidyverse data visualization package</span></span><br></pre></td></tr></table></figure>
<ul>
<li>您还需要按照以下方式读取几个数据集，以进行<em>栅格数据的空间操作</em>部分的内容：</li>
</ul>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nz_elev <span class="operator">=</span> rast<span class="punctuation">(</span>system.file<span class="punctuation">(</span><span class="string">&quot;raster/nz_elev.tif&quot;</span><span class="punctuation">,</span> package <span class="operator">=</span> <span class="string">&quot;spDataLarge&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<h1 id="引言">引言</h1>
<p>地理研究中令人满意和重要的一个方面是传达研究结果。制图——地图制作的艺术——是一项古老的技能，涉及沟通、细节关注和创造性元素。在R中进行静态制图非常简单，可以使用<code>plot()</code>函数。通过使用基本R方法，可以创建高级地图<span
class="citation"
data-cites="murrell_r_2016">[@murrell_r_2016]</span>。然而，本章的重点是使用专门的制图包进行地图制作。在学习新技能时，首先在一个领域深入掌握知识，然后再进行扩展，这是合乎情理的做法。制图也不例外，因此本章深入介绍了一个包（<strong>tmap</strong>），而不是浅尝辄止地介绍多个包。</p>
<p>除了有趣和富有创意外，制图还具有重要的实际应用。精心制作的地图可能是传达工作结果的最佳方式，但设计不良的地图可能会留下不好的印象。常见的设计问题包括文本的位置、大小和可读性差，以及颜色的选择不慎，正如《地图杂志》的风格<a
target="_blank" rel="noopener" href="https://www.tandf.co.uk//journals/authors/style/TJOM-suppmaterial-quick-guide.pdf">指南</a>中所述。此外，糟糕的地图制作可能会妨碍结果的传达<span
class="citation"
data-cites="brewer_designing_2015">[@brewer_designing_2015]</span>：</p>
<blockquote>
<p>看起来业余的地图可能会削弱您的受众理解重要信息的能力，减弱专业数据调查的呈现效果。
数千年来，地图已被用于各种各样的目的。
历史上的例子包括3000多年前的旧巴比伦王朝的建筑和土地所有权地图，以及近2000年前托勒密在他的杰作<em>地理学</em>中的世界地图<span
class="citation"
data-cites="talbert_ancient_2014">[@talbert_ancient_2014]</span>。</p>
</blockquote>
<p>制图活动在历史上曾经只由精英或代表精英进行。随着开源地图制作软件的出现，如R包<strong>tmap</strong>和QGIS中的'print
composer'，任何人都可以制作高质量的地图，从而实现了'公民科学'。地图也常常是以易于理解的方式呈现地理计算研究结果的最佳途径。制图因此是地理计算的关键部分，它不仅强调描述世界，还强调<em>改变</em>世界。</p>
<p>本章介绍了如何制作各种类型的地图。接下来的部分将涵盖静态地图的各种情况，包括美学考虑、分面和插图地图。部分章节将介绍动态和交互式地图（包括网络地图和地图应用程序）。最
后，将介绍一系列备选的地图制作包，包括<strong>ggplot2</strong>和<strong>cartogram</strong>。</p>
<h1 id="静态地图">静态地图</h1>
<p>静态地图是地理计算的最常见的可视输出类型。它们通常以标准格式保存，包括
<code>.png</code>和<code>.pdf</code>用于图形光栅和矢量输出。最初，静态地图是R唯一能够生成的地图类型。随着<strong>sp</strong>的发布[<a
href="mailto:见@pebesma"
class="email">见@pebesma</a>_classes_2005]，自那时以来，许多地图制作技术、函数和软件包得到了发展。然而，尽管有交互式地图的创新，静态绘图仍然是十年后<span
class="citation"
data-cites="cheshire_spatial_2015">[@cheshire_spatial_2015]</span>R中地理数据可视化的重点。</p>
<p>通用的 <code>plot()</code>
函数是从矢量和栅格空间对象创建静态地图的最快方法。有时，在项目开发阶段，简单性和速度是首要考虑的因素，这就是
<code>plot()</code> 函数的优势所在。 基本的 R
方法也是可扩展的，<code>plot()</code>
函数提供了许多参数选项。另一种方法是使用 <strong>grid</strong>
软件包，它允许对静态地图进行低级别的控制，如 <span class="citation"
data-cites="murrell_r_2016">@murrell_r_2016</span> 的第 <a
target="_blank" rel="noopener" href="https://www.stat.auckland.ac.nz/~paul/RG2e/chapter14.html">14</a>
章所示。本书的这部分将重点介绍
<strong>tmap</strong>，并强调其基本的美学和布局选项。</p>
<p><strong>tmap</strong>是一个功能强大且灵活的制图软件包，具有合理的默认设置。它具有简洁的语法，允许使用最少的代码创建具有吸引力的地图，这对于
<strong>ggplot2</strong>
用户来说会非常熟悉。它还具有独特的功能，通过<code>tmap_mode()</code>可以生成静态和交互式地图，使用相同的代码。最后，它接受比其他替代方案（如
<strong>ggplot2</strong>）更广泛的空间类别（包括 <strong>sf</strong> 和
<strong>terra</strong> 对象）。 <!--toDo:jn-->
<!-- update the below vignettes links -->
<!-- (see the vignettes [`tmap-getstarted`](https://cran.r-project.org/web/packages/tmap/vignettes/tmap-getstarted.html) and [`tmap-changes-v2`](https://cran.r-project.org/web/packages/tmap/vignettes/tmap-changes-v2.html), as well as @tennekes_tmap_2018, for further documentation). --></p>
<h2 id="tmap-基础">tmap 基础</h2>
<p>与<strong>ggplot2</strong>类似，<strong>tmap</strong>基于"图形语法"的理念
<span class="citation"
data-cites="wilkinson_grammar_2005">[@wilkinson_grammar_2005]</span>。这涉及将输入数据与美学（数据如何可视化）分离：每个输入数据集可以通过多种不同的方式进行"映射"，包括在地图上的位置（由数据的<code>geometry</code>定义）、颜色和其他视觉变量。基本构建块是
<code>tm_shape()</code>（定义输入数据：矢量或栅格对象），然后是一个或多个图层元素，如
<code>tm_fill()</code> 和
<code>tm_dots()</code>。以下代码块演示了这种分层结构，生成了图中呈现的地图：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Add fill layer to nz shape</span></span><br><span class="line">tm_shape<span class="punctuation">(</span>nz<span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  tm_fill<span class="punctuation">(</span><span class="punctuation">)</span> </span><br><span class="line"><span class="comment"># Add border layer to nz shape</span></span><br><span class="line">tm_shape<span class="punctuation">(</span>nz<span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  tm_borders<span class="punctuation">(</span><span class="punctuation">)</span> </span><br><span class="line"><span class="comment"># Add fill and border layers to nz shape</span></span><br><span class="line">tm_shape<span class="punctuation">(</span>nz<span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  tm_fill<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  tm_borders<span class="punctuation">(</span><span class="punctuation">)</span> </span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309031738903.png" />
New Zealand's shape plotted with fill (left), border (middle) and fill
and border (right) layers added using tmap functions.</p>
<p>在这种情况下，传递给<code>tm_shape()</code>的对象是<code>nz</code>，一个代表新西兰各个地区的<code>sf</code>对象。添加图层以在视觉上表示<code>nz</code>，使用<code>tm_fill()</code>和<code>tm_borders()</code>分别在上图的左侧面板和中间面板中创建了阴影区。</p>
<ul>
<li><code>tm_fill()</code>: （多）多边形的阴影区域</li>
<li><code>tm_borders()</code>: （多）多边形的边界轮廓</li>
<li><code>tm_polygons()</code>: （多）多边形的阴影区域和边界轮廓</li>
<li><code>tm_lines()</code>: （多）线串的线条</li>
<li><code>tm_symbols()</code>: （多）点、线串和多边形的符号</li>
<li><code>tm_raster()</code>:
栅格数据的彩色单元格（也有用于具有三个图层的栅格的
<code>tm_rgb()</code>）</li>
<li><code>tm_text()</code>: （多）点、线串和多边形的文本信息</li>
</ul>
<!--toDo: jn-->
<!-- update help link -->
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 请参阅 `help(&quot;tmap-element&quot;)` 获取所有可能的图层类型的完整列表。这种图层叠加效果在图的右侧面板中得以体现，这是在填充图层之上添加了边界。 --&gt;</span><br></pre></td></tr></table></figure>
<!--toDo: jn-->
<!-- update when/if -->
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">&gt; `qtm()` 是一个方便的函数，用于创建快速、主题、地图（因此取了一个简洁的名字）。</span><br><span class="line">它非常简洁，对许多情况下都提供了很好的默认可视化效果：例如，`qtm(nz)` 等同于 `tm_shape(nz) + tm_fill() + tm_borders()`。</span><br><span class="line">此外，可以使用多个 `qtm()` 调用简洁地添加图层，例如 `qtm(nz) + qtm(nz_height)`。</span><br><span class="line">缺点是它使得单个图层的美学更难以控制，这就解释了为什么我们在本章中避免教授它。</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure>
<h2 id="地图对象">地图对象</h2>
<p><strong>tmap</strong>
的一个有用特性是它能够存储代表地图的<em>对象</em>。下面的代码块演示了这一点，通过将上图中的最后一个绘图保存为一个<code>tmap</code>类型的对象（注意使用了<code>tm_polygons()</code>，它将<code>tm_fill()+tm_borders()</code>结合成一个函数）：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map_nz <span class="operator">=</span> tm_shape<span class="punctuation">(</span>nz<span class="punctuation">)</span> <span class="operator">+</span> tm_polygons<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line"><span class="built_in">class</span><span class="punctuation">(</span>map_nz<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] &quot;tmap&quot;</span></span><br></pre></td></tr></table></figure>
<p><code>map_nz</code>可以进行绘图，例如添加额外的图层（如下所示），或者只需在控制台中运行
<code>map_nz</code>，这相当于 <code>print(map_nz)</code>。</p>
<p>可以使用 <code>+ tm_shape(new_obj)</code>
添加新的<em>shapes</em>。在这种情况下，<code>new_obj</code>表示要绘制在之前图层之上的新的空间对象。当以这种方式添加新的形状shape时，所有后续的美学函数都会与它相关联，直到添加另一个新的shape为止。这种语法允许创建具有多个形状和图层的地图，如下面的代码块所示，使用函数
<code>tm_raster()</code>绘制一个栅格图层（设置<code>col_alpha</code>
使图层半透明）：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map_nz1 <span class="operator">=</span> map_nz <span class="operator">+</span></span><br><span class="line">  tm_shape<span class="punctuation">(</span>nz_elev<span class="punctuation">)</span> <span class="operator">+</span> tm_raster<span class="punctuation">(</span>col_alpha <span class="operator">=</span> <span class="number">0.7</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<!--toDo: jn-->
<!-- explain the SpatRaster object downsampled to 1141 by 877 cells. message -->
<p>Building on the previously created <code>map_nz</code> object, the
preceding code creates a new map object <code>map_nz1</code> that
contains another shape (<code>nz_elev</code>) representing average
elevation across New Zealand (see Figure @ref(fig:tmlayers), left). More
shapes and layers can be added, as illustrated in the code chunk below
which creates <code>nz_water</code>, representing New Zealand's <a
target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Territorial_waters">territorial
waters</a>, and adds the resulting lines to an existing map object.</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nz_water <span class="operator">=</span> st_union<span class="punctuation">(</span>nz<span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">  st_buffer<span class="punctuation">(</span><span class="number">22200</span><span class="punctuation">)</span> <span class="operator">|&gt;</span> </span><br><span class="line">  st_cast<span class="punctuation">(</span>to <span class="operator">=</span> <span class="string">&quot;LINESTRING&quot;</span><span class="punctuation">)</span></span><br><span class="line">map_nz2 <span class="operator">=</span> map_nz1 <span class="operator">+</span></span><br><span class="line">  tm_shape<span class="punctuation">(</span>nz_water<span class="punctuation">)</span> <span class="operator">+</span> tm_lines<span class="punctuation">(</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>There is no limit to the number of layers or shapes that can be added
to <code>tmap</code> objects, and the same shape can even be used
multiple times. The final map illustrated in Figure @ref(fig:tmlayers)
is created by adding a layer representing high points (stored in the
object <code>nz_height</code>) onto the previously created
<code>map_nz2</code> object with <code>tm_symbols()</code> (see
<code>?tm_symbols</code> for details on <strong>tmap</strong>'s point
plotting functions). The resulting map, which has four layers, is
illustrated in the right-hand panel of Figure @ref(fig:tmlayers):</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map_nz3 <span class="operator">=</span> map_nz2 <span class="operator">+</span></span><br><span class="line">  tm_shape<span class="punctuation">(</span>nz_height<span class="punctuation">)</span> <span class="operator">+</span> tm_symbols<span class="punctuation">(</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>A useful and little known feature of <strong>tmap</strong> is that
multiple map objects can be arranged in a single 'metaplot' with
<code>tmap_arrange()</code>. This is demonstrated in the code chunk
below which plots <code>map_nz1</code> to <code>map_nz3</code>,
resulting in Figure @ref(fig:tmlayers).</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmap_arrange<span class="punctuation">(</span>map_nz1<span class="punctuation">,</span> map_nz2<span class="punctuation">,</span> map_nz3<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<div class="figure" style="text-align: center">
<img data-src="09-mapping_files/figure-html/tmlayers-1.png" alt="Maps with additional layers added to the final map of Figure 9.1." width="100%" />
<p class="caption">
(#fig:tmlayers)Maps with additional layers added to the final map of
Figure 9.1.
</p>
</div>
<p>More elements can also be added with the <code>+</code> operator.
Aesthetic settings, however, are controlled by arguments to layer
functions.</p>
<h3 id="可视化变量">可视化变量</h3>
<p> The plots in the previous section demonstrate
<strong>tmap</strong>'s default aesthetic settings. Gray shades are used
for <code>tm_fill()</code> and <code>tm_symbols()</code> layers and a
continuous black line is used to represent lines created with
<code>tm_lines()</code>. Of course, these default values and other
aesthetics can be overridden. The purpose of this section is to show
how.</p>
<p>There are two main types of map aesthetics: those that change with
the data and those that are constant. Unlike <strong>ggplot2</strong>,
which uses the helper function <code>aes()</code> to represent variable
aesthetics, <strong>tmap</strong> accepts a few aesthetic arguments,
depending on a selected layer type:</p>
<ul>
<li><code>fill</code>: fill color of a polygon</li>
<li><code>col</code>: color of a polygon border, line, point, or
raster</li>
<li><code>lwd</code>: line width</li>
<li><code>lty</code>: line type</li>
<li><code>size</code>: size of a symbol</li>
<li><code>shape</code>: shape of a symbol</li>
</ul>
<p>Additionally, we may customize the fill and border color transparency
using <code>fill_alpha</code> and <code>col_alpha</code>.</p>
<p>To map a variable to an aesthetic, pass its column name to the
corresponding argument, and to set a fixed aesthetic, pass the desired
value instead.<a href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a> The impact of setting these with
fixed values is illustrated in Figure @ref(fig:tmstatic).</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ma1 <span class="operator">=</span> tm_shape<span class="punctuation">(</span>nz<span class="punctuation">)</span> <span class="operator">+</span> tm_polygons<span class="punctuation">(</span>fill <span class="operator">=</span> <span class="string">&quot;red&quot;</span><span class="punctuation">)</span></span><br><span class="line">ma2 <span class="operator">=</span> tm_shape<span class="punctuation">(</span>nz<span class="punctuation">)</span> <span class="operator">+</span> tm_polygons<span class="punctuation">(</span>fill <span class="operator">=</span> <span class="string">&quot;red&quot;</span><span class="punctuation">,</span> fill_alpha <span class="operator">=</span> <span class="number">0.3</span><span class="punctuation">)</span></span><br><span class="line">ma3 <span class="operator">=</span> tm_shape<span class="punctuation">(</span>nz<span class="punctuation">)</span> <span class="operator">+</span> tm_polygons<span class="punctuation">(</span>col <span class="operator">=</span> <span class="string">&quot;blue&quot;</span><span class="punctuation">)</span></span><br><span class="line">ma4 <span class="operator">=</span> tm_shape<span class="punctuation">(</span>nz<span class="punctuation">)</span> <span class="operator">+</span> tm_polygons<span class="punctuation">(</span>lwd <span class="operator">=</span> <span class="number">3</span><span class="punctuation">)</span></span><br><span class="line">ma5 <span class="operator">=</span> tm_shape<span class="punctuation">(</span>nz<span class="punctuation">)</span> <span class="operator">+</span> tm_polygons<span class="punctuation">(</span>lty <span class="operator">=</span> <span class="number">2</span><span class="punctuation">)</span></span><br><span class="line">ma6 <span class="operator">=</span> tm_shape<span class="punctuation">(</span>nz<span class="punctuation">)</span> <span class="operator">+</span> tm_polygons<span class="punctuation">(</span>fill <span class="operator">=</span> <span class="string">&quot;red&quot;</span><span class="punctuation">,</span> fill_alpha <span class="operator">=</span> <span class="number">0.3</span><span class="punctuation">,</span></span><br><span class="line">                                 col <span class="operator">=</span> <span class="string">&quot;blue&quot;</span><span class="punctuation">,</span> lwd <span class="operator">=</span> <span class="number">3</span><span class="punctuation">,</span> lty <span class="operator">=</span> <span class="number">2</span><span class="punctuation">)</span></span><br><span class="line">tmap_arrange<span class="punctuation">(</span>ma1<span class="punctuation">,</span> ma2<span class="punctuation">,</span> ma3<span class="punctuation">,</span> ma4<span class="punctuation">,</span> ma5<span class="punctuation">,</span> ma6<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<div class="figure" style="text-align: center">
<img data-src="09-mapping_files/figure-html/tmstatic-1.png" alt="The impact of changing commonly used fill and border aesthetics to fixed values." width="100%" />
<p class="caption">
(#fig:tmstatic)The impact of changing commonly used fill and border
aesthetics to fixed values.
</p>
</div>
<p>Like base R plots, arguments defining aesthetics can also receive
values that vary. Unlike the base R code below (which generates the left
panel in Figure @ref(fig:tmcol)), <strong>tmap</strong> aesthetic
arguments will not accept a numeric vector:</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plot<span class="punctuation">(</span>st_geometry<span class="punctuation">(</span>nz<span class="punctuation">)</span><span class="punctuation">,</span> col <span class="operator">=</span> nz<span class="operator">$</span>Land_area<span class="punctuation">)</span>  <span class="comment"># works</span></span><br><span class="line">tm_shape<span class="punctuation">(</span>nz<span class="punctuation">)</span> <span class="operator">+</span> tm_fill<span class="punctuation">(</span>col <span class="operator">=</span> nz<span class="operator">$</span>Land_area<span class="punctuation">)</span> <span class="comment"># fails</span></span><br><span class="line"><span class="comment">#&gt; Error: palette should be a character value</span></span><br></pre></td></tr></table></figure>
<p>Instead <code>col</code> (and other aesthetics that can vary such as
<code>lwd</code> for line layers and <code>size</code> for point layers)
requires a character string naming an attribute associated with the
geometry to be plotted. Thus, one would achieve the desired result as
follows (plotted in the right-hand panel of Figure @ref(fig:tmcol)):</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tm_shape<span class="punctuation">(</span>nz<span class="punctuation">)</span> <span class="operator">+</span> tm_fill<span class="punctuation">(</span>fill <span class="operator">=</span> <span class="string">&quot;Land_area&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<div class="figure" style="text-align: center">
<img data-src="09-mapping_files/figure-html/tmcol-1.png" alt="Comparison of base (left) and tmap (right) handling of a numeric color field." width="45%" /><img data-src="09-mapping_files/figure-html/tmcol-2.png" alt="Comparison of base (left) and tmap (right) handling of a numeric color field." width="45%" />
<p class="caption">
(#fig:tmcol)Comparison of base (left) and tmap (right) handling of a
numeric color field.
</p>
</div>
<p>Each visual variable has three related additional arguments, with
prefixes of <code>.scale</code>, <code>.legend</code>, and
<code>.free</code>. For example, the <code>tm_fill()</code> function has
arguments such as <code>fill</code>, <code>fill.scale</code>,
<code>fill.legend</code>, and <code>fill.free</code>. The
<code>.scale</code> argument determines how the provided values are
represented on the map and in the legend (Section @ref(scales)), while
the <code>.legend</code> argument is used to customize the legend
settings, such as its title, orientation, or position (Section
@ref(legends)). The <code>.free</code> argument is relevant only for
maps with many facets to determine if each facet has the same or
different scale and legend (Section @ref(faceted-maps)).</p>
<h3 id="标度">标度</h3>
<p> Scales control how the values are represented on the map and in the
legend, and largely depend on the selected visual variable. For example,
when our visual variable is <code>col</code>, then
<code>col.scale</code> controls how the colors of spatial objects are
related to the provided values; and when our visual variable is
<code>size</code>, then <code>size.scale</code> controls how the sizes
represent the provided values. By default, the used scale is
<code>tm_scale()</code>, which selects the visual settings automatically
given by the data type (factor, numeric, and integer).</p>
<p> Let's see how the scales work by customizing polygons' fill colors.
Color settings are an important part of map design -- they can have a
major impact on how spatial variability is portrayed as illustrated in
Figure @ref(fig:tmpal). This figure shows four ways of coloring regions
in New Zealand depending on median income, from left to right (and
demonstrated in the code chunk below):</p>
<ul>
<li>The default setting uses 'pretty' breaks, described in the next
paragraph</li>
<li><code>breaks</code> allows you to manually set the breaks</li>
<li><code>n</code> sets the number of bins into which numeric variables
are categorized</li>
<li><code>values</code> defines the color scheme, for example,
<code>BuGn</code></li>
</ul>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tm_shape<span class="punctuation">(</span>nz<span class="punctuation">)</span> <span class="operator">+</span> tm_polygons<span class="punctuation">(</span>fill <span class="operator">=</span> <span class="string">&quot;Median_income&quot;</span><span class="punctuation">)</span></span><br><span class="line">tm_shape<span class="punctuation">(</span>nz<span class="punctuation">)</span> <span class="operator">+</span> tm_polygons<span class="punctuation">(</span>fill <span class="operator">=</span> <span class="string">&quot;Median_income&quot;</span><span class="punctuation">,</span></span><br><span class="line">                           fill.scale <span class="operator">=</span> tm_scale<span class="punctuation">(</span>breaks <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span> <span class="number">30000</span><span class="punctuation">,</span> <span class="number">40000</span><span class="punctuation">,</span> <span class="number">50000</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">tm_shape<span class="punctuation">(</span>nz<span class="punctuation">)</span> <span class="operator">+</span> tm_polygons<span class="punctuation">(</span>fill <span class="operator">=</span> <span class="string">&quot;Median_income&quot;</span><span class="punctuation">,</span></span><br><span class="line">                           fill.scale <span class="operator">=</span> tm_scale<span class="punctuation">(</span>n <span class="operator">=</span> <span class="number">10</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">tm_shape<span class="punctuation">(</span>nz<span class="punctuation">)</span> <span class="operator">+</span> tm_polygons<span class="punctuation">(</span>fill <span class="operator">=</span> <span class="string">&quot;Median_income&quot;</span><span class="punctuation">,</span></span><br><span class="line">                           fill.scale <span class="operator">=</span> tm_scale<span class="punctuation">(</span>values <span class="operator">=</span> <span class="string">&quot;BuGn&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<div class="figure" style="text-align: center">
<img data-src="09-mapping_files/figure-html/tmpal-1.png" alt="Illustration of settings that affect color settings. The results show (from left to right): default settings, manual breaks, n breaks, and the impact of changing the palette." width="100%" />
<p class="caption">
(#fig:tmpal)Illustration of settings that affect color settings. The
results show (from left to right): default settings, manual breaks, n
breaks, and the impact of changing the palette.
</p>
</div>

<div class="rmdnote">
All of the above arguments (<code>breaks</code>, <code>n</code>, and
<code>values</code>) also work for other types of visual variables. For
example, <code>values</code> expects a vector of colors or a palette
name for <code>fill.scale</code> or <code>col.scale</code>, a vector of
sizes for <code>size.scale</code>, or a vector of symbols for
<code>shape.scale</code>.
</div>
<p> We are also able to customize scales using a family of functions
that start with the <code>tm_scale_</code> prefix. The most important
ones are <code>tm_scale_intervals()</code>,
<code>tm_scale_continuous()</code>, and
<code>tm_scale_categorical()</code>.</p>
<p> The <code>tm_scale_intervals()</code> function splits the input data
values into a set of intervals. In addition to manually setting
<code>breaks,</code> <strong>tmap</strong> allows users to specify
algorithms to create breaks with the <code>style</code> argument
automatically. Here are some of the most useful scale functions (Figure
@ref(fig:break-styles)):</p>
<ul>
<li><code>style = "pretty"</code>: the default setting, rounds breaks
into whole numbers where possible and spaces them evenly</li>
<li><code>style = "equal"</code>: divides input values into bins of
equal range and is appropriate for variables with a uniform distribution
(not recommended for variables with a skewed distribution as the
resulting map may end-up having little color diversity)</li>
<li><code>style = "quantile"</code>: ensures the same number of
observations fall into each category (with the potential downside that
bin ranges can vary widely)</li>
<li><code>style = "jenks"</code>: identifies groups of similar values in
the data and maximizes the differences between categories</li>
<li><code>style = "log10_pretty"</code>: a common logarithmic (the
logarithm to base 10) version of the regular pretty style used for
variables with a right-skewed distribution</li>
</ul>

<div class="rmdnote">
Although <code>style</code> is an argument of <strong>tmap</strong>
functions, in fact it originates as an argument in
<code>classInt::classIntervals()</code> --- see the help page of this
function for details.
</div>
<div class="figure" style="text-align: center">
<img data-src="09-mapping_files/figure-html/break-styles-1.png" alt="Illustration of different interval scales' methods set using the style argument in tmap." width="100%" />
<p class="caption">
(#fig:break-styles)Illustration of different interval scales' methods
set using the style argument in tmap.
</p>
</div>
<p> The <code>tm_scale_continuous()</code> function present a large
number of colors over continuous color fields and are particularly
suited for continuous rasters. In case of variables with skewed
distribution you can also use its variants --
<code>tm_scale_continuous_log()</code> and
<code>tm_scale_continuous_log1p()</code>. Finally,
<code>tm_scale_categorical()</code> was designed to represent
categorical values and assures that each category receives a unique
color (Figure @ref(fig:concat)).</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#&gt; Warning in strwidth(comp$text, units = &quot;inch&quot;, family = comp$fontfamily, : no</span><br><span class="line">#&gt; font could be found for family &quot;monospace&quot;</span><br><span class="line"></span><br><span class="line">#&gt; Warning in strwidth(comp$text, units = &quot;inch&quot;, family = comp$fontfamily, : no</span><br><span class="line">#&gt; font could be found for family &quot;monospace&quot;</span><br><span class="line">#&gt; Warning in strwidth(comp$text, units = &quot;inch&quot;, family = comp$fontfamily, : font</span><br><span class="line">#&gt; family &#x27;monospace&#x27; not found, will use &#x27;sans&#x27; instead</span><br><span class="line"></span><br><span class="line">#&gt; Warning in strwidth(comp$text, units = &quot;inch&quot;, family = comp$fontfamily, : font</span><br><span class="line">#&gt; family &#x27;monospace&#x27; not found, will use &#x27;sans&#x27; instead</span><br></pre></td></tr></table></figure>
<div class="figure" style="text-align: center">
<img data-src="09-mapping_files/figure-html/concat-1.png" alt="Illustration of continuous and categorical scales in tmap." width="100%" />
<p class="caption">
(#fig:concat)Illustration of continuous and categorical scales in tmap.
</p>
</div>
<p> Palettes define the color ranges associated with the bins and
determined by the <code>tm_scale_*()</code> functions, and its
<code>breaks</code> and <code>n</code> arguments described above. The
default color palette is specified in <code>tm_layout()</code> (see
Section @ref(layouts) to learn more); however, it could be quickly
changed using the <code>values</code> argument. It expects a vector of
colors or a new color palette name, which can be find interactively with
<code>cols4all::c4a_gui()</code>. You can also add a <code>-</code> as
the color palette name prefix to reverse the palette order.</p>

<div class="rmdnote">
All of the default <code>values</code> of the visual variables, such as
default color palettes for different types of input variables, can be
found with <code>tmap_options()$values.var</code>.
</div>
<p>There are three main groups of color palettes: categorical,
sequential and diverging (Figure @ref(fig:colpal)), and each of them
serves a different purpose.<a href="#fn2" class="footnote-ref"
id="fnref2" role="doc-noteref"><sup>2</sup></a> Categorical palettes
consist of easily distinguishable colors and are most appropriate for
categorical data without any particular order such as state names or
land cover classes. Colors should be intuitive: rivers should be blue,
for example, and pastures green. Avoid too many categories: maps with
large legends and many colors can be uninterpretable. <!--^[
toDo:jn
tmap4??
`fill = "MAP_COLORS"` can be used in maps with a large number of individual polygons (for example, a map of individual countries) to create unique fill colors for adjacent polygons.]
--></p>
<p>The second group is sequential palettes. These follow a gradient, for
example from light to dark colors (light colors often tend to represent
lower values), and are appropriate for continuous (numeric) variables.
Sequential palettes can be single (<code>greens</code> goes from light
to dark blue, for example) or multi-color/hue (<code>yl_gn_bu</code> is
gradient from light yellow to blue via green, for example), as
demonstrated in the code chunk below --- output not shown, run the code
yourself to see the results!</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tm_shape<span class="punctuation">(</span>nz<span class="punctuation">)</span> <span class="operator">+</span> tm_polygons<span class="punctuation">(</span><span class="string">&quot;Median_income&quot;</span><span class="punctuation">,</span> fill.scale <span class="operator">=</span> tm_scale<span class="punctuation">(</span>values <span class="operator">=</span> <span class="string">&quot;greens&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">tm_shape<span class="punctuation">(</span>nz<span class="punctuation">)</span> <span class="operator">+</span> tm_polygons<span class="punctuation">(</span><span class="string">&quot;Median_income&quot;</span><span class="punctuation">,</span> fill.scale <span class="operator">=</span> tm_scale<span class="punctuation">(</span>values <span class="operator">=</span> <span class="string">&quot;yl_gn_bu&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>The third group, diverging palettes, typically range between three
distinct colors (purple-white-green in Figure @ref(fig:colpal)) and are
usually created by joining two single-color sequential palettes with the
darker colors at each end. Their main purpose is to visualize the
difference from an important reference point, e.g., a certain
temperature, the median household income or the mean probability for a
drought event. The reference point's value can be adjusted in
<strong>tmap</strong> using the <code>midpoint</code> argument.</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tm_shape<span class="punctuation">(</span>nz<span class="punctuation">)</span> <span class="operator">+</span> </span><br><span class="line">  tm_polygons<span class="punctuation">(</span><span class="string">&quot;Median_income&quot;</span><span class="punctuation">,</span></span><br><span class="line">              fill.scale <span class="operator">=</span> tm_scale_continuous<span class="punctuation">(</span>values <span class="operator">=</span> <span class="string">&quot;pu_gn_div&quot;</span><span class="punctuation">,</span> midpoint <span class="operator">=</span> <span class="number">28000</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<div class="figure" style="text-align: center">
<img data-src="09-mapping_files/figure-html/colpal-1.png" alt="Examples of categorical, sequential and diverging palettes." width="75%" />
<p class="caption">
(#fig:colpal)Examples of categorical, sequential and diverging palettes.
</p>
</div>
<p>There are two important principles for consideration when working
with colors: perceptibility and accessibility. Firstly, colors on maps
should match our perception. This means that certain colors are viewed
through our experience and also cultural lenses. For example, green
colors usually represent vegetation or lowlands and blue is connected
with water or cool. Color palettes should also be easy to understand to
effectively convey information. It should be clear which values are
lower and which are higher, and colors should change gradually.
<!--toDo:jn--> <!-- update and improve -->
<!-- This property is not preserved in the rainbow color palette; therefore, we suggest avoiding it in geographic data visualization [@borland_rainbow_2007]. -->
<!-- Instead, [the viridis color palettes](https://cran.r-project.org/web/packages/viridis/), also available in **tmap**, can be used. -->
Secondly, changes in colors should be accessible to the largest number
of people. Therefore, it is important to use colorblind friendly
palettes as often as possible.<a href="#fn3" class="footnote-ref"
id="fnref3" role="doc-noteref"><sup>3</sup></a></p>
<h3 id="图例">图例</h3>
<p> After we decided on our visual variable and its properties, we
should move our attention toward the related map legend style. Using the
<code>tm_legend()</code> function, we may change its title, position,
orientation, or even disable it. The most important argument in this
function is <code>title</code>, which sets the title of the associated
legend. In general, a map legend title should provide two pieces of
information: what the legend represents and what are the units of the
presented variable. The following code chunk demonstrates this
functionality by providing a more attractive name than the variable name
<code>Land_area</code> (note the use of <code>expression()</code> to
create superscript text):</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">legend_title <span class="operator">=</span> <span class="built_in">expression</span><span class="punctuation">(</span><span class="string">&quot;Area (km&quot;</span><span class="operator">^</span><span class="number">2</span><span class="operator">*</span><span class="string">&quot;)&quot;</span><span class="punctuation">)</span></span><br><span class="line">map_nza <span class="operator">=</span> tm_shape<span class="punctuation">(</span>nz<span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  tm_polygons<span class="punctuation">(</span>fill <span class="operator">=</span> <span class="string">&quot;Land_area&quot;</span><span class="punctuation">,</span> fill.legend <span class="operator">=</span> tm_legend<span class="punctuation">(</span>title <span class="operator">=</span> legend_title<span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>The default legend orientation in <strong>tmap</strong> is
<code>"portrait"</code>, however, an alternative legend orientation,
<code>"landscape"</code>, is also possible. Other than that, we can also
customize the location of the legend using the <code>position</code>
argument.</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map_nza2 <span class="operator">=</span> tm_shape<span class="punctuation">(</span>nz<span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  tm_polygons<span class="punctuation">(</span>fill <span class="operator">=</span> <span class="string">&quot;Land_area&quot;</span><span class="punctuation">,</span> fill.legend <span class="operator">=</span> tm_legend<span class="punctuation">(</span>title <span class="operator">=</span> legend_title<span class="punctuation">,</span></span><br><span class="line">                                                          orientation <span class="operator">=</span> <span class="string">&quot;landscape&quot;</span><span class="punctuation">,</span></span><br><span class="line">                                                          position <span class="operator">=</span> tm_pos_out<span class="punctuation">(</span><span class="string">&quot;center&quot;</span><span class="punctuation">,</span> <span class="string">&quot;bottom&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>The legend position (and also the position of several other map
elements in <strong>tmap</strong>) can be customized using one of a few
functions. The two most important are:</p>
<ul>
<li><code>tm_pos_out()</code>: the default, adds the legend outside of
the map frame area. We can customize its location with two values that
represent the horizontal position (<code>"left"</code>,
<code>"center"</code>, or <code>"right"</code>), and the vertical
position (<code>"bottom"</code>, <code>"center"</code>, or
<code>"top"</code>)</li>
<li><code>tm_pos_in()</code>: puts the legend inside of the map frame
area. We may decided on its position using two arguments, where the
first one can be <code>"left"</code>, <code>"center"</code>, or
<code>"right"</code>, and the second one can be <code>"bottom"</code>,
<code>"center"</code>, or <code>"top"</code>.</li>
</ul>
<p>Alternatively, we may just provide a vector of two values (or two
numbers between 0 and 1) here -- and in such case, the legend will be
put inside the map frame.</p>
<h3 id="布局">布局</h3>
<p> The map layout refers to the combination of all map elements into a
cohesive map. Map elements include among others the objects to be
mapped, the title, the scale bar, the map grid, and margins, while the
color settings covered in the previous section relate to the palette and
break-points used to affect how the map looks. Both may result in subtle
changes that can have an equally large impact on the impression left by
your maps.</p>
<p>Additional map elements such as graticules , north arrows, scale bars
and map titles have their own functions: <code>tm_graticules()</code>,
<code>tm_compass()</code>, <code>tm_scalebar()</code>, and
<code>tm_title()</code> (Figure @ref(fig:na-sb)).<a href="#fn4"
class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a></p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map_nz <span class="operator">+</span> </span><br><span class="line">  tm_graticules<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  tm_compass<span class="punctuation">(</span>type <span class="operator">=</span> <span class="string">&quot;8star&quot;</span><span class="punctuation">,</span> position <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;left&quot;</span><span class="punctuation">,</span> <span class="string">&quot;top&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  tm_scalebar<span class="punctuation">(</span>breaks <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span> <span class="number">100</span><span class="punctuation">,</span> <span class="number">200</span><span class="punctuation">)</span><span class="punctuation">,</span> text.size <span class="operator">=</span> <span class="number">1</span><span class="punctuation">,</span> position <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;left&quot;</span><span class="punctuation">,</span> <span class="string">&quot;top&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  tm_title<span class="punctuation">(</span><span class="string">&quot;New Zealand&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<div class="figure" style="text-align: center">
<img data-src="09-mapping_files/figure-html/na-sb-1.png" alt="Map with additional elements - a north arrow and scale bar." width="65%" />
<p class="caption">
(#fig:na-sb)Map with additional elements - a north arrow and scale bar.
</p>
</div>
<p><strong>tmap</strong> also allows a wide variety of layout settings
to be changed, some of which, produced using the following code (see
<code>args(tm_layout)</code> or <code>?tm_layout</code> for a full
list), are illustrated in Figure @ref(fig:layout1):</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map_nz <span class="operator">+</span> tm_layout<span class="punctuation">(</span>scale <span class="operator">=</span> <span class="number">4</span><span class="punctuation">)</span></span><br><span class="line">map_nz <span class="operator">+</span> tm_layout<span class="punctuation">(</span>bg.color <span class="operator">=</span> <span class="string">&quot;lightblue&quot;</span><span class="punctuation">)</span></span><br><span class="line">map_nz <span class="operator">+</span> tm_layout<span class="punctuation">(</span>frame <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<div class="figure" style="text-align: center">
<img data-src="09-mapping_files/figure-html/layout1-1.png" alt="Layout options specified by (from left to right) title, scale, bg.color and frame arguments." width="100%" />
<p class="caption">
(#fig:layout1)Layout options specified by (from left to right) title,
scale, bg.color and frame arguments.
</p>
</div>
<p>The other arguments in <code>tm_layout()</code> provide control over
many more aspects of the map in relation to the canvas on which it is
placed. Here are some useful layout settings (some of which are
illustrated in Figure @ref(fig:layout2)):</p>
<ul>
<li>Margin settings including <code>outer.margin</code> and
<code>inner.margin</code></li>
<li>Font settings controlled by <code>fontface</code> and
<code>fontfamily</code></li>
<li>Legend settings including options such as <code>legend.show</code>
(whether or not to show the legend) <code>legend.orientation</code>,
<code>legend.position</code>, and <code>legend.frame</code></li>
<li>Frame width (<code>frame.lwd</code>) and an option to allow double
lines (<code>frame.double.line</code>)</li>
<li>Color settings controlling <code>color.sepia.intensity</code> (how
<em>yellowy</em> the map looks) and <code>color.saturation</code> (a
color-grayscale)</li>
</ul>
<div class="figure" style="text-align: center">
<img data-src="09-mapping_files/figure-html/layout2-1.png" alt="Illustration of selected layout options." width="100%" />
<p class="caption">
(#fig:layout2)Illustration of selected layout options.
</p>
</div>
<h3 id="地图分面">地图分面</h3>
<p> Faceted maps, also referred to as 'small multiples', are composed of
many maps arranged side-by-side, and sometimes stacked vertically <span
class="citation"
data-cites="meulemans_small_2017">[@meulemans_small_2017]</span>. Facets
enable the visualization of how spatial relationships change with
respect to another variable, such as time. The changing populations of
settlements, for example, can be represented in a faceted map with each
panel representing the population at a particular moment in time. The
time dimension could be represented via another <em>visual variable</em>
such as color. However, this risks cluttering the map because it will
involve multiple overlapping points (cities do not tend to move over
time!).</p>
<p>Typically all individual facets in a faceted map contain the same
geometry data repeated multiple times, once for each column in the
attribute data (this is the default plotting method for <code>sf</code>
objects, see Chapter @ref(spatial-class)). However, facets can also
represent shifting geometries such as the evolution of a point pattern
over time. This use case of faceted plot is illustrated in Figure
@ref(fig:urban-facet).</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">urb_1970_2030 <span class="operator">=</span> urban_agglomerations <span class="operator">|&gt;</span> </span><br><span class="line">  filter<span class="punctuation">(</span>year <span class="operator">%in%</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">1970</span><span class="punctuation">,</span> <span class="number">1990</span><span class="punctuation">,</span> <span class="number">2010</span><span class="punctuation">,</span> <span class="number">2030</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">tm_shape<span class="punctuation">(</span>world<span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  tm_polygons<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  tm_shape<span class="punctuation">(</span>urb_1970_2030<span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  tm_symbols<span class="punctuation">(</span>fill <span class="operator">=</span> <span class="string">&quot;black&quot;</span><span class="punctuation">,</span> col <span class="operator">=</span> <span class="string">&quot;white&quot;</span><span class="punctuation">,</span> size <span class="operator">=</span> <span class="string">&quot;population_millions&quot;</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  tm_facets_wrap<span class="punctuation">(</span>by <span class="operator">=</span> <span class="string">&quot;year&quot;</span><span class="punctuation">,</span> nrow <span class="operator">=</span> <span class="number">2</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<div class="figure" style="text-align: center">
<img data-src="09-mapping_files/figure-html/urban-facet-1.png" alt="Faceted map showing the top 30 largest urban agglomerations from 1970 to 2030 based on population projections by the United Nations." width="100%" />
<p class="caption">
(#fig:urban-facet)Faceted map showing the top 30 largest urban
agglomerations from 1970 to 2030 based on population projections by the
United Nations.
</p>
</div>
<p>The preceding code chunk demonstrates key features of faceted maps
created using the <code>tm_facets_wrap()</code> function:</p>
<ul>
<li>Shapes that do not have a facet variable are repeated (the countries
in <code>world</code> in this case)</li>
<li>The <code>by</code> argument which varies depending on a variable
(<code>"year"</code> in this case)</li>
<li>The <code>nrow</code>/<code>ncol</code> setting specifying the
number of rows and columns that facets should be arranged into</li>
</ul>
<p>Alternatively, it is possible to use the
<code>tm_facets_grid()</code> function that allows to have facets based
on up to three different variables: one for <code>rows</code>, one for
<code>columns</code>, and possibly one for <code>pages</code>.</p>
<p>In addition to their utility for showing changing spatial
relationships, faceted maps are also useful as the foundation for
animated maps (see Section @ref(animated-maps)).</p>
<h3 id="插图地图">插图地图</h3>
<p> An inset map is a smaller map rendered within or next to the main
map. It could serve many different purposes, including providing a
context (Figure @ref(fig:insetmap1)) or bringing some non-contiguous
regions closer to ease their comparison (Figure @ref(fig:insetmap2)).
They could be also used to focus on a smaller area in more detail or to
cover the same area as the map, but representing a different topic.</p>
<p>In the example below, we create a map of the central part of New
Zealand's Southern Alps. Our inset map will show where the main map is
in relation to the whole New Zealand. The first step is to define the
area of interest, which can be done by creating a new spatial object,
<code>nz_region</code>.</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nz_region <span class="operator">=</span> st_bbox<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span>xmin <span class="operator">=</span> <span class="number">1340000</span><span class="punctuation">,</span> xmax <span class="operator">=</span> <span class="number">1450000</span><span class="punctuation">,</span></span><br><span class="line">                      ymin <span class="operator">=</span> <span class="number">5130000</span><span class="punctuation">,</span> ymax <span class="operator">=</span> <span class="number">5210000</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">                    crs <span class="operator">=</span> st_crs<span class="punctuation">(</span>nz_height<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">|&gt;</span> </span><br><span class="line">  st_as_sfc<span class="punctuation">(</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>In the second step, we create a base map showing the New Zealand's
Southern Alps area. This is a place where the most important message is
stated.</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nz_height_map <span class="operator">=</span> tm_shape<span class="punctuation">(</span>nz_elev<span class="punctuation">,</span> bbox <span class="operator">=</span> nz_region<span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  tm_raster<span class="punctuation">(</span>col.scale <span class="operator">=</span> tm_scale_continuous<span class="punctuation">(</span>values <span class="operator">=</span> <span class="string">&quot;YlGn&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">            col.legend <span class="operator">=</span> tm_legend<span class="punctuation">(</span>position <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;left&quot;</span><span class="punctuation">,</span> <span class="string">&quot;top&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  tm_shape<span class="punctuation">(</span>nz_height<span class="punctuation">)</span> <span class="operator">+</span> tm_symbols<span class="punctuation">(</span>shape <span class="operator">=</span> <span class="number">2</span><span class="punctuation">,</span> col <span class="operator">=</span> <span class="string">&quot;red&quot;</span><span class="punctuation">,</span> size <span class="operator">=</span> <span class="number">1</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  tm_scalebar<span class="punctuation">(</span>position <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;left&quot;</span><span class="punctuation">,</span> <span class="string">&quot;bottom&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>The third step consists of the inset map creation. It gives a context
and helps to locate the area of interest. Importantly, this map needs to
clearly indicate the location of the main map, for example by stating
its borders.</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nz_map <span class="operator">=</span> tm_shape<span class="punctuation">(</span>nz<span class="punctuation">)</span> <span class="operator">+</span> tm_polygons<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  tm_shape<span class="punctuation">(</span>nz_height<span class="punctuation">)</span> <span class="operator">+</span> tm_symbols<span class="punctuation">(</span>shape <span class="operator">=</span> <span class="number">2</span><span class="punctuation">,</span> col <span class="operator">=</span> <span class="string">&quot;red&quot;</span><span class="punctuation">,</span> size <span class="operator">=</span> <span class="number">0.1</span><span class="punctuation">)</span> <span class="operator">+</span> </span><br><span class="line">  tm_shape<span class="punctuation">(</span>nz_region<span class="punctuation">)</span> <span class="operator">+</span> tm_borders<span class="punctuation">(</span>lwd <span class="operator">=</span> <span class="number">3</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  tm_layout<span class="punctuation">(</span>bg.color <span class="operator">=</span> <span class="string">&quot;lightblue&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>One of the main differences between regular charts (e.g.,
scatterplots) and maps is that the input data determine the aspect ratio
of maps. Thus, in this case, we need to calculate the aspect ratios of
our two main datasets, <code>nz_region</code> and <code>nz</code>. The
following function, <code>norm_dim()</code> returns the normalized width
(<code>"w"</code>) and height (<code>"h"</code>) of the object (as
<code>"snpc"</code> units understood my the graphic device).</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">library<span class="punctuation">(</span>grid<span class="punctuation">)</span></span><br><span class="line">norm_dim <span class="operator">=</span> <span class="keyword">function</span><span class="punctuation">(</span>obj<span class="punctuation">)</span><span class="punctuation">&#123;</span></span><br><span class="line">    bbox <span class="operator">=</span> st_bbox<span class="punctuation">(</span>obj<span class="punctuation">)</span></span><br><span class="line">    width <span class="operator">=</span> bbox<span class="punctuation">[[</span><span class="string">&quot;xmax&quot;</span><span class="punctuation">]</span><span class="punctuation">]</span> <span class="operator">-</span> bbox<span class="punctuation">[[</span><span class="string">&quot;xmin&quot;</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line">    height <span class="operator">=</span> bbox<span class="punctuation">[[</span><span class="string">&quot;ymax&quot;</span><span class="punctuation">]</span><span class="punctuation">]</span> <span class="operator">-</span> bbox<span class="punctuation">[[</span><span class="string">&quot;ymin&quot;</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line">    w <span class="operator">=</span> width <span class="operator">/</span> <span class="built_in">max</span><span class="punctuation">(</span>width<span class="punctuation">,</span> height<span class="punctuation">)</span></span><br><span class="line">    h <span class="operator">=</span> height <span class="operator">/</span> <span class="built_in">max</span><span class="punctuation">(</span>width<span class="punctuation">,</span> height<span class="punctuation">)</span></span><br><span class="line">    <span class="built_in">return</span><span class="punctuation">(</span>unit<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span>w<span class="punctuation">,</span> h<span class="punctuation">)</span><span class="punctuation">,</span> <span class="string">&quot;snpc&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line">main_dim <span class="operator">=</span> norm_dim<span class="punctuation">(</span>nz_region<span class="punctuation">)</span></span><br><span class="line">ins_dim <span class="operator">=</span> norm_dim<span class="punctuation">(</span>nz<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>Next, knowing the aspect ratios, we need to specify the sizes and
locations of our two maps -- the main map and the inset map -- using the
<code>viewport()</code> function. A viewport is part of a graphics
device we use to draw the graphical elements at a given moment. The
viewport of our main map is just the representation of its aspect
ratio.</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main_vp <span class="operator">=</span> viewport<span class="punctuation">(</span>width <span class="operator">=</span> main_dim<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">,</span> height <span class="operator">=</span> main_dim<span class="punctuation">[</span><span class="number">2</span><span class="punctuation">]</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>On the other hand, the viewport of the inset map needs to specify its
size and location. Here, we would make the inset map twice smaller as
the main one by multiplying the width and height by 0.5, and we will
locate it 0.5 cm from the bottom right of the main map frame.</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ins_vp <span class="operator">=</span> viewport<span class="punctuation">(</span>width <span class="operator">=</span> ins_dim<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="operator">*</span> <span class="number">0.5</span><span class="punctuation">,</span> height <span class="operator">=</span> ins_dim<span class="punctuation">[</span><span class="number">2</span><span class="punctuation">]</span> <span class="operator">*</span> <span class="number">0.5</span><span class="punctuation">,</span></span><br><span class="line">                  x <span class="operator">=</span> unit<span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span> <span class="string">&quot;npc&quot;</span><span class="punctuation">)</span> <span class="operator">-</span> unit<span class="punctuation">(</span><span class="number">0.5</span><span class="punctuation">,</span> <span class="string">&quot;cm&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> y <span class="operator">=</span> unit<span class="punctuation">(</span><span class="number">0.5</span><span class="punctuation">,</span> <span class="string">&quot;cm&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">                  just <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;right&quot;</span><span class="punctuation">,</span> <span class="string">&quot;bottom&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>Finally, we combine the two maps by creating a new, blank canvas,
printing out the main map, and then placing the inset map inside of the
main map viewport.</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">grid.newpage<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line">print<span class="punctuation">(</span>nz_height_map<span class="punctuation">,</span> vp <span class="operator">=</span> main_vp<span class="punctuation">)</span></span><br><span class="line">pushViewport<span class="punctuation">(</span>main_vp<span class="punctuation">)</span></span><br><span class="line">print<span class="punctuation">(</span>nz_map<span class="punctuation">,</span> vp <span class="operator">=</span> ins_vp<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<div class="figure" style="text-align: center">
<img data-src="09-mapping_files/figure-html/insetmap1-1.png" alt="Inset map providing a context - location of the central part of the Southern Alps in New Zealand." width="100%" />
<p class="caption">
(#fig:insetmap1)Inset map providing a context - location of the central
part of the Southern Alps in New Zealand.
</p>
</div>
<p>Inset map can be saved to file either by using a graphic device (see
Section @ref(visual-outputs)) or the <code>tmap_save()</code> function
and its arguments - <code>insets_tm</code> and
<code>insets_vp</code>.</p>
<p>Inset maps are also used to create one map of non-contiguous areas.
Probably, the most often used example is a map of the United States,
which consists of the contiguous United States, Hawaii and Alaska. It is
very important to find the best projection for each individual inset in
these types of cases (see Chapter @ref(reproj-geo-data) to learn more).
We can use US National Atlas Equal Area for the map of the contiguous
United States by putting its EPSG code in the <code>projection</code>
argument of <code>tm_shape()</code>.</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">us_states_map <span class="operator">=</span> tm_shape<span class="punctuation">(</span>us_states<span class="punctuation">,</span> projection <span class="operator">=</span> <span class="string">&quot;EPSG:2163&quot;</span><span class="punctuation">)</span> <span class="operator">+</span> tm_polygons<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">+</span> </span><br><span class="line">  tm_layout<span class="punctuation">(</span>frame <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>The rest of our objects, <code>hawaii</code> and <code>alaska</code>,
already have proper projections; therefore, we just need to create two
separate maps:</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hawaii_map <span class="operator">=</span> tm_shape<span class="punctuation">(</span>hawaii<span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  tm_polygons<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">+</span> </span><br><span class="line">  tm_title<span class="punctuation">(</span><span class="string">&quot;Hawaii&quot;</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  tm_layout<span class="punctuation">(</span>frame <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">,</span> bg.color <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">,</span> </span><br><span class="line">            title.position <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;LEFT&quot;</span><span class="punctuation">,</span> <span class="string">&quot;BOTTOM&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">alaska_map <span class="operator">=</span> tm_shape<span class="punctuation">(</span>alaska<span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  tm_polygons<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">+</span> </span><br><span class="line">  tm_title<span class="punctuation">(</span><span class="string">&quot;Alaska&quot;</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  tm_layout<span class="punctuation">(</span>frame <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">,</span> bg.color <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>The final map is created by combining and arranging these three
maps:</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">us_states_map</span><br><span class="line">print<span class="punctuation">(</span>hawaii_map<span class="punctuation">,</span> vp <span class="operator">=</span> grid<span class="operator">::</span>viewport<span class="punctuation">(</span><span class="number">0.35</span><span class="punctuation">,</span> <span class="number">0.1</span><span class="punctuation">,</span> width <span class="operator">=</span> <span class="number">0.2</span><span class="punctuation">,</span> height <span class="operator">=</span> <span class="number">0.1</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">print<span class="punctuation">(</span>alaska_map<span class="punctuation">,</span> vp <span class="operator">=</span> grid<span class="operator">::</span>viewport<span class="punctuation">(</span><span class="number">0.15</span><span class="punctuation">,</span> <span class="number">0.15</span><span class="punctuation">,</span> width <span class="operator">=</span> <span class="number">0.3</span><span class="punctuation">,</span> height <span class="operator">=</span> <span class="number">0.3</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<div class="figure" style="text-align: center">
<img data-src="09-mapping_files/figure-html/insetmap2-1.png" alt="Map of the United States." width="100%" />
<p class="caption">
(#fig:insetmap2)Map of the United States.
</p>
</div>
<p>The code presented above is compact and can be used as the basis for
other inset maps but the results, in Figure @ref(fig:insetmap2), provide
a poor representation of the locations of Hawaii and Alaska. For a more
in-depth approach, see the <a
target="_blank" rel="noopener" href="https://geocompx.github.io/geocompkg/articles/us-map.html"><code>us-map</code></a>
vignette from the <strong>geocompkg</strong>.</p>
<h2 id="动画地图">动画地图</h2>
<aside id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>If there is a clash between a fixed value and a column
name, the column name takes precedence. This can be verified by running
the next code chunk after running <code>nz$red = 1:nrow(nz)</code>.<a
href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>A fourth group of color palettes, called bivariate, also
exists. They are used when we want to represent relations between two
variables on one map.<a href="#fnref2" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>See the "Color vision" options and the "Color Blind
Friendliness" panel in <code>cols4all::c4a_gui()</code>.<a
href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>Another additional map elements include
<code>tm_grid()</code>, <code>tm_logo()</code> and
<code>tm_credits()</code>.<a href="#fnref4" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>

            
        </div>

        
        
        

        <div>
            
        </div>

        <footer class="post-footer">
            <div class="post-eof"></div>
            
        </footer>
    </article>
</div>




    


<div class="post-block">
    
    

    <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
        <link itemprop="mainEntityOfPage" href="https://ancao96.github.io/2023/08/17/2023-8-17-8-%E5%9C%B0%E7%90%86%E6%95%B0%E6%8D%AEIO/">

        <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
            <meta itemprop="image" content="/images/avatar.gif">
            <meta itemprop="name" content="SCY">
        </span>

        <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
            <meta itemprop="name" content="SCY SPACE">
            <meta itemprop="description" content="">
        </span>

        <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
            <meta itemprop="name" content="undefined | SCY SPACE">
            <meta itemprop="description" content="">
        </span>
        <header class="post-header">
            <h2 class="post-title" itemprop="name headline">
                <a href="/2023/08/17/2023-8-17-8-%E5%9C%B0%E7%90%86%E6%95%B0%E6%8D%AEIO/" class="post-title-link" itemprop="url">(8)地理数据 I/O</a>
            </h2>

            <div class="post-meta-container">
                <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-08-17 14:11:20" itemprop="dateCreated datePublished" datetime="2023-08-17T14:11:20+08:00">2023-08-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-09-03 17:31:11" itemprop="dateModified" datetime="2023-09-03T17:31:11+08:00">2023-09-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/R/" itemprop="url" rel="index"><span itemprop="name">R</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/R/Geocomputaion/" itemprop="url" rel="index"><span itemprop="name">Geocomputaion</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2023/08/17/2023-8-17-8-%E5%9C%B0%E7%90%86%E6%95%B0%E6%8D%AEIO/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2023/08/17/2023-8-17-8-%E5%9C%B0%E7%90%86%E6%95%B0%E6%8D%AEIO/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>9.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>36 分钟</span>
    </span>
</div>

            </div>
        </header>

        
        
        
        <div class="post-body" itemprop="articleBody">
            <p>本章关于读取和写入地理数据。地理数据<em>输入</em>对地理计算至关重要，没有数据就不可能有真实世界的应用。数据<em>输出</em>也非常关键,它能够让其他人使用由你的工作产生的有价值的新数据集或改进后的数据集。总而言之,输入/输出这些进程可以称为数据I/O。
            <!--noindex-->
            <div class="post-button">
                <a class="btn" href="/2023/08/17/2023-8-17-8-%E5%9C%B0%E7%90%86%E6%95%B0%E6%8D%AEIO/#more" rel="contents">
                    阅读全文 &raquo;
                </a>
            </div>
            <!--/noindex-->
            
            
        </div>

        
        
        

        <div>
            
        </div>

        <footer class="post-footer">
            <div class="post-eof"></div>
            
        </footer>
    </article>
</div>




    


<div class="post-block">
    
    

    <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
        <link itemprop="mainEntityOfPage" href="https://ancao96.github.io/2023/08/15/2023-8-15-6-%E6%A0%85%E6%A0%BC%E7%9F%A2%E9%87%8F%E4%BA%A4%E5%8F%89/">

        <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
            <meta itemprop="image" content="/images/avatar.gif">
            <meta itemprop="name" content="SCY">
        </span>

        <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
            <meta itemprop="name" content="SCY SPACE">
            <meta itemprop="description" content="">
        </span>

        <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
            <meta itemprop="name" content="undefined | SCY SPACE">
            <meta itemprop="description" content="">
        </span>
        <header class="post-header">
            <h2 class="post-title" itemprop="name headline">
                <a href="/2023/08/15/2023-8-15-6-%E6%A0%85%E6%A0%BC%E7%9F%A2%E9%87%8F%E4%BA%A4%E5%8F%89/" class="post-title-link" itemprop="url">(6)栅格矢量交叉</a>
            </h2>

            <div class="post-meta-container">
                <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-08-15 18:29:20" itemprop="dateCreated datePublished" datetime="2023-08-15T18:29:20+08:00">2023-08-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-09-03 16:54:04" itemprop="dateModified" datetime="2023-09-03T16:54:04+08:00">2023-09-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/R/" itemprop="url" rel="index"><span itemprop="name">R</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/R/Geocomputaion/" itemprop="url" rel="index"><span itemprop="name">Geocomputaion</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2023/08/15/2023-8-15-6-%E6%A0%85%E6%A0%BC%E7%9F%A2%E9%87%8F%E4%BA%A4%E5%8F%89/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2023/08/15/2023-8-15-6-%E6%A0%85%E6%A0%BC%E7%9F%A2%E9%87%8F%E4%BA%A4%E5%8F%89/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>16 分钟</span>
    </span>
</div>

            </div>
        </header>

        
        
        
        <div class="post-body" itemprop="articleBody">
            <p>本章专注于栅格和矢量地理数据模型之间的相互作用。包括四个主要技术：使用矢量对象进行栅格裁剪和遮罩；使用不同类型的矢量数据提取栅格值；以及栅格与矢量之间的转换。以上概念使用前几章中使用的数据进行演示，以了解其潜在的现实应用。
            <!--noindex-->
            <div class="post-button">
                <a class="btn" href="/2023/08/15/2023-8-15-6-%E6%A0%85%E6%A0%BC%E7%9F%A2%E9%87%8F%E4%BA%A4%E5%8F%89/#more" rel="contents">
                    阅读全文 &raquo;
                </a>
            </div>
            <!--/noindex-->
            
            
        </div>

        
        
        

        <div>
            
        </div>

        <footer class="post-footer">
            <div class="post-eof"></div>
            
        </footer>
    </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
    </main>
    <footer class="footer">
      <div class="footer-inner">

<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">160k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">9:43</span>
  </span>
</div>
<div class="busuanzi-count">
</div>

<!-- 删除 “由 Hexo & NexT.Gemini 强力驱动” -->
<!-- -->

      </div>
    </footer>
    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

    
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.20/fancybox/fancybox.umd.js" integrity="sha256-q8XkJ6dj5VwSvzI8+nATCHHQG+Xv/dAZBCgqmu93zOY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/algoliasearch/4.19.1/algoliasearch-lite.umd.js" integrity="sha256-qzlNbRtZWHoUV5I2mI2t9QR7oYXlS9oNctX+0pECXI0=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/instantsearch.js/4.56.8/instantsearch.production.min.js" integrity="sha256-xUys6KCuRGBxFaRaYZlWulRUjY48XFv6/Q2s0mb1dmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/algolia-search.js"></script>
<script class="next-config" data-name="chatra" type="application/json">{"enable":true,"async":true,"id":null}</script>
<script src="/js/third-party/chat/chatra.js"></script>
<script async src="https://call.chatra.io/chatra.js"></script>

  <script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.2.12/pdfobject.min.js","integrity":"sha256-g2xji1rlE3KsGVClvuxTbcR0Kn2+wtQADSff2Tbb4zA="},"url":"/lib/pdf/web/viewer.html"}</script>
  <script src="/js/third-party/tags/pdf.js"></script>

  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.3.0/mermaid.min.js","integrity":"sha256-9y71g5Lz/KLsHjB8uXwnkuWDtAMDSzD/HdIbqhJfTAI="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>

  <script class="next-config" data-name="wavedrom" type="application/json">{"enable":true,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/wavedrom/3.3.0/wavedrom.min.js","integrity":"sha256-IRMDzTC+wK5stMucZ/XSXkeS5VNtxZ+/Bm8Mcqfoxdo="}}</script>
  <script class="next-config" data-name="wavedrom_skin" type="application/json">{"enable":true,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/wavedrom/3.3.0/skins/default.js","integrity":"sha256-fduc/Zszk5ezWws2uInY/ALWVmIrmV6VTgXbsYSReFI="}}</script>
  <script src="/js/third-party/tags/wavedrom.js"></script>

  <script src="/js/third-party/fancybox.js"></script>


  <script src="/js/third-party/addtoany.js"></script>

    
  <script data-pjax async src="/js/busuanzi.js"></script>



  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"ams","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


  <script src="https://cdnjs.cloudflare.com/ajax/libs/quicklink/2.3.0/quicklink.umd.js" integrity="sha256-yvJQOINiH9fWemHn0vCA5lsHWJaHs6/ZmO+1Ft04SvM=" crossorigin="anonymous"></script>
  <script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":true,"archive":true,"delay":true,"timeout":3000,"priority":true,"url":"https://ancao96.github.io/"}</script>
  <script src="/js/third-party/quicklink.js"></script>
<script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"https://waline-server-nxpj3ksyo-scy.vercel.app","cssUrl":"https://unpkg.com/@waline/client@v2/dist/waline.css","commentCount":true,"pageview":false,"placeholder":"请文明评论呀~","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"visitor":true,"comment_count":true,"requiredFields":["nick","mail"],"libUrl":"//unpkg.com/@waline/client@v2/dist/waline.js","eemoji":["https://unpkg.com/@waline/emojis@1.1.0/tw-emoji","//unpkg.com/@waline/emojis@1.1.0/bilibili","//unpkg.com/@waline/emojis@1.1.0/alus","https://unpkg.com/@waline/emojis@1.1.0/weibo"],"el":"#waline","comment":true,"path":"/"}</script>
<link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css">
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script>

    <link rel="stylesheet" href="/dist/APlayer.min.css">
    <div id="aplayer"></div>
    <script type="text/javascript" src="/dist/APlayer.min.js"></script>
    <script type="text/javascript" src="/dist/music.js"></script>
    
  </body>
</html>
