<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.png" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.20/fancybox/fancybox.css" integrity="sha256-RvRHGSuWAxZpXKV9lLDt2e+rZ+btzn48Wp4ueS3NZKs=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"ancao96.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.18.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":true,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"algolia":{"appID":"BFJCK79VF9","apiKey":"613fe5e83863193288c6ef2ab02cefad","indexName":"hexo","hits":{"per_page":10}}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="SCY SPACE">
<meta property="og:url" content="https://ancao96.github.io/index.html">
<meta property="og:site_name" content="SCY SPACE">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="SCY">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://ancao96.github.io/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>SCY SPACE</title>
    







<link rel="dns-prefetch" href="https://waline-server-nxpj3ksyo-scy.vercel.app">
    <noscript>
      <link rel="stylesheet" href="/css/noscript.css">
    </noscript>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.0.0/style.css">
    <style>
      body,div.post-body,h1,h2,h3,h4 {
        font-family: "LXGW WenKai LITE", sans-serif;
        font-size: 108%;
      }
    </style>
  </head>
  <body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
    <div class="headband"></div>
    <main class="main">
      <div class="column">
        <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">SCY SPACE</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">10</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">10</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">22</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container">
  <div class="algolia-stats"><hr></div>
  <div class="algolia-hits"></div>
  <div class="algolia-pagination"></div>
</div>

    </div>
  </div>

</header>
          
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="SCY" src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">SCY</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">22</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/AnCao96" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;AnCao96" rel="external nofollow noopener noreferrer" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:ancao.cugb@gmail.com" title="E-Mail → mailto:ancao.cugb@gmail.com" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
        <div class="pjax">
        </div>
  </aside>


      </div>
      <div class="main-inner index posts-expand">

    


<div class="post-block">
    
    

    <article itemscope itemtype="http://schema.org/Article" class="post-content" lang>
        <link itemprop="mainEntityOfPage" href="https://ancao96.github.io/2023/10/15/21-hello/">

        <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
            <meta itemprop="image" content="/images/avatar.gif">
            <meta itemprop="name" content="SCY">
        </span>

        <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
            <meta itemprop="name" content="SCY SPACE">
            <meta itemprop="description" content>
        </span>

        <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
            <meta itemprop="name" content="undefined | SCY SPACE">
            <meta itemprop="description" content>
        </span>
        <header class="post-header">
            <h2 class="post-title" itemprop="name headline">
                <a href="/2023/10/15/21-hello/" class="post-title-link" itemprop="url">(01) 欢迎（空间数据科学——R语言应用）</a>
            </h2>

            <div class="post-meta-container">
                <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-10-15 13:29:20 / 修改时间：15:08:08" itemprop="dateCreated datePublished" datetime="2023-10-15T13:29:20+08:00">2023-10-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/R/" itemprop="url" rel="index"><span itemprop="name">R</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/R/Spatial-Data-Science/" itemprop="url" rel="index"><span itemprop="name">Spatial Data Science</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2023/10/15/21-hello/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2023/10/15/21-hello/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.6k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>17 分钟</span>
    </span>
</div>

            </div>
        </header>

        
        
        
        <div class="post-body" itemprop="articleBody">
            <blockquote><p>本文由SCY翻译，转载注明出处。</p>
</blockquote>
<p>本章介绍了一系列与处理空间和时空数据相关的概念，并指向后续章节，其中这些概念将会被更详细地讨论。它还介绍了一系列构成所有空间数据科学语言实现基础的开源技术。</p>
            <!--noindex-->
            <div class="post-button">
                <a class="btn" href="/2023/10/15/21-hello/#more" rel="contents">
                    阅读全文 &raquo;
                </a>
            </div>
            <!--/noindex-->
            
            
        </div>

        
        
        

        <div>
            
        </div>

        <footer class="post-footer">
            <div class="post-eof"></div>
            
        </footer>
    </article>
</div>




    


<div class="post-block">
    
    

    <article itemscope itemtype="http://schema.org/Article" class="post-content" lang>
        <link itemprop="mainEntityOfPage" href="https://ancao96.github.io/2023/10/05/2023-10-5-20%E4%B8%80%E5%85%83%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/">

        <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
            <meta itemprop="image" content="/images/avatar.gif">
            <meta itemprop="name" content="SCY">
        </span>

        <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
            <meta itemprop="name" content="SCY SPACE">
            <meta itemprop="description" content>
        </span>

        <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
            <meta itemprop="name" content="undefined | SCY SPACE">
            <meta itemprop="description" content>
        </span>
        <header class="post-header">
            <h2 class="post-title" itemprop="name headline">
                <a href="/2023/10/05/2023-10-5-20%E4%B8%80%E5%85%83%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/" class="post-title-link" itemprop="url">(20)一元线性回归及显著性检验（Slope趋势分析）</a>
            </h2>

            <div class="post-meta-container">
                <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-10-05 14:37:20 / 修改时间：17:54:25" itemprop="dateCreated datePublished" datetime="2023-10-05T14:37:20+08:00">2023-10-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/R/" itemprop="url" rel="index"><span itemprop="name">R</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/R/Statistic/" itemprop="url" rel="index"><span itemprop="name">Statistic</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/R/Statistic/Regression/" itemprop="url" rel="index"><span itemprop="name">Regression</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2023/10/05/2023-10-5-20%E4%B8%80%E5%85%83%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2023/10/05/2023-10-5-20%E4%B8%80%E5%85%83%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>8 分钟</span>
    </span>
</div>

            </div>
        </header>

        
        
        
        <div class="post-body" itemprop="articleBody">
            <blockquote><p>本文由SCY原创，转载注明出处。</p>
</blockquote>
<h1 id="时间序列趋势分析">时间序列趋势分析</h1>
<p>时序趋势分析是一种重要的统计技术，用于分析随时间变化的数据模式。以下是一些常用的时序趋势分析方法：</p>
<ul>
<li><p><strong>线性和非线性趋势分析</strong>：</p>
<p>通过线性回归或非线性回归模型，可以估计时间序列数据的趋势。例如，<em>一元线性回归</em>可以用来估计线性趋势，而多项式回归或指数回归可以用来估计非线性趋势。</p></li>
<li><p><strong>季节分解（Seasonal Decomposition）</strong>：</p>
<p>季节分解可以分离出时序数据中的趋势、季节性和随机组成部分。例如，可以使用STL（Seasonal
and Trend decomposition using Loess）或季节分解的经典方法。</p></li>
<li><p><strong>时间序列平滑（Time Series Smoothing）</strong>：</p>
<p>时间序列平滑方法，如移动平均和指数平滑，可以用来估计时间序列数据的趋势。</p></li>
<li><p><strong>自相关和偏自相关分析（Autocorrelation and Partial
Autocorrelation Analysis）</strong>：</p>
<p>通过计算时间序列数据的自相关和偏自相关函数，可以识别数据中的循环模式和趋势。</p></li>
<li><p><strong>时间序列分解（Time Series Decomposition）</strong>：</p>
<p>将时间序列分解为趋势、周期和随机噪声组件，通常使用模型如X-12-ARIMA或其变体。</p></li>
<li><p><strong>时间序列模型（Time Series Modeling）</strong>：</p>
<p>ARIMA（自回归整合移动平均模型）、ETS（错误、趋势、季节性模型）和状态空间模型等可以用于分析时间序列的趋势和周期性。</p></li>
<li><p><strong>波段分析（Wavelet Analysis）</strong>：</p>
<p>波段分析可以在不同的时间尺度上识别时序数据的趋势和周期性。</p></li>
<li><p><strong>Mann-Kendall趋势检验和Sen的斜率估计</strong>：</p>
<p>这些非参数方法用于检测时间序列数据的趋势并估计变化的速度。</p></li>
<li><p><strong>突变点分析（Changepoint Analysis）</strong>：</p>
<p>用于识别时间序列数据中的结构变化，例如趋势的改变或方差的改变。</p></li>
<li><p><strong>谱分析（Spectral Analysis）</strong>：</p>
<p>通过分析时序数据的频率域特性来识别周期性和趋势。</p></li>
</ul>
<h1 id="一元线性回归和mann-kendall检验">一元线性回归和Mann-Kendall检验</h1>
<p>本文重点介绍<strong>一元线性回归</strong>和<strong>Mann-Kendall检验</strong>的原理和R语言实现步骤，以1980——2020年的降雨数据为例。</p>
<p>一元线性回归和Mann-Kendall检验是分析时间序列趋势的两种不同方法，它们各自有其特点和适用场景。下面是对它们的比较和联系的说明：</p>
<ol type="1">
<li><strong>基本原理</strong>：</li>
</ol>
<p><strong>一元线性回归</strong>是基于参数的统计方法，它假设数据之间存在线性关系，并试图找到描述这种关系的线性方程。它提供了估计的斜率和截距，以及相关的统计测试，以评估这种关系的显著性和强度。</p>
<p><strong>Mann-Kendall检验</strong>是一种非参数的统计方法，用于检测时间序列数据中的单调趋势，而不假设数据之间的特定关系。它基于数据的秩次，而不是数据的实际值。</p>
<ol start="2" type="1">
<li><strong>假设</strong>：</li>
</ol>
<p><strong>一元线性回归</strong>通常需要满足一些基本假设，例如误差的<em>正态性</em>和<em>独立性</em>，以及数据的<em>线性关系</em>。当数据不满足这些假设时，线性回归的结果可能会受到影响。</p>
<p><strong>Mann-Kendall检验</strong>作为非参数检验，不需要数据满足<em>正态分布</em>或其他分布假设，因此它对<em>异常值</em>和<em>非正态</em>数据更具<strong>鲁棒性</strong>。</p>
<ol start="3" type="1">
<li><strong>输出</strong>：</li>
</ol>
<p><strong>一元线性回归</strong>提供了详细的模型参数（例如斜率和截距）和预测值，同时也提供了模型的显著性检验结果。</p>
<p><strong>Mann-Kendall检验</strong>主要提供了趋势的显著性检验结果，但不提供具体的模型参数或预测值。</p>
<ol start="4" type="1">
<li><strong>适用场景</strong>：</li>
</ol>
<p>当数据具有明确的线性关系，并且满足线性回归的基本假设时，<strong>一元线性回归</strong>是一个很好的选择。</p>
<p>当数据可能有单调趋势，但不一定是线性的，或者当数据可能包含异常值或不满足正态分布假设时，<strong>Mann-Kendall检验</strong>可能是一个更好的选择。</p>
<ol start="5" type="1">
<li><strong>联系</strong>：</li>
</ol>
<p>两者都可以用于分析时间序列数据中的趋势，但方法和假设有很大的不同。</p>
<p>在某些情况下，它们可以互补使用。例如，可以首先使用<strong>Mann-Kendall检验</strong>来确定是否存在显著的趋势，然后使用一元线性回归来估计趋势的具体参数。</p>
<ol start="6" type="1">
<li><strong>扩展</strong>：</li>
</ol>
<p><strong>Mann-Kendall检验</strong>可以与<strong>Sen的斜率估计</strong>结合使用，以提供趋势的斜率估计，这在一定程度上类似于一元线性回归提供的斜率估计。</p>
<h1 id="一元线性回归">一元线性回归</h1>
<p>一元线性回归用于研究一个变量（自变量）如何线性影响另一个变量（因变量）。以下是一元线性回归的基本原理和步骤：</p>
<h2 id="数学模型"><strong>数学模型</strong>：</h2>
<p>一元线性回归假设两个变量之间存在线性关系，可以用下面的方程式表示：
<span class="math display">\[ Y = \beta_0 + \beta_1X + \varepsilon
\]</span></p>
<p>其中： - ( Y ) 是因变量的值， - ( X ) 是自变量的值， - ( <span class="math inline">\(\beta_0\)</span> ) 是截距项， - ( <span class="math inline">\(\beta_1\)</span> ) 是斜率项， - ( <span class="math inline">\(\varepsilon\)</span> ) 是误差项。</p>
<h2 id="参数估计"><strong>参数估计</strong>：</h2>
<p>一元线性回归的目标是找到最佳的 ( <span class="math inline">\(\beta_0\)</span> ) 和 ( <span class="math inline">\(\beta_1\)</span>
)，使得模型的预测值与实际值的差异（误差平方和，<span class="math inline">\(SSE\)</span>）最小。这通常通过最小二乘法（OLS）实现，它的基本思想是最小化所有观测值的残差平方和，即：
<span class="math display">\[SSE = \sum_{i=1}^n (Y_i - (\beta_0 +
\beta_1X_i))^2 \]</span></p>
<p>通过对 <span class="math inline">\(SSE\)</span> 关于 <span class="math inline">\(\beta_0\)</span> 和 <span class="math inline">\(\beta_1\)</span> 的偏导数并令其为零，可以解得
<span class="math inline">\(\beta_0\)</span> 和 <span class="math inline">\(\beta_1\)</span> 的估计值。</p>
<h2 id="显著性检验"><strong>显著性检验</strong>：</h2>
<p>一旦得到了 <span class="math inline">\(\beta_0\)</span> 和 <span class="math inline">\(\beta_1\)</span>
的估计值，通常会进行假设检验来评估这些参数是否显著不为零。这涉及到计算<span class="math inline">\(t\)</span>统计量和对应的<span class="math inline">\(p\)</span>值。如果<span class="math inline">\(p\)</span>值低于某个预定的显著性水平（通常为0.05），则认为参数是显著的。</p>
<h2 id="模型评估"><strong>模型评估</strong>：</h2>
<p>模型评估通常包括计算 <span class="math inline">\(R^2\)</span>
（决定系数）和调整 <span class="math inline">\(R^2\)</span>，以评估模型对数据的拟合程度。<span class="math inline">\(R^2\)</span> 表示模型解释的数据变异的比例。</p>
<h2 id="预测"><strong>预测</strong>：</h2>
<p>使用得到的 <span class="math inline">\(\beta_0\)</span> 和 <span class="math inline">\(\beta_1\)</span> 估计值，可以对新的 <span class="math inline">\(X\)</span>
值做预测，并计算预测区间，以估计预测的不确定性。</p>
<h2 id="模型诊断"><strong>模型诊断</strong>：</h2>
<p>模型诊断是检查模型是否满足回归分析的基本假设，例如误差的正态性、独立性和方差齐性。这可以通过残差图、正态概率图和其他诊断图来完成。</p>
<h2 id="案例分析">案例分析</h2>
<h1 id="mann-kendall检验和sen斜率估计">Mann-Kendall检验和Sen斜率估计</h1>
<p>Mann-Kendall（MK）检验和Sen的斜率估计是两种常用的非参数方法，用于分析时间序列数据中的趋势。下面是它们的基本原理介绍：</p>
<h2 id="mann-kendall检验">Mann-Kendall检验：</h2>
<p>Mann-Kendall检验是一种非参数检验，用于确定一个数据序列中是否存在单调的趋势。它不需要数据满足特定的分布假设，因此对于非正态分布的数据很有用。MK检验的基本步骤如下：
1. 对于序列中的每一对数据点(<span class="math inline">\(x_i\)</span>,
<span class="math inline">\(x_j\)</span>)，计算符号统计量 (<span class="math inline">\(S\)</span>)： <span class="math display">\[S =
\sum_{i=1}^{n-1} \sum_{j=i+1}^n \text{sign}(x_j - x_i)\]</span>
其中<span class="math inline">\(\text{sign}(x_j -
x_i)\)</span>是符号函数，如果 <span class="math inline">\(x_j\)</span>
&gt; <span class="math inline">\(x_i\)</span> 则值为 +1，如果 <span class="math inline">\(x_j\)</span> &lt; <span class="math inline">\(x_i\)</span> 则值为 -1，如果 <span class="math inline">\(x_j\)</span> = <span class="math inline">\(x_i\)</span> 则值为 0。</p>
<ol start="2" type="1">
<li>计算检验统计量 <span class="math inline">\(U\)</span> 和对应的 <span class="math inline">\(p\)</span> 值以判断趋势是否显著。</li>
</ol>
<h2 id="sen的斜率估计">Sen的斜率估计：</h2>
<p>Sen的斜率估计是一种非参数方法，用于估计数据序列中的趋势斜率。它通过计算所有可能的数据点对之间的斜率，然后取这些斜率的<em>中位数</em>作为趋势斜率的估计。Sen的斜率估计的基本步骤如下：</p>
<ol type="1">
<li><p>对于序列中的每一对数据点<span class="math inline">\((x_i,
y_i)\)</span> 和 <span class="math inline">\((x_j,
y_j)\)</span>，计算斜率： <span class="math display">\[d_k = \frac{(y_j
- y_i)}{(x_j - x_i)}\]</span> 其中 <span class="math inline">\(1 \leq i
&lt; j \leq n\)</span>。</p></li>
<li><p>从所有计算得到的斜率 <span class="math inline">\(d_k\)</span>
中，取中位数作为Sen的斜率估计： <span class="math display">\[b_{\text{Sen}} = \text{median}(d_k)\]</span>
Sen的斜率估计可以提供一个关于时间序列数据趋势的稳健（对异常值不敏感）的估计，而Mann-Kendall检验可以提供这种趋势是否显著的证据。通常，这两种方法可以结合使用，以提供对数据趋势的全面理解。在时间序列趋势分析中，MK检验通常用于检测趋势的显著性，而Sen的斜率估计用于量化趋势的大小。</p></li>
</ol>
<h2 id="案例分析-1">案例分析</h2>

            
        </div>

        
        
        

        <div>
            
        </div>

        <footer class="post-footer">
            <div class="post-eof"></div>
            
        </footer>
    </article>
</div>




    


<div class="post-block">
    
    

    <article itemscope itemtype="http://schema.org/Article" class="post-content" lang>
        <link itemprop="mainEntityOfPage" href="https://ancao96.github.io/2023/09/26/2023-9-26-19%E5%9C%B0%E5%9B%BE%E5%8F%AF%E8%A7%86%E5%8C%96/">

        <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
            <meta itemprop="image" content="/images/avatar.gif">
            <meta itemprop="name" content="SCY">
        </span>

        <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
            <meta itemprop="name" content="SCY SPACE">
            <meta itemprop="description" content>
        </span>

        <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
            <meta itemprop="name" content="undefined | SCY SPACE">
            <meta itemprop="description" content>
        </span>
        <header class="post-header">
            <h2 class="post-title" itemprop="name headline">
                <a href="/2023/09/26/2023-9-26-19%E5%9C%B0%E5%9B%BE%E5%8F%AF%E8%A7%86%E5%8C%96/" class="post-title-link" itemprop="url">(19)地图可视化</a>
            </h2>

            <div class="post-meta-container">
                <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-09-26 19:47:20" itemprop="dateCreated datePublished" datetime="2023-09-26T19:47:20+08:00">2023-09-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-10-04 13:18:22" itemprop="dateModified" datetime="2023-10-04T13:18:22+08:00">2023-10-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/R/" itemprop="url" rel="index"><span itemprop="name">R</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/R/Visualization/" itemprop="url" rel="index"><span itemprop="name">Visualization</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2023/09/26/2023-9-26-19%E5%9C%B0%E5%9B%BE%E5%8F%AF%E8%A7%86%E5%8C%96/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2023/09/26/2023-9-26-19%E5%9C%B0%E5%9B%BE%E5%8F%AF%E8%A7%86%E5%8C%96/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

            </div>
        </header>

        
        
        
        <div class="post-body" itemprop="articleBody">
            <blockquote><p>本文由SCY原创，转载注明出处。</p>
</blockquote>
<p>本文主要讲解地图可视化
            <!--noindex-->
            <div class="post-button">
                <a class="btn" href="/2023/09/26/2023-9-26-19%E5%9C%B0%E5%9B%BE%E5%8F%AF%E8%A7%86%E5%8C%96/#more" rel="contents">
                    阅读全文 &raquo;
                </a>
            </div>
            <!--/noindex-->
            
            
        </p></div>

        
        
        

        <div>
            
        </div>

        <footer class="post-footer">
            <div class="post-eof"></div>
            
        </footer>
    </article>
</div>




    


<div class="post-block">
    
    

    <article itemscope itemtype="http://schema.org/Article" class="post-content" lang>
        <link itemprop="mainEntityOfPage" href="https://ancao96.github.io/2023/09/26/2023-9-26-18ggplot2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

        <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
            <meta itemprop="image" content="/images/avatar.gif">
            <meta itemprop="name" content="SCY">
        </span>

        <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
            <meta itemprop="name" content="SCY SPACE">
            <meta itemprop="description" content>
        </span>

        <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
            <meta itemprop="name" content="undefined | SCY SPACE">
            <meta itemprop="description" content>
        </span>
        <header class="post-header">
            <h2 class="post-title" itemprop="name headline">
                <a href="/2023/09/26/2023-9-26-18ggplot2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">(18)ggplot2学习笔记</a>
            </h2>

            <div class="post-meta-container">
                <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-09-26 18:44:20" itemprop="dateCreated datePublished" datetime="2023-09-26T18:44:20+08:00">2023-09-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-10-04 13:18:32" itemprop="dateModified" datetime="2023-10-04T13:18:32+08:00">2023-10-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/R/" itemprop="url" rel="index"><span itemprop="name">R</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/R/ggplot2/" itemprop="url" rel="index"><span itemprop="name">ggplot2</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2023/09/26/2023-9-26-18ggplot2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2023/09/26/2023-9-26-18ggplot2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>6.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>22 分钟</span>
    </span>
</div>

            </div>
        </header>

        
        
        
        <div class="post-body" itemprop="articleBody">
            <blockquote><p>本文由SCY原创，转载注明出处。</p>
</blockquote>
<p>本文主要讲解ggplot2包的绘图原理及案例。
            <!--noindex-->
            <div class="post-button">
                <a class="btn" href="/2023/09/26/2023-9-26-18ggplot2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#more" rel="contents">
                    阅读全文 &raquo;
                </a>
            </div>
            <!--/noindex-->
            
            
        </p></div>

        
        
        

        <div>
            
        </div>

        <footer class="post-footer">
            <div class="post-eof"></div>
            
        </footer>
    </article>
</div>




    


<div class="post-block">
    
    

    <article itemscope itemtype="http://schema.org/Article" class="post-content" lang>
        <link itemprop="mainEntityOfPage" href="https://ancao96.github.io/2023/09/24/2023-9-24-17%E6%A0%85%E6%A0%BC%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%8A%80%E5%B7%A7/">

        <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
            <meta itemprop="image" content="/images/avatar.gif">
            <meta itemprop="name" content="SCY">
        </span>

        <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
            <meta itemprop="name" content="SCY SPACE">
            <meta itemprop="description" content>
        </span>

        <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
            <meta itemprop="name" content="undefined | SCY SPACE">
            <meta itemprop="description" content>
        </span>
        <header class="post-header">
            <h2 class="post-title" itemprop="name headline">
                <a href="/2023/09/24/2023-9-24-17%E6%A0%85%E6%A0%BC%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">(17)栅格数据处理技巧</a>
            </h2>

            <div class="post-meta-container">
                <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-09-24 13:53:20" itemprop="dateCreated datePublished" datetime="2023-09-24T13:53:20+08:00">2023-09-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-10-04 13:11:40" itemprop="dateModified" datetime="2023-10-04T13:11:40+08:00">2023-10-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/R/" itemprop="url" rel="index"><span itemprop="name">R</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/R/Geocomputaion/" itemprop="url" rel="index"><span itemprop="name">Geocomputaion</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/R/Geocomputaion/Raster/" itemprop="url" rel="index"><span itemprop="name">Raster</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2023/09/24/2023-9-24-17%E6%A0%85%E6%A0%BC%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%8A%80%E5%B7%A7/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2023/09/24/2023-9-24-17%E6%A0%85%E6%A0%BC%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%8A%80%E5%B7%A7/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>873</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

            </div>
        </header>

        
        
        
        <div class="post-body" itemprop="articleBody">
            <blockquote><p>本文由SCY原创，转载注明出处。</p>
</blockquote>
<p>本文主要讲解<code>R</code>的<code>terra</code>包的使用技巧，包括数据导入，批量处理，绘图，导出等内容
            <!--noindex-->
            <div class="post-button">
                <a class="btn" href="/2023/09/24/2023-9-24-17%E6%A0%85%E6%A0%BC%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%8A%80%E5%B7%A7/#more" rel="contents">
                    阅读全文 &raquo;
                </a>
            </div>
            <!--/noindex-->
            
            
        </p></div>

        
        
        

        <div>
            
        </div>

        <footer class="post-footer">
            <div class="post-eof"></div>
            
        </footer>
    </article>
</div>




    


<div class="post-block">
    
    

    <article itemscope itemtype="http://schema.org/Article" class="post-content" lang>
        <link itemprop="mainEntityOfPage" href="https://ancao96.github.io/2023/08/25/2023-8-25-16%E7%BB%93%E8%AE%BA/">

        <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
            <meta itemprop="image" content="/images/avatar.gif">
            <meta itemprop="name" content="SCY">
        </span>

        <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
            <meta itemprop="name" content="SCY SPACE">
            <meta itemprop="description" content>
        </span>

        <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
            <meta itemprop="name" content="undefined | SCY SPACE">
            <meta itemprop="description" content>
        </span>
        <header class="post-header">
            <h2 class="post-title" itemprop="name headline">
                <a href="/2023/08/25/2023-8-25-16%E7%BB%93%E8%AE%BA/" class="post-title-link" itemprop="url">(16)结论</a>
            </h2>

            <div class="post-meta-container">
                <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-08-25 17:21:20" itemprop="dateCreated datePublished" datetime="2023-08-25T17:21:20+08:00">2023-08-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-10-04 13:12:51" itemprop="dateModified" datetime="2023-10-04T13:12:51+08:00">2023-10-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/R/" itemprop="url" rel="index"><span itemprop="name">R</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/R/Geocomputaion/" itemprop="url" rel="index"><span itemprop="name">Geocomputaion</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2023/08/25/2023-8-25-16%E7%BB%93%E8%AE%BA/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2023/08/25/2023-8-25-16%E7%BB%93%E8%AE%BA/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>25 分钟</span>
    </span>
</div>

            </div>
        </header>

        
        
        
        <div class="post-body" itemprop="articleBody">
            <blockquote><p>本文由SCY翻译自《Geocomputation with R》<a target="_blank" rel="external nofollow noopener noreferrer" href="https://r.geocompx.org/conclusion">第十六章</a></p>
</blockquote>
<p>综合本书的内容，引用重复出现的主题/概念，并激发未来应用和发展的方向。本章不需要先修知识。然而，如果您已经阅读并尝试了第一部分（基础）中的练习，并考虑了地理计算如何帮助您解决工作、研究或其他问题，参考了第三部分（应用）中的章节，那么您可能会从中获得更多收益。
            <!--noindex-->
            <div class="post-button">
                <a class="btn" href="/2023/08/25/2023-8-25-16%E7%BB%93%E8%AE%BA/#more" rel="contents">
                    阅读全文 &raquo;
                </a>
            </div>
            <!--/noindex-->
            
            
        </p></div>

        
        
        

        <div>
            
        </div>

        <footer class="post-footer">
            <div class="post-eof"></div>
            
        </footer>
    </article>
</div>




    


<div class="post-block">
    
    

    <article itemscope itemtype="http://schema.org/Article" class="post-content" lang>
        <link itemprop="mainEntityOfPage" href="https://ancao96.github.io/2023/08/24/2023-8-24-15%E7%94%9F%E6%80%81/">

        <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
            <meta itemprop="image" content="/images/avatar.gif">
            <meta itemprop="name" content="SCY">
        </span>

        <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
            <meta itemprop="name" content="SCY SPACE">
            <meta itemprop="description" content>
        </span>

        <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
            <meta itemprop="name" content="undefined | SCY SPACE">
            <meta itemprop="description" content>
        </span>
        <header class="post-header">
            <h2 class="post-title" itemprop="name headline">
                <a href="/2023/08/24/2023-8-24-15%E7%94%9F%E6%80%81/" class="post-title-link" itemprop="url">(15)生态</a>
            </h2>

            <div class="post-meta-container">
                <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-08-24 01:49:20" itemprop="dateCreated datePublished" datetime="2023-08-24T01:49:20+08:00">2023-08-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-10-04 13:16:37" itemprop="dateModified" datetime="2023-10-04T13:16:37+08:00">2023-10-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/R/" itemprop="url" rel="index"><span itemprop="name">R</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/R/Geocomputaion/" itemprop="url" rel="index"><span itemprop="name">Geocomputaion</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2023/08/24/2023-8-24-15%E7%94%9F%E6%80%81/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2023/08/24/2023-8-24-15%E7%94%9F%E6%80%81/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>7.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>26 分钟</span>
    </span>
</div>

            </div>
        </header>

        
        
        
        <div class="post-body" itemprop="articleBody">
            <blockquote><p>本文由SCY翻译自《Geocomputation with R》<a target="_blank" rel="external nofollow noopener noreferrer" href="https://r.geocompx.org/eco">第十五章</a></p>
</blockquote>
<p>本章通过模拟雾绿洲（也叫<em>lomas</em>）的植被分布，揭示了明显受到水源供应控制的不同植被区域。这个案例研究不仅整合了前几章中的核心观点，还拓展了这些观点，帮助你更全面地掌握使用R进行地理计算的相关技能。
            <!--noindex-->
            <div class="post-button">
                <a class="btn" href="/2023/08/24/2023-8-24-15%E7%94%9F%E6%80%81/#more" rel="contents">
                    阅读全文 &raquo;
                </a>
            </div>
            <!--/noindex-->
            
            
        </p></div>

        
        
        

        <div>
            
        </div>

        <footer class="post-footer">
            <div class="post-eof"></div>
            
        </footer>
    </article>
</div>




    


<div class="post-block">
    
    

    <article itemscope itemtype="http://schema.org/Article" class="post-content" lang>
        <link itemprop="mainEntityOfPage" href="https://ancao96.github.io/2023/08/23/2023-8-23-14%E5%9C%B0%E7%90%86%E8%90%A5%E9%94%80/">

        <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
            <meta itemprop="image" content="/images/avatar.gif">
            <meta itemprop="name" content="SCY">
        </span>

        <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
            <meta itemprop="name" content="SCY SPACE">
            <meta itemprop="description" content>
        </span>

        <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
            <meta itemprop="name" content="undefined | SCY SPACE">
            <meta itemprop="description" content>
        </span>
        <header class="post-header">
            <h2 class="post-title" itemprop="name headline">
                <a href="/2023/08/23/2023-8-23-14%E5%9C%B0%E7%90%86%E8%90%A5%E9%94%80/" class="post-title-link" itemprop="url">(14)地理营销</a>
            </h2>

            <div class="post-meta-container">
                <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-08-23 15:33:20" itemprop="dateCreated datePublished" datetime="2023-08-23T15:33:20+08:00">2023-08-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-10-04 13:17:52" itemprop="dateModified" datetime="2023-10-04T13:17:52+08:00">2023-10-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/R/" itemprop="url" rel="index"><span itemprop="name">R</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/R/Geocomputaion/" itemprop="url" rel="index"><span itemprop="name">Geocomputaion</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2023/08/23/2023-8-23-14%E5%9C%B0%E7%90%86%E8%90%A5%E9%94%80/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2023/08/23/2023-8-23-14%E5%9C%B0%E7%90%86%E8%90%A5%E9%94%80/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>19 分钟</span>
    </span>
</div>

            </div>
        </header>

        
        
        
        <div class="post-body" itemprop="articleBody">
            <blockquote><p>本文由SCY翻译自《Geocomputation with R》<a target="_blank" rel="external nofollow noopener noreferrer" href="https://r.geocompx.org/location">第十四章</a></p>
</blockquote>
<ul>
<li>T本章要求使用下列包 (<strong>tmaptools</strong> 必须安装）:</li>
</ul>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">library<span class="punctuation">(</span>sf<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>dplyr<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>purrr<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>terra<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>osmdata<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>spDataLarge<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>必要的数据将会在适当的时候下载。</li>
</ul>
<p>为了方便读者并确保易于复现，我们已将下载的数据放在
<strong>spDataLarge</strong> 包中供使用。</p>
<h1 id="引言">引言</h1>
<p>本章展示了在第一部分和第二部分学到的技能如何应用于特定领域：地理营销（有时也称为位置分析或位置智能）。这是一个广泛的研究和商业应用领域。地理营销的典型例子是如何选择一个新店的位置。这里的目标是吸引最多的顾客，最终实现最大的利润。此外，还有许多非商业应用可以利用这种技术来造福公众，例如选择新的卫生服务设施的位置。</p>
<p>人类对于位置分析来说是基本要素，特别是人们可能会在哪里花费时间和其他资源。有趣的是，生态学的概念和模型与用于店铺选址分析的概念和模型非常相似。动植物可以在某些“最优”位置最好地满足其需求，这些位置是基于随空间变化的变量确定的。这是地理计算和地理信息科学的一个重要优势：概念和方法可以转移到其他领域。例如，北极熊更喜欢气温较低且食物（海豹和海狮）丰富的北纬地区。同样地，人类倾向于聚集在某些地方，创造出类似于北极地区的生态位的经济位。位置分析的主要任务是基于现有数据找出这些特定服务的“最优位置”在哪里。典型的研究问题包括：</p>
<ul>
<li>目标群体居住在哪里，他们经常去哪些地区？</li>
<li>竞争的商店或服务位于哪里？</li>
<li>有多少人可以轻松到达特定的商店？</li>
<li>现有的服务是否过度或不足地利用了市场潜力？</li>
<li>公司在特定地区的市场份额是多少？</li>
</ul>
<p>本章通过一个基于实际数据的假设案例研究，演示了地理计算如何回答这些问题。</p>
<h1 id="案例研究德国自行车商店">案例研究：德国自行车商店</h1>
<p>假设您正在德国开设一家自行车连锁店。这些店铺应该位于尽可能多的潜在顾客所在的城市地区。此外，一个虚构的调查（仅用于本章，非商业用途！）表明，单身年轻男性（年龄在20到40岁之间）最有可能购买您的产品：这就是<em>目标受众</em>。幸运的是，您有足够的资本来开设多家店铺。但是，它们应该放在哪里呢？咨询公司（雇佣地理营销分析师的公司）通常会收取高额费用来回答此类问题。幸运的是，借助开放数据和开源软件，我们可以自己解决这些问题。以下几节将演示如何将本书前几章学到的技术应用于执行服务位置分析中的常见步骤：</p>
<ul>
<li>整理来自德国人口普查的输入数据</li>
<li>将表格化的人口普查数据转换为栅格对象</li>
<li>识别人口密度较高的大都市地区</li>
<li>为这些地区下载详细的地理数据（使用<strong>osmdata</strong>从OpenStreetMap下载）</li>
<li>使用地图代数创建评分栅格，以评估不同位置的相对吸引力</li>
</ul>
<p>尽管我们将这些步骤应用于一个特定的案例研究，但它们可以推广到许多店铺选址或公共服务提供的情景。</p>
<h1 id="整理数据">整理数据</h1>
<p>德国政府提供了分辨率为1公里或100米的栅格化人口普查数据。下面的代码块用于下载、解压缩和读取1公里分辨率的数据。
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">download.file<span class="punctuation">(</span><span class="string">&quot;https://tinyurl.com/ybtpkwxz&quot;</span><span class="punctuation">,</span> </span><br><span class="line">              destfile <span class="operator">=</span> <span class="string">&quot;census.zip&quot;</span><span class="punctuation">,</span> mode <span class="operator">=</span> <span class="string">&quot;wb&quot;</span><span class="punctuation">)</span></span><br><span class="line">unzip<span class="punctuation">(</span><span class="string">&quot;census.zip&quot;</span><span class="punctuation">)</span> <span class="comment"># unzip the files</span></span><br><span class="line">census_de <span class="operator">=</span> readr<span class="operator">::</span>read_csv2<span class="punctuation">(</span>list.files<span class="punctuation">(</span>pattern <span class="operator">=</span> <span class="string">&quot;Gitter.csv&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure></p>
<p>请注意，<code>census_de</code> 数据也可以从
<strong>spDataLarge</strong> 包中获取：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data<span class="punctuation">(</span><span class="string">&quot;census_de&quot;</span><span class="punctuation">,</span> package <span class="operator">=</span> <span class="string">&quot;spDataLarge&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><code>census_de</code>
对象是一个包含13个变量的数据框，涵盖德国境内超过360,000个栅格单元。对于我们的工作，我们只需要其中的一个子集：东向坐标
(<code>x</code>)、北向坐标
(<code>y</code>)、居民数量（人口；<code>pop</code>）、平均年龄（<code>mean_age</code>）、女性比例（<code>women</code>）和平均家庭规模（<code>hh_size</code>）。下面的代码块从这些变量中选择并将其从德文重命名为英文，并在表格
@ref(tab:census-desc) 中进行了总结。此外，<code>mutate()</code>
函数被用于将值-1和-9（表示“未知”）转换为 <code>NA</code>。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pop = population, hh_size = household size</span></span><br><span class="line">input <span class="operator">=</span> select<span class="punctuation">(</span>census_de<span class="punctuation">,</span> x <span class="operator">=</span> x_mp_1km<span class="punctuation">,</span> y <span class="operator">=</span> y_mp_1km<span class="punctuation">,</span> pop <span class="operator">=</span> Einwohner<span class="punctuation">,</span></span><br><span class="line">                      women <span class="operator">=</span> Frauen_A<span class="punctuation">,</span> mean_age <span class="operator">=</span> Alter_D<span class="punctuation">,</span> hh_size <span class="operator">=</span> HHGroesse_D<span class="punctuation">)</span></span><br><span class="line"><span class="comment"># set -1 and -9 to NA</span></span><br><span class="line">input_tidy <span class="operator">=</span> dplyr<span class="operator">::</span>mutate<span class="punctuation">(</span>input<span class="punctuation">,</span></span><br><span class="line">  dplyr<span class="operator">::</span>across<span class="punctuation">(</span>.cols <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span>pop<span class="punctuation">,</span> women<span class="punctuation">,</span> mean_age<span class="punctuation">,</span> hh_size<span class="punctuation">)</span><span class="punctuation">,</span> </span><br><span class="line">                .fns <span class="operator">=</span>  <span class="operator">~</span>ifelse<span class="punctuation">(</span>.x <span class="operator">%in%</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="operator">-</span><span class="number">1</span><span class="punctuation">,</span> <span class="operator">-</span><span class="number">9</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="literal">NA</span><span class="punctuation">,</span> .x<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<table>
<caption>Categories for each variable in census data from
Datensatzbeschreibung...xlsx located in the downloaded file census.zip
(see Figure @ref(fig:census-stack) for their spatial
distribution).</caption>
<thead>
<tr class="header">
<th style="text-align: center;">Class</th>
<th style="text-align: center;">Population</th>
<th style="text-align: center;">% female</th>
<th style="text-align: center;">Mean age</th>
<th style="text-align: center;">Household size</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">3-250</td>
<td style="text-align: center;">0-40</td>
<td style="text-align: center;">0-40</td>
<td style="text-align: center;">1-2</td>
</tr>
<tr class="even">
<td style="text-align: center;">2</td>
<td style="text-align: center;">250-500</td>
<td style="text-align: center;">40-47</td>
<td style="text-align: center;">40-42</td>
<td style="text-align: center;">2-2.5</td>
</tr>
<tr class="odd">
<td style="text-align: center;">3</td>
<td style="text-align: center;">500-2000</td>
<td style="text-align: center;">47-53</td>
<td style="text-align: center;">42-44</td>
<td style="text-align: center;">2.5-3</td>
</tr>
<tr class="even">
<td style="text-align: center;">4</td>
<td style="text-align: center;">2000-4000</td>
<td style="text-align: center;">53-60</td>
<td style="text-align: center;">44-47</td>
<td style="text-align: center;">3-3.5</td>
</tr>
<tr class="odd">
<td style="text-align: center;">5</td>
<td style="text-align: center;">4000-8000</td>
<td style="text-align: center;">&gt;60</td>
<td style="text-align: center;">&gt;47</td>
<td style="text-align: center;">&gt;3.5</td>
</tr>
<tr class="even">
<td style="text-align: center;">6</td>
<td style="text-align: center;">&gt;8000</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<h1 id="创建人口普查栅格">创建人口普查栅格</h1>
<p>在预处理之后，可以使用<code>rast()</code>函数将数据转换为<code>SpatRaster</code>对象。当将其
<code>type</code> 参数设置为 <code>xyz</code> 时，输入数据框的
<code>x</code> 和 <code>y</code>
列应该对应于正规栅格上的坐标。所有其余列（在这里是
<code>pop</code>、<code>women</code>、<code>mean_age</code>、<code>hh_size</code>）将用作栅格图层的值（请参阅图
@ref(fig:census-stack)；还可以在我们的 GitHub
存储库中的<code>code/14-location-figures.R</code>
文件中找到相关代码）。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">input_ras <span class="operator">=</span> terra<span class="operator">::</span>rast<span class="punctuation">(</span>input_tidy<span class="punctuation">,</span> type <span class="operator">=</span> <span class="string">&quot;xyz&quot;</span><span class="punctuation">,</span> crs <span class="operator">=</span> <span class="string">&quot;EPSG:3035&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">input_ras</span><br><span class="line"><span class="comment">#&gt; class       : SpatRaster </span></span><br><span class="line"><span class="comment">#&gt; dimensions  : 868, 642, 4  (nrow, ncol, nlyr)</span></span><br><span class="line"><span class="comment">#&gt; resolution  : 1000, 1000  (x, y)</span></span><br><span class="line"><span class="comment">#&gt; extent      : 4031000, 4673000, 2684000, 3552000  (xmin, xmax, ymin, ymax)</span></span><br><span class="line"><span class="comment">#&gt; coord. ref. : ETRS89-extended / LAEA Europe (EPSG:3035) </span></span><br><span class="line"><span class="comment">#&gt; source(s)   : memory</span></span><br><span class="line"><span class="comment">#&gt; names       : pop, women, mean_age, hh_size </span></span><br><span class="line"><span class="comment">#&gt; min values  :   1,     1,        1,       1 </span></span><br><span class="line"><span class="comment">#&gt; max values  :   6,     5,        5,       5</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>📌请注意，我们使用的是等面积投影（EPSG:3035；欧洲兰伯特等面积投影），即每个栅格单元的面积相同，这里是1000
x
1000平方米。由于我们主要使用诸如每个栅格单元的居民数量或女性比例等密度数据，因此每个栅格单元的面积相同非常重要，以避免“苹果与橙子比较”。请注意，在地理坐标系（CRS）中，栅格单元的面积在向极地方向不断减小，因此需要谨慎处理。</p>
</blockquote>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309051728640.png">
Gridded German census data of 2011 (see Table @ref(tab:census-desc) for
a description of the classes).</p>
<p>下一步是根据前面章节提到的调查，使用 <strong>terra</strong> 函数
<code>classify()</code> 对存储在 <code>input_ras</code>
中的栅格图层的值进行重新分类。对于人口数据，我们使用类均值将类别转换为数值数据类型。假设栅格单元的值为1（'class
1'
中的单元包含3到250名居民），则栅格单元的人口被假定为127；如果值为2（包含250到500名居民的单元），则人口被假定为375，依此类推（请参阅上表）。对于'类别6'，栅格单元的值被选为8000名居民，因为这些单元包含的人口超过8000人。当然，这些都是对真实人口的近似值，而不是精确值。<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>然而，这个详细级别足以划定大都市区域（请参阅下一节）。</p>
<p>与变量 <code>pop</code>
不同，该变量表示总人口的绝对估计，其他变量被重新分类为与调查中使用的权重相对应的权重。例如，变量
<code>women</code>
中的'类别1'代表的是人口中女性占0到40%的地区；这些地区被重新分类为较高的权重3，因为目标人群主要是男性。同样地，包含最年轻人口和最高比例的单身家庭的类别被重新分类为高权重。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rcl_pop <span class="operator">=</span> matrix<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">127</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">,</span> <span class="number">375</span><span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">,</span> <span class="number">1250</span><span class="punctuation">,</span> </span><br><span class="line">                   <span class="number">4</span><span class="punctuation">,</span> <span class="number">4</span><span class="punctuation">,</span> <span class="number">3000</span><span class="punctuation">,</span> <span class="number">5</span><span class="punctuation">,</span> <span class="number">5</span><span class="punctuation">,</span> <span class="number">6000</span><span class="punctuation">,</span> <span class="number">6</span><span class="punctuation">,</span> <span class="number">6</span><span class="punctuation">,</span> <span class="number">8000</span><span class="punctuation">)</span><span class="punctuation">,</span> </span><br><span class="line">                 ncol <span class="operator">=</span> <span class="number">3</span><span class="punctuation">,</span> byrow <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br><span class="line">rcl_women <span class="operator">=</span> matrix<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">4</span><span class="punctuation">,</span> <span class="number">5</span><span class="punctuation">,</span> <span class="number">0</span><span class="punctuation">)</span><span class="punctuation">,</span> </span><br><span class="line">                   ncol <span class="operator">=</span> <span class="number">3</span><span class="punctuation">,</span> byrow <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br><span class="line">rcl_age <span class="operator">=</span> matrix<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">,</span> <span class="number">0</span><span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">,</span> <span class="number">5</span><span class="punctuation">,</span> <span class="number">0</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">                 ncol <span class="operator">=</span> <span class="number">3</span><span class="punctuation">,</span> byrow <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br><span class="line">rcl_hh <span class="operator">=</span> rcl_women</span><br><span class="line">rcl <span class="operator">=</span> <span class="built_in">list</span><span class="punctuation">(</span>rcl_pop<span class="punctuation">,</span> rcl_women<span class="punctuation">,</span> rcl_age<span class="punctuation">,</span> rcl_hh<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>请注意，我们确保了列表中重新分类矩阵的顺序与 <code>input_ras</code>
的元素顺序相同。例如，第一个元素在两种情况下都对应于人口。随后，<code>for</code>
循环 将重新分类矩阵应用于相应的栅格图层。最后，下面的代码块确保
<code>reclass</code> 图层与 <code>input_ras</code>
的图层具有相同的名称。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">reclass <span class="operator">=</span> input_ras</span><br><span class="line"><span class="keyword">for</span> <span class="punctuation">(</span>i <span class="keyword">in</span> <span class="built_in">seq_len</span><span class="punctuation">(</span>terra<span class="operator">::</span>nlyr<span class="punctuation">(</span>reclass<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="punctuation">&#123;</span></span><br><span class="line">  reclass<span class="punctuation">[[</span>i<span class="punctuation">]</span><span class="punctuation">]</span> <span class="operator">=</span> terra<span class="operator">::</span>classify<span class="punctuation">(</span>x <span class="operator">=</span> reclass<span class="punctuation">[[</span>i<span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">,</span> rcl <span class="operator">=</span> rcl<span class="punctuation">[[</span>i<span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">,</span> right <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="built_in">names</span><span class="punctuation">(</span>reclass<span class="punctuation">)</span> <span class="operator">=</span> <span class="built_in">names</span><span class="punctuation">(</span>input_ras<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">reclass</span><br><span class="line"><span class="comment">#&gt; ... (full output not shown)</span></span><br><span class="line"><span class="comment">#&gt; names       :  pop, women, mean_age, hh_size </span></span><br><span class="line"><span class="comment">#&gt; min values  :  127,     0,        0,       0 </span></span><br><span class="line"><span class="comment">#&gt; max values  : 8000,     3,        3,       3</span></span><br></pre></td></tr></table></figure>
<h1 id="定义都市区">定义都市区</h1>
<p>我们特意将大都市区域定义为面积为20平方公里且居住人口超过500,000人的像素。在这种粗分辨率下，可以通过使用
<code>aggregate()</code>快速创建像素。下面的命令使用参数
<code>fact = 20</code>
将结果的分辨率降低了20倍（回想一下，原始栅格的分辨率是1平方公里）：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pop_agg <span class="operator">=</span> terra<span class="operator">::</span>aggregate<span class="punctuation">(</span>reclass<span class="operator">$</span>pop<span class="punctuation">,</span> fact <span class="operator">=</span> <span class="number">20</span><span class="punctuation">,</span> fun <span class="operator">=</span> <span class="built_in">sum</span><span class="punctuation">,</span> na.rm <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br><span class="line">summary<span class="punctuation">(</span>pop_agg<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt;       pop         </span></span><br><span class="line"><span class="comment">#&gt;  Min.   :    127  </span></span><br><span class="line"><span class="comment">#&gt;  1st Qu.:  39886  </span></span><br><span class="line"><span class="comment">#&gt;  Median :  66008  </span></span><br><span class="line"><span class="comment">#&gt;  Mean   :  99503  </span></span><br><span class="line"><span class="comment">#&gt;  3rd Qu.: 105696  </span></span><br><span class="line"><span class="comment">#&gt;  Max.   :1204870  </span></span><br><span class="line"><span class="comment">#&gt;  NA&#x27;s   :447</span></span><br></pre></td></tr></table></figure>
<p>接下来的步骤是仅保留居住人口超过500,000人的单元格。您可以使用以下代码来实现：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pop_agg <span class="operator">=</span> pop_agg<span class="punctuation">[</span>pop_agg <span class="operator">&gt;</span> <span class="number">500000</span><span class="punctuation">,</span> drop <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">]</span> </span><br></pre></td></tr></table></figure>
<p>绘制这些数据将显示出八个大都市区域。每个区域由一个或多个栅格单元组成。如果我们能够将属于同一区域的所有单元格连接起来，那将会很好。<strong>terra</strong>
的 <code>patches()</code>
命令正是这样的功能。随后，<code>as.polygons()</code>
将栅格对象转换为空间多边形，而 <code>st_as_sf()</code> 将其转换为
<code>sf</code> 对象。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">metros <span class="operator">=</span> pop_agg <span class="operator">|&gt;</span> </span><br><span class="line">  terra<span class="operator">::</span>patches<span class="punctuation">(</span>directions <span class="operator">=</span> <span class="number">8</span><span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">  terra<span class="operator">::</span>as.polygons<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">  sf<span class="operator">::</span>st_as_sf<span class="punctuation">(</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309051739055.png">
The aggregated population raster (resolution: 20 km) with the identified
metropolitan areas (golden polygons) and the corresponding names.</p>
<p>生成的八个适合自行车店的大都市区域；请参阅
<code>code/14-location-figures.R</code>
以创建图表）仍然缺少名称。逆地理编码方法可以解决这个问题：根据坐标找到对应的地址。因此，提取每个大都市区域的中心坐标可以作为逆地理编码API的输入。这正是
<strong>tmaptools</strong> 包中的 <code>rev_geocode_OSM()</code>
函数所期望的。此外，将 <code>as.data.frame</code> 设置为
<code>TRUE</code> 将返回一个包含多列关于位置的
<code>data.frame</code>，包括街道名称、门牌号和城市。然而，在这里，我们只关注城市的名称。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">metro_names <span class="operator">=</span> sf<span class="operator">::</span>st_centroid<span class="punctuation">(</span>metros<span class="punctuation">,</span> of_largest_polygon <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">  tmaptools<span class="operator">::</span>rev_geocode_OSM<span class="punctuation">(</span>as.data.frame <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">  select<span class="punctuation">(</span>city<span class="punctuation">,</span> town<span class="punctuation">,</span> state<span class="punctuation">)</span></span><br><span class="line"><span class="comment"># smaller cities are returned in column town. To have all names in one column,</span></span><br><span class="line"><span class="comment"># we move the town name to the city column in case it is NA</span></span><br><span class="line">metro_names <span class="operator">=</span> dplyr<span class="operator">::</span>mutate<span class="punctuation">(</span>metro_names<span class="punctuation">,</span> city <span class="operator">=</span> ifelse<span class="punctuation">(</span><span class="built_in">is.na</span><span class="punctuation">(</span>city<span class="punctuation">)</span><span class="punctuation">,</span> town<span class="punctuation">,</span> city<span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>为了确保读者使用完全相同的结果，我们已将它们存储在
<strong>spDataLarge</strong> 中，对象名称为
<code>metro_names</code>。</p>
<table>
<caption>Result of the reverse geocoding.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">city</th>
<th style="text-align: left;">state</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Hamburg</td>
<td style="text-align: left;">NA</td>
</tr>
<tr class="even">
<td style="text-align: left;">Berlin</td>
<td style="text-align: left;">NA</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Velbert</td>
<td style="text-align: left;">Nordrhein-Westfalen</td>
</tr>
<tr class="even">
<td style="text-align: left;">Leipzig</td>
<td style="text-align: left;">Sachsen</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Frankfurt am Main</td>
<td style="text-align: left;">Hessen</td>
</tr>
<tr class="even">
<td style="text-align: left;">Nürnberg</td>
<td style="text-align: left;">Bayern</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Stuttgart</td>
<td style="text-align: left;">Baden-Württemberg</td>
</tr>
<tr class="even">
<td style="text-align: left;">München</td>
<td style="text-align: left;">Bayern</td>
</tr>
</tbody>
</table>
<p>总体而言，我们对 <code>city</code>
列作为大都市名称（上表）感到满意，除了一个例外，即属于杜塞尔多夫大区的费尔伯特。因此，我们将
Velbert 替换为 Düsseldorf（上图）。像 <code>ü</code>
这样的特殊字符可能会在后续的操作中引起问题，例如在使用
<code>opq()</code>
确定大都市区域的边界框时（请参见下面的内容），因此我们避免使用它们。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">metro_names <span class="operator">=</span> metro_names<span class="operator">$</span>city <span class="operator">|&gt;</span> </span><br><span class="line">  <span class="built_in">as.character</span><span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">  <span class="punctuation">&#123;</span><span class="punctuation">\</span><span class="punctuation">(</span>x<span class="punctuation">)</span> ifelse<span class="punctuation">(</span>x <span class="operator">==</span> <span class="string">&quot;Velbert&quot;</span><span class="punctuation">,</span> <span class="string">&quot;Düsseldorf&quot;</span><span class="punctuation">,</span> x<span class="punctuation">)</span><span class="punctuation">&#125;</span><span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">  <span class="punctuation">&#123;</span><span class="punctuation">\</span><span class="punctuation">(</span>x<span class="punctuation">)</span> gsub<span class="punctuation">(</span><span class="string">&quot;ü&quot;</span><span class="punctuation">,</span> <span class="string">&quot;ue&quot;</span><span class="punctuation">,</span> x<span class="punctuation">)</span><span class="punctuation">&#125;</span><span class="punctuation">(</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<h1 id="兴趣点">兴趣点</h1>
<p><strong>osmdata</strong>包提供了易于使用的访问OSM数据的方法。我们不是下载整个德国的商店数据，而是将查询限制在了定义好的大都市区域，以减少计算负担并且只获取感兴趣区域内的商店位置。下面的代码块使用了许多函数，包括：</p>
<ul>
<li><code>map()</code>（<strong>tidyverse</strong> 中的
<code>lapply()</code>等效函数），它遍历了八个大都市名称，随后在OSM查询函数
<code>opq()</code> 中定义了边界框。</li>
<li><code>add_osm_feature()</code> 用于指定带有键值为 <code>shop</code>
的OSM元素（请参阅 <a target="_blank" rel="external nofollow noopener noreferrer" href="http://wiki.openstreetmap.org/wiki/Map_Features">wiki.openstreetmap.org</a>
以获取常见的键值对列表）。</li>
<li><code>osmdata_sf()</code> 将OSM数据转换为空间对象（<code>sf</code>
类）。</li>
<li><code>while()</code>，如果第一次下载失败，将重复尝试（在本例中为三次）。<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></li>
</ul>
<p>在运行此代码之前，请考虑它将下载近2GB的数据。为了节省时间和资源，我们已将名为
<code>shops</code> 的输出放入 <strong>spDataLarge</strong>
包中。要在您的环境中使用它，请运行
<code>data("shops", package = "spDataLarge")</code>。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">shops <span class="operator">=</span> purrr<span class="operator">::</span>map<span class="punctuation">(</span>metro_names<span class="punctuation">,</span> <span class="keyword">function</span><span class="punctuation">(</span>x<span class="punctuation">)</span> <span class="punctuation">&#123;</span></span><br><span class="line">  message<span class="punctuation">(</span><span class="string">&quot;Downloading shops of: &quot;</span><span class="punctuation">,</span> x<span class="punctuation">,</span> <span class="string">&quot;\n&quot;</span><span class="punctuation">)</span></span><br><span class="line">  <span class="comment"># give the server a bit time</span></span><br><span class="line">  Sys.sleep<span class="punctuation">(</span>sample<span class="punctuation">(</span>seq<span class="punctuation">(</span><span class="number">5</span><span class="punctuation">,</span> <span class="number">10</span><span class="punctuation">,</span> <span class="number">0.1</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">  query <span class="operator">=</span> osmdata<span class="operator">::</span>opq<span class="punctuation">(</span>x<span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">    osmdata<span class="operator">::</span>add_osm_feature<span class="punctuation">(</span>key <span class="operator">=</span> <span class="string">&quot;shop&quot;</span><span class="punctuation">)</span></span><br><span class="line">  points <span class="operator">=</span> osmdata<span class="operator">::</span>osmdata_sf<span class="punctuation">(</span>query<span class="punctuation">)</span></span><br><span class="line">  <span class="comment"># request the same data again if nothing has been downloaded</span></span><br><span class="line">  iter <span class="operator">=</span> <span class="number">2</span></span><br><span class="line">  <span class="keyword">while</span> <span class="punctuation">(</span>nrow<span class="punctuation">(</span>points<span class="operator">$</span>osm_points<span class="punctuation">)</span> <span class="operator">==</span> <span class="number">0</span> <span class="operator">&amp;&amp;</span> iter <span class="operator">&gt;</span> <span class="number">0</span><span class="punctuation">)</span> <span class="punctuation">&#123;</span></span><br><span class="line">    points <span class="operator">=</span> osmdata_sf<span class="punctuation">(</span>query<span class="punctuation">)</span></span><br><span class="line">    iter <span class="operator">=</span> iter <span class="operator">-</span> <span class="number">1</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="comment"># return only the point features</span></span><br><span class="line">  points<span class="operator">$</span>osm_points</span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>在我们定义的任何大都市区域中几乎不可能没有商店。以下的
<code>if</code>
条件仅仅检查每个区域是否至少有一家商店。如果没有的话，我们建议尝试再次为该/这些特定区域下载商店数据。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># checking if we have downloaded shops for each metropolitan area</span></span><br><span class="line">ind <span class="operator">=</span> purrr<span class="operator">::</span>map_dbl<span class="punctuation">(</span>shops<span class="punctuation">,</span> nrow<span class="punctuation">)</span> <span class="operator">==</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> <span class="punctuation">(</span><span class="built_in">any</span><span class="punctuation">(</span>ind<span class="punctuation">)</span><span class="punctuation">)</span> <span class="punctuation">&#123;</span></span><br><span class="line">  message<span class="punctuation">(</span><span class="string">&quot;There are/is still (a) metropolitan area/s without any features:\n&quot;</span><span class="punctuation">,</span></span><br><span class="line">          paste<span class="punctuation">(</span>metro_names<span class="punctuation">[</span>ind<span class="punctuation">]</span><span class="punctuation">,</span> collapse <span class="operator">=</span> <span class="string">&quot;, &quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="string">&quot;\nPlease fix it!&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>为确保每个列表元素（一个 <code>sf</code> 数据框）具有相同的列<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>，我们只保留 <code>osm_id</code> 和
<code>shop</code> 列，使用 <code>map_dfr</code>
循环将所有商店合并为一个大的 <code>sf</code> 对象。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># select only specific columns</span></span><br><span class="line">shops <span class="operator">=</span> purrr<span class="operator">::</span>map_dfr<span class="punctuation">(</span>shops<span class="punctuation">,</span> select<span class="punctuation">,</span> osm_id<span class="punctuation">,</span> shop<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>注意：<code>shops</code> 已经在 <code>spDataLarge</code>
中提供，并且可以通过以下方式访问：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data<span class="punctuation">(</span><span class="string">&quot;shops&quot;</span><span class="punctuation">,</span> package <span class="operator">=</span> <span class="string">&quot;spDataLarge&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>唯一剩下的任务是将空间点对象转换为栅格。<code>sf</code> 对象
<code>shops</code> 将被转换为一个栅格，其参数（维度、分辨率、CRS）与
<code>reclass</code> 对象相同。重要的是，在此处使用
<code>length()</code> 函数来计算每个单元格中的商店数量。</p>
<p>因此，下面的代码块的结果是商店密度的估计（商店/平方公里）。在使用
<code>rasterize()</code> 之前，使用 <code>st_transform()</code>
来确保两个输入的CRS匹配。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shops <span class="operator">=</span> sf<span class="operator">::</span>st_transform<span class="punctuation">(</span>shops<span class="punctuation">,</span> st_crs<span class="punctuation">(</span>reclass<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># create poi raster</span></span><br><span class="line">poi <span class="operator">=</span> terra<span class="operator">::</span>rasterize<span class="punctuation">(</span>x <span class="operator">=</span> shops<span class="punctuation">,</span> y <span class="operator">=</span> reclass<span class="punctuation">,</span> field <span class="operator">=</span> <span class="string">&quot;osm_id&quot;</span><span class="punctuation">,</span> fun <span class="operator">=</span> <span class="string">&quot;length&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>与其他栅格图层（人口、女性、平均年龄、户籍人口）一样，<code>poi</code>
栅格也被重新分类为四个类别。在一定程度上，定义类别间隔是一个主观的任务。可以使用等距断点、分位数断点、固定值或其他方法。在这里，我们选择了费舍尔-詹金斯自然断点法，该方法最小化了类内方差，其结果为重新分类矩阵提供了一个输入。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># construct reclassification matrix</span></span><br><span class="line">int <span class="operator">=</span> classInt<span class="operator">::</span>classIntervals<span class="punctuation">(</span>terra<span class="operator">::</span>values<span class="punctuation">(</span>poi<span class="punctuation">)</span><span class="punctuation">,</span> n <span class="operator">=</span> <span class="number">4</span><span class="punctuation">,</span> style <span class="operator">=</span> <span class="string">&quot;fisher&quot;</span><span class="punctuation">)</span></span><br><span class="line">int <span class="operator">=</span> <span class="built_in">round</span><span class="punctuation">(</span>int<span class="operator">$</span>brks<span class="punctuation">)</span></span><br><span class="line">rcl_poi <span class="operator">=</span> matrix<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span>int<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="built_in">rep</span><span class="punctuation">(</span>int<span class="punctuation">[</span><span class="operator">-</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span> <span class="built_in">length</span><span class="punctuation">(</span>int<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">]</span><span class="punctuation">,</span> each <span class="operator">=</span> <span class="number">2</span><span class="punctuation">)</span><span class="punctuation">,</span> </span><br><span class="line">                   int<span class="punctuation">[</span><span class="built_in">length</span><span class="punctuation">(</span>int<span class="punctuation">)</span><span class="punctuation">]</span> <span class="operator">+</span> <span class="number">1</span><span class="punctuation">)</span><span class="punctuation">,</span> ncol <span class="operator">=</span> <span class="number">2</span><span class="punctuation">,</span> byrow <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br><span class="line">rcl_poi <span class="operator">=</span> cbind<span class="punctuation">(</span>rcl_poi<span class="punctuation">,</span> <span class="number">0</span><span class="operator">:</span><span class="number">3</span><span class="punctuation">)</span>  </span><br><span class="line"><span class="comment"># reclassify</span></span><br><span class="line">poi <span class="operator">=</span> terra<span class="operator">::</span>classify<span class="punctuation">(</span>poi<span class="punctuation">,</span> rcl <span class="operator">=</span> rcl_poi<span class="punctuation">,</span> right <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">)</span> </span><br><span class="line"><span class="built_in">names</span><span class="punctuation">(</span>poi<span class="punctuation">)</span> <span class="operator">=</span> <span class="string">&quot;poi&quot;</span></span><br></pre></td></tr></table></figure>
<h1 id="明确合适的位置">明确合适的位置</h1>
<p>在将所有图层组合在一起之前，只剩下几个步骤：将 <code>poi</code>
添加到 <code>reclass</code>
栅格堆叠中，并将人口图层从中移除。后者的原因有两点。首先，我们已经勾勒出了大都市区域，即人口密度高于德国其他地区平均水平的地区。其次，虽然在特定的服务区域内有许多潜在的顾客可能是有优势的，但仅仅数量本身可能并不真正代表所需的目标群体。例如，高层住宅区是人口密度较高的地区，但不一定具有购买昂贵自行车配件的高购买力。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># remove population raster and add poi raster</span></span><br><span class="line">reclass <span class="operator">=</span> reclass<span class="punctuation">[[</span><span class="built_in">names</span><span class="punctuation">(</span>reclass<span class="punctuation">)</span> <span class="operator">!=</span> <span class="string">&quot;pop&quot;</span><span class="punctuation">]</span><span class="punctuation">]</span> <span class="operator">|&gt;</span></span><br><span class="line">  <span class="built_in">c</span><span class="punctuation">(</span>poi<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>与其他数据科学项目一样，数据检索和“整理”在整个工作量中占据了很大一部分。有了干净的数据，最后一步——通过将所有栅格图层相加来计算最终得分——可以在一行代码中完成。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># calculate the total score</span></span><br><span class="line">result <span class="operator">=</span> <span class="built_in">sum</span><span class="punctuation">(</span>reclass<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>例如，得分大于9的分数可能是一个适当的阈值，表示可以放置自行车店的栅格单元格；请参阅
<code>code/14-location-figures.R</code>）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#&gt; The legacy packages maptools, rgdal, and rgeos, underpinning the sp package,</span><br><span class="line">#&gt; which was just loaded, will retire in October 2023.</span><br><span class="line">#&gt; Please refer to R-spatial evolution reports for details, especially</span><br><span class="line">#&gt; https://r-spatial.org/r/2023/05/15/evolution4.html.</span><br><span class="line">#&gt; It may be desirable to make the sf package available;</span><br><span class="line">#&gt; package maintainers should consider adding sf to Suggests:.</span><br><span class="line">#&gt; The sp package is now running under evolution status 2</span><br><span class="line">#&gt;      (status 2 uses the sf package in place of rgdal)</span><br></pre></td></tr></table></figure>
<div class="figure" style="text-align: center">
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;leaflet html-widget html-fill-item-overflow-hidden html-fill-item&quot; id=&quot;htmlwidget-841de324d41155df19a0&quot; style=&quot;width:100%;height:415.296px;&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;script type=&quot;application/json&quot; data-for=&quot;htmlwidget-841de324d41155df19a0&quot;&gt;&#123;&quot;x&quot;:&#123;&quot;options&quot;:&#123;&quot;crs&quot;:&#123;&quot;crsClass&quot;:&quot;L.CRS.EPSG3857&quot;,&quot;code&quot;:null,&quot;proj4def&quot;:null,&quot;projectedBounds&quot;:null,&quot;options&quot;:&#123;&#125;&#125;&#125;,&quot;calls&quot;:[&#123;&quot;method&quot;:&quot;addTiles&quot;,&quot;args&quot;:[&quot;https://&#123;s&#125;.tile.openstreetmap.org/&#123;z&#125;/&#123;x&#125;/&#123;y&#125;.png&quot;,null,null,&#123;&quot;minZoom&quot;:0,&quot;maxZoom&quot;:18,&quot;tileSize&quot;:256,&quot;subdomains&quot;:&quot;abc&quot;,&quot;errorTileUrl&quot;:&quot;&quot;,&quot;tms&quot;:false,&quot;noWrap&quot;:false,&quot;zoomOffset&quot;:0,&quot;zoomReverse&quot;:false,&quot;opacity&quot;:1,&quot;zIndex&quot;:1,&quot;detectRetina&quot;:false,&quot;attribution&quot;:&quot;&amp;copy; &lt;a href=\&quot;https://openstreetmap.org/copyright/\&quot;&gt;OpenStreetMap&lt;\/a&gt;,  &lt;a href=\&quot;https://opendatacommons.org/licenses/odbl/\&quot;&gt;ODbL&lt;\/a&gt;&quot;&#125;]&#125;,&#123;&quot;method&quot;:&quot;addRasterImage&quot;,&quot;args&quot;:[&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAoCAYAAACM/rhtAAAAM0lEQVRYhe3SMQ0AMAwEsQcb/hTSuQSaVLIR3HAJAADfqfR0wm1dEC9VevcCq+MAAIBhB20vBvBK3JZrAAAAAElFTkSuQmCC&quot;,[[52.69660085729196,13.08200261479863],[52.32107408861835,13.69815913809763]],0.8,null,null,null]&#125;,&#123;&quot;method&quot;:&quot;addLegend&quot;,&quot;args&quot;:[&#123;&quot;colors&quot;:[&quot;darkgreen&quot;],&quot;labels&quot;:[&quot;potential locations&quot;],&quot;na_color&quot;:null,&quot;na_label&quot;:&quot;NA&quot;,&quot;opacity&quot;:0.5,&quot;position&quot;:&quot;bottomright&quot;,&quot;type&quot;:&quot;unknown&quot;,&quot;title&quot;:&quot;Legend&quot;,&quot;extra&quot;:null,&quot;layerId&quot;:null,&quot;className&quot;:&quot;info legend&quot;,&quot;group&quot;:null&#125;]&#125;],&quot;limits&quot;:&#123;&quot;lat&quot;:[52.32107408861835,52.69660085729196],&quot;lng&quot;:[13.08200261479863,13.69815913809763]&#125;&#125;,&quot;evals&quot;:[],&quot;jsHooks&quot;:[]&#125;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p class="caption">
Suitable areas (i.e., raster cells with a score &gt; 9) in accordance
with our hypothetical survey for bike stores in Berlin.
</p>
</div>
<h1 id="讨论和下一步">讨论和下一步</h1>
<p>所呈现的方法是GIS的典型应用示例。我们将调查数据与基于专家知识和假设的方法相结合（定义大都市区域，定义类别间隔，定义最终得分阈值）。这种方法不如应用分析适用于科学研究，因为它可以提供基于证据的适合自行车店的区域，应该与其他信息来源进行比较。对方法的一些变更可以改进分析：</p>
<ul>
<li>在计算最终得分时，我们使用了相等的权重，但其他因素，如户籍人口，可能与女性比例或平均年龄一样重要。</li>
<li>我们使用了所有兴趣点，但只有与自行车店相关的兴趣点，如自行车店、五金店、自行车、钓鱼、狩猎、摩托车、户外和运动用品店（请参阅
<a target="_blank" rel="external nofollow noopener noreferrer" href="http://wiki.openstreetmap.org/wiki/Map_Features#Shop">OSM
Wiki</a> 上可用的店铺值范围）可能会产生更精细的结果。</li>
<li>更高分辨率的数据可能会改善输出（请参阅练习）。</li>
<li>我们仅使用了有限的变量集和来自其他来源的数据，如 <a target="_blank" rel="external nofollow noopener noreferrer" href="http://inspire-geoportal.ec.europa.eu/discovery/">INSPIRE
geoportal</a> 或来自 OpenStreetMap 的自行车路径数据，可以丰富分析。</li>
<li>未考虑交互作用，如男性比例和单身户之间可能存在的关系。</li>
</ul>
<p>简而言之，分析可以在多个方向上进行扩展。然而，它应该给您对如何在geomarketing背景下在R中获取和处理空间数据的第一印象和理解。</p>
<p>最后，我们必须指出，所呈现的分析仅仅是找到合适位置的第一步。到目前为止，我们已经确定了大小为1x1公里的区域，代表根据我们的调查可能适合自行车店的位置。分析的后续步骤可以是：</p>
<ul>
<li>基于特定服务区域内的居民数量找到最佳位置。例如，在骑自行车的15分钟行程范围内，店铺应该为尽可能多的人提供可达性（服务区域路由）。在此过程中，我们应该考虑到远离店铺的人越远，他们实际访问店铺的可能性就越小（距离衰减函数）。</li>
<li>此外，考虑竞争对手也是一个好主意。也就是说，如果已经有一家自行车店在所选位置附近，可能的顾客（或销售潜力）应该在竞争对手之间分配。</li>
<li>我们需要找到适合并且价格合理的房地产，例如在可访问性、停车位的可用性、过路人的期望频率、有大窗户等方面。</li>
</ul>
<h1 id="练习">练习</h1>
<p>E1.
首先，您需要从提供的链接下载包含居民信息的CSV文件（以100米单元格分辨率）。请注意，解压缩后的文件大小为1.23
GB。您可以使用<code>readr::read_csv</code>将其读入R中。在具有16 GB
RAM的机器上，这需要30秒钟。<code>data.table::fread()</code>可能会更快，它返回一个<code>data.table()</code>类的对象。使用<code>dplyr::as_tibble()</code>将其转换为tibble。构建一个居民栅格，将其聚合到1
km的单元格分辨率，并将其与我们使用类平均值创建的居民栅格（<code>inh</code>）进行比较。</p>
<p>E2.
假设我们的自行车店主要向老年人销售电动自行车。相应地更改年龄栅格，重复剩余的分析，并将更改与我们的原始结果进行比较。</p>
<aside id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr>
<ol>
<li id="fn1"><p>在这个重新分类阶段引入的潜在误差将在练习中进行探讨。<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>有时在第一次尝试下载OSM数据时可能会失败。<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>这并不是一定的，因为OSM的贡献者在收集数据时并不总是一样仔细。<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>

            
        </div>

        
        
        

        <div>
            
        </div>

        <footer class="post-footer">
            <div class="post-eof"></div>
            
        </footer>
    </article>
</div>




    


<div class="post-block">
    
    

    <article itemscope itemtype="http://schema.org/Article" class="post-content" lang>
        <link itemprop="mainEntityOfPage" href="https://ancao96.github.io/2023/08/22/2023-8-22-13%E8%BF%90%E8%BE%93/">

        <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
            <meta itemprop="image" content="/images/avatar.gif">
            <meta itemprop="name" content="SCY">
        </span>

        <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
            <meta itemprop="name" content="SCY SPACE">
            <meta itemprop="description" content>
        </span>

        <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
            <meta itemprop="name" content="undefined | SCY SPACE">
            <meta itemprop="description" content>
        </span>
        <header class="post-header">
            <h2 class="post-title" itemprop="name headline">
                <a href="/2023/08/22/2023-8-22-13%E8%BF%90%E8%BE%93/" class="post-title-link" itemprop="url">(13)（应用）运输</a>
            </h2>

            <div class="post-meta-container">
                <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-08-22 05:26:20" itemprop="dateCreated datePublished" datetime="2023-08-22T05:26:20+08:00">2023-08-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-10-04 13:08:11" itemprop="dateModified" datetime="2023-10-04T13:08:11+08:00">2023-10-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/R/" itemprop="url" rel="index"><span itemprop="name">R</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/R/Geocomputaion/" itemprop="url" rel="index"><span itemprop="name">Geocomputaion</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2023/08/22/2023-8-22-13%E8%BF%90%E8%BE%93/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2023/08/22/2023-8-22-13%E8%BF%90%E8%BE%93/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>13k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>48 分钟</span>
    </span>
</div>

            </div>
        </header>

        
        
        
        <div class="post-body" itemprop="articleBody">
            <blockquote><p>本文由SCY翻译自《Geocomputation with R》<a target="_blank" rel="external nofollow noopener noreferrer" href="https://r.geocompx.org/transport">第十三章</a></p>
</blockquote>
<h1 id="前提条件">前提条件</h1>
<ul>
<li>本章使用下列包：<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></li>
</ul>
<p><a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>：<strong>nabor</strong>
必须安装。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">library<span class="punctuation">(</span>sf<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>dplyr<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>spDataLarge<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>stplanr<span class="punctuation">)</span>      <span class="comment"># for processing geographic transport data</span></span><br><span class="line">library<span class="punctuation">(</span>tmap<span class="punctuation">)</span>         <span class="comment"># map making (see Chapter 9)</span></span><br><span class="line">library<span class="punctuation">(</span>ggplot2<span class="punctuation">)</span>      <span class="comment"># data visualization package</span></span><br><span class="line">library<span class="punctuation">(</span>sfnetworks<span class="punctuation">)</span>   <span class="comment"># spatial network classes and functions </span></span><br></pre></td></tr></table></figure>
<h1 id="引言">引言</h1>
<p>很少有其他部门的地理空间比交通更有形。移动(克服距离)的努力是地理学“第一定律”的核心，Waldo
Tobler 在1970年定义如下(Tobler 1970) :</p>
<blockquote>
<p>一切事物都与其他事物相关，但是近的事物比远的事物更相关。</p>
</blockquote>
<p>这个“定律”是空间自相关和其他关键地理概念的基础。它适用于各种各样的现象，如友谊网络和生态多样性，可以用交通成本来解释——在时间、精力和金钱方面——这些构成了“距离摩擦”。从这个角度来看，运输技术具有颠覆性，改变了包括移动人员和货物在内的地理实体之间的空间关系:
“运输的目的是克服空间”(Rodrigue，Comtois，and Slack 2013)。</p>
<p>运输是一个固有的空间活动，包括从一个起点‘ A’到目的地‘
B’，通过无限的位置之间。因此，交通运输研究人员长期以来一直采用地理和计算方法来理解运动模式，以及干预措施如何能够提高他们的表现，这并不令人惊讶(Lovelace
2021)。</p>
<p>本章介绍了不同地理层次运输系统的地理分析:</p>
<ul>
<li><strong>Areal units</strong>:
交通模式可以通过参考区域总量来理解，比如主要的出行方式(例如，汽车、自行车或步行)
，以及生活在特定区域的人们的平均出行距离(见第13.3节)</li>
<li><strong>Desire lines</strong>:
表示“起点-目的地”数据的直线，记录有多少人在地理空间的不同地点(点或区域)之间旅行(或可能旅行)
，这是第13.4节的主题</li>
<li><strong>Nodes</strong>:
这些是交通系统中可以代表共同起点和目的地的点，以及公共交通站点，如公共汽车站和火车站，这是第13.5节的主题</li>
<li><strong>Routes</strong>:
这些线路表示沿着路由网络沿着所需的线路和节点之间的路径。路由(可以表示为单行字符串或多个<em>短段</em>)和生成它们的<em>路由引擎</em>，在第13.6节中介绍</li>
<li><strong>Route networks</strong>:
这些代表了一个区域内的道路、路径和其他线性特征的系统，在第13.6节中有介绍。
它们可以表示为地理特征（通常是组成完整网络的短路段）或结构化为一个相互连接的图，不同段上的交通流量被运输模型师称为“流量”(Hollander
2016)。</li>
</ul>
<p>This highlights an important feature of transport systems: they are
closely linked to broader phenomena and land-use patterns.
另一个关键层次是<strong>代理</strong>，如你我以及使我们能够移动的交通工具，比如自行车和公交车。这些可以在像<a target="_blank" rel="external nofollow noopener noreferrer" href="http://www.matsim.org/">MATSim</a>和<a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/a-b-street/abstreet">A/B
Street</a>这样的软件中以计算方式表示，它们使用基于代理的建模（ABM）框架，通常具有很高的空间和时间分辨率，来表示交通系统的动态性(Horni，Nagel
和 Axhausen
2016)。尽管ABM是一种具有很大整合潜力的强大的交通研究方法，尤其是与R的空间类(Thiele
2014; Lovelace and Dumont 2016)
，但它不在本章的范围内。除了地理层次和代理之外，许多交通模型中的基本分析单位是<strong>行程</strong>，即从一个起点'A'到一个终点'B'的单一目的地之旅(Hollander
2016)。行程连接了交通系统的不同层次，并可以简单地表示为连接<em>区域</em>质心（<em>节点</em>）的地理<em>需求线</em>，或作为遵循交通<em>路线网络</em>的路线。在这种情况下，<em>代理人</em>通常是在交通网络内移动的点实体。</p>
<p>交通系统是动态的(Xie and Levinson
2011)。尽管本章的重点是交通系统的<em>地理</em>分析，但它也提供了如何使用这种方法来模拟变化情景的见解，在第13.8节中有介绍。地理交通建模的目的可以理解为以捕捉其本质的方式简化这些时空系统的复杂性。选择适当的地理分析层次可以在不失去其最重要的特征和变量的情况下，简化这种复杂性，从而实现更好的决策和更有效的干预(Hollander
2016)。</p>
<p>通常，模型被设计用来解决特定问题，比如如何提高交通系统的安全性或环境性能。因此，本章围绕一个政策情境展开，将在下一节中介绍，即：如何增加布里斯托尔市的自行车使用？第14章演示了地理计算的一个相关应用：优先考虑新自行车店的位置。章节之间有一个联系：新的和有效定位的自行车基础设施可以使人们开始骑自行车，从而增加对自行车店和当地经济活动的需求。这突出了交通系统的一个重要特点：它们与更广泛的现象和土地利用模式密切相关。</p>
<h1 id="布里斯托尔案例研究">布里斯托尔案例研究</h1>
<p>本章使用的案例研究位于英格兰西部的布里斯托尔市，距离威尔士首都加的夫约30公里以东。该地区的交通网络概览在下图中展示，图中展示了多样的交通基础设施，包括自行车、公共交通和私家车。</p>
<p>布里斯托尔是一个充满活力和多样性的城市，拥有各种各样的交通选项。从自行车道到公交线路，再到繁忙的高速公路，布里斯托尔的交通网络反映了其居民多样化的出行需求。这为进行地理和交通研究提供了一个极为丰富的背景。</p>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309051448576.png">
Bristol's transport network represented by colored lines for active
(green), public (railways, black) and private motor (red) modes of
travel. Black border lines represent the inner city boundary
(highlighted in yellow) and the larger Travel To Work Area (TTWA).</p>
<p>布里斯托尔是英格兰第十大的市议会，拥有50万人口，尽管其交通服务覆盖区域更广泛（参见13.3节）。该市拥有一个充满活力的经济体，包括航空航天、媒体、金融服务和旅游公司，以及两所主要大学。尽管布里斯托尔的人均收入较高，但也有严重贫困的地区(布里斯托尔市议会2015年)。</p>
<p>从交通角度看，布里斯托尔的铁路和公路连接非常便利，活跃出行的水平相对较高。根据<a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.gov.uk/government/statistical-data-sets/how-often-and-time-spent-walking-and-cycling-at-local-authority-level-cw010#table-cw0103">Active
People
Survey</a>，19%的市民每月至少骑一次自行车，88%的人每月至少走一次路（全国平均分别为15%和81%）。2011年的人口普查数据显示，8%的人口自行车上班，而全国平均仅为3%。</p>
<p>与许多城市一样，布里斯托尔面临严重的交通拥堵、空气质量和体力不活跃的问题。自行车出行能有效地解决这些问题：与步行相比，自行车更有可能替代汽车出行，因为其典型<a target="_blank" rel="external nofollow noopener noreferrer" href="https://en.wikipedia.org/wiki/Bicycle_performance">速度</a>为15-20
km/h，而步行为4-6 km/h。因此，布里斯托尔的<a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.bristol.gov.uk/council-and-mayor/policies-plans-and-strategies/bristol-transport-strategy">交通战略</a>对自行车出行有着雄心勃勃的计划。</p>
<p>为了强调政策考虑在交通研究中的重要性，本章旨在为那些负责让人们从汽车转向更可持续出行方式（特别是步行和自行车）的人（如交通规划师、政治家和其他利益相关者）提供证据。更广泛的目标是演示地理计算如何支持基于证据的交通规划。</p>
<p>在本章中，你将学习如何：</p>
<ul>
<li>描述城市交通行为的地理模式</li>
<li>识别支持多模式出行的关键公共交通节点</li>
<li>分析旅行"愿望线"，找出哪里有许多人驾车短途出行</li>
<li>识别鼓励少开车、多骑自行车的自行车路线位置</li>
</ul>
<p>为了在实践方面展开本章的内容，下一节将开始加载关于旅行模式的区域数据。这些区域级别的数据集虽小，但对于获取对城市整体交通系统的基本了解至关重要。</p>
<h1 id="交通区域">交通区域</h1>
<p>尽管交通系统主要基于线性特征和节点——包括路径和车站——从面数据开始通常更有意义，以将连续空间划分为可触及的单位
(Hollander
2016)。除了定义研究区域的边界（在这种情况下是布里斯托尔）之外，对交通研究人员尤为感兴趣的两种区域类型是：起源区域和目的区域。通常，相同的地理单位用于起点和目的地。然而，不同的分区系统，例如
'<a target="_blank" rel="external nofollow noopener noreferrer" href="https://data.gov.uk/dataset/workplace-zones-a-new-geography-for-workplace-statistics3">工作区</a>'，可能更适合代表在有许多'旅行吸引点'的区域内旅行目的地的增加密度
(国家统计局2014年)。</p>
<p>最简单定义研究区域的方式通常是第一个由OpenStreetMap返回的匹配边界。这可以通过诸如
<code>osmdata::getbb("Bristol", format_out = "sf_polygon",  limit = 1)</code>
的命令来完成。这返回一个 <code>sf</code> 对象（或者如果没有指定
<code>limit = 1</code>，则返回一组 <code>sf</code>
对象），代表最大匹配城市区域的范围，要么是边界框的矩形多边形，要么是一个详细的多边形边界。<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>对于布里斯托尔，返回了一个详细的多边形，由
<strong>spDataLarge</strong> 包中的 <code>bristol_region</code>
对象表示。请参见上图中的内部蓝色边界：这种方法有几个问题：</p>
<ul>
<li>第一个由OSM返回的OSM边界可能不是当地政府使用的官方边界</li>
<li>即使OSM返回官方边界，这也可能不适合交通研究，因为它们与人们的旅行路线关系不大</li>
</ul>
<p>工作通勤区域（TTWAs）通过创建一个类似于水文流域的分区系统来解决这些问题。TTWAs最初被定义为连续区域，在其中75%的人口前往工作(Coombes,
Green, and Openshaw
1986)，这是本章使用的定义。由于布里斯托尔是一个主要的雇主，吸引了周边城镇的旅行，因此其TTWA比城市界限要大得多（见上图）。代表这一以交通为导向的边界的多边形存储在由章节开始时加载的
<strong>spDataLarge</strong> 包提供的 <code>bristol_ttwa</code>
对象中。</p>
<p>本章使用的起点和终点区域是相同的：官方定义的中等地理分辨率区域（它们的<a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.ons.gov.uk/peoplepopulationandcommunity/populationandmigration/populationestimates/bulletins/annualsmallareapopulationestimates/2014-10-23">官方</a>名称是中层超级输出区域或MSOAs）。
每个区域大约有8,000人。这种行政区域可以为交通分析提供重要的背景信息，例如可能最受特定干预措施影响的人群类型(例如,
Moreno-Monroy, Lovelace, and Ramos 2017)。</p>
<p>这些区域的地理分辨率很重要：小区域具有高地理分辨率通常更可取，但它们在大区域中的高数量可能对处理（尤其是对于起点-终点分析，在其中可能性作为区域数量的非线性函数增加）有影响
(Hollander 2016)。</p>
<blockquote>
<p>📌与小区域相关的另一个问题与匿名规则有关。为了使在区域内无法推断个人身份，详细社会人口统计变量通常仅在低地理分辨率下可用。例如，旅行方式的年龄和性别细分在英国的地方当局层面上可用，但不在更高的输出区域层面上，其中每个区域大约包含100户家庭。有关更多详细信息，请参阅
www.ons.gov.uk/methodology/geography。</p>
</blockquote>
<p>本章中使用的102个区域存储在 <code>bristol_zones</code>
中，如下图所示。注意，在人口密集地区，区域变得更小：每个区域都有类似数量的人。<code>bristol_zones</code>
不包含关于交通的属性数据，只有每个区域的名称和代码：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">names</span><span class="punctuation">(</span>bristol_zones<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] &quot;geo_code&quot; &quot;name&quot;     &quot;geometry&quot;</span></span><br></pre></td></tr></table></figure>
<p>为了添加旅行数据，我们将执行<em>属性连接</em>，这是在<em>矢量属性连接</em>节中描述的常见任务。我们将使用来自英国2011年人口普查关于工作通勤的问题的旅行数据，该数据存储在
<code>bristol_od</code> 中，由 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.ons.gov.uk/help/localstatistics">ons.gov.uk</a>
数据门户提供。<code>bristol_od</code>
是一个关于英国2011年人口普查中各区域间通勤旅行的起点-终点（OD）数据集。第一列是起始区域的ID，第二列是目的区域。<code>bristol_od</code>
的行数比 <code>bristol_zones</code>
多，代表的是区域<em>之间</em>的旅行，而不是区域本身：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nrow<span class="punctuation">(</span>bristol_od<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] 2910</span></span><br><span class="line">nrow<span class="punctuation">(</span>bristol_zones<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] 102</span></span><br></pre></td></tr></table></figure>
<p>前一个代码块的结果显示，每个区域有超过10个起点-终点（OD）对，这意味着在将其与
<code>bristol_zones</code>
进行连接之前，我们需要对起点-终点数据进行聚合，如下图所示 ：
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zones_attr <span class="operator">=</span> bristol_od <span class="operator">|&gt;</span> </span><br><span class="line">  group_by<span class="punctuation">(</span>o<span class="punctuation">)</span> <span class="operator">|&gt;</span> </span><br><span class="line">  summarize<span class="punctuation">(</span>across<span class="punctuation">(</span>where<span class="punctuation">(</span><span class="built_in">is.numeric</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">sum</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">|&gt;</span> </span><br><span class="line">  dplyr<span class="operator">::</span>rename<span class="punctuation">(</span>geo_code <span class="operator">=</span> o<span class="punctuation">)</span></span><br></pre></td></tr></table></figure></p>
<p>前面的代码块执行了以下操作：</p>
<ul>
<li>按照起点区域（包含在<code>o</code>列中）对数据进行了分组</li>
<li><em>如果</em>在<code>bristol_od</code>
数据集中的变量是数值型的，就对它们进行了聚合，以找出每个区域中按交通方式分布的人口总数<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a></li>
<li>将分组变量<code>o</code>重命名，使其与<code>bristol_zones</code>对象中的ID列<code>geo_code</code>匹配</li>
</ul>
<p>由此产生的对象<code>zones_attr</code>是一个数据框，其行代表各个区域和一个ID变量。我们可以使用<code>%in%</code>操作符验证这些ID是否与<code>zones</code>数据集中的ID匹配，操作如下：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">summary<span class="punctuation">(</span>zones_attr<span class="operator">$</span>geo_code <span class="operator">%in%</span> bristol_zones<span class="operator">$</span>geo_code<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt;    Mode    TRUE </span></span><br><span class="line"><span class="comment">#&gt; logical     102</span></span><br></pre></td></tr></table></figure>
<p>结果显示，新对象中包含所有102个区域，而<code>zone_attr</code>具有可以与区域连接的形式<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>。这是通过使用连接函数
<code>left_join()</code>
来完成的（注意，在这里<code>inner_join()</code>也会产生相同的结果）。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">zones_joined <span class="operator">=</span> left_join<span class="punctuation">(</span>bristol_zones<span class="punctuation">,</span> zones_attr<span class="punctuation">,</span> by <span class="operator">=</span> <span class="string">&quot;geo_code&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="built_in">sum</span><span class="punctuation">(</span>zones_joined<span class="operator">$</span><span class="built_in">all</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] 238805</span></span><br><span class="line"><span class="built_in">names</span><span class="punctuation">(</span>zones_joined<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] &quot;geo_code&quot;   &quot;name&quot;       &quot;all&quot;        &quot;bicycle&quot;    &quot;foot&quot;      </span></span><br><span class="line"><span class="comment">#&gt; [6] &quot;car_driver&quot; &quot;train&quot;      &quot;geometry&quot;</span></span><br></pre></td></tr></table></figure>
<p>结果是<code>zones_joined</code>，它包含新的列，代表研究区域内每个区域起始的总出行次数（接近四分之一百万次）以及它们的出行方式（自行车、步行、汽车和火车）。出行起点的地理分布在下图的左侧地图中有所体现。这显示了大多数区域在研究区内有0至4000次的出行起始。生活在布里斯托尔市中心附近的人进行的出行次数更多，而在城市边缘的则较少。这是为什么呢？记住我们只在研究区域内处理出行：边缘区域低出行次数可以归因于这些周边区域的许多人会前往研究区域之外的其他地区。通过一个特殊的目的地ID，研究区域之外的出行可以被包括在区域模型中，该ID涵盖了任何前往模型中未表示的区域的出行(Hollander
2016)。然而，<code>bristol_od</code>中的数据简单地忽略了这样的出行：它是一个“区域内”的模型。</p>
<p>与OD（出发-目的地）数据集可以聚合到出发区域的方式相同，它们也可以被聚合以提供关于目的地区域的信息。人们倾向于聚集在中心地区。这解释了为什么下图右侧面板中表示的空间分布相对不均匀，最常见的目的地区域集中在布里斯托尔市中心。结果是<code>zones_od</code>，其中包含一个新列，报告了任何出行方式的目的地数量，如下所创建：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">zones_destinations <span class="operator">=</span> bristol_od <span class="operator">|&gt;</span> </span><br><span class="line">  group_by<span class="punctuation">(</span>d<span class="punctuation">)</span> <span class="operator">|&gt;</span> </span><br><span class="line">  summarize<span class="punctuation">(</span>across<span class="punctuation">(</span>where<span class="punctuation">(</span><span class="built_in">is.numeric</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">sum</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">|&gt;</span> </span><br><span class="line">  select<span class="punctuation">(</span>geo_code <span class="operator">=</span> d<span class="punctuation">,</span> all_dest <span class="operator">=</span> <span class="built_in">all</span><span class="punctuation">)</span></span><br><span class="line">zones_od <span class="operator">=</span> inner_join<span class="punctuation">(</span>zones_joined<span class="punctuation">,</span> zones_destinations<span class="punctuation">,</span> by <span class="operator">=</span> <span class="string">&quot;geo_code&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>下面的代码创建了一个简化版本的下图（参见书籍GitHub仓库的 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/geocompx/geocompr/tree/main/code"><code>code</code></a>
文件夹中的 <code>12-zones.R</code>
文件以重现该图，以及有关使用<strong>tmap</strong>创建分面地图的详细信息）：
<!-- toDo: rl   --> <!-- qtm does not exist... --></p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">qtm<span class="punctuation">(</span>zones_od<span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;all&quot;</span><span class="punctuation">,</span> <span class="string">&quot;all_dest&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  tm_layout<span class="punctuation">(</span>panel.labels <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;Origin&quot;</span><span class="punctuation">,</span> <span class="string">&quot;Destination&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309051544306.png">
Number of trips (commuters) living and working in the region. The left
map shows zone of origin of commute trips; the right map shows zone of
destination (generated by the script 13-zones.R).</p>
<h1 id="欲望线">欲望线</h1>
<p>欲望线连接起点和终点，表示人们<em>想要</em>去的地方，通常是在各个区域之间。它们代表了从A点到B点最快的“直线”或“鸟飞”路线，如果没有建筑物和弯曲道路的阻碍的话（我们将在下一节看到如何将欲望线转化为实际路线）。通常，欲望线在地理上表示为每个区域的地理（或人口加权）中心的起点和终点。这是我们将在本节中创建和使用的欲望线类型，尽管值得注意的是，“抖动”技术能够增加多个起点和终点，以提高基于OD数据构建的分析的空间覆盖和准确性
(Lovelace，Félix 和 Carlino 2022)。</p>
<p>我们已经在数据集<code>bristol_od</code>中加载了代表欲望线的数据。这个起点-终点（OD）数据框对象表示在<code>o</code>和<code>d</code>所代表的区域之间旅行的人数，如下表所示。要按所有旅行对OD数据进行排序，然后只过滤出前5名，请输入：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">od_top5 <span class="operator">=</span> bristol_od <span class="operator">|&gt;</span> </span><br><span class="line">  slice_max<span class="punctuation">(</span><span class="built_in">all</span><span class="punctuation">,</span> n <span class="operator">=</span> <span class="number">5</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<table>
<caption>Sample of the top 5 origin-destination pairs in the Bristol OD
data frame, representing travel desire lines between zones in the study
area.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">o</th>
<th style="text-align: left;">d</th>
<th style="text-align: right;">all</th>
<th style="text-align: right;">bicycle</th>
<th style="text-align: right;">foot</th>
<th style="text-align: right;">car_driver</th>
<th style="text-align: right;">train</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">E02003043</td>
<td style="text-align: left;">E02003043</td>
<td style="text-align: right;">1493</td>
<td style="text-align: right;">66</td>
<td style="text-align: right;">1296</td>
<td style="text-align: right;">64</td>
<td style="text-align: right;">8</td>
</tr>
<tr class="even">
<td style="text-align: left;">E02003047</td>
<td style="text-align: left;">E02003043</td>
<td style="text-align: right;">1300</td>
<td style="text-align: right;">287</td>
<td style="text-align: right;">751</td>
<td style="text-align: right;">148</td>
<td style="text-align: right;">8</td>
</tr>
<tr class="odd">
<td style="text-align: left;">E02003031</td>
<td style="text-align: left;">E02003043</td>
<td style="text-align: right;">1221</td>
<td style="text-align: right;">305</td>
<td style="text-align: right;">600</td>
<td style="text-align: right;">176</td>
<td style="text-align: right;">7</td>
</tr>
<tr class="even">
<td style="text-align: left;">E02003037</td>
<td style="text-align: left;">E02003043</td>
<td style="text-align: right;">1186</td>
<td style="text-align: right;">88</td>
<td style="text-align: right;">908</td>
<td style="text-align: right;">110</td>
<td style="text-align: right;">3</td>
</tr>
<tr class="odd">
<td style="text-align: left;">E02003034</td>
<td style="text-align: left;">E02003043</td>
<td style="text-align: right;">1177</td>
<td style="text-align: right;">281</td>
<td style="text-align: right;">711</td>
<td style="text-align: right;">100</td>
<td style="text-align: right;">7</td>
</tr>
</tbody>
</table>
<p>生成的表格提供了关于布里斯托尔通勤（上班往返）出行模式的快照。它表明，在前5大起点-终点（OD）组合中，步行是最受欢迎的出行方式，而<code>E02003043</code>
区域是一个受欢迎的目的地（布里斯托尔市中心，所有前5大OD组合的目的地），并且<em>区内</em>
出行，从<code>E02003043</code>
区域的一个部分到另一个部分（表的第一行），是数据集中出行最多的OD组合。但从政策角度看，表中呈现的原始数据用处有限：除了它仅包含了2,910个OD组合中的一小部分之外，它几乎没有告诉我们<em>在哪里</em>需要政策措施，或者<em>有多少比例</em>的出行是通过步行和骑自行车完成的。
以下命令计算了由这些积极模式完成的每条欲望线的百分比：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bristol_od<span class="operator">$</span>Active <span class="operator">=</span> <span class="punctuation">(</span>bristol_od<span class="operator">$</span>bicycle <span class="operator">+</span> bristol_od<span class="operator">$</span>foot<span class="punctuation">)</span> <span class="operator">/</span></span><br><span class="line">  bristol_od<span class="operator">$</span><span class="built_in">all</span> <span class="operator">*</span> <span class="number">100</span></span><br></pre></td></tr></table></figure>
<p>有两种主要类型的OD（起点-终点）组合：<em>区间（Interzonal）</em> 和
<em>区内（Intrazonal）</em>。区间的OD组合代表了目的地与起点不同区域之间的出行。区内的OD组合代表了在同一区域内的出行（参见表的顶行）。以下代码块将
<code>od_bristol</code> 分为这两种类型：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">od_intra <span class="operator">=</span> filter<span class="punctuation">(</span>bristol_od<span class="punctuation">,</span> o <span class="operator">==</span> d<span class="punctuation">)</span></span><br><span class="line">od_inter <span class="operator">=</span> filter<span class="punctuation">(</span>bristol_od<span class="punctuation">,</span> o <span class="operator">!=</span> d<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>下一步是将区间（interzonal）的OD组合转换为一个表示“欲望线（desire
lines）”的<code>sf</code>对象，这可以通过使用 <strong>stplanr</strong>
函数 <code>od2line()</code> 来在地图上进行绘制。<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a></p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">desire_lines <span class="operator">=</span> od2line<span class="punctuation">(</span>od_inter<span class="punctuation">,</span> zones_od<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; Creating centroids representing desire line start and end points.</span></span><br></pre></td></tr></table></figure>
<p>下图展示了结果的示例，其简化版本可以通过以下命令创建（要完全复制该图形，请查看
<code>13-desire.R</code> 中的代码，有关使用 <strong>tmap</strong>
进行可视化的详细信息，请参见章节<em>高级制图</em>）：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qtm<span class="punctuation">(</span>desire_lines<span class="punctuation">,</span> lines.lwd <span class="operator">=</span> <span class="string">&quot;all&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309051558946.png">
Desire lines representing trip patterns in Bristol, with width
representing number of trips and color representing the percentage of
trips made by active modes (walking and cycling). The four black lines
represent the interzonal OD pairs in Table 7.1.</p>
<p>该地图显示，市中心主导了该地区的交通模式，这暗示政策应当优先考虑这里，尽管也可以看到一些边缘的次中心。欲望线是交通系统中重要的概括性组成部分。更具体的组成部分包括节点，这些节点有特定的目的地（而不是欲望线中所表示的假设直线）。下一节将涵盖节点。</p>
<h1 id="节点">节点</h1>
<p>在地理交通数据集中，节点是组成交通网络的主要线性特征之间的点。大致上，有两种主要类型的交通节点：</p>
<ol type="1">
<li>不直接位于网络上的节点，例如区域质心或个体的起点和终点（如住宅和工作场所）。</li>
<li>是交通网络一部分的节点。
从技术上讲，一个节点可以位于交通网络上的任何点，但实际上它们通常是特殊类型的顶点，例如路径（交叉口）之间的交点和进入或退出交通网络的点，如公交站和火车站[^13-transport-6]。</li>
</ol>
<p>交通网络可以表示为图形，其中每个段通过地理线（代表边）与网络中的一个或多个其他边相连。可以通过“质心连接器”添加网络之外的节点，这些新的路线段连接到网络上附近的节点(Hollander
2016)[^13-transport-7]。网络中的每个节点然后通过一个或多个代表网络上个别段的“边”进行连接。我们将在<em>路线网络</em>节中看到如何将交通网络表示为图。</p>
<p>公共交通站点是特别重要的节点，可以表示为两种类型的节点：是道路的一部分的公交站，或由距离铁路轨道数百米的行人入口点代表的大型铁路站。我们将使用火车站来说明与布里斯托尔市增加自行车使用相关的公共交通节点。这些站由
<strong>spDataLarge</strong> 在 <code>bristol_stations</code>
中提供。</p>
<p>一个常见的障碍是，从家到工作的距离太远，无法步行或骑自行车。公共交通可以通过为进入城市的常见路线提供快速和高容量的选择来减少这一障碍。从积极出行的角度来看，长途旅行的公共交通“腿”将旅行分为三部分：</p>
<ul>
<li>起点腿，通常从住宅区到公共交通站</li>
<li>公共交通腿，通常从离旅行起点最近的站到离目的地最近的站</li>
<li>目的地腿，从下车站到目的地</li>
</ul>
<p>在<em>欲望线</em>节进行的分析的基础上，公共交通节点可用于为可乘坐公共汽车和（在本例中使用的）火车的旅行构建三部分欲望线。第一阶段是确定具有最多公共交通出行的欲望线，在我们的情况下这很容易，因为我们之前创建的数据集
<code>desire_lines</code> 已经包含了描述火车旅行数量的变量（也可以使用如
<a target="_blank" rel="external nofollow noopener noreferrer" href="http://www.opentripplanner.org/">OpenTripPlanner</a>
等公共交通路线服务来估计公共交通潜力）。为了使该方法更容易遵循，我们将仅选择关于铁路使用方面的前三条欲望线。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">desire_rail <span class="operator">=</span> top_n<span class="punctuation">(</span>desire_lines<span class="punctuation">,</span> n <span class="operator">=</span> <span class="number">3</span><span class="punctuation">,</span> wt <span class="operator">=</span> train<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>现在的挑战是将每一条这样的线分解为三部分，代表通过公共交通节点的出行。这可以通过将一条欲望线转换为一个由三个线几何体组成的多线字符串对象来实现，这三个线几何体分别代表行程的起点、公共交通和终点阶段。这个操作可以分为三个阶段：矩阵创建（代表起点、终点和表示铁路站的“途经”点）、最近邻标识和转换为多线字符串。这些都由<code>line_via()</code>函数来完成。这个<strong>stplanr</strong>函数接受输入线和点，并返回一份欲望线的副本——具体细节请参见<a target="_blank" rel="external nofollow noopener noreferrer" href="https://docs.ropensci.org/stplanr/reference/line_via.html"><code>?line_via()</code></a>。
输出与输入线相同，只不过它有新的几何列，代表通过公共交通节点的行程，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ncol<span class="punctuation">(</span>desire_rail<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] 9</span></span><br><span class="line">desire_rail <span class="operator">=</span> line_via<span class="punctuation">(</span>desire_rail<span class="punctuation">,</span> bristol_stations<span class="punctuation">)</span></span><br><span class="line">ncol<span class="punctuation">(</span>desire_rail<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] 12</span></span><br></pre></td></tr></table></figure>
<p>如下图所示，初始的 <code>desire_rail</code>
线现在有三个额外的几何列表列，分别代表从家到起点站、从那里到目的地，以及最后从目的地站到目的地的旅行。在这种情况下，目的地段非常短（步行距离），但起点段可能足够远，以证明需要在骑行基础设施上进行投资，以鼓励人们在上班途中到居住区周围的三个起点站骑自行车，如下图所示。</p>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309051613261.png">
Station nodes (red dots) used as intermediary points that convert
straight desire lines with high rail usage (thin green lines) into three
legs: to the origin station (orange) via public transport (blue) and to
the destination (pink, not visible because it is so short).</p>
<h1 id="路线">路线</h1>
<p>从地理角度看，路线是不再直线的需求线：起点和终点与旅行的需求线表示相同，但从A到B的路径更为复杂。路线的几何形状通常（但不总是）由交通网络决定。</p>
<p>虽然需求线仅包含两个顶点（其起点和终点），但路线可以包含任意数量的顶点，代表由直线连接的A和B之间的点：这就是linestring几何形状的定义。覆盖大距离或遵循复杂网络的路线可能有数百个顶点；基于网格或简化道路网络的路线通常较少。</p>
<p>路线是由需求线生成的，或更常见地，由包含代表需求线的坐标对的矩阵生成。这个路由过程是由一系列广义定义的<em>路由引擎</em>完成的：软件和Web服务，它们返回描述如何从起点到终点的几何形状和属性。根据它们相对于R运行的<em>位置</em>，路由引擎可以被分类为：</p>
<ul>
<li>内存路由，使用使路线计算成为可能的R包</li>
<li>本地托管的、外部于R的路由引擎，可以从R中调用</li>
<li>由外部实体远程托管的路由引擎，提供一个可以从R中调用的Web API</li>
</ul>
<p>在描述每一个之前，值得概述分类路由引擎的其他方式。路由引擎可以是多模式的，意味着它们可以计算由多种交通方式组成的行程，或者不是。多模式路由引擎可以返回由不同交通方式组成的多个<em>段</em>的结果。从住宅区到商业区的最佳路线可能涉及1）步行到最近的公交车站，2）乘公交车到离目的地最近的节点，以及3）步行到目的地，给定一组输入参数。这三段之间的转换点通常被称为“进入”和“出口”，意味着上下公共交通工具。像R5这样的多模式路由引擎比如OSRM这样的'单一模式'路由引擎更为复杂，并且有更大的输入数据要求。</p>
<p>多模式引擎的一个主要优势是它们能够表示由火车、公共汽车等组成的“公共交通”行程。多模型路由引擎需要代表公共交通网络的输入数据集，通常以General
Transit Feed Specification（<a target="_blank" rel="external nofollow noopener noreferrer" href="https://developers.google.com/transit/gtfs">GTFS</a>）文件形式，这些可以用<a target="_blank" rel="external nofollow noopener noreferrer" href="https://r-transit.github.io/tidytransit/index.html"><strong>tidytransit</strong></a>和<a target="_blank" rel="external nofollow noopener noreferrer" href="https://ipeagit.github.io/gtfstools/"><strong>gtfstools</strong></a>包（也有其他用于处理GTFS文件的包和工具）中的函数进行处理。对于专注于特定（非公共）交通方式的项目，单一模式路由引擎可能就足够了。另一种分类路由引擎（或设置）的方式是通过输出的地理级别：路线、段和环节。</p>
<h2 id="路线段和环节">路线、段和环节</h2>
<p>路由引擎可以在三个地理级别生成输出：路线、段和环节：</p>
<ul>
<li><strong>路线</strong>级别的输出每个起点-终点对包含一个单一特征（通常是数据框表示中的多线几何和关联行），意味着每次行程的数据有一行。</li>
<li><strong>段</strong>级别的输出在每个起点-终点对内的每个<em>模式</em>都包含一个单一特征和相关属性。对于仅涉及一种模式的行程（例如，从家到工作的驾驶，忽略走到汽车的短距离），段与路线相同：即汽车行程。对于涉及公共交通的行程，段提供关键信息。<strong>r5r</strong>函数<code>detailed_itineraries()</code>返回的段有时令人困惑地被称为“环节”。</li>
<li>环节级别的输出提供了有关路线的最详细信息，具有交通网络的每个小段的记录。通常，环节在长度上类似于，或与，OpenStreetMap中的道路相同。<strong>cyclestreets</strong>函数<code>journey()</code>返回在环节级别的数据，这些数据可以通过对<strong>stplanr</strong>中<code>route()</code>函数返回的起点和终点级别数据进行分组而聚合。</li>
</ul>
<p>大多数路由引擎默认返回路线级别的输出，尽管多模式引擎通常在段级别提供输出（每个连续运动的单一交通模式一个特征）。
环节级别的输出有提供更多细节的优点。
<strong>cyclestreets</strong>包返回每条路线的多个“安静度”级别，使得可以识别自行车网络中的“最薄弱环节”。
环节级别输出的劣势包括增加的文件大小和与额外细节相关的复杂性。</p>
<p>使用函数<code>stplanr::overline()</code><span class="citation" data-cites="morgan_travel_2020">[@morgan_travel_2020]</span>，路线级别的结果可以转换为环节级别的结果。在使用环节或段级别的数据时，通过对表示行程起点和终点的列进行分组，并汇总/聚合包含环节级别数据的列，可以返回路线级别的统计数据。</p>
<h2 id="使用r进行内存内路由">使用R进行内存内路由</h2>
<p>R中的路由引擎允许将存储为R对象的<em>内存内</em>路由网络用作路由计算的基础。选项包括<a target="_blank" rel="external nofollow noopener noreferrer" href="https://luukvdmeer.github.io/sfnetworks/"><strong>sfnetworks</strong></a>、<a target="_blank" rel="external nofollow noopener noreferrer" href="https://atfutures.github.io/dodgr/"><strong>dodgr</strong></a> 和
<a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/vlarmet/cppRouting"><strong>cppRouting</strong></a>
包，每个包都提供了它们自己的类系统来表示路由网络，这是下一节的主题。</p>
<p>尽管快速和灵活，使用原生R的路由选项通常比用于现实路由计算的专用路由引擎更难设置。路由是一个复杂问题，开源路由引擎已经投入了很多时间，这些引擎可以下载并在本地主机上运行。另一方面，基于R的路由引擎可能非常适用于模型实验和网络上变化影响的统计分析。在单一语言中更改路由网络特性（或与不同路由段类型相关联的权重）、重新计算路由和分析多个场景下的结果对研究应用有益。</p>
<h2 id="本地托管的专用路由引擎">本地托管的专用路由引擎</h2>
<p><strong>本地托管</strong>的路由引擎包括OpenTripPlanner、<a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/valhalla/valhalla">Valhalla</a>
和R5（它们是多模式的），以及OpenStreetMap路由机器（OSRM）（它是“单模式”的）。这些可以通过<strong>opentripplanner</strong>、<a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/chris31415926535/valhallr"><strong>valhalla</strong></a>、<strong>r5r</strong>
和 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/riatelab/osrm"><strong>osrm</strong></a>
包从R中访问(Morgan 等，2019; Pereira
等，2021)。本地托管的路由引擎在用户的计算机上运行，但在一个与R分开的进程中。它们的优点包括执行速度和对不同运输模式的权重配置文件的控制。劣势包括在本地表示复杂网络的困难；时间动态（主要是由于交通）；以及需要专用外部软件。</p>
<h2 id="远程托管的专用路由引擎">远程托管的专用路由引擎</h2>
<p><strong>远程托管</strong>的路由引擎使用web
API发送有关起点和终点的查询并返回结果。基于开源路由引擎的路由服务，例如OSRM的公开可用服务，在从R调用时与本地托管实例的工作方式相同，只需更新指定“基础URL”的参数即可。然而，由于外部路由服务托管在专用机器上（通常由有激励生成准确路由的商业公司资助），这可能给它们带来优势，包括：</p>
<ul>
<li>提供全球（或通常至少在大区域内）的路由服务</li>
<li>已建立的路由服务通常会定期更新，并且经常能够响应交通水平</li>
<li>路由服务通常在专用硬件和软件上运行，包括像负载均衡器这样的系统以确保性能稳定</li>
</ul>
<p>远程路由服务的劣势包括批量作业不可能时的速度（它们通常依赖于一条条路由的基础上通过互联网进行数据传输）、价格（例如，谷歌路由API限制了免费查询的数量）和许可问题。</p>
<p><a target="_blank" rel="external nofollow noopener noreferrer" href="http://symbolixau.github.io/googleway/"><strong>googleway</strong></a>
和 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://walker-data.com/mapboxapi/articles/navigation.html"><strong>mapbox</strong></a>
包通过提供对Google和Mapbox的路由服务的访问来展示这种方法。免费（但有速率限制）的路由服务包括
<a target="_blank" rel="external nofollow noopener noreferrer" href="http://project-osrm.org/">OSRM</a> 和 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://openrouteservice.org/">openrouteservice.org</a>，它们可以通过
<a target="_blank" rel="external nofollow noopener noreferrer" href="https://rgeomatic.hypotheses.org/category/osrm"><strong>osrm</strong></a>
和 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/GIScience/openrouteservice-r"><strong>openrouteservice</strong></a>
包从R中访问，后者不在CRAN上。还有更具体的路由服务，例如由 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.cyclestreets.net/">CycleStreets.net</a>
提供的，这是一个自行车旅行规划器和非营利性交通技术公司“为骑自行车者，由骑自行车者”。虽然R用户可以通过
<a target="_blank" rel="external nofollow noopener noreferrer" href="https://rpackage.cyclestreets.net/"><strong>cyclestreets</strong></a>
包访问CycleStreets路由，但许多路由服务缺乏R接口，这代表了一个巨大的软件包开发机会：构建一个R包以提供一个接口到web
API可能是一种有益的经历。</p>
<p>R包用于计算和导入代表交通网络上路由的数据的广泛范围是一种优势，这意味着该语言近年来越来越多地用于交通研究。然而，这种包和方法的激增的一个小缺点是有很多包和函数名称需要记住。
<strong>stplanr</strong> 包通过提供一个用于生成路由的统一接口
<code>route()</code>
函数来解决这个问题。该函数接受广泛的输入，包括地理欲望线（使用
<code>l =</code>
参数）、坐标甚至表示独特地址的文本字符串，并返回作为一致 <code>sf</code>
对象的路由数据。</p>
<!-- TODO: 在某个时候我希望创建一个专用的路由包，如果它被创建了，请提及（RL 2022-07） -->
<h2 id="路径规划一个实际示例">路径规划：一个实际示例</h2>
<p>与其对部分生成的<em>所有</em>期望线进行路径规划，我们专注于高度政策相关的一个子集。在尝试处理整个数据集之前，先对一个子集进行计算密集型操作通常是明智的，这同样适用于路径规划。路径规划可能需要消耗大量时间和内存，并生成大型对象，这是因为路线对象的详细几何形状和额外属性。因此，我们将在本节中过滤期望线，然后计算路径。</p>
<p>当骑行替代开车出行时，效益最大。短距离（大约5公里，以20公里/小时的速度可以在15分钟内骑完）有相对较高的被骑行的概率，当使用<a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.sciencedirect.com/science/article/pii/S0967070X21003401">电动自行车</a>进行出行时，最大距离会增加(Lovelace
等，2017)。以下代码片段考虑了这些因素，过滤了期望线，并返回了表示OD对（起点到终点对）的对象
<code>desire_lines_short</code>，在这些OD对之间有很多（100+）短距离（2.5至5公里的欧几里得距离）的车程：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">desire_lines<span class="operator">$</span>distance_km <span class="operator">=</span> <span class="built_in">as.numeric</span><span class="punctuation">(</span>st_length<span class="punctuation">(</span>desire_lines<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">/</span> <span class="number">1000</span></span><br><span class="line">desire_lines_short <span class="operator">=</span> desire_lines <span class="operator">|&gt;</span> </span><br><span class="line">  filter<span class="punctuation">(</span>car_driver <span class="operator">&gt;=</span> <span class="number">100</span><span class="punctuation">,</span> distance_km <span class="operator">&lt;=</span> <span class="number">5</span><span class="punctuation">,</span> distance_km <span class="operator">&gt;=</span> <span class="number">2.5</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，<code>st_length()</code>
计算了每个期望线的长度。<strong>dplyr</strong> 的 <code>filter()</code>
函数基于上述标准过滤了 <code>desire_lines</code>
数据集。下一步是将这些期望线转换为路线。这是通过下面的代码块中使用公开可用的OSRM服务和
<strong>stplanr</strong> 的 <code>route()</code> 和
<code>route_osrm()</code> 函数来完成的：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">routes_short <span class="operator">=</span> route<span class="punctuation">(</span>l <span class="operator">=</span> desire_lines_short<span class="punctuation">,</span> route_fun <span class="operator">=</span> route_osrm<span class="punctuation">,</span></span><br><span class="line">                     osrm.profile <span class="operator">=</span> <span class="string">&quot;bike&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>输出是
<code>routes_short</code>，一个代表适用于骑自行车的交通网络上的路线的
<code>sf</code> 对象（至少根据 OSRM
路由引擎是这样），每个期望线对应一个。注意：像上面的命令中那样调用外部路由引擎只有在有互联网连接的情况下才能工作（有时还需要存储在环境变量中的
API 密钥，尽管在这种情况下不需要）。除了 <code>desire_lines</code>
对象中包含的列之外，新的路线数据集还包含
<code>distance</code>（这次是指路线距离）和
<code>duration</code>（以秒为单位）列，这些提供了有关每条路线性质的潜在有用额外信息。我们将绘制沿着这些线路进行许多短途汽车行驶的期望线和骑行路线。通过使路线的宽度与可能被替换的汽车行驶数量成比例，提供了一种有效的方式来优先考虑对道路网络进行干预(Lovelace
等 2017)。
下面的代码块绘制了期望线和路线，该图显示了人们驾驶短距离的路线：<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a></p>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309051636508.png">
Routes along which many (100+) short (&lt;5km Euclidean distance) car
journeys are made (red) overlaying desire lines representing the same
trips (black) and zone centroids (dots).</p>
<p>通过在交互式地图上绘制结果，例如使用
<code>mapview::mapview(st_geometry(routes_short))</code>，可以看到许多短途汽车行程发生在布拉德利斯托克（Bradley
Stoke）及其周围，距离布里斯托尔（Bristol）市中心大约10公里以北。找出该地区高度依赖汽车的原因很容易：根据<a target="_blank" rel="external nofollow noopener noreferrer" href="https://en.wikipedia.org/wiki/Bradley_Stoke">维基百科</a>，布拉德利斯托克是“欧洲最大的由私人投资建设的新城镇”，这暗示了有限的公共交通供应。此外，该城镇被包括M4和M5高速公路在内的大型（对自行车不友好）的道路结构所环绕（tallon
2007)。</p>
<p>将旅行需求线转换为路线有很多好处。重要的是要记住，我们不能确定有多少（如果有的话）行程会沿着路由引擎计算出的确切路线进行。然而，路线和街道/道路/段级别的结果可能具有很高的政策相关性。路段结果可以根据可用数据(Lovelace
等 2017)，实现在最需要的地方优先进行投资。</p>
<h1 id="路线网络">路线网络</h1>
<p>虽然路线通常包含有关旅行<em>行为</em>的数据，在与需求线和OD（起点-终点）对相同的地理层级上，路线网络数据集通常代表物理交通网络。路线网络中的每个<em>段</em>大致对应于交叉口之间的连续街道段，并且只出现一次，尽管段的平均长度取决于数据源（本节中使用的由OSM（开放街道地图）派生的<code>bristol_ways</code>数据集中的段平均长度刚好超过200米，标准差接近500米）。段长度的可变性可以由这样一个事实来解释：在一些农村地区，交叉口相距很远，而在密集的城市区域，每隔几米就有交叉口和其他段的断点。</p>
<p>路线网络可以是交通数据分析项目的输入或输出，或者两者都是。任何涉及路线计算的交通研究都需要内部或外部路由引擎中的路线网络数据集（在后一种情况下，路线网络数据不一定需要导入到R中）。然而，路线网络在许多交通研究项目中也是重要的输出：总结诸如特定段上可能进行的潜在行程数量的数据，并以路线网络的形式表示，可以帮助在最需要的地方优先进行投资。</p>
<p>为了演示如何从路线级别的数据中创建路线网络作为输出，想象一个简单的模式转移场景。假设0到3公里的路线距离之间的50%的汽车行程被自行车取代，这一百分比每增加1公里的路线距离就减少10个百分点，以至于6公里的汽车行程有20%被自行车取代，而8公里或更长的汽车行程没有被自行车取代。当然，这是一个不现实的情景(Lovelace
等 2017)，但它是一个有用的起点。
在这种情况下，我们可以按照以下方式模拟从汽车到自行车的模式转移：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">uptake <span class="operator">=</span> <span class="keyword">function</span><span class="punctuation">(</span>x<span class="punctuation">)</span> <span class="punctuation">&#123;</span></span><br><span class="line">  case_when<span class="punctuation">(</span></span><br><span class="line">    x <span class="operator">&lt;=</span> <span class="number">3</span> <span class="operator">~</span> <span class="number">0.5</span><span class="punctuation">,</span></span><br><span class="line">    x <span class="operator">&gt;=</span> <span class="number">8</span> <span class="operator">~</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="literal">TRUE</span> <span class="operator">~</span> <span class="punctuation">(</span><span class="number">8</span> <span class="operator">-</span> x<span class="punctuation">)</span> <span class="operator">/</span> <span class="punctuation">(</span><span class="number">8</span> <span class="operator">-</span> <span class="number">3</span><span class="punctuation">)</span> <span class="operator">*</span> <span class="number">0.5</span></span><br><span class="line">  <span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line">routes_short_scenario <span class="operator">=</span> routes_short <span class="operator">|&gt;</span> </span><br><span class="line">  mutate<span class="punctuation">(</span>uptake <span class="operator">=</span> uptake<span class="punctuation">(</span>distance <span class="operator">/</span> <span class="number">1000</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">|&gt;</span> </span><br><span class="line">  mutate<span class="punctuation">(</span>bicycle <span class="operator">=</span> bicycle <span class="operator">+</span> car_driver <span class="operator">*</span> uptake<span class="punctuation">,</span></span><br><span class="line">         car_driver <span class="operator">=</span> car_driver <span class="operator">*</span> <span class="punctuation">(</span><span class="number">1</span> <span class="operator">-</span> uptake<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="built_in">sum</span><span class="punctuation">(</span>routes_short_scenario<span class="operator">$</span>bicycle<span class="punctuation">)</span> <span class="operator">-</span> <span class="built_in">sum</span><span class="punctuation">(</span>routes_short<span class="operator">$</span>bicycle<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] 3733</span></span><br></pre></td></tr></table></figure>
<p>在创建了一个大约有4000次行程从驾驶转向骑自行车的场景后，我们现在可以模拟这个更新后的模拟自行车活动将在哪里发生。为此，我们将使用<strong>stplanr</strong>包中的<code>overline()</code>函数。该函数在交叉口（两条或更多的折线几何相交的地方）处断开折线，并计算每个唯一路段的聚合统计信息(Morgan
和 Lovelace
2020)，它将包含路线的对象和要汇总的属性的名称作为第一和第二个参数：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route_network_scenario <span class="operator">=</span> overline<span class="punctuation">(</span>routes_short_scenario<span class="punctuation">,</span> attrib <span class="operator">=</span> <span class="string">&quot;bicycle&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>前面两个代码块的输出总结如下面的图所示。</p>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309051646384.png">
Illustration of the percentage of car trips switching to cycling as a
function of distance (left) and route network level results of this
function (right).</p>
<p>具有在路段级别的记录的交通网络，通常带有诸如道路类型和宽度之类的属性，构成了一种常见的路线网络。这种路线网络数据集在全球范围内都可以从OpenStreetMap获得，并可以使用诸如<strong>osmdata</strong>和<strong>osmextract</strong>这样的软件包进行下载。为了节省下载和准备OSM的时间，我们将使用来自<strong>spDataLarge</strong>包的<code>bristol_ways</code>对象，这是一个带有LINESTRING几何图形和属性的<code>sf</code>对象，代表了案例研究区域内交通网络的一个样本（详见<code>?bristol_ways</code>以获取详细信息），如下面的输出所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">summary<span class="punctuation">(</span>bristol_ways<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt;      highway       maxspeed             ref                     geometry   </span></span><br><span class="line"><span class="comment">#&gt;  cycleway:1721   Length:6160        Length:6160        LINESTRING   :6160  </span></span><br><span class="line"><span class="comment">#&gt;  rail    :1017   Class :character   Class :character   epsg:4326    :   0  </span></span><br><span class="line"><span class="comment">#&gt;  road    :3422   Mode  :character   Mode  :character   +proj=long...:   0</span></span><br></pre></td></tr></table></figure>
<p>输出显示<code>bristol_ways</code>代表了交通网络上刚刚超过6千个路段。这种和其他地理网络可以表示为数学图，网络上的节点由边连接。一些R软件包已经为处理这样的图而开发，尤其是<strong>igraph</strong>。您可以手动将路线网络转换为<code>igraph</code>对象，但地理属性将会丢失。为了克服<strong>igraph</strong>的这一局限性，开发了<strong>sfnetworks</strong>软件包，该软件包能够同时将路线网络表示为图<em>和</em>地理线。我们将在<code>bristol_ways</code>对象上演示<strong>sfnetworks</strong>的功能。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bristol_ways<span class="operator">$</span>lengths <span class="operator">=</span> st_length<span class="punctuation">(</span>bristol_ways<span class="punctuation">)</span></span><br><span class="line">ways_sfn <span class="operator">=</span> as_sfnetwork<span class="punctuation">(</span>bristol_ways<span class="punctuation">)</span></span><br><span class="line"><span class="built_in">class</span><span class="punctuation">(</span>ways_sfn<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] &quot;sfnetwork&quot; &quot;tbl_graph&quot; &quot;igraph&quot;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ways_sfn</span><br><span class="line"><span class="comment">#&gt; # A sfnetwork with 5728 nodes and 4915 edges</span></span><br><span class="line"><span class="comment">#&gt; # A directed multigraph with 1013 components with spatially explicit edges</span></span><br><span class="line"><span class="comment">#&gt; # Node Data:     5,728 × 1 (active)</span></span><br><span class="line"><span class="comment">#&gt; # Edge Data:     4,915 × 7</span></span><br><span class="line"><span class="comment">#&gt;    from    to highway maxspeed ref                              geometry lengths</span></span><br><span class="line"><span class="comment">#&gt;   &lt;int&gt; &lt;int&gt; &lt;fct&gt;   &lt;fct&gt;    &lt;fct&gt;                    &lt;LINESTRING [°]&gt;     [m]</span></span><br><span class="line"><span class="comment">#&gt; 1     1     2 road    &lt;NA&gt;     B3130 (-2.61 51.4, -2.61 51.4, -2.61 51.…    218.</span></span><br><span class="line"><span class="comment">#&gt; # … </span></span><br></pre></td></tr></table></figure>
<p>由于空间考虑，前一个代码块的输出（最后的输出被缩短，仅包含最重要的8行）显示<code>ways_sfn</code>是一个复合对象，以图和空间形式包含节点和边。<code>ways_sfn</code>是<code>sfnetwork</code>类，该类基于<strong>igraph</strong>包中的<code>igraph</code>类。在下面的示例中，计算了'边介数'，也就是经过每条边的最短路径的数量（有关更多详细信息，请参见<code>?igraph::betweenness</code>）。边介数计算的输出显示在下图，该图以用<code>overline()</code>函数计算的自行车路线网络数据集作为叠加层进行比较。结果表明，每个图的边代表一个路段：靠近道路网络中心的路段具有最高的介数值，而靠近布里斯托尔中心的路段基于这些简单数据集具有更高的自行车潜力。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ways_centrality <span class="operator">=</span> ways_sfn <span class="operator">|&gt;</span> </span><br><span class="line">  activate<span class="punctuation">(</span><span class="string">&quot;edges&quot;</span><span class="punctuation">)</span> <span class="operator">|&gt;</span>  </span><br><span class="line">  mutate<span class="punctuation">(</span>betweenness <span class="operator">=</span> tidygraph<span class="operator">::</span>centrality_edge_betweenness<span class="punctuation">(</span>lengths<span class="punctuation">)</span><span class="punctuation">)</span> </span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309051653021.png">
Illustration of route network datasets. The grey lines represent a
simplified road network, with segment thickness proportional to
betweenness. The green lines represent potential cycling flows (one way)
calculated with the code above</p>
<p>人们还可以使用<strong>sfnetworks</strong>包中的这种路由网络的图表示法来找到起点和终点之间的最短路线。<!-- TODO: 如果时间允许，基于这一点制作一个练习（RL 2022-07） -->与可能的情况相比，本节介绍的方法相对简单。<strong>sfnetworks</strong>开放的双重图/空间功能使得许多新的强大技术得以实现，这些在本节中无法完全涵盖。然而，本节确实为进一步探索和研究该领域提供了一个坚实的起点。最后一点是，我们上面使用的示例数据集相对较小。也可能值得考虑如何将工作适应到更大的网络：在数据的子集上测试方法，并确保您有足够的RAM将有所帮助，尽管也值得探索其他优化用于大型网络的交通网络分析工具，比如R5
(Alessandretti 等 2022)。</p>
<h1 id="优先考虑新基础设施">优先考虑新基础设施</h1>
<p>本节演示了地理计算如何在交通规划领域创造与政策相关的成果。我们将使用一个简单的方法（出于教育目的）来识别可持续交通基础设施投资的有希望的地点。</p>
<p>本章概述的数据驱动方法的一个优点是其模块性：每个方面本身就很有用，并可以融入更广泛的分析中。使我们达到这一阶段的步骤包括在<em>路线</em>节中识别短途但依赖汽车的通勤路线（由欲望线生成），以及使用<strong>sfnetworks</strong>包在<em>路线网络</em>中分析路由网络特性。本章的最后一个代码块将这些分析纵向结合，通过在代表距离自行车基础设施很近的区域的新数据集上覆盖上一节中的自行车潜力估计。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">existing_cycleways_buffer <span class="operator">=</span> bristol_ways <span class="operator">|&gt;</span> </span><br><span class="line">  filter<span class="punctuation">(</span>highway <span class="operator">==</span> <span class="string">&quot;cycleway&quot;</span><span class="punctuation">)</span> <span class="operator">|&gt;</span>    <span class="comment"># 1) filter out cycleways</span></span><br><span class="line">  st_union<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">|&gt;</span>                       <span class="comment"># 2) unite geometries</span></span><br><span class="line">  st_buffer<span class="punctuation">(</span>dist <span class="operator">=</span> <span class="number">100</span><span class="punctuation">)</span>               <span class="comment"># 3) create buffer</span></span><br></pre></td></tr></table></figure>
<p>下一步是创建一个数据集，该数据集代表网络上存在高自行车潜力但几乎没有为自行车提供便利设施的点：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">route_network_no_infra <span class="operator">=</span> st_difference<span class="punctuation">(</span></span><br><span class="line">  route_network_scenario<span class="punctuation">,</span></span><br><span class="line">  route_network_scenario <span class="operator">|&gt;</span> st_set_crs<span class="punctuation">(</span>st_crs<span class="punctuation">(</span>existing_cycleways_buffer<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">  existing_cycleways_buffer</span><br><span class="line"><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#&gt; Warning: attribute variables are assumed to be spatially constant throughout</span><br><span class="line">#&gt; all geometries</span><br></pre></td></tr></table></figure>
<p>前面代码块的结果显示在下图中，该图显示了具有高度依赖汽车、具有高自行车潜力但没有自行车道的路线。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tmap_mode<span class="punctuation">(</span><span class="string">&quot;view&quot;</span><span class="punctuation">)</span></span><br><span class="line">qtm<span class="punctuation">(</span>route_network_no_infra<span class="punctuation">,</span> basemaps <span class="operator">=</span> leaflet<span class="operator">::</span>providers<span class="operator">$</span>Esri.WorldTopoMap<span class="punctuation">,</span></span><br><span class="line">    lines.lwd <span class="operator">=</span> <span class="number">5</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<!-- toDo: rl -->
<!-- the next figure must be updated -->
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#&gt; Warning: Some legend items or map compoments do not fit well (e.g. due to the</span><br><span class="line">#&gt; specified font size).</span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309051701347.png">
Potential routes along which to prioritise cycle infrastructure in
Bristol to reduce car dependency. The static map provides an overview of
the overlay between existing infrastructure and routes with high
car-bike switching potential (left). The screenshot the interactive map
generated from the <code>qtm()</code> function highlights Whiteladies
Road as somewhere that would benefit from a new cycleway (right).</p>
<p>该方法存在一些局限性：实际上，人们并不总是前往区域中心或始终使用特定模式的最短路径算法。然而，结果展示了如何使用地理数据分析来突出可能特别有益于新投资自行车道的地方，尽管这种方法很简单。为了在实践中指导交通规划设计，这种分析需要大幅扩展——包括使用更大的输入数据集。</p>
<h1 id="旅行的未来方向">旅行的未来方向</h1>
<p>这一章提供了使用地理计算进行交通研究的可能性的一个概览，并使用开放数据和可复制代码探讨了构成城市交通系统的一些关键地理元素。这些结果有助于规划需要投资的地方。</p>
<p>交通系统在多个相互作用的层面上运行，这意味着地理计算方法有很大的潜力，可以生成有关它们如何运作以及不同干预措施可能产生的影响的见解。在这一领域还有更多可以做的事情：基于本章提供的基础，有很多方向可以进行拓展。</p>
<p>交通是许多国家温室气体排放增长最快的来源，并将成为“尤其是在发达国家中最大的温室气体排放部门”。交通相关的排放在社会上分布不均，但（与食物和供暖不同）对幸福来说并非必需品。通过需求减少、车队电气化以及积极采取像步行和骑自行车这样的活动出行方式，该部门有很大的快速减碳潜力。新技术可以通过更多的汽车共享来减少对汽车的依赖。诸如无桩自行车和电动滑板车方案这样的“微移动”系统也正在出现，以General
Bikeshare Feed Specification（GBFS）格式创建有价值的数据集，可以用<a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/simonpcouch/gbfs"><strong>gbfs</strong></a>包进行导入和处理。</p>
<p>从方法论的角度看，本章提供的基础可以通过在分析中包括更多变量来进行扩展。例如，通过使用R语言的统计建模能力，这可以用来预测当前和未来的自行车使用水平。</p>
<p>这种类型的分析是Propensity to Cycle
Tool（PCT）的基础，这是一个用R语言开发的，用于优先考虑英格兰各地自行车投资的公开可访问的映射工具（lovelace
2017）。类似的工具可以用于鼓励与空气污染和公共交通准入等其他主题相关的基于证据的交通政策。</p>
<h1 id="练习">练习</h1>
<p>E1. 在本章的大部分分析中，我们关注的是主动模式，但是驾驶行程呢？</p>
<ul>
<li>在<code>desire_lines</code>对象中，有多大比例的行程是通过驾驶完成的？</li>
<li>有多大比例的<code>desire_lines</code>的直线长度为5公里或更远？</li>
<li>在长度超过5公里的<code>desire_lines</code>中，有多大比例的行程是通过驾驶完成的？</li>
<li>绘制那些长度小于5公里且其中超过50%的行程是通过汽车完成的<code>desire_lines</code>。</li>
<li>你注意到这些依赖汽车但<code>desire_lines</code>较短的地方有什么特点？</li>
</ul>
<p>E2.
如果在离现有自行车道超过100米的区段上建造了上图中展示的所有路线，会增加多少长度的自行车道？</p>
<p>E3.
<code>desire_lines</code>中表示的行程有多大比例在<code>routes_short_scenario</code>对象中得到了体现？</p>
<ul>
<li>奖励：所有行程中有多大比例发生在穿越<code>routes_short_scenario</code>的<code>desire_lines</code>上？</li>
</ul>
<p>E4. 本章展示的分析旨在教授如何将地理计算方法应用于交通研究。
如果你是在政府或交通咨询公司中真正进行这项工作，你会有哪三个不同的做法？</p>
<p>E5. 显然，上图中识别的路线只是部分情况。 你会如何扩展这个分析？</p>
<p>E6.
假设你想通过创建投资基于场所的自行车政策的关键<em>区域</em>（而不是路线）来扩展场景，比如无车区、自行车停车点和减少汽车停车策略。
栅格数据集如何协助完成这项工作？</p>
<ul>
<li>奖励：开发一个光栅层，将布里斯托地区划分为100个单元格（10x10），并从<code>bristol_ways</code>数据集（参见章节
@ref(location)）估算每个单元格中道路的平均速度限制。</li>
</ul>
<aside id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr>
<ol>
<li id="fn1"><p>13-transport-1<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>13-transport-1<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>在第一个匹配没有提供正确名称的情况下，应指定国家或地区，例如位于美国的布里斯托尔应为
<code>Bristol Tennessee</code>。<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p><code>_if</code> 后缀要求对变量提出一个
<code>TRUE</code>/<code>FALSE</code>
的问题，在这个情况下是'是否为数值型?' 只有返回 true 的变量会被汇总。<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>在实际数据中，检查ID在反方向上是否匹配也同样重要。这可以通过改变<code>summary()</code>命令中ID的顺序来完成——<code>summary(bristol_zones$geo_code %in% zones_attr$geo_code)</code>——或者通过如下使用<code>setdiff()</code>：<code>setdiff(bristol_zones$geo_code, zones_attr$geo_code)</code>。<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p><code>od2line()</code> 的工作方式是通过匹配
<code>bristol_od</code> 对象的前两列中的ID与地理 <code>zones_od</code>
对象中的 <code>zone_code</code>
ID列。需要注意的是，该操作会发出一个警告，因为 <code>od2line()</code>
是通过将每一对起点-终点分配给其起源和目的地区域的<em>质心</em>来工作的。对于实际应用，人们会使用由投影数据生成的质心值，或者更好地使用<em>基于人口加权</em>的质心<span class="citation" data-cites="lovelace_propensity_2017">[@lovelace_propensity_2017]</span>。<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7"><p>注意，红色的路线和黑色的期望线的起点并不完全相同。这是因为区域质心很少位于路线网络上：相反，路线起源于距离质心最近的交通网络节点。还要注意，假设路线起源于区域质心，这是一个简化假设，用于减少计算所有可能起点和终点组合之间的最短路径所需的计算资源<span class="citation" data-cites="hollander_transport_2016">[@hollander_transport_2016]</span>。<a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>

            
        </div>

        
        
        

        <div>
            
        </div>

        <footer class="post-footer">
            <div class="post-eof"></div>
            
        </footer>
    </article>
</div>




    


<div class="post-block">
    
    

    <article itemscope itemtype="http://schema.org/Article" class="post-content" lang>
        <link itemprop="mainEntityOfPage" href="https://ancao96.github.io/2023/08/21/2023-8-21-12%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0/">

        <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
            <meta itemprop="image" content="/images/avatar.gif">
            <meta itemprop="name" content="SCY">
        </span>

        <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
            <meta itemprop="name" content="SCY SPACE">
            <meta itemprop="description" content>
        </span>

        <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
            <meta itemprop="name" content="undefined | SCY SPACE">
            <meta itemprop="description" content>
        </span>
        <header class="post-header">
            <h2 class="post-title" itemprop="name headline">
                <a href="/2023/08/21/2023-8-21-12%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">(12)统计学习</a>
            </h2>

            <div class="post-meta-container">
                <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-08-21 03:36:20" itemprop="dateCreated datePublished" datetime="2023-08-21T03:36:20+08:00">2023-08-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-10-04 13:04:54" itemprop="dateModified" datetime="2023-10-04T13:04:54+08:00">2023-10-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/R/" itemprop="url" rel="index"><span itemprop="name">R</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/R/Geocomputaion/" itemprop="url" rel="index"><span itemprop="name">Geocomputaion</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2023/08/21/2023-8-21-12%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2023/08/21/2023-8-21-12%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>8.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>32 分钟</span>
    </span>
</div>

            </div>
        </header>

        
        
        
        <div class="post-body" itemprop="articleBody">
            <blockquote><p>本文由SCY翻译自《Geocomputation with R》<a target="_blank" rel="external nofollow noopener noreferrer" href="https://r.geocompx.org/spatial-cv">第十二章</a></p>
</blockquote>
<h1 id="前提条件">前提条件</h1>
<p>本章假设您已经具备地理数据分析的熟练技能，例如通过学习并完成章节<em>空间数据</em>至<em>地理数据重投影</em>中的练习来获得。强烈推荐熟悉广义线性模型（GLM）和机器学习。</p>
<p>本章使用以下的R包：<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">library<span class="punctuation">(</span>sf<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>terra<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>dplyr<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>future<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>lgr<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>mlr3<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>mlr3learners<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>mlr3extralearners<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>mlr3spatiotempcv<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>mlr3tuning<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>mlr3viz<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>progressr<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>当然，所需数据将在适当的时候附上。</p>
<h1 id="引言">引言</h1>
<p>统计学习主要关注使用统计和计算模型来识别数据中的模式，并根据这些模式进行预测。由于其起源，统计学习是
R 语言的一大优势（见章节<em>地理计算软件</em>）。<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>。</p>
<p>本章重点介绍有训练数据集的监督技术，而非像聚类这样的无监督技术。响应变量可以是二元的（如山体滑坡发生与否）、分类的（土地利用）、整数（物种丰富度计数）或数值的（以
pH
衡量的土壤酸度）。监督技术用于建模——响应与一个或多个预测变量之间的关系——这些响应是基于一组观测样本而已知的。</p>
<p>大多数机器学习研究的主要目的是进行良好的预测。机器学习在“大数据”时代蓬勃发展，因为其方法对输入变量几乎没有假设，并且能处理巨大的数据集。机器学习适用于预测未来客户行为、推荐服务（音乐、电影、接下来购买什么）、面部识别、自动驾驶、文本分类和预测性维护（基础设施、产业）等任务。</p>
<p>本章基于一个案例研究：（空间）预测山体滑坡。
该应用与定义在<em>引言</em>章中的地理计算的应用性有关，并说明了机器学习在唯一目的是预测时如何借鉴统计学领域。因此，本章首先使用广义线性模型介绍建模和交叉验证的概念。在此基础上，该章实施了一个更典型的机器学习算法，即支持向量机（SVM）。模型的<strong>预测性能</strong>将使用空间交叉验证（CV）进行评估，该方法考虑到地理数据是特殊的。</p>
<p>CV确定模型泛化到新数据的能力，通过将数据集（反复）分割为训练集和测试集。它使用训练数据来拟合模型，并检查其在对测试数据进行预测时的性能。CV
有助于检测过拟合，因为过于紧密地预测训练数据（噪声）的模型通常会在测试数据上表现不佳。</p>
<p>随机分割空间数据可能导致训练点与测试点在空间上是邻近的。由于空间自相关，在这种情况下，测试数据集和训练数据集将不是独立的，因此交叉验证无法检测出可能的过拟合。空间交叉验证缓解了这个问题，并且是本章的<strong>核心</strong>主题。</p>
<h1 id="案例-滑坡敏感性">案例: 滑坡敏感性</h1>
<p>本案例研究基于南厄瓜多尔滑坡地点的一个数据集，如下图所示，并在@muenchow_geomorphic_2012中详细描述。该论文中使用的数据集的一个子集提供在<strong>spDataLarge</strong>包中，可以如下加载：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data<span class="punctuation">(</span><span class="string">&quot;lsl&quot;</span><span class="punctuation">,</span> <span class="string">&quot;study_mask&quot;</span><span class="punctuation">,</span> package <span class="operator">=</span> <span class="string">&quot;spDataLarge&quot;</span><span class="punctuation">)</span></span><br><span class="line">ta <span class="operator">=</span> terra<span class="operator">::</span>rast<span class="punctuation">(</span>system.file<span class="punctuation">(</span><span class="string">&quot;raster/ta.tif&quot;</span><span class="punctuation">,</span> package <span class="operator">=</span> <span class="string">&quot;spDataLarge&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>T上面的代码加载了三个对象：一个名为<code>lsl</code>的<code>data.frame</code>，一个名为<code>study_mask</code>的<code>sf</code>对象，以及一个名为<code>ta</code>的<code>SpatRaster</code>，其中包含地形属性栅格。<code>lsl</code>包含一个因子列<code>lslpts</code>，其中<code>TRUE</code>对应于观察到的滑坡'发起点'，坐标存储在列<code>x</code>和<code>y</code>中。<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>
有175个滑坡点和175个非滑坡点，如<code>summary(lsl$lslpts)</code>所示。这175个非滑坡点是从研究区域随机抽样的，但必须落在滑坡多边形周围的小缓冲区之外。</p>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309051146030.png">
Landslide initiation points (red) and points unaffected by landsliding
(blue) in Southern Ecuador.</p>
<p><code>lsl</code>的前三行，四舍五入为两位有效数字，可以在下表中找到。</p>
<table class="table" style="margin-left: auto; margin-right: auto;">
<caption>
Structure of the lsl dataset.
</caption>
<thead>
<tr>
<th style="text-align:left;">
</th>
<th style="text-align:right;">
x
</th>
<th style="text-align:right;">
y
</th>
<th style="text-align:left;">
lslpts
</th>
<th style="text-align:right;">
slope
</th>
<th style="text-align:right;">
cplan
</th>
<th style="text-align:right;">
cprof
</th>
<th style="text-align:right;">
elev
</th>
<th style="text-align:right;">
log10_carea
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
1
</td>
<td style="text-align:right;">
713888
</td>
<td style="text-align:right;">
9558537
</td>
<td style="text-align:left;">
FALSE
</td>
<td style="text-align:right;">
34
</td>
<td style="text-align:right;">
0.023
</td>
<td style="text-align:right;">
0.003
</td>
<td style="text-align:right;">
2400
</td>
<td style="text-align:right;">
2.8
</td>
</tr>
<tr>
<td style="text-align:left;">
2
</td>
<td style="text-align:right;">
712788
</td>
<td style="text-align:right;">
9558917
</td>
<td style="text-align:left;">
FALSE
</td>
<td style="text-align:right;">
39
</td>
<td style="text-align:right;">
-0.039
</td>
<td style="text-align:right;">
-0.017
</td>
<td style="text-align:right;">
2100
</td>
<td style="text-align:right;">
4.1
</td>
</tr>
<tr>
<td style="text-align:left;">
350
</td>
<td style="text-align:right;">
713826
</td>
<td style="text-align:right;">
9559078
</td>
<td style="text-align:left;">
TRUE
</td>
<td style="text-align:right;">
35
</td>
<td style="text-align:right;">
0.020
</td>
<td style="text-align:right;">
-0.003
</td>
<td style="text-align:right;">
2400
</td>
<td style="text-align:right;">
3.2
</td>
</tr>
</tbody>
</table>
<p>要对滑坡易发性进行建模，我们需要一些预测因子。由于地形属性经常与滑坡有关<span class="citation" data-cites="muenchow_geomorphic_2012">[@muenchow_geomorphic_2012]</span>，我们已经从<code>ta</code>提取到<code>lsl</code>中以下的地形属性：</p>
<ul>
<li><code>slope</code>：坡度角（°）</li>
<li><code>cplan</code>：平面曲率（rad
m<sup>−1</sup>）表示坡度的汇聚或发散，从而表示水流</li>
<li><code>cprof</code>：剖面曲率（rad
m<sup>-1</sup>）作为流速加速的衡量标准，也称为坡度角的下坡变化</li>
<li><code>elev</code>：海拔高度（m
a.s.l.）作为研究区不同海拔带植被和降水的表示</li>
<li><code>log10_carea</code>：集水区面积（log10
m<sup>2</sup>）的常用对数，表示流向某个位置的水量</li>
</ul>
<p>使用R-GIS桥计算地形属性并将其提取到滑坡点（参见本章末尾的练习部分）可能是一个值得尝试的练习。</p>
<h1 id="在r中的传统建模方法">在R中的传统建模方法</h1>
<p>在介绍<strong>mlr3</strong>包之前，这是一个提供统一接口以访问数十种学习算法的
umbrella
包，值得先看一下R传统的建模接口。这一介绍到有监督的统计学习为进行空间CV提供了基础，并有助于更好地理解随后呈现的<strong>mlr3</strong>方法。</p>
<p>监督学习涉及将响应变量作为预测因子的函数进行预测。在R中，建模函数通常使用公式来指定（有关R公式的更多详细信息，请参阅<code>?formula</code>）。以下命令指定并运行一个广义线性模型：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fit <span class="operator">=</span> glm<span class="punctuation">(</span>lslpts <span class="operator">~</span> slope <span class="operator">+</span> cplan <span class="operator">+</span> cprof <span class="operator">+</span> elev <span class="operator">+</span> log10_carea<span class="punctuation">,</span></span><br><span class="line">          family <span class="operator">=</span> binomial<span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">          data <span class="operator">=</span> lsl<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>理解这三个输入参数各自的意义是非常有价值的：</p>
<ul>
<li>一个公式，用于指定由预测因子决定的滑坡发生（<code>lslpts</code>）</li>
<li>一个家族（family），用于指定模型的类型，在这个例子中是<code>binomial</code>，因为响应是二元的（见<code>?family</code>）</li>
<li>包含响应和预测因子（作为列）的数据框</li>
</ul>
<p>可以如下打印这个模型的结果（<code>summary(fit)</code>提供了关于结果的更详细的描述）：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">class</span><span class="punctuation">(</span>fit<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] &quot;glm&quot; &quot;lm&quot;</span></span><br><span class="line">fit</span><br><span class="line"><span class="comment">#&gt; </span></span><br><span class="line"><span class="comment">#&gt; Call:  glm(formula = lslpts ~ slope + cplan + cprof + elev + log10_carea, </span></span><br><span class="line"><span class="comment">#&gt;     family = binomial(), data = lsl)</span></span><br><span class="line"><span class="comment">#&gt; </span></span><br><span class="line"><span class="comment">#&gt; Coefficients:</span></span><br><span class="line"><span class="comment">#&gt; (Intercept)        slope        cplan        cprof         elev  log10_carea  </span></span><br><span class="line"><span class="comment">#&gt;    2.511364     0.079011   -28.941961   -17.563601     0.000179    -2.274877  </span></span><br><span class="line"><span class="comment">#&gt; </span></span><br><span class="line"><span class="comment">#&gt; Degrees of Freedom: 349 Total (i.e. Null);  344 Residual</span></span><br><span class="line"><span class="comment">#&gt; Null Deviance:	    485 </span></span><br><span class="line"><span class="comment">#&gt; Residual Deviance: 373 	AIC: 385</span></span><br></pre></td></tr></table></figure>
<p>模型对象<code>fit</code>，其类别为<code>glm</code>，包含了定义响应和预测因子之间拟合关系的系数。这个对象也可以用于预测。这是通过通用的<code>predict()</code>方法来完成的，在这个案例中，它调用了<code>predict.glm()</code>函数。将<code>type</code>设置为<code>response</code>会返回<code>lsl</code>中每个观测的预测概率（即滑坡发生的概率），如下图所示（见<code>?predict.glm</code>）：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pred_glm <span class="operator">=</span> predict<span class="punctuation">(</span>object <span class="operator">=</span> fit<span class="punctuation">,</span> type <span class="operator">=</span> <span class="string">&quot;response&quot;</span><span class="punctuation">)</span></span><br><span class="line">head<span class="punctuation">(</span>pred_glm<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt;      1      2      3      4      5      6 </span></span><br><span class="line"><span class="comment">#&gt; 0.1901 0.1172 0.0952 0.2503 0.3382 0.1575</span></span><br></pre></td></tr></table></figure>
<p>通过将系数应用于预测因子的栅格数据，可以创建空间分布图。这可以手动完成，也可以使用<code>terra::predict()</code>来完成。除了一个模型对象（<code>fit</code>）外，这个函数还需要一个具有预测因子（栅格层）的<code>SpatRaster</code>，这些预测因子的名称应与模型输入数据框中的名称相同（见下图）。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># making the prediction</span></span><br><span class="line">pred <span class="operator">=</span> terra<span class="operator">::</span>predict<span class="punctuation">(</span>ta<span class="punctuation">,</span> model <span class="operator">=</span> fit<span class="punctuation">,</span> type <span class="operator">=</span> <span class="string">&quot;response&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309051151962.png">
Spatial distribution mapping of landslide susceptibility using a
GLM.</p>
<p>在进行预测时，我们忽略了空间自相关，因为我们假设平均预测准确性在有或没有空间自相关结构的情况下保持不变。然而，也可以将空间自相关结构纳入模型和预测中。
尽管这超出了本书的范围，但我们为感兴趣的读者提供了一些查阅的方向：</p>
<ol type="1">
<li>回归克里金（Regression
Kriging）的预测结合了回归的预测和回归残差的克里金。</li>
<li>人们还可以向广义最小二乘模型[<code>nlme::gls()</code>]添加空间相关（依赖）结构。</li>
<li>人们也可以使用混合效应建模方法。</li>
</ol>
<p>基本上，随机效应对响应变量施加了依赖结构，从而使某一类的观察结果与另一类的观察结果更相似。类别可以是蜜蜂巢、猫头鹰巢、植被样带或高度分层。这种混合建模方法假设随机截距是正态和独立分布的。这甚至可以通过使用正态和空间依赖的随机截距来扩展。然而，为此，你可能需要采用贝叶斯建模方法，因为频率论软件工具在这方面尤其有限，尤其是对于更复杂的模型。</p>
<p>空间分布图是模型（上图）的一个非常重要的结果。更重要的是，基础模型在制作这些图时有多好，因为如果模型的预测性能差，预测图就毫无用处。评估二项模型预测性能的最流行指标是接收器操作特性曲线下的面积（AUROC）。这是一个介于0.5和1.0之间的值，其中0.5表示模型不比随机模型好，1.0表示两个类的完美预测。因此，AUROC越高，模型的预测能力越好。以下代码块使用<code>roc()</code>计算模型的AUROC值，该函数将响应和预测值作为输入。<code>auc()</code>返回曲线下的面积。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pROC<span class="operator">::</span>auc<span class="punctuation">(</span>pROC<span class="operator">::</span>roc<span class="punctuation">(</span>lsl<span class="operator">$</span>lslpts<span class="punctuation">,</span> fitted<span class="punctuation">(</span>fit<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; Area under the curve: 0.8216</span></span><br></pre></td></tr></table></figure>
<p>AUROC 值为
<!-- `r # round(pROC::auc(pROC::roc(lsl$lslpts, fitted(fit))), 2)` -->
0.82
代表了一个良好的拟合。然而，这是一个过于乐观的估计，因为我们是在完整数据集上进行的计算。为了得到一个偏差较小的评估，我们需要使用交叉验证，并且在处理空间数据的情况下，应使用空间CV。</p>
<h2 id="介绍空间交叉验证">介绍（空间）交叉验证</h2>
<p>交叉验证属于重采样方法的家族 <span class="citation" data-cites="james_introduction_2013">[@james_introduction_2013]</span>。基本思想是将数据集（反复）分为训练集和测试集，其中训练数据用于拟合模型，然后将该模型应用于测试集。通过使用如二项式案例中的AUROC这样的性能度量，将预测值与测试集中已知的响应值进行比较，从而得到模型将学习到的关系泛化到独立数据的能力的偏差较小的评估。例如，100次重复的5折交叉验证意味着将数据随机分为五个部分（折叠），每个折叠都被用作一次测试集（见下图的上行）。这保证了每个观测值都在测试集中使用一次，并需要拟合五个模型。随后，这一过程重复100次。当然，每次重复中的数据分割都会有所不同。总体而言，这合计为500个模型，而所有模型的平均性能度量（AUROC）即为模型的整体预测能力。</p>
<p>然而，地理数据是特殊的。正如我们将在<em>运输</em>章节中看到的，地理学的“第一定律”指出，彼此靠近的点通常比远离的点更相似
<span class="citation" data-cites="miller_tobler_2004">[@miller_tobler_2004]</span>。这意味着这些点在统计上并不独立，因为在传统的CV中，训练点和测试点通常过于靠近（见下图的第一行）。靠近“测试”观测值的“训练”观测值可能提供一种“偷窥预览”：这些信息本应对训练数据集不可用。为了缓解这一问题，“空间划分”被用于将观测值分为空间上不相交的子集（使用观测值的坐标进行<em>k</em>-均值聚类；<span class="citation" data-cites="brenning_spatial_2012">@brenning_spatial_2012</span>；见下图的第二行）。这种划分策略是空间CV和传统CV之间的<strong>唯一</strong>差异。因此，空间CV导致了对模型预测性能的偏差较小的评估，从而有助于避免过拟合。</p>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309051156779.png">
Spatial visualization of selected test and training observations for
cross-validation of one repetition. Random (upper row) and spatial
partitioning (lower row).</p>
<h1 id="使用mlr3进行空间交叉验证">使用<strong>mlr3</strong>进行空间交叉验证</h1>
<p>如<a target="_blank" rel="external nofollow noopener noreferrer" href="https://CRAN.R-project.org/view=MachineLearning">CRAN
机器学习任务视图</a>所描述的，有数十个用于统计学的包。熟悉其中每一个包，包括如何进行交叉验证和超参数调整，可能是一个耗时的过程。比较来自不同包的模型结果可能更为繁琐。<strong>mlr3</strong>
包和生态系统是为了解决这些问题而开发的。它充当一个“元包”，为包括分类、回归、生存分析和聚类在内的流行的有监督和无监督统计学习技术提供统一的接口
<span class="citation" data-cites="lang_mlr3_2019 becker_mlr3_2022">[@lang_mlr3_2019;
@becker_mlr3_2022]</span>。标准化的 <strong>mlr3</strong>
接口基于八个“构建块”。 如下图所示，这些构建块有明确的顺序。</p>
<p>(ref:building-blocks) mlr3包的基础构建块。来源：<span class="citation" data-cites="becker_mlr3_2022">@becker_mlr3_2022</span>。（得到了友好地重新使用此图的许可。）</p>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309051206276.png">
(ref:building-blocks)</p>
<p><strong>mlr3</strong> 建模过程包含三个主要阶段。
首先，<strong>任务（task）</strong>指定了数据（包括响应变量和预测变量）和模型类型（如回归或分类）。
其次，<strong>学习器（learner）</strong>
定义了应用于创建的任务的特定学习算法。
第三，<strong>重采样（resampling）</strong>方法评估了模型的预测性能，即其泛化到新数据的能力。</p>
<h2 id="广义线性模型">广义线性模型</h2>
<p>要在
<strong>mlr3</strong>中实现GLM，我们必须创建一个包含滑坡数据的<strong>任务（task）</strong>。由于响应是二元（两类变量）且具有空间维度，我们使用
<strong>mlr3spatiotempcv</strong>
包的<code>TaskClassifST$new()</code>创建一个分类任务<span class="citation" data-cites="schratz_mlr3spatiotempcv_2021">[@schratz_mlr3spatiotempcv_2021，对于非空间任务，使用
`mlr3::TaskClassif$new()`
或对于回归任务使用`mlr3::TaskRegr$new()`，其他任务类型请参见
`?Task`]</span>。<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> 这些 <code>Task*$new()</code>
函数的第一个重要参数是 <code>backend</code>。<code>backend</code>
期望输入数据包括响应变量和预测变量。<code>target</code>
参数指示响应变量的名称（在我们的例子中是 <code>lslpts</code>），而
<code>positive</code>
决定响应变量的两个因子水平中哪一个表示滑坡起点（在我们的例子中是
<code>TRUE</code>）。<code>lsl</code>
数据集的所有其他变量将作为预测因子。对于空间交叉验证，我们需要提供一些额外的参数。<code>coordinate_names</code>
参数期望坐标列的名称（参见<em>空间交叉验证</em>章节和图3）。另外，我们应该指示使用的坐标参考系统（<code>crs</code>）并决定是否希望在建模中使用坐标作为预测因子（<code>coords_as_features</code>）。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># create task</span></span><br><span class="line">task <span class="operator">=</span> mlr3spatiotempcv<span class="operator">::</span>TaskClassifST<span class="operator">$</span>new<span class="punctuation">(</span></span><br><span class="line">  id <span class="operator">=</span> <span class="string">&quot;ecuador_lsl&quot;</span><span class="punctuation">,</span></span><br><span class="line">  backend <span class="operator">=</span> mlr3<span class="operator">::</span>as_data_backend<span class="punctuation">(</span>lsl<span class="punctuation">)</span><span class="punctuation">,</span> </span><br><span class="line">  target <span class="operator">=</span> <span class="string">&quot;lslpts&quot;</span><span class="punctuation">,</span> </span><br><span class="line">  positive <span class="operator">=</span> <span class="string">&quot;TRUE&quot;</span><span class="punctuation">,</span></span><br><span class="line">  coordinate_names <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;x&quot;</span><span class="punctuation">,</span> <span class="string">&quot;y&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">  coords_as_features <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">,</span></span><br><span class="line">  crs <span class="operator">=</span> <span class="string">&quot;EPSG:32717&quot;</span></span><br><span class="line">  <span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>注意，<code>mlr3spatiotempcv::as_task_classif_st()</code> 也接受一个
<code>sf</code>-对象作为 <code>backend</code>
参数的输入。在这种情况下，你可能只想额外指定
<code>coords_as_features</code> 参数。我们没有将 <code>lsl</code>
转换为一个 <code>sf</code>-对象，因为 <code>TaskClassifST$new()</code>
在背景中会将其转换回一个非空间的 <code>data.table</code>
对象。对于简短的数据探索，<strong>mlr3viz</strong> 包的
<code>autoplot()</code>
函数可能会很方便，因为它会绘制响应与所有预测因子的关系，以及所有预测因子之间的关系（未显示）。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># plot response against each predictor</span></span><br><span class="line">mlr3viz<span class="operator">::</span>autoplot<span class="punctuation">(</span>task<span class="punctuation">,</span> type <span class="operator">=</span> <span class="string">&quot;duo&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># plot all variables against each other</span></span><br><span class="line">mlr3viz<span class="operator">::</span>autoplot<span class="punctuation">(</span>task<span class="punctuation">,</span> type <span class="operator">=</span> <span class="string">&quot;pairs&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>创建了任务之后，我们需要选择一个<strong>学习器（learner）</strong>，以确定要使用的统计学方法。所有分类的<strong>学习器</strong>以
<code>classif.</code> 开头，所有回归的学习器以 <code>regr.</code>
开头（详见
<code>?Learner</code>）。<code>mlr3extralearners::list_mlr3learners()</code>
列出了所有可用的学习器以及 <strong>mlr3</strong>
从哪个软件包中导入了它们（表
@ref(tab:lrns)）。要了解能够对二元响应变量进行建模的学习器，我们可以运行：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mlr3extralearners<span class="operator">::</span>list_mlr3learners<span class="punctuation">(</span></span><br><span class="line">  filter <span class="operator">=</span> <span class="built_in">list</span><span class="punctuation">(</span><span class="built_in">class</span> <span class="operator">=</span> <span class="string">&quot;classif&quot;</span><span class="punctuation">,</span> properties <span class="operator">=</span> <span class="string">&quot;twoclass&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> </span><br><span class="line">  select <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;id&quot;</span><span class="punctuation">,</span> <span class="string">&quot;mlr3_package&quot;</span><span class="punctuation">,</span> <span class="string">&quot;required_packages&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">  head<span class="punctuation">(</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<table>
<caption>
Sample of available learners for binomial tasks in the mlr3 package.
</caption>
<thead>
<tr>
<th style="text-align:left;">
Class
</th>
<th style="text-align:left;">
Name
</th>
<th style="text-align:left;">
Short name
</th>
<th style="text-align:left;">
Package
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
classif.adaboostm1
</td>
<td style="text-align:left;">
ada Boosting M1
</td>
<td style="text-align:left;">
adaboostm1
</td>
<td style="text-align:left;">
RWeka
</td>
</tr>
<tr>
<td style="text-align:left;">
classif.binomial
</td>
<td style="text-align:left;">
Binomial Regression
</td>
<td style="text-align:left;">
binomial
</td>
<td style="text-align:left;">
stats
</td>
</tr>
<tr>
<td style="text-align:left;">
classif.featureless
</td>
<td style="text-align:left;">
Featureless classifier
</td>
<td style="text-align:left;">
featureless
</td>
<td style="text-align:left;">
mlr
</td>
</tr>
<tr>
<td style="text-align:left;">
classif.fnn
</td>
<td style="text-align:left;">
Fast k-Nearest Neighbour
</td>
<td style="text-align:left;">
fnn
</td>
<td style="text-align:left;">
FNN
</td>
</tr>
<tr>
<td style="text-align:left;">
classif.gausspr
</td>
<td style="text-align:left;">
Gaussian Processes
</td>
<td style="text-align:left;">
gausspr
</td>
<td style="text-align:left;">
kernlab
</td>
</tr>
<tr>
<td style="text-align:left;">
classif.IBk
</td>
<td style="text-align:left;">
k-Nearest Neighbours
</td>
<td style="text-align:left;">
ibk
</td>
<td style="text-align:left;">
RWeka
</td>
</tr>
</tbody>
</table>
<p>这将产生所有能够处理两类问题（有或没有滑坡）的学习器。我们选择在<em>传统建模</em>节中使用的二项分类方法，该方法在
<strong>mlr3learners</strong> 中实现为
<code>classif.log_reg</code>。另外，我们需要指定
<code>predict.type</code>，它决定了预测的类型，<code>prob</code>
会得出滑坡发生概率在0到1之间的预测值（这对应于 <code>predict.glm</code>
中的 <code>type = response</code>）。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">learner <span class="operator">=</span> mlr3<span class="operator">::</span>lrn<span class="punctuation">(</span><span class="string">&quot;classif.log_reg&quot;</span><span class="punctuation">,</span> predict_type <span class="operator">=</span> <span class="string">&quot;prob&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>要访问学习器的帮助页面并找出它来自哪个包，我们可以运行：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">learner<span class="operator">$</span>help<span class="punctuation">(</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<!--
Having specified a learner and a task, we can train our model which basically executes the `glm()` command in the background for our task. 

<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">learner<span class="operator">$</span>train<span class="punctuation">(</span>task<span class="punctuation">)</span></span><br><span class="line">learner<span class="operator">$</span>model</span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fit <span class="operator">=</span> glm<span class="punctuation">(</span>lslpts <span class="operator">~</span> .<span class="punctuation">,</span> family <span class="operator">=</span> binomial<span class="punctuation">(</span>link <span class="operator">=</span> <span class="string">&quot;logit&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> </span><br><span class="line">          data <span class="operator">=</span> select<span class="punctuation">(</span>lsl<span class="punctuation">,</span> <span class="operator">-</span>x<span class="punctuation">,</span> <span class="operator">-</span>y<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">identical<span class="punctuation">(</span>fit<span class="operator">$</span>coefficients<span class="punctuation">,</span> learner<span class="operator">$</span>model<span class="operator">$</span>coefficients<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>--&gt;</p>
<p>使用
<strong>mlr3</strong>进行建模的设置步骤可能看似繁琐。但请记住，这个单一的接口提供了访问
<code>mlr3extralearners::list_mlr3learners()</code>
显示的130多个学习器的途径；学习每个学习器的接口将会更加繁琐！其他优点包括简单的重采样技术的并行化和调整机器学习超参数的能力。最重要的是，<strong>mlr3spatiotempcv</strong>
<span class="citation"
data-cites="schratz_mlr3spatiotempcv_2021">[@schratz_mlr3spatiotempcv_2021]</span>
中的（空间）重采样非常直接，只需要两个额外的步骤：指定一个重采样方法并运行它。我们将使用100重复的5折空间CV：根据我们
<code>task</code> 中提供的坐标选择五个分区，并重复该划分100次：<a
href="#fn5" class="footnote-ref" id="fnref5"
role="doc-noteref"><sup>5</sup></a></p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resampling <span class="operator">=</span> mlr3<span class="operator">::</span>rsmp<span class="punctuation">(</span><span class="string">&quot;repeated_spcv_coords&quot;</span><span class="punctuation">,</span> folds <span class="operator">=</span> <span class="number">5</span><span class="punctuation">,</span> repeats <span class="operator">=</span> <span class="number">100</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>要执行空间重采样，我们运行<code>resample()</code>，使用之前指定的任务、学习器和重采样策略。这需要一些时间（在现代笔记本电脑上大约需要15秒），因为它计算了500个重采样分区和500个模型。
作为性能度量，我们再次选择AUROC。要获取它，我们使用重采样结果输出对象（<code>score_spcv_glm</code>）的<code>score()</code>方法。这将返回一个具有500行的<code>data.table</code>对象——每个模型一行。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># reduce verbosity</span></span><br><span class="line">lgr<span class="operator">::</span>get_logger<span class="punctuation">(</span><span class="string">&quot;mlr3&quot;</span><span class="punctuation">)</span><span class="operator">$</span>set_threshold<span class="punctuation">(</span><span class="string">&quot;warn&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># run spatial cross-validation and save it to resample result glm (rr_glm)</span></span><br><span class="line">rr_spcv_glm <span class="operator">=</span> mlr3<span class="operator">::</span>resample<span class="punctuation">(</span>task <span class="operator">=</span> task<span class="punctuation">,</span></span><br><span class="line">                             learner <span class="operator">=</span> learner<span class="punctuation">,</span></span><br><span class="line">                             resampling <span class="operator">=</span> resampling<span class="punctuation">)</span></span><br><span class="line"><span class="comment"># compute the AUROC as a data.table</span></span><br><span class="line">score_spcv_glm <span class="operator">=</span> rr_spcv_glm<span class="operator">$</span>score<span class="punctuation">(</span>measure <span class="operator">=</span> mlr3<span class="operator">::</span>msr<span class="punctuation">(</span><span class="string">&quot;classif.auc&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># keep only the columns you need</span></span><br><span class="line">score_spcv_glm <span class="operator">=</span> score_spcv_glm<span class="punctuation">[</span><span class="punctuation">,</span> .<span class="punctuation">(</span>task_id<span class="punctuation">,</span> learner_id<span class="punctuation">,</span> resampling_id<span class="punctuation">,</span> </span><br><span class="line">                                    classif.auc<span class="punctuation">)</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<p>前面代码块的输出是模型预测性能的偏差减少评估。我们已经将其保存为书籍GitHub仓库中的<code>extdata/12-bmr_score.rds</code>。如有需要，您可以按照以下方式读取它：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">score <span class="operator">=</span> readRDS<span class="punctuation">(</span><span class="string">&quot;extdata/12-bmr_score.rds&quot;</span><span class="punctuation">)</span></span><br><span class="line">score_spcv_glm <span class="operator">=</span> score<span class="punctuation">[</span>learner_id <span class="operator">==</span> <span class="string">&quot;classif.log_reg&quot;</span> <span class="operator">&amp;</span> </span><br><span class="line">                         resampling_id <span class="operator">==</span> <span class="string">&quot;repeated_spcv_coords&quot;</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<p>要计算所有500个模型的AUROC均值，我们运行：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mean<span class="punctuation">(</span>score_spcv_glm<span class="operator">$</span>classif.auc<span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">  <span class="built_in">round</span><span class="punctuation">(</span><span class="number">2</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] 0.77</span></span><br></pre></td></tr></table></figure>
<p>为了更全面地理解这些结果，让我们将它们与来自100次重复的5折非空间交叉验证的AUROC值进行比较；非空间交叉验证的代码在这里没有显示，但将在练习部分进行探讨）。
如预期，与传统的交叉验证方法相比，空间交叉验证的结果平均而言产生了较低的AUROC值，这强调了后者由于空间自相关而过于乐观的预测性能。</p>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309051217339.png" />
Boxplot showing the difference in GLM AUROC values on spatial and
conventional 100-repeated 5-fold cross-validation.</p>
<h2 id="机器学习超参数的空间调优">机器学习超参数的空间调优</h2>
<p><em>空间交叉验证</em>节绍了机器学习作为统计学习的一部分。回顾一下，我们遵循<a
target="_blank" rel="noopener" href="https://machinelearningmastery.com/linear-regression-for-machine-learning/">Jason
Brownlee</a>对机器学习的以下定义：</p>
<blockquote>
<p>机器学习，更具体地说是预测建模领域，主要关注的是最小化模型的错误或以解释性为代价做出尽可能准确的预测。在应用机器学习中，我们将从许多不同的领域借用、重用和窃取算法，包括统计学，并将它们用于这些目的。</p>
</blockquote>
<p>在节<em>广义线性模型</em>中，使用了广义线性模型（GLM）来预测滑坡敏感性。本节介绍了用于同一目的的支持向量机（SVM）。随机森林模型可能比SVM更受欢迎；然而，调整超参数对模型性能的积极影响在SVM的情况下更为明显<span
class="citation"
data-cites="probst_hyperparameters_2018">[@probst_hyperparameters_2018]</span>。由于（空间）超参数调整是本节的主要目标，我们将使用SVM。对于希望应用随机森林模型的人，我们建议阅读这一章，然后继续阅读章节<em>生态</em>，在其中我们将应用目前涵盖的概念和技术，基于随机森林模型制作空间分布图。</p>
<p>SVM（支持向量机）寻找最佳可能的'超平面'来分隔类别（在分类情况下）并估计具有特定超参数的'核'以在类别之间创建非线性边界<span
class="citation"
data-cites="james_introduction_2013">[@james_introduction_2013]</span>。
机器学习算法通常具有超参数和参数。参数可以从数据中估算，而超参数则在学习开始之前设置（另请参见<a
target="_blank" rel="noopener" href="https://machinelearningmastery.com/difference-between-a-parameter-and-a-hyperparameter/">machine
mastery blog</a>和mlr3书中的<a
target="_blank" rel="noopener" href="https://mlr3book.mlr-org.com/optimization.html">超参数优化章节</a>）。最优的超参数配置通常在特定的搜索空间内找到，并在交叉验证方法的帮助下确定。这称为超参数调优，是本节的主要话题。</p>
<p>一些SVM实现，如由<strong>kernlab</strong>提供的，允许自动调整超参数，通常基于随机抽样（见图3的上行）。这适用于非空间数据，但对于应进行'空间调优'的空间数据则用处不大。</p>
<p>在定义空间调优之前，我们将设置用于SVM的<strong>mlr3</strong>构建块，这些在<em>glm</em>节中已经介绍过。分类任务保持不变，因此我们可以简单地重用在节<em>glm</em>中创建的<code>task</code>对象。实现SVM的学习器可以使用<strong>mlr3extralearners</strong>的<code>list_mlr3learners()</code>命令找到。</p>
<p>在选项中，我们将使用<strong>kernlab</strong>软件包<span
class="citation"
data-cites="karatzoglou_kernlab_2004">[@karatzoglou_kernlab_2004]</span>的<code>ksvm()</code>。为了允许非线性关系，我们使用流行的径向基函数（或高斯）核（"rbfdot"），这也是<code>ksvm()</code>的默认设置。将<code>type</code>参数设置为<code>"C-svc"</code>确保<code>ksvm()</code>正在解决一个分类任务。为确保调优不会因一个失败的模型而停止，我们还定义了一个后备学习器（更多信息请参考https://mlr3book.mlr-org.com/technical.html#fallback-learners）。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lrn_ksvm <span class="operator">=</span> mlr3<span class="operator">::</span>lrn<span class="punctuation">(</span><span class="string">&quot;classif.ksvm&quot;</span><span class="punctuation">,</span> predict_type <span class="operator">=</span> <span class="string">&quot;prob&quot;</span><span class="punctuation">,</span> kernel <span class="operator">=</span> <span class="string">&quot;rbfdot&quot;</span><span class="punctuation">,</span></span><br><span class="line">                     type <span class="operator">=</span> <span class="string">&quot;C-svc&quot;</span><span class="punctuation">)</span></span><br><span class="line">lrn_ksvm<span class="operator">$</span>fallback <span class="operator">=</span> lrn<span class="punctuation">(</span><span class="string">&quot;classif.featureless&quot;</span><span class="punctuation">,</span> predict_type <span class="operator">=</span> <span class="string">&quot;prob&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>下一步是指定一个重采样策略。
我们再次将使用100次重复的5折空间交叉验证（CV）。</p>
<!-- 在我们的论文中，我们一致同意使用“性能估计级别”和“调优级别”，而不是说“外部和内部重采样” -->
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># performance estimation level</span></span><br><span class="line">perf_level <span class="operator">=</span> mlr3<span class="operator">::</span>rsmp<span class="punctuation">(</span><span class="string">&quot;repeated_spcv_coords&quot;</span><span class="punctuation">,</span> folds <span class="operator">=</span> <span class="number">5</span><span class="punctuation">,</span> repeats <span class="operator">=</span> <span class="number">100</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>请注意，这与节<em>glm</em>中用于GLM的重采样所用的代码完全相同；我们只是在这里重复它作为提醒。</p>
<p>到目前为止，这个过程与节<em>glm</em>中描述的过程相同。然而，下一步是新的：调整超参数。使用相同的数据进行性能评估和调优可能会导致过于乐观的结果<span class="citation" data-cites="cawley_overfitting_2010">[@cawley_overfitting_2010]</span>。这可以通过使用嵌套的空间交叉验证（CV）来避免。</p>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309051230694.png">
Schematic of hyperparameter tuning and performance estimation levels in
CV. [Figure was taken from Schratz et al. (2019). Permission to reuse it
was kindly granted.]</p>
<p>这意味着我们将每个折叠再次分成五个空间上不重叠的子折叠，这些子折叠用于确定最佳的超参数（下面代码块中的<code>tune_level</code>对象；见上图以获取视觉表示）。为了找到最优的超参数组合，我们在这些子折叠中分别拟合50个模型（下面代码块中的<code>terminator</code>对象），并为超参数C和Sigma随机选择值。C和Sigma的随机选择值还受到预定义调优空间（<code>search_space</code>对象）的额外限制。调优空间的范围是根据文献中推荐的值来选择的<span class="citation" data-cites="schratz_hyperparameter_2019">[@schratz_hyperparameter_2019]</span>。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># five spatially disjoint partitions</span></span><br><span class="line">tune_level <span class="operator">=</span> mlr3<span class="operator">::</span>rsmp<span class="punctuation">(</span><span class="string">&quot;spcv_coords&quot;</span><span class="punctuation">,</span> folds <span class="operator">=</span> <span class="number">5</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># use 50 randomly selected hyperparameters</span></span><br><span class="line">terminator <span class="operator">=</span> mlr3tuning<span class="operator">::</span>trm<span class="punctuation">(</span><span class="string">&quot;evals&quot;</span><span class="punctuation">,</span> n_evals <span class="operator">=</span> <span class="number">50</span><span class="punctuation">)</span></span><br><span class="line">tuner <span class="operator">=</span> mlr3tuning<span class="operator">::</span>tnr<span class="punctuation">(</span><span class="string">&quot;random_search&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># define the outer limits of the randomly selected hyperparameters</span></span><br><span class="line">search_space <span class="operator">=</span> paradox<span class="operator">::</span>ps<span class="punctuation">(</span></span><br><span class="line">  C <span class="operator">=</span> paradox<span class="operator">::</span>p_dbl<span class="punctuation">(</span>lower <span class="operator">=</span> <span class="operator">-</span><span class="number">12</span><span class="punctuation">,</span> upper <span class="operator">=</span> <span class="number">15</span><span class="punctuation">,</span> trafo <span class="operator">=</span> <span class="keyword">function</span><span class="punctuation">(</span>x<span class="punctuation">)</span> <span class="number">2</span><span class="operator">^</span>x<span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">  sigma <span class="operator">=</span> paradox<span class="operator">::</span>p_dbl<span class="punctuation">(</span>lower <span class="operator">=</span> <span class="operator">-</span><span class="number">15</span><span class="punctuation">,</span> upper <span class="operator">=</span> <span class="number">6</span><span class="punctuation">,</span> trafo <span class="operator">=</span> <span class="keyword">function</span><span class="punctuation">(</span>x<span class="punctuation">)</span> <span class="number">2</span><span class="operator">^</span>x<span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>下一步是根据所有定义超参数调优的特性，使用<code>AutoTuner$new()</code>来修改学习器<code>lrn_ksvm</code>。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">at_ksvm <span class="operator">=</span> mlr3tuning<span class="operator">::</span>AutoTuner<span class="operator">$</span>new<span class="punctuation">(</span></span><br><span class="line">  learner <span class="operator">=</span> lrn_ksvm<span class="punctuation">,</span></span><br><span class="line">  resampling <span class="operator">=</span> tune_level<span class="punctuation">,</span></span><br><span class="line">  measure <span class="operator">=</span> mlr3<span class="operator">::</span>msr<span class="punctuation">(</span><span class="string">&quot;classif.auc&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">  search_space <span class="operator">=</span> search_space<span class="punctuation">,</span></span><br><span class="line">  terminator <span class="operator">=</span> terminator<span class="punctuation">,</span></span><br><span class="line">  tuner <span class="operator">=</span> tuner</span><br><span class="line"><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>现在调优设置已完成，用于确定一个折叠的最佳超参数将拟合250个模型。重复这个过程针对每个折叠，我们最终得到125,000（250
*
5）个模型用于每次重复。重复100次意味着拟合总共125,000个模型以确定最佳超参数（见图）。这些将用于性能评估，这需要拟合另外500个模型（5个折叠
* 100次重复；参见图。
为了更清晰地描述性能评估处理链，让我们记录下我们给计算机的命令：</p>
<ol type="1">
<li>性能层次（图的左上部分）-
将数据集分成五个空间上不交叠的（外部）子折叠。</li>
<li>调优层次（图的左下部分）-
使用性能层次的第一个折叠，并再次将其空间上分成五个（内部）子折叠进行超参数调优。在这些内部子折叠中使用50个随机选定的超参数，即拟合250个模型。</li>
<li>性能估计 -
使用上一步（调优层次）中的最佳超参数组合，并将其应用于性能层次中的第一个外部折叠以估计性能（AUROC）。</li>
<li>重复步骤2和3，针对其余四个外部折叠。</li>
<li>重复步骤2至4，共100次。</li>
</ol>
<p>超参数调优和性能估计的过程在计算上是非常密集的。为了减少模型运行时间，<strong>mlr3</strong>提供了使用<strong>future</strong>包进行并行化的可能性。由于我们即将进行嵌套交叉验证，我们可以决定是否希望并行化内部循环或外部循环（见图的左下部分）。由于前者将运行125,000个模型，而后者仅运行500个，很明显我们应该并行化内部循环。要设置内部循环的并行化，我们执行：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">library<span class="punctuation">(</span>future<span class="punctuation">)</span></span><br><span class="line"><span class="comment"># execute the outer loop sequentially and parallelize the inner loop</span></span><br><span class="line">future<span class="operator">::</span>plan<span class="punctuation">(</span><span class="built_in">list</span><span class="punctuation">(</span><span class="string">&quot;sequential&quot;</span><span class="punctuation">,</span> <span class="string">&quot;multisession&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> </span><br><span class="line">             workers <span class="operator">=</span> <span class="built_in">floor</span><span class="punctuation">(</span>availableCores<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">/</span> <span class="number">2</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>确实，我们指示<strong>future</strong>包仅使用可用核心的一半而非全部（默认设置），这样做是为了在使用高性能计算集群的情况下允许其他可能的用户也能在同一个集群上工作。</p>
<p>现在，我们已经为执行嵌套空间交叉验证做好了准备。指定<code>resample()</code>参数的过程与使用GLM时完全相同，唯一的区别是<code>store_models</code>和<code>encapsulate</code>参数。将前者设置为<code>TRUE</code>将允许我们提取超参数调优结果，这在我们计划对调优进行后续分析时非常重要。后者确保即使其中一个模型出错，处理过程也会继续。这避免了由于一个失败的模型而导致整个过程停止，这在大规模模型运行中是非常需要的。一旦处理完成，可以查看失败的模型。处理完成后，最好使用<code>future:::ClusterRegistry("stop")</code>明确地停止并行化。最后，我们将输出对象（<code>result</code>）保存到磁盘，以防我们希望在另一个R会话中使用它。</p>
<p>在运行以下代码之前，请注意，由于它将执行包括125,500个模型在内的空间交叉验证，所以这是一个耗时的过程。在现代笔记本电脑上轻松运行半天也是可能的。需要注意的是，运行时间取决于多个方面：CPU速度、所选算法、所选核心数以及数据集。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">progressr<span class="operator">::</span>with_progress<span class="punctuation">(</span>expr <span class="operator">=</span> <span class="punctuation">&#123;</span></span><br><span class="line">  rr_spcv_svm <span class="operator">=</span> mlr3<span class="operator">::</span>resample<span class="punctuation">(</span>task <span class="operator">=</span> task<span class="punctuation">,</span></span><br><span class="line">                               learner <span class="operator">=</span> at_ksvm<span class="punctuation">,</span> </span><br><span class="line">                               <span class="comment"># outer resampling (performance level)</span></span><br><span class="line">                               resampling <span class="operator">=</span> perf_level<span class="punctuation">,</span></span><br><span class="line">                               store_models <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">,</span></span><br><span class="line">                               encapsulate <span class="operator">=</span> <span class="string">&quot;evaluate&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># stop parallelization</span></span><br><span class="line">future<span class="operator">:::</span>ClusterRegistry<span class="punctuation">(</span><span class="string">&quot;stop&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># compute the AUROC values</span></span><br><span class="line">score_spcv_svm <span class="operator">=</span> rr_spcv_svm<span class="operator">$</span>score<span class="punctuation">(</span>measure <span class="operator">=</span> mlr3<span class="operator">::</span>msr<span class="punctuation">(</span><span class="string">&quot;classif.auc&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span> </span><br><span class="line"><span class="comment"># keep only the columns you need</span></span><br><span class="line">score_spcv_svm <span class="operator">=</span> score_spcv_svm<span class="punctuation">[</span><span class="punctuation">,</span> .<span class="punctuation">(</span>task_id<span class="punctuation">,</span> learner_id<span class="punctuation">,</span> resampling_id<span class="punctuation">,</span> classif.auc<span class="punctuation">)</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<p>如果你不想在本地运行代码，我们已经将 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/geocompx/geocompr/blob/main/extdata/12-bmr_score.rds">score_svm</a>
保存在本书的GitHub仓库中。你可以按照以下方式加载它们：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">score <span class="operator">=</span> readRDS<span class="punctuation">(</span><span class="string">&quot;extdata/12-bmr_score.rds&quot;</span><span class="punctuation">)</span></span><br><span class="line">score_spcv_svm <span class="operator">=</span> score<span class="punctuation">[</span>learner_id <span class="operator">==</span> <span class="string">&quot;classif.ksvm.tuned&quot;</span> <span class="operator">&amp;</span> </span><br><span class="line">                         resampling_id <span class="operator">==</span> <span class="string">&quot;repeated_spcv_coords&quot;</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<p>让我们看一下最终的AUROC：模型区分两个类别的能力。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># final mean AUROC</span></span><br><span class="line"><span class="built_in">round</span><span class="punctuation">(</span>mean<span class="punctuation">(</span>score_spcv_svm<span class="operator">$</span>classif.auc<span class="punctuation">)</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] 0.74</span></span><br></pre></td></tr></table></figure>
<p>在这个特定情况下，似乎GLM（汇总的AUROC是
<code>r score[resampling_id == "repeated_spcv_coords" &amp; learner_id == "classif.log_reg", round(mean(classif.auc), 2)]</code>）比SVM略好一些。为了保证一个绝对公平的比较，还应确保两个模型使用完全相同的划分——这是我们在这里没有展示，但在背后默默使用的（更多信息请参见本书GitHub仓库中的<code>code/12_cv.R</code>）。为此，<strong>mlr3</strong>提供了<code>benchmark_grid()</code>和<code>benchmark()</code>函数<span class="citation" data-cites="becker_mlr3_2022">[参见https://mlr3book.mlr-org.com/perf-eval-cmp.html#benchmarking，@becker_mlr3_2022]</span>。我们将在练习中更详细地探讨这些函数。还请注意，在SVM的随机搜索中使用超过50次迭代可能会产生导致模型具有更好AUROC的超参数
<span class="citation" data-cites="schratz_hyperparameter_2019">[@schratz_hyperparameter_2019]</span>。另一方面，增加随机搜索迭代次数也会增加总模型数量，从而增加运行时间。</p>
<p>到目前为止，空间CV已被用于评估学习算法泛化到未见数据的能力。对于预测性制图目的，人们会在完整的数据集上调整超参数。这将在<em>生态</em>章中讨论。</p>
<h1 id="结论">结论</h1>
<p>重采样方法是数据科学家工具箱中的一个重要组成部分<span class="citation" data-cites="james_introduction_2013">[@james_introduction_2013]</span>。本章使用交叉验证来评估各种模型的预测性能。具有空间坐标的观测值可能由于空间自相关而不是统计上独立的，这违反了交叉验证的一个基本假设。空间CV通过减少空间自相引入的偏见来解决这个问题。</p>
<p><strong>mlr3</strong>软件包便于使用（空间）重采样技术，结合最受欢迎的统计学习技术，包括线性回归，如广义加性模型之类的半参数模型，以及如随机森林，SVMs和增强回归树<span class="citation" data-cites="bischl_mlr:_2016 schratz_hyperparameter_2019">[@bischl_mlr:_2016;@schratz_hyperparameter_2019]</span>等机器学习技术。机器学习算法通常需要超参数输入，其中最优的“调整”可能需要数千次模型运行，这需要大量的计算资源，消耗大量时间、RAM和/或核心。<strong>mlr3</strong>通过启用并行化来解决这个问题。</p>
<p>总体而言，机器学习及其用于理解空间数据是一个大领域，本章提供了基础知识，但还有更多需要学习。我们推荐以下方向的资源：</p>
<ul>
<li><strong>mlr3 book</strong> [<span class="citation" data-cites="becker_mlr3_2022">@becker_mlr3_2022</span>;
https://mlr-org.github.io/mlr-tutorial/release/html/]，特别是<a target="_blank" rel="external nofollow noopener noreferrer" href="https://mlr3book.mlr-org.com/spatiotemporal.html">关于处理时空数据的章节</a></li>
<li>关于超参数调整的学术论文<span class="citation" data-cites="schratz_hyperparameter_2019">[@schratz_hyperparameter_2019]</span></li>
<li>关于如何使用<strong>mlr3spatiotempcv</strong>的学术论文<span class="citation" data-cites="schratz_mlr3spatiotempcv_2021">[@schratz_mlr3spatiotempcv_2021]</span></li>
<li>在处理时空数据的情况下，应当在进行CV时考虑空间和时间自相关<span class="citation" data-cites="meyer_improving_2018">[@meyer_improving_2018]</span></li>
</ul>
<h1 id="练习">练习</h1>
<p>E1.
使用R-GIS桥梁（参见GIS软件桥梁章节），从通过<code>terra::rast(system.file("raster/ta.tif", package = "spDataLarge"))$elev</code>加载的<code>elev</code>数据集中计算以下地形属性：</p>
<ul>
<li>坡度</li>
<li>平面曲率</li>
<li>轮廓曲率</li>
<li>流域面积</li>
</ul>
<p>E2.
从相应的输出栅格中提取值到<code>lsl</code>数据框（通过<code>data("lsl", package = "spDataLarge")</code>），并添加名为<code>slope</code>、<code>cplan</code>、<code>cprof</code>、<code>elev</code>和<code>log_carea</code>的新变量。</p>
<p>E3.
结合GLM使用派生的地形属性栅格，制作一个与图12.2中显示的相似的空间预测地图。
运行<code>data("study_mask", package = "spDataLarge")</code>将学习区域的掩码附加上。</p>
<p>E4.
基于GLM学习器计算100次重复的5折非空间交叉验证和空间CV，并利用箱线图比较两种重采样策略的AUROC值。</p>
<p>提示：你需要指定一个非空间重采样策略。</p>
<p>另一个提示：你可能想借助<code>mlr3::benchmark()</code>和<code>mlr3::benchmark_grid()</code>（更多信息，请参考https://mlr3book.mlr-org.com/performance.html#benchmarking）一次性解决练习4至6。
在做此操作时，请记住计算可能需要很长时间，可能需要几天。
这当然取决于你的系统。 你拥有的RAM和核心越多，计算时间就会越短。</p>
<p>E5. 使用二次判别分析（QDA）对滑坡敏感性进行建模。 评估QDA的预测性能。
QDA和GLM的空间交叉验证平均AUROC值之间有什么区别？</p>
<p>E6. 不调整超参数运行SVM。 使用<span class="math inline">\(\sigma\)</span> = 1 和 <em>C</em> =
1的<code>rbfdot</code>核。
否则，在<strong>kernlab</strong>的<code>ksvm()</code>中不指定超参数将初始化自动的非空间超参数调整。</p>
<aside id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr>
<ol>
<li id="fn1"><p>虽然不需要附加，但还必须安装<strong>GGally</strong>、<strong>lgr</strong>、<strong>kernlab</strong>、<strong>mlr3measures</strong>、<strong>paradox</strong>、<strong>pROC</strong>、<strong>progressr</strong>
和 <strong>spDataLarge</strong>包。<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>几十年来，将统计技术应用于地理数据一直是地统计学、空间统计学和点模式分析领域中的一个活跃的研究课题。统计学习结合了统计和机器学习的方法，并可分为监督和无监督技术。这两者越来越多地应用于从物理学、生物学和生态学到地理学和经济学等各个学科<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>滑坡发起点位于滑坡多边形的断崖中。有关进一步的详细信息。<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p><strong>mlr3</strong> 生态系统大量使用
<strong>data.table</strong> 和 <strong>R6</strong>
类。尽管你可能在不了解 <strong>data.table</strong> 或
<strong>R6</strong> 的具体情况下使用
<strong>mlr3</strong>，但了解它们可能相当有帮助。要了解更多关于
<strong>data.table</strong> 的信息，请参考
https://rdatatable.gitlab.io/data.table/index.html。要了解更多关于
<strong>R6</strong>，我们推荐阅读《Advanced R》书的<a target="_blank" rel="external nofollow noopener noreferrer" href="https://adv-r.hadley.nz/fp.html">第14章</a> <span class="citation" data-cites="wickham_advanced_2019">[@wickham_advanced_2019]</span>。<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>请注意，<strong>sperrorest</strong>
包最初在R中实现了空间交叉验证 <span class="citation" data-cites="brenning_spatial_2012">[@brenning_spatial_2012]</span>。其功能已经被集成到
<strong>mlr3</strong> 生态系统中，这就是为什么我们使用
<strong>mlr3</strong> <span class="citation" data-cites="schratz_hyperparameter_2019">[@schratz_hyperparameter_2019]</span>。<strong>tidymodels</strong>
框架是R中另一个用于简化建模的 umbrella-package；然而，它最近才通过
<strong>spatialsample</strong>
集成了对空间交叉验证的支持，迄今为止只支持一种空间重采样方法。<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>

            
        </div>

        
        
        

        <div>
            
        </div>

        <footer class="post-footer">
            <div class="post-eof"></div>
            
        </footer>
    </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
    </main>
    <footer class="footer">
      <div class="footer-inner">

<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">178k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">10:47</span>
  </span>
</div>
<div class="busuanzi-count">
</div>

<!-- 删除 “由 Hexo & NexT.Gemini 强力驱动” -->
<!-- -->

      </div>
    </footer>
    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

    
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.20/fancybox/fancybox.umd.js" integrity="sha256-q8XkJ6dj5VwSvzI8+nATCHHQG+Xv/dAZBCgqmu93zOY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/algoliasearch/4.19.1/algoliasearch-lite.umd.js" integrity="sha256-qzlNbRtZWHoUV5I2mI2t9QR7oYXlS9oNctX+0pECXI0=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/instantsearch.js/4.56.8/instantsearch.production.min.js" integrity="sha256-xUys6KCuRGBxFaRaYZlWulRUjY48XFv6/Q2s0mb1dmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/algolia-search.js"></script>
<script class="next-config" data-name="chatra" type="application/json">{"enable":true,"async":true,"id":null}</script>
<script src="/js/third-party/chat/chatra.js"></script>
<script async src="https://call.chatra.io/chatra.js"></script>

  <script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.2.12/pdfobject.min.js","integrity":"sha256-g2xji1rlE3KsGVClvuxTbcR0Kn2+wtQADSff2Tbb4zA="},"url":"/lib/pdf/web/viewer.html"}</script>
  <script src="/js/third-party/tags/pdf.js"></script>

  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.3.0/mermaid.min.js","integrity":"sha256-9y71g5Lz/KLsHjB8uXwnkuWDtAMDSzD/HdIbqhJfTAI="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>

  <script class="next-config" data-name="wavedrom" type="application/json">{"enable":true,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/wavedrom/3.3.0/wavedrom.min.js","integrity":"sha256-IRMDzTC+wK5stMucZ/XSXkeS5VNtxZ+/Bm8Mcqfoxdo="}}</script>
  <script class="next-config" data-name="wavedrom_skin" type="application/json">{"enable":true,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/wavedrom/3.3.0/skins/default.js","integrity":"sha256-fduc/Zszk5ezWws2uInY/ALWVmIrmV6VTgXbsYSReFI="}}</script>
  <script src="/js/third-party/tags/wavedrom.js"></script>

  <script src="/js/third-party/fancybox.js"></script>


  <script src="/js/third-party/addtoany.js"></script>

    
  <script data-pjax async src="/js/busuanzi.js"></script>



  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"ams","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


  <script src="https://cdnjs.cloudflare.com/ajax/libs/quicklink/2.3.0/quicklink.umd.js" integrity="sha256-yvJQOINiH9fWemHn0vCA5lsHWJaHs6/ZmO+1Ft04SvM=" crossorigin="anonymous"></script>
  <script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":true,"archive":true,"delay":true,"timeout":3000,"priority":true,"url":"https://ancao96.github.io/"}</script>
  <script src="/js/third-party/quicklink.js"></script>
<script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"https://waline-server-nxpj3ksyo-scy.vercel.app","cssUrl":"https://unpkg.com/@waline/client@v2/dist/waline.css","commentCount":true,"pageview":false,"placeholder":"请文明评论呀~","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"visitor":true,"comment_count":true,"requiredFields":["nick","mail"],"libUrl":"//unpkg.com/@waline/client@v2/dist/waline.js","eemoji":["https://unpkg.com/@waline/emojis@1.1.0/tw-emoji","//unpkg.com/@waline/emojis@1.1.0/bilibili","//unpkg.com/@waline/emojis@1.1.0/alus","https://unpkg.com/@waline/emojis@1.1.0/weibo"],"el":"#waline","comment":true,"path":"/"}</script>
<link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css">
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script>

    <link rel="stylesheet" href="/dist/APlayer.min.css">
    <div id="aplayer"></div>
    <script type="text/javascript" src="/dist/APlayer.min.js"></script>
    <script type="text/javascript" src="/dist/music.js"></script>
    
  </body>
</html>
