<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>产水量计算</title>
    <url>/2020/10/20/2023-8-20-%E4%BA%A7%E6%B0%B4%E9%87%8F%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<h1 id="产水量模型">产水量模型</h1>
<p>InVEST模型的产水量：水库水电生产模块，不仅评估了景观中各次一级流域对产水的相对贡献量，而且有助于研究土地利用格局变化如何影响年地表产水量和水电生产。</p>
<p>模拟景观格局变化和水文过程的关系是个科学难题。用来模拟这些关系及其相关
过程的复杂模型（如WEAP水资源评估和规划系统模型）要求较高的数据和资源资料，并且要求大量专业知识。为满足更多学科背景需求，使用易获取的数据，InVEST模型绘制和模拟用于景观水电生产的年平均产水量，而不是直接评估土地利用/覆被变化导致的水电减产，因为这一过程在逐日和逐月的时间尺度上主要由流入水量变化决定。
因此，InVEST模型计算了景观中各子流域对产水的相对贡献量及其对应的水电产量。
水库经济使用年限内的水电生产净现值也可以通过年收益还原法计算。
<span id="more"></span></p>
<ul>
<li><p><a href="#工作原理">工作原理</a></p></li>
<li><p><a href="#数据需求">数据需求</a></p>
<ul>
<li><a
href="#土壤的最大根系埋藏深度必需">土壤的最大根系埋藏深度（必需）：</a></li>
<li><a href="#年降水量必需">年降水量（必需）：</a></li>
<li><a href="#植物可利用水量必需">植物可利用水量（必需）：</a></li>
<li><a href="#年平均潜在蒸散发必需">年平均潜在蒸散发（必需）：</a></li>
<li><a href="#土地利用覆被必需">土地利用/覆被（必需）：</a></li>
<li><a href="#流域必需">流域（必需）：</a></li>
<li><a href="#次一级小流域必需">次一级小流域（必需）：</a></li>
<li><a href="#生物物理系数表必需">生物物理系数表（必需）：</a></li>
<li><a href="#季节常数Z必需">季节常数Z（必需）：</a></li>
<li><a href="#用水需求表必需">用水需求表（必需）：</a></li>
</ul></li>
<li><p><a href="#结果分析">结果分析</a></p></li>
</ul>
<h1 id="工作原理"><em>工作原理</em></h1>
<p>模型运行基于栅格地图。模型估算了研究区各次一级流域对水电生产贡献水量及其经济价值。模块包括三个组件，按顺序运行。</p>
<ol type="1">
<li>模型估算了每栅格单元降水量减去实际蒸散发后的水量即水源供给量。
模型不做地表水、地下水、基流的区分，而是假设每个栅格单元的产水通过上述途径汇集到信息点。然后，模型计算出次一级流域产水量的总量和平均值。栅格计算有助于确定决定流域产汇流空间异质性的关键因素，如土壤类型，降水量，植被类型等。
但是，这组模型的基础理论基于次一级流域到流域尺度，对次一级流域过程的模型解释是可信的，因此产水量的总量和/或平均值结果也应当维持在次一级流域水平上。模型仅为校准和模型检验提供输出结果的栅格数据。这些栅格数据图件不能用于水文过程的解释说明，或作为任何类型的决策信息源。</li>
<li>模型计算了用于水电生产的水源供给量，即将水源供给总量减去除水电生产以外的其他用水量。</li>
<li>模型计算了到达水库水流的发电量及其水库有效使用年期内的经济价值。</li>
</ol>
<p><strong><em>NOTE</em></strong>: Water Yield
模块运行的前提条件是假设栅格单元的产水量都是通过地表径流或
者地下径流的方式汇集到流域出口，在这个前提条件下计算每个栅格单元的产水量,
即降水量减去植被蒸腾与地表蒸散。</p>
<p><strong><em>产水量评估模型</em></strong></p>
<p>产水量评估模块基于Budyko水热耦合平衡假设（1974）和年平均降水量数据。首先，确定研究区每个栅格单元<span
class="math inline">\(x\)</span>的年产水量<span
class="math inline">\(Y(x)\)</span>，公式如下：</p>
<p><span class="math display">\[
Y(x)=\left(1-\frac{A E T(x)}{P(x)}\right) \cdot P(x)
\]</span></p>
<p><span class="math inline">\(AET(x)\)</span>表示栅格单元<span
class="math inline">\(x\)</span>的年实际蒸散量、<span
class="math inline">\(P(x)\)</span>表示栅格单元<span
class="math inline">\(x\)</span>的年降水量。</p>
<p>水量平衡公式中，土地利用/覆被类型的植被蒸散发<span
class="math inline">\(\frac{A E
T(x)}{P(x)}\)</span>计算，采用Fu和Zhang等提出的Budyko水热耦合平衡假设公式：</p>
<p><span class="math display">\[
\frac{A E T(x)}{P(x)}=1+\frac{P E T(x)}{P(x)}-\left[1+\left(\frac{P E
T(x)}{P(x)}\right)^{\omega}\right]^{1 / \omega}
\]</span></p>
<p><span
class="math inline">\(PET(x)\)</span><strong>表示潜在蒸散量</strong>、<span
class="math inline">\(ω(x)\)</span>表示自然气候-土壤性质的非物理参数。
潜在蒸散量<span class="math inline">\(PET(x)\)</span>定义为：</p>
<p><span class="math display">\[
{PET}(x)=K_{c}\left(\ell_{x}\right) \cdot E T_{0}(x)
\]</span></p>
<p>式中，<span class="math inline">\(ET_0(x)\)</span>表示栅格单元<span
class="math inline">\(x\)</span>的参考作物蒸散，<span
class="math inline">\(K_c(\ell_x)\)</span>表示栅格单元<span
class="math inline">\(x\)</span>中特定土地利用/覆被类型的植物（植被）蒸散系数。<span
class="math inline">\(ET_0(x)\)</span>通过参考作物蒸散量反映当地气候条件，例如苜蓿的蒸散量反映其草地生境气候。<span
class="math inline">\(K_c(\ell_x)\)</span>很大程度上取决于栅格单元<span
class="math inline">\(x\)</span>中土地利用/覆被的植被性质。在土地利用/覆被图中，<span
class="math inline">\(K_c\)</span>用于将<span
class="math inline">\(ET_0(x)\)</span>修正为栅格单元中特定作物或植被类型蒸散量。</p>
<p><span class="math inline">\(ω(x)\)</span>是一个经验参数，通常用<span
class="math inline">\(\frac{A W C \times
N}{P}\)</span>线性函数表示，式中<span
class="math inline">\(N\)</span>表示每年的降水事件数，<span
class="math inline">\(AWC\)</span>表示植物可利用水含量。虽然基于全球数据的$
ω(x) $公式亟待进一步研究，
InVEST模型采用Donohue等人提出的公式表达，定义为：</p>
<p><span class="math display">\[
\]</span></p>
<ul>
<li><span
class="math inline">\(AWC(x)\)</span>表示土壤有效含水量（mm），由土壤质地和土壤有效深度决定，用来确定土壤为植物生长储存和提供的总水量。由植物利用水分含量<span
class="math inline">\((PAWC)\)</span>，
以及土壤的最大根系埋藏深度和植物根系深度的最小值决定：</li>
</ul>
<p><span class="math display">\[
A W C(x)=\operatorname{Min}( Re st.layer.depth, root.depth ) \cdot PAWC
\]</span></p>
<p>土壤的最大根系埋藏深度是指由于环境的物理和化学特征不同，植物根系在土壤中能够延伸的最大深度（也叫土壤深度）。植物根系深度通常指特定植物类型的根系生物量为95%的土层深度。<span
class="math inline">\(PAWC\)</span>表示植物利用水分含量，即田间持水量和萎蔫点之间的差值。</p>
<ul>
<li><span
class="math inline">\(Z\)</span>为经验常数，又称<code>季节常数</code>，能够代表区域降水分布及其他水文地质特征。<span
class="math inline">\(Z\)</span>与<span
class="math inline">\(N\)</span>正相关，<span
class="math inline">\(N\)</span>是每年降水发生次数。1.25为<span
class="math inline">\(ω(x)\)</span>基数，即裸地（根系深度为0）的植被年需水量和年降水量比值。<span
class="math inline">\(ω(x)\)</span>上限为5。</li>
</ul>
<p>其他土地利用/覆被类型（开放水域，城市，湿地）的实际蒸散发通过参考作物蒸散<span
class="math inline">\(ET_0(x)\)</span>直接计算，由降水量决定其最大值：</p>
<p><span class="math display">\[
A E T(x)=\operatorname{Min}\left(K_{c}\left(\ell_{x}\right) \cdot E
T_{0}(x), P(x)\right)
\]</span></p>
<p><span class="math inline">\(ET_0(x)\)</span>表示参考作物蒸散，而<span
class="math inline">\(K_c(\ell_x)\)</span>表示特定土地利用/覆被类型蒸腾作用的影响因子。</p>
<h1 id="数据需求"><strong><em>数据需求</em></strong></h1>
<p>模型使用的数据需求列表如下，关于数据来源和预处理的详细信息见附录。所有数据输入前，应先定义栅格数据投影，栅格单位为米（m）。</p>
<h2
id="土壤的最大根系埋藏深度必需">土壤的最大根系埋藏深度（必需）：</h2>
<p>每个栅格对应一个土壤的最大根系埋藏深度平均值的GIS栅格数据集。土壤的最大根系埋藏深度是指由于环境的物理和化学特征不同，植物根系在土壤中能够延伸的最大深度，单位毫米（mm）。根系限制层深度可从一些土壤图中获得。如果无法获得根系限制层深度或按土壤类型划分的可扎根深度，可使用土壤深度作为替代。如果有几个土壤层是详细的，那么限制根系层的深度就是非限制性土壤层的深度之和。</p>
<p><em>命名：</em>用户自定义，但若为ESRI
GRID格式，文件名不能有空格并且少于13个字，
若为TIF或IMG格式，命名可能更长。</p>
<p><em>格式：</em> GIS标准栅格文件（如：ESRI
GRID，TIF或IMG），每个栅格对应一个土壤的最大根系埋藏深度平均值，单位毫米（mm）。</p>
<p><em>数据获得：</em></p>
<ol type="1">
<li><a href="http://globalchange.bnu.edu.cn/research/cdtb.jsp"
title="http://globalchange.bnu.edu.cn/research/cdtb.jsp">http://globalchange.bnu.edu.cn/research/cdtb.jsp</a>
（单位为m，需转化为mm，已下载处理，上传百度☁️） 原文 <a
href="https://doi.org/10.1038/s41597-019-0345-6"
title="https://doi.org/10.1038/s41597-019-0345-6">https://doi.org/10.1038/s41597-019-0345-6</a></li>
<li>SoilGrids250m 2017-03 - Depth to bedrock (R horizon)
（单位为cm，需转化为mm）<a
href="https://data.isric.org/geonetwork/srv/eng/catalog.search#/metadata/bfb01655-db81-4571-b6eb-3caae86c037a"
title="https://data.isric.org/geonetwork/srv/eng/catalog.search#/metadata/bfb01655-db81-4571-b6eb-3caae86c037a">https://data.isric.org/geonetwork/srv/eng/catalog.search#/metadata/bfb01655-db81-4571-b6eb-3caae86c037a</a></li>
</ol>
<h2 id="年降水量必需">年降水量（必需）：</h2>
<p>每个栅格对应一个非空值的<strong>年平均降水量</strong>的GIS栅格数据集，单位毫米（mm）。</p>
<p><em>命名</em>：用户自定义，但若为ESRI
GRID格式，文件名不能有空格并且少于13个字，
若为TIF或IMG格式，命名可能更长。</p>
<p><em>格式</em>：GIS标准栅格文件（如：ESRI
GRID，TIF或IMG），每个栅格对应一个年平 均降水量。</p>
<p><em>数据获得</em>：</p>
<ol type="1">
<li>利用<a href="https://www.wolai.com/pLvSQy6dLBrwJX9ATDTiy4"
title="日值（v3）数据">日值（v3）数据</a>进行差值。</li>
<li>国家地球系统科学数据中心：中国1km分辨率年降水量数据（2001-2020年）已下载直接使用，单位为0.1mm
<a
href="http://www.geodata.cn/data/datadetails.html?dataguid=113786088533256&amp;docid=3549"
title="http://www.geodata.cn/data/datadetails.html?dataguid=113786088533256&amp;docid=3549">http://www.geodata.cn/data/datadetails.html?dataguid=113786088533256&amp;docid=3549</a></li>
<li>WorldClim (v 2.1) 数据范围：1970-2000，月值，最大精度：30s ，单位:mm
<a href="https://www.worldclim.org/data/worldclim21.html"
title="https://www.worldclim.org/data/worldclim21.html">https://www.worldclim.org/data/worldclim21.html</a></li>
<li>GEE （"UCSB-CHG/CHIRPS/DAILY")数据集，完整教程见<a
href="https://www.wolai.com/mQ6iivaJ3BAPg21kq2uXsE"
title="编程分享-利用GEE得到研究区年、月、日降水量数据">编程分享-利用GEE得到研究区年、月、日降水量数据</a></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="variable constant_">ROI</span> = ee.<span class="title class_">FeatureCollection</span>(<span class="string">&quot;users/rice20220411/AH&quot;</span>);</span><br><span class="line"><span class="title class_">Map</span>.<span class="title function_">addLayer</span>(<span class="variable constant_">ROI</span>,&#123;&#125;,<span class="string">&#x27;ROI&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">2015</span>;i&lt;=<span class="number">2021</span>;i++)&#123;</span><br><span class="line"><span class="keyword">var</span> CHIRPS_Daily = ee.<span class="title class_">ImageCollection</span>(<span class="string">&quot;UCSB-CHG/CHIRPS/DAILY&quot;</span>)</span><br><span class="line">.<span class="title function_">filterDate</span>(i+<span class="string">&#x27;-01-01&#x27;</span>, i+<span class="string">&#x27;-12-31&#x27;</span>)</span><br><span class="line"> .<span class="title function_">select</span>(<span class="string">&#x27;precipitation&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> CHIRPS_Year_mean = CHIRPS_Daily.<span class="title function_">mean</span>().<span class="title function_">clip</span>(<span class="variable constant_">ROI</span>)</span><br><span class="line"><span class="keyword">var</span> precipitationVis = &#123;</span><br><span class="line">  <span class="attr">min</span>: <span class="number">1.0</span>,</span><br><span class="line">  <span class="attr">max</span>: <span class="number">17.0</span>,</span><br><span class="line">  <span class="attr">palette</span>: [<span class="string">&#x27;001137&#x27;</span>, <span class="string">&#x27;0aab1e&#x27;</span>, <span class="string">&#x27;e7eb05&#x27;</span>, <span class="string">&#x27;ff4a2d&#x27;</span>, <span class="string">&#x27;e90000&#x27;</span>],</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">print</span>(CHIRPS_Year_mean)</span><br><span class="line"><span class="title class_">Map</span>.<span class="title function_">addLayer</span>(CHIRPS_Year_mean, precipitationVis, i+<span class="string">&#x27;_CHIRPS_Year_mean&#x27;</span>);</span><br><span class="line"><span class="comment">// Map.addLayer(CHIRPS_Daily.first().clip(ROI), precipitationVis, &#x27;CHIRPS_Year_mean_first&#x27;);</span></span><br><span class="line"><span class="title class_">Export</span>.<span class="property">image</span>.<span class="title function_">toDrive</span>(&#123;</span><br><span class="line">      <span class="attr">image</span>: CHIRPS_Year_mean,</span><br><span class="line">      <span class="attr">description</span>: i+<span class="string">&#x27;year_mean&#x27;</span>,</span><br><span class="line">      <span class="attr">region</span>: <span class="variable constant_">ROI</span>,</span><br><span class="line">      <span class="attr">maxPixels</span>: <span class="number">1e13</span>,</span><br><span class="line">      <span class="attr">folder</span>: <span class="string">&#x27;CHIRPS&#x27;</span></span><br><span class="line">    &#125;) </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="植物可利用水量必需">植物可利用水量（必需）：</h2>
<p>每个栅格对应一个植物可利用水的GIS栅格数据集。
植物可利用水（PAWC）是指土壤土层中为植物生长提供的水量所占比例。PAWC是[0,1]的小数。</p>
<p><em>命名</em>：用户自定义，但若为ESRI
GRID格式，文件名不能有空格并且少于13个字，
若为TIF或IMG格式，命名可能更长。 </p>
<p><em>格式</em>：GIS标准栅格文件（如：ESRI
GRID，TIF或IMG），每个栅格对应一个植物可利用水含量百分比。</p>
<p><em>数据获得</em>：（下载好处理好后传百度☁️）</p>
<p>SoilGrids250m 2017-03 - “Derived available soil water capacity
(volumetric fraction) until wilting point” (<a
href="https://data.isric.org/geonetwork/srv/eng/catalog.search#/metadata/e33e75c0-d9ab-46b5-a915-cb344345099c"
title="https://data.isric.org/geonetwork/srv/eng/catalog.search#/metadata/e33e75c0-d9ab-46b5-a915-cb344345099c">https://data.isric.org/geonetwork/srv/eng/catalog.search#/metadata/e33e75c0-d9ab-46b5-a915-cb344345099c</a>)
SoilGrids 2.0版目前不提供AWC。SoilGrids
2017提供7个土壤深度区间的AWC层。所有7个深度区间都需要下载，然后合并成一个单一的图层，以便在模型中使用。</p>
<p>栅格值以整数百分比的形式给出（如25，表示AWC值为25%）。
（标准）深度区间的平均值，如0-5厘米或0-30厘米，可以通过使用数字积分，如梯形规则，对深度区间内的预测值进行加权平均来得出：</p>
<p><span class="math display">\[
\left(\frac{1}{(b-a)}\right)\left(\frac{1}{2}\right)
\sum_{k=1}^{N-1}\left(x_{k+1}-x_{k}\right)\left(f\left(x_{k}\right)+f\left(x_{k+1}\right)\right)
\]</span></p>
<p>其中，<span class="math inline">\(N\)</span>是深度数，<span
class="math inline">\(x_k\)</span>是第<span
class="math inline">\(k\)</span>个深度，<span
class="math inline">\(f(x_k)\)</span>是目标变量（即土壤属性）在深度<span
class="math inline">\(x_k\)</span>的值。</p>
<p>操作步骤：</p>
<ol type="1">
<li>从ISRIC网站上下载所有可用的深度区间。深度区间为0cm-200cm。注意，每个栅格的大小为1.5GB。</li>
<li>使用 GIS
缓冲区工具，在你要建模的流域/感兴趣的区域周围创建一个缓冲区。由于SoilGrids数据的分辨率为250米，因此缓冲区的宽度为250或500米。这样做是为了确保土壤数据完全覆盖你正在建模的流域，边界周围没有漏洞。</li>
<li>使用缓冲流域，将所有原始的ISRIC AWC
栅格数据剪辑到你感兴趣的区域。在ArcGIS中，这可以通过空间分析工具<code>掩模提取</code>来完成。在这个例子中，我们将把剪下的图层称为AWC_sl1_clip.tif、AWC_sl2_clip.tif
... AWC_sl7_clip.tif。</li>
<li>使用GIS栅格计算器工具来计算合并后的AWC层。将其代入上面的方程，我们可以得到：
<span class="math display">\[(1/(200-0)) \* (1/2) \* ( ((5-0) \*
(AWC\_sl1\_clip.tif + AWC\_sl2\_clip.tif)) + ((15-5) \*
(AWC\_sl2\_clip.tif + AWC\_sl3\_clip.tif)) + ((30-15) \*
(AWC\_sl3\_clip.tif + AWC\_sl4\_clip.tif)) + ((60-30) \*
(AWC\_sl4\_clip.tif + AWC\_sl5\_clip.tif)) + ((100-60) \*
(AWC\_sl5\_clip.tif + AWC\_sl6\_clip.tif)) + ((200-100) \* (
AWC\_sl6\_clip.tif + AWC\_sl7\_clip.tif)) )\]</span>
将此公式输入光栅计算器，根据需要调整文件名。</li>
<li>得到的栅格应该包含0-100范围内的数值，代表整数百分比。该模型<strong>要求AWC以分数</strong>的形式给出，因此将步骤4中计算的<strong>栅格除以100</strong>。</li>
<li>重新投影AWC分数层，使其具有与其他模型输入相同的投影坐标系统。这个栅格现在可以用作模型的可用水含量输入。</li>
</ol>
<h2 id="年平均潜在蒸散发必需">年平均潜在蒸散发（必需）：</h2>
<p>
每个栅格对应一个<strong>年平均潜在蒸散发</strong>的GIS栅格数据集。潜在蒸散发是指水分充足的情况下，通过土壤蒸发和植物（如苜蓿或其他草类等健康植被）蒸散作用可能散逸的水量，单位毫米（mm）。</p>
<p><em>命名</em>：用户自定义，但若为ESRI
GRID格式，文件名不能有空格并且少于13个字，若为TIF或IMG格式，命名可能更长。
</p>
<p><em>格式</em>：GIS标准栅格文件（如：ESRI
GRID，TIF或IMG），每个栅格对应一个年平均潜在蒸散发。</p>
<p><em>数据获得</em>：</p>
<ul>
<li>FA0工具计算，详见<a
href="https://www.wolai.com/sWbxWLVBydbK2t5aT584Fa"
title="使用EToCalculator 计算潜在蒸散发详细教程">使用EToCalculator
计算潜在蒸散发详细教程</a><a
href="https://blog.sciencenet.cn/blog-3459054-1308734.html"
title="https://blog.sciencenet.cn/blog-3459054-1308734.html">https://blog.sciencenet.cn/blog-3459054-1308734.html</a></li>
<li>Global Aridity Index and Potential Evapotranspiration (ET0) Climate
Database v2 (Penman Monteith Evapotranspiration
equation，30弧秒，1970-2000，暂时未使用，有待验证。) <a
href="https://figshare.com/articles/dataset/Global_Aridity_Index_and_Potential_Evapotranspiration_ET0_Climate_Database_v2/7504448/3"
title="https://figshare.com/articles/dataset/Global_Aridity_Index_and_Potential_Evapotranspiration_ET0_Climate_Database_v2/7504448/3">https://figshare.com/articles/dataset/Global_Aridity_Index_and_Potential_Evapotranspiration_ET0_Climate_Database_v2/7504448/3</a></li>
<li>大部分研究采用，Modified-Hargreaves 法对潜在蒸散量进行计算。
式中：<span
class="math inline">\(ET_0\)</span>代表栅格单元上的潜在蒸散量（mm）；<span
class="math inline">\(RA\)</span>为太阳大气顶层辐射 （<span
class="math inline">\(MJ·m^{-2}·d^{-1}\)</span>）；<span
class="math inline">\(T_a\)</span>为不同小流域的日最高温均值和日最低温均值的平均值（°C）；
<span
class="math inline">\(T_d\)</span>为小流域上的日最高温均值和日最低温均值的差值（°C）；<span
class="math inline">\(P\)</span>为小流域的降雨量 （mm）。</li>
</ul>
<p><span class="math display">\[
ET_{0}=0.0013 \times 0.408 \times R A
\times\left(T_{\mathrm{a}}+17\right) \times\left(T_{\mathrm{d}}-0.0123
P\right)^{0.76}
\]</span></p>
<ul>
<li>GEE获取 (Penman-Monteith法)（代码传GEE和GitHub）
已经下载全国区域的2000-2020年数据压缩上传百度云 </li>
</ul>
<p> 原文链接 <a href="https://doi.org/10.1016/j.rse.2018.12.031"
title="https://doi.org/10.1016/j.rse.2018.12.031">https://doi.org/10.1016/j.rse.2018.12.031</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//完美运行，输入坐标即可，获取每年的平均值。</span></span><br><span class="line"><span class="comment">//加入矢量边界之后直接运行var </span></span><br><span class="line"><span class="keyword">var</span> <span class="variable constant_">ROI</span> = table.<span class="title function_">geometry</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Map.addLayer(ROI,&#123;&#125;,&#x27;ROI&#x27;);</span></span><br><span class="line"><span class="keyword">var</span> imgcol_PMLV2_v016_8d = ee.<span class="title class_">ImageCollection</span>(<span class="string">&#x27;projects/pml_evapotranspiration/PML/OUTPUT/PML_V2_8day_v016&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> imgcol_PMLV2_v016_8d = ee.<span class="title class_">ImageCollection</span>(imgcol_PMLV2_v016_8d.<span class="title function_">toList</span>(<span class="number">2000</span>));</span><br><span class="line"><span class="title function_">print</span>(imgcol_PMLV2_v016_8d);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pkg_export = <span class="built_in">require</span>(<span class="string">&#x27;users/kongdd/pkgs:pkg_export.js&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;drive&quot;</span>,</span><br><span class="line">    <span class="attr">range</span>: [<span class="number">110</span>,<span class="number">34</span>,<span class="number">114</span>,<span class="number">40</span>],<span class="comment">//ROI, // [73, 25, 105, 40], </span></span><br><span class="line">    <span class="attr">cellsize</span>: <span class="number">1</span>/<span class="number">240</span>,</span><br><span class="line">    <span class="comment">// crsTransform : [463.312716528, 0, -20015109.354, 0, -463.312716527, 10007554.677], // prj.crsTransform;</span></span><br><span class="line">    <span class="comment">// scale        : 463.3127165275, // prj.scale</span></span><br><span class="line">    <span class="attr">crs</span>: <span class="string">&#x27;EPSG:4326&#x27;</span>, <span class="comment">// &#x27;SR-ORG:6974&#x27;, // EPSG:4326</span></span><br><span class="line">    <span class="attr">folder</span>: <span class="string">&#x27;ET0&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> imgcol_years = <span class="title function_">aggregateToYearly</span>(imgcol_PMLV2_v016_8d, <span class="number">2010</span>, <span class="number">2019</span>, <span class="number">0.01</span>);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">aggregateToYearly</span>(<span class="params">imgcol, year_begin, year_end, scale_factor</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> bands = [<span class="string">&#x27;ET_pot&#x27;</span>]; <span class="comment">//,&#x27;qc&#x27;</span></span><br><span class="line">    <span class="keyword">var</span> years = ee.<span class="property">List</span>.<span class="title function_">sequence</span>(year_begin, year_end);</span><br><span class="line">    <span class="keyword">var</span> imgcol_years = years.<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params">year</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> date_begin = ee.<span class="property">Date</span>.<span class="title function_">fromYMD</span>(year,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">var</span> date_end   = ee.<span class="property">Date</span>.<span class="title function_">fromYMD</span>(year,<span class="number">12</span>,<span class="number">31</span>);</span><br><span class="line">        <span class="keyword">var</span> ydays = date_begin.<span class="title function_">advance</span>(<span class="number">1</span>, <span class="string">&#x27;year&#x27;</span>).<span class="title function_">difference</span>(date_begin, <span class="string">&#x27;day&#x27;</span>);</span><br><span class="line">        <span class="keyword">var</span> imgcol_year = imgcol.<span class="title function_">filterDate</span>(date_begin, date_end);</span><br><span class="line">        <span class="keyword">var</span> scale = ydays.<span class="title function_">multiply</span>(scale_factor);</span><br><span class="line">        <span class="keyword">return</span> imgcol_year.<span class="title function_">select</span>(bands)</span><br><span class="line">            <span class="comment">//.multiply(scale_factor).</span></span><br><span class="line">            .<span class="title function_">mean</span>()</span><br><span class="line">            .<span class="title function_">multiply</span>(scale)</span><br><span class="line">            .<span class="title function_">toFloat</span>()</span><br><span class="line">            .<span class="title function_">set</span>(<span class="string">&#x27;system:time_start&#x27;</span>, date_begin.<span class="title function_">millis</span>())</span><br><span class="line">            .<span class="title function_">set</span>(<span class="string">&#x27;system:id&#x27;</span>, date_begin.<span class="title function_">format</span>());</span><br><span class="line">    &#125;);</span><br><span class="line">    imgcol_years = ee.<span class="title class_">ImageCollection</span>(imgcol_years);</span><br><span class="line">    <span class="comment">// pkg_export.ExportImg(img_year, task, range, cellsize, type, folder_yearly, crs, crsTransform);</span></span><br><span class="line">    <span class="keyword">return</span> imgcol_years;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> imgcol_years = imgcol_years.<span class="title function_">filterBounds</span>(<span class="variable constant_">ROI</span>);</span><br><span class="line"><span class="title function_">print</span>(imgcol_years);</span><br><span class="line"><span class="comment">//var batch = require(&#x27;users/fitoprincipe/geetools:batch&#x27;);</span></span><br><span class="line"><span class="comment">//batch.Download.ImageCollection.toDrive(imgcol_years,&quot;ETO&quot;, &#123;</span></span><br><span class="line"><span class="comment">//scale: 1/240&#125;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pkg_export.<span class="title class_">ExportImgCol</span>(imgcol_years.<span class="title function_">limit</span>(<span class="number">10</span>), <span class="string">&#x27;ET0&#x27;</span>, options);</span><br></pre></td></tr></table></figure>
<p>GEE批量导出方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">var</span> runButtons = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#task-pane&#x27;</span>).<span class="property">shadowRoot</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&quot;.run-button&quot;</span>)</span><br><span class="line">     runButtons.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">e</span>) &#123;e.<span class="title function_">click</span>()&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">runTaskList</span>()</span><br><span class="line"><span class="built_in">setTimeout</span>( </span><br><span class="line">    <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">       <span class="keyword">var</span> taskDialog = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&quot;ee-image-config-dialog&quot;</span>) <span class="comment">//table的话-image-改成-table-</span></span><br><span class="line">        taskDialog.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">e</span>) &#123;e.<span class="property">shadowRoot</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;ee-dialog&quot;</span>).<span class="property">shadowRoot</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;paper-dialog&quot;</span>).<span class="title function_">querySelector</span>(<span class="string">&quot;.ok-button&quot;</span>).<span class="title function_">click</span>()&#125;)</span><br><span class="line"> &#125;,<span class="number">5</span> * <span class="number">1000</span> );  </span><br></pre></td></tr></table></figure>
<h2 id="土地利用覆被必需">土地利用/覆被（必需）：</h2>
<p>每个栅格对应一个土地利用类型的GIS栅格数据集。
土地利用类型代码定义为<strong>整数</strong>。 </p>
<p><em>命名：</em>用户自定义，但若为ESRI
GRID格式，文件名不能有空格并且少于13个字，
若为TIF或IMG格式，命名可能更长。 </p>
<p><em>格式：</em>GIS标准栅格文件（如：ESRI
GRID，TIF或IMG），每个栅格对应一个土地利用类型代码（如：1表示森林，3表示草地，等）。地类代码必须与生物物理系数表中的地类代码一致。</p>
<p><em>数据获取得：</em></p>
<ol type="1">
<li>Land cover classification gridded maps from 1992 to present derived
from satellite observations <a
href="https://cds.climate.copernicus.eu/cdsapp#!/dataset/satellite-land-cover?tab=overview"
title="https://cds.climate.copernicus.eu/cdsapp#!/dataset/satellite-land-cover?tab=overview">https://cds.climate.copernicus.eu/cdsapp#!/dataset/satellite-land-cover?tab=overview</a></li>
<li>ESA全球10米<a href="https://esa-worldcover.org/en"
title="https://esa-worldcover.org/en">https://esa-worldcover.org/en</a></li>
<li>GLOBELAND30 包含2000，2010，2020三期数据。<a
href="http://www.globallandcover.com/defaults.html?src=/Scripts/map/defaults/download.html&amp;head=download&amp;type=data"
title="http://www.globallandcover.com/defaults.html?src=/Scripts/map/defaults/download.html&amp;head=download&amp;type=data">http://www.globallandcover.com/defaults.html?src=/Scripts/map/defaults/download.html&amp;head=download&amp;type=data</a>
<code>note:</code>汾河流域在图幅N49_35,山西省全域需要图幅N49_30,N49_35,N49_40,N50_35,N50_40</li>
<li>Sentinel-2 Land Use/ Land Cover Downloader
2017-2021年数据，10米分辨率。 <a
href="https://www.arcgis.com/apps/instant/media/index.html?appid=fc92d38533d440078f17678ebc20e8e2"
title="https://www.arcgis.com/apps/instant/media/index.html?appid=fc92d38533d440078f17678ebc20e8e2">https://www.arcgis.com/apps/instant/media/index.html?appid=fc92d38533d440078f17678ebc20e8e2</a>
</li>
<li>1990-2021全国30米数据（每年更新） <a
href="https://zenodo.org/record/5816591#.YzQUF-xBwbk"
title="https://zenodo.org/record/5816591#.YzQUF-xBwbk">https://zenodo.org/record/5816591#.YzQUF-xBwbk</a></li>
</ol>
<h2 id="流域必需">流域（必需）：</h2>
<p>用多边形表示流域的图形文件（shapefile）。即与研究区水电生产研究相关的所有小流域图层。
</p>
<p><em>命名：</em> 用户定义，但文件名不能有空格 </p>
<p><em>格式： </em>图形文件（.shp） </p>
<p><em>属性表横列：</em>每一行表示一个小流域</p>
<p><em>属性表纵列：</em>必须包含定义为整数的“ws_id”字段，每个小流域赋予唯一数值。</p>
<h2 id="次一级小流域必需">次一级小流域（必需）：</h2>
<p>流域图层中选定区域中用多图形文件（shapefile）。生成次一级小流域的工具和方法，详见
“DEM数据处理”章节。</p>
<p><em>格式：</em>图形文件（.shp） </p>
<p><em>属性表横列：</em>每一行表示一个次一级小流域</p>
<p><em>属性表纵列：</em>必须包含定义为整数的“subws_id”字段，每个次一级小流域赋予唯一数值。</p>
<h2 id="生物物理系数表必需">生物物理系数表（必需）：</h2>
<p>土地利用/覆被（LULC）类型表，包括用于该工具使用的生物物理系数数据。注意事项：这些数据主要针对每种土地利用类型属性而非栅格图栅格单元属性。</p>
<p><em>命名：</em>文件名由字母、数字和下划线组成，不能有空格。</p>
<p><em>格式：</em>ArcGIS模型的*.dbf或*.mdb格式，独立运行模块要求一个*.csv文件。</p>
<p><em>属性表横列：</em>每一行表示一个土地利用类型 。</p>
<p><em>属性表纵列：</em>每一列包含每种土地利用类型的不同属性，属性命名如下：</p>
<p>Lucode（土地利用类型代码）：每种土地利用类型地类代码（如：1表示森林，
3表示草地，等），必须与上述土地利用类型栅格图保持一致。</p>
<p>LULC_desc：土地利用类型的描述性命名（可选填）。</p>
<p> LULC_veg：包括使用的实际蒸散发AET计算公式。植被覆盖地类
（不包括湿地）赋值为1，其他土地利用类型（包括湿地、城市用地、水体）赋值为0。</p>
<p>root_depth：植被覆盖地类的最大根系深度，单位毫米（mm），取整数。植物根系深度通常指特定植物类型的根系生物量为95%的土层深度。对不适用一般
Budyko干燥指数（即应使用公式2计算实际蒸散发AET）的土地利用类型而言，
不需要根系深度数据，设为N/A。</p>
<p>Kc
：每种土地利用类型的植物蒸散系数，通过将植物生理学特性与苜蓿相比较，将苜蓿的参考作物蒸散修正为特定土地利用类型的潜在蒸散量。因此土地利用类型的植物蒸散系数取值为[0，1.5]的小数（在某些非常潮湿的热带区域，水分充足）。</p>
<h2 id="季节常数z必需">季节常数Z（必需）：</h2>
<p>是根据季节性降水分布定义的从1 到30排序浮动值。 </p>
<h2 id="用水需求表必需">用水需求表（必需）：</h2>
<p>土地利用类型表，表示不同土地利用类型的消耗性用水量。消耗性用水量是指提供植物和作物生长，被人类和畜牧消耗，或其他应从
流域水量平衡中扣除的水量。</p>
<p><em>命名：</em>文件名由字母、数字和下划线组成，不能有空格。 </p>
<p><em>格式：</em>ArcGIS模型的*.dbf或*.mdb格式，独立运行模块要求一个*.csv文件
属性表横列：每一行表示一个土地利用类型，并且必须包含土地利用栅格图中所
有土地覆被属性值。 </p>
<p><em>属性表纵列：</em>每一列包含每种土地利用类型的不同用水需求属性，属性命名如下：</p>
<p>lucode（土地利用类型代码）：每种土地利用类型地类代码（如：1表示森林，
3表示草地，等），必须与上述土地利用类型栅格图保持一致。 </p>
<p>demand：每种土地利用类型的预测平均消耗性用水量。土地利用类型图中的用水量用立方米/年/栅格单元表示。注意事项：由于区域越大，相同土地覆被类型消耗的水量可能，因此用水量的栅格计算方法十分重要。</p>
<h1 id="结果分析">结果分析</h1>
<p>output_pixel（分数）：模型估算每个栅格单元降水量的实际蒸散发占比（实际蒸发量/降水量）。这是栅格单元的实际蒸散发占降水量的平均值。</p>
<p>output_pixel（mm）：模型估算栅格单元实际蒸散发。</p>
<p>output_pixel（mm）：模型估算栅格单元产水量。</p>
<ul>
<li>output_results_wyield.shp 和
output_results_wyield.csv：包含模型估算次一级流域生物物理学参数值的shapefile文件和表格，属性包括：
<ul>
<li>precip_mn（mm）：次一级流域栅格单元的平均降水量。</li>
<li>PET_mn（mm）：次一级流域栅格单元的平均潜在蒸散发。</li>
<li>AET_mn（mm）：次一级流域栅格单元的平均实际蒸散发。</li>
<li>wyield_mn（mm）：次一级流域栅格单元的平均产水量。</li>
<li>num_pixel：次一级流域栅格单元的数量。</li>
<li>wyield_vol（$ m^3 $）：次一级流域产水量体积。</li>
<li>wyield_ha（$ m^3 $）：次一级流域每公顷产水量体积。</li>
</ul></li>
<li>output_results_wyield.shp 和 output_results_wyield.csv ：
包含模型估算每个小流域生物物理学参数值的shapefile文件和表格：
运行产水量评估模块时，输出结果的生物物理学参数如下：
<ul>
<li>precip_mn（mm）：每个小流域栅格单元的平均降水量。</li>
<li>PET_mn（mm）：每个小流域栅格单元的平均潜在蒸散发。</li>
<li>AET_mn（mm）：每个小流域栅格单元的平均实际蒸散发。</li>
<li>wyield_mn（mm）：每个小流域栅格单元的平均产水量。</li>
<li>num_pixel：每个小流域栅格单元的数量。</li>
<li>wyield_vol（$ m^3 $）：每个小流域内产水量体积。</li>
<li>wyield_ha（$ m^3 $）：每个小流域每公顷产水量体积。 </li>
</ul></li>
</ul>
<p><strong><code>Note:</code></strong>
<strong>产水量（wyield_vol）</strong>字段数据是模型估算研究区流域的每一个次一级流域的年平均<em>产汇流</em>水量。字段数值可以用于确定对全年产水量贡献最大的次一级流域。</p>
<p><a href="https://www.wolai.com/pLvSQy6dLBrwJX9ATDTiy4"
title="日值（v3）数据">日值（v3）数据</a></p>
<p><a href="https://www.wolai.com/sWbxWLVBydbK2t5aT584Fa"
title="使用EToCalculator 计算潜在蒸散发详细教程">使用EToCalculator
计算潜在蒸散发详细教程</a></p>
<p><a href="https://www.wolai.com/mQ6iivaJ3BAPg21kq2uXsE"
title="编程分享-利用GEE得到研究区年、月、日降水量数据">编程分享-利用GEE得到研究区年、月、日降水量数据</a></p>
]]></content>
      <categories>
        <category>Ecosystem service</category>
        <category>Annual Water Yield</category>
      </categories>
      <tags>
        <tag>Ecosystem service</tag>
        <tag>Annual Water Yield</tag>
      </tags>
  </entry>
  <entry>
    <title>属性操作</title>
    <url>/2023/08/22/2023-8-22-%E5%B1%9E%E6%80%A7%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>本章讲授如何基于属性来操作地理对象，例如矢量数据集中的公交站名和栅格数据集中像素的高程。对于矢量数据，意味着应用例如<code>subsetting</code>和<code>aggregation</code>方法（参见矢量属性提取子集和矢量属性聚合章节）。和创建属性移除空间信息章节演示了如何通过共享<strong>ID</strong>将数据连接到简单要素对象以及如何创建新变量。这些操作都有空间等效功能：例如，基于属性和空间对象的<code>subsetting</code>操作都可以使用R中的<code>[</code>运算符；您还可以使用<code>spatial joins</code>将两个地理数据集的属性进行连接。本章所培养的技能具有交叉传递性。<em>空间数据操作</em>章节将本章介绍的方法扩展到空间方面。
<span id="more"></span></p>
<h1 id="前提条件">前提条件</h1>
<ul>
<li>本章要求安装并且连接以下包：</li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>sf<span class="punctuation">)</span> </span><br><span class="line">library<span class="punctuation">(</span>terra<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>dplyr<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>依赖于 <strong>spData</strong>
包，该包装载了本章代码示例所使用的数据集：</li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>spData<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>另外，如果您希望在栅格数据汇总章节中运行数据"整理"操作，请确保已安装了<strong>tidyr</strong>包，或者安装了其所属的<strong>tidyverse</strong>包。</li>
</ul>
<h1 id="引言">引言</h1>
<p>属性数据是与地理（几何）数据相关联的非空间信息。公共汽车站提供了一个简单的例子：除了名称之外，它的位置通常用经纬度坐标(几何数据)来表示。例如，位于伦敦<a
href="https://www.openstreetmap.org/relation/6610626"
title="Elephant &amp; Castle / New Kent Road">Elephant &amp; Castle /
New Kent Road</a> 站的坐标为：经度 -0.098和纬度
51.495，在<em>空间数据类型</em>章节描述的
<code>sfc</code>表示中可以表示为<code>POINT (-0.098 51.495)</code>。诸如点属性的<code>name</code>属性（使用
Simple Features 术语）之类的属性是本章的主题。</p>
<p>另一个示例是栅格数据中特定网格单元的海拔值（属性）。与矢量数据模型不同，栅格数据模型间接存储了网格单元的坐标，这意味着属性和空间信息之间的区分不太清晰。为了阐明这一观点，可以想象一下栅格矩阵中第3行第4列的像素点。其空间位置由其在矩阵中的索引确定：在<code>x</code>方向上从原点向右（通常是东方和地图上的右方）移动四个单元格，在<code>y</code>方向上从原点向下（通常是南方和向下）移动三个单元格。栅格的分辨率定义了每个<code>x</code>和<code>y</code>步的距离，这些距离在头部文件中指定。头部文件是栅格数据集的关键组成部分，它指定了像素与地理坐标的关系（另见空间数据操作章节）。</p>
<p>本章讲授如何基于属性来操作地理对象，例如矢量数据集中的公交站名和栅格数据集中像素的高程。对于矢量数据，意味着应用例如<code>subsetting</code>和<code>aggregation</code>方法（参见矢量属性提取子集和矢量属性聚合章节。）和创建属性移除空间信息章节演示了如何通过共享<strong>ID</strong>将数据连接到简单要素对象以及如何创建新变量。这些操作都有空间等效功能：例如，基于属性和空间对象的<code>subsetting</code>操作都可以使用R中的<code>[</code>运算符；您还可以使用<code>spatial joins</code>将两个地理数据集的属性进行连接。本章所培养的技能具有交叉传递性。<em>空间数据操作</em>章节将本章介绍的方法扩展到空间方面。</p>
<p>在下一节深入探讨各种类型的<strong>矢量属性</strong>操作后，栅格数据操作章节介绍了<strong>栅格属性</strong>数据操作，演示了如何创建包含连续和分类属性的栅格图层，并从一个或多个图层中提取单元格的值（栅格子集）。栅格数据汇总章节提供了<strong>全局</strong>栅格操作的概述，这些操作可以用于总结整个栅格数据集。</p>
<h1 id="矢量数据操作">矢量数据操作</h1>
<p>地理矢量数据集在R中得到了很好的支持，这得益于<code>sf</code>类的出现，它是基于R的<code>data.frame</code>进行扩展的。与数据框类似，<code>sf</code>对象每列都有一个属性变量（例如"name"），每行代表一个观测值或<code>feature</code>（例如每个公交车站）。与基本数据框不同的是，<code>sf</code>对象具有一个<strong>几何列</strong>，其类型为<code>sfc</code>，每个行可以包含多个地理实体（单个和"多"点，线，多边形要素）。第
<em>空间类</em>中进行了描述，演示了<code>plot()</code>和<code>Summary()</code>等<strong>通用</strong>方法是如何处理<code>sf</code>对象的。<code>sf</code>还提供了<strong>通用方法</strong>，允许<code>sf</code>对象像常规数据框一样运行，如<em>打印</em><strong>类</strong>的方法所示：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">methods<span class="punctuation">(</span><span class="built_in">class</span> <span class="operator">=</span> <span class="string">&quot;sf&quot;</span><span class="punctuation">)</span> </span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#&gt; [1] [             [[&lt;-          $&lt;-           aggregate    </span></span><br><span class="line"><span class="comment">#&gt; [5] as.data.frame cbind         coerce        filter       </span></span><br><span class="line"><span class="comment">#&gt; [9] identify      initialize    merge         plot        </span></span><br></pre></td></tr></table></figure>
<p>其中许多函数（<code>aggregate()</code>，<code>cbind()</code>，<code>merge()</code>，<code>rbind()</code>和<code>[</code>）用于操作数据框。例如，<code>rbind()</code>会将数据框的行"一上一下"连接在一起。<code>$&lt;-</code>可以创建新的列。<code>sf</code>
对象的一个重要特征是它们以相同的方式将<strong>空间数据</strong>和<strong>非空间数据</strong>存储为<code>data.frame</code>中的列。</p>
<blockquote>
<p>📌对象的几何列通常称为<code>geometry</code>或<code>geom</code>，但可以使用任何名称。例如，下面的命令创建了一个名为<code>g</code>的几何列:
<code>st_sf(data.frame(n = world$name_long), g = world$geom)</code>
这使得从空间数据库导入的几何图形具有多种名称，如<code>wkb_geometry</code>和<code>The_geom</code>。</p>
</blockquote>
<p><code>sf</code>对象对于数据框可以扩展<code>tidyverse</code>类，<code>tbl_df</code>和<code>tbl</code>。因此，无论您使用基础R还是tidyverse函数进行数据分析，<code>sf</code>都可以释放R数据分析能力对地理数据的全部威力。
<code>sf</code>对象还可以与高性能数据处理软件包<code>data.table</code>一起使用，尽管文献中有记载说明，它与<code>sf</code>对象不完全兼容，<a
href="https://github.com/Rdatatable/data.table/issues/2273"
title="Rdatatable/data.table#2273">Rdatatable/data.table#2273</a>。在使用这些功能之前，回顾怎样探索矢量数据对象的基本属性。让我们开始使用基本R函数来了解从
<strong>spData</strong> 软件包中的<code>world</code>数据集：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="built_in">class</span><span class="punctuation">(</span>world<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] &quot;sf&quot;         &quot;tbl_df&quot;     &quot;tbl&quot;        &quot;data.frame&quot;</span></span><br><span class="line"><span class="built_in">dim</span><span class="punctuation">(</span>world<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] 177  11</span></span><br></pre></td></tr></table></figure>
<p><code>world</code>含有十个非地理列（以及一个几何列表列），共有近200行代表各个世界国家。函数<code>st_drop_geometry()</code>可保留仅为<code>sf</code>对象的属性数据，也就是删除其几何学属性：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">world_df <span class="operator">=</span> st_drop_geometry<span class="punctuation">(</span>world<span class="punctuation">)</span></span><br><span class="line"><span class="built_in">class</span><span class="punctuation">(</span>world_df<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] &quot;tbl_df&quot;     &quot;tbl&quot;        &quot;data.frame&quot;</span></span><br><span class="line">ncol<span class="punctuation">(</span>world_df<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] 10</span></span><br></pre></td></tr></table></figure>
<p>在使用属性数据之前，删除几何列可能会很有用；当数据处理过程仅涉及属性数据时，处理速度可以更快，并且不一定总需要几何列。然而，在大多数情况下，保留几何列是有意义的，解释为什么几何列具有"粘性"（大多数属性操作之后仍然存在，除非特别删除。）。在<code>sf</code>对象上进行非空间数据操作仅在适当时更改对象的几何结构（例如，在聚合后消除相邻多边形之间的边界）。掌握地理属性数据操作技能意味着掌握操作数据框的技能。</p>
<p>对于许多应用程序来说，tidyverse中的<strong>dplyr</strong>
包为处理数据框提供了有效的方法。与其前身<strong>sp</strong>相比，<strong>sf</strong>具有<strong>tidyverse</strong>兼容性的优势，但需要避免一些陷阱（详情请参见
<a
href="https://geocompx.github.io/geocompkg/articles/tidyverse-pitfalls.html"
title="geocompx.org">geocompx.org</a>
上的补充<code>tidyverse-pitfalls</code>文献）。</p>
<h2 id="矢量属性提取子集">矢量属性提取子集</h2>
<p>基础R的子集提取方法包括<code>[</code>和<code>subset()</code>。在<strong>dplyr</strong>中，子集提取数据的关键函数是<code>filter()</code>和<code>slice()</code>用于子集提取行，而<code>select()</code>用于子集提取列。两种方法都可以保持
<code>sf</code>对象中属性数据的空间组件不变。然而，使用运算符<code>$</code>或<strong>dplyr</strong>函数<code>pull()</code>提取单个属性列作为向量会导致几何数据的丢失，我们将在后文中进一步阐述。本节重点关注如何对<code>sf</code>数据框进行子集提取，如果进一步了解如何对向量和非地理数据框进行子集提取，建议参考《An
Introduction to R》第<a
href="https://cran.r-project.org/doc/manuals/r-release/R-intro.html#Index-vectors"
title="2.7">2.7</a> 节以及《Advanced R Programming》第<a
href="https://adv-r.hadley.nz/subsetting.html" title="4">4</a>章。</p>
<p><code>[</code>操作符可以对行和列提取子集。方括号直接放在数据框对象名称之后，里面的索引指定要保留的元素。命令<code>object[i, j]</code>意味着：返回由<code>i</code>表示的行和由<code>j</code>表示的列，其中<code>i</code>和<code>j</code>通常包含整数或<code>TRUE</code>和<code>FALSE</code>（索引也可以是字符串，表示行或列名称）。例如，<code>object[5, 1:3]</code>意味着：返回包含第5行和第1到第3列的数据，结果应该是一个只有1行和3列的数据框，如果是<code>sf</code>对象，则还要包含第4个几何列。留下<code>i</code>或<code>j</code>为空会返回所有的行或列，因此<code>world[1:5, ]</code>返回前5行和所有11列。下面的示例演示了使用基本<strong>R</strong>进行子集提取的方法。猜
测每个命令返回的<code>sf</code>数据框的行数和列数，并在自己的计算机上检查结果（更多练习请参见本章末尾）：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">world<span class="punctuation">[</span><span class="number">1</span><span class="operator">:</span><span class="number">6</span><span class="punctuation">,</span> <span class="punctuation">]</span>    <span class="comment"># 按位置提取行</span></span><br><span class="line">world<span class="punctuation">[</span><span class="punctuation">,</span> <span class="number">1</span><span class="operator">:</span><span class="number">3</span><span class="punctuation">]</span>    <span class="comment"># 按位置提取列</span></span><br><span class="line">world<span class="punctuation">[</span><span class="number">1</span><span class="operator">:</span><span class="number">6</span><span class="punctuation">,</span> <span class="number">1</span><span class="operator">:</span><span class="number">3</span><span class="punctuation">]</span> <span class="comment"># 按位置提取行和列</span></span><br><span class="line">world<span class="punctuation">[</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;name_long&quot;</span><span class="punctuation">,</span> <span class="string">&quot;pop&quot;</span><span class="punctuation">)</span><span class="punctuation">]</span> <span class="comment"># 按名称提取列</span></span><br><span class="line">world<span class="punctuation">[</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="built_in">T</span><span class="punctuation">,</span> <span class="built_in">T</span><span class="punctuation">,</span> <span class="built_in">F</span><span class="punctuation">,</span> <span class="built_in">F</span><span class="punctuation">,</span> <span class="built_in">F</span><span class="punctuation">,</span> <span class="built_in">F</span><span class="punctuation">,</span> <span class="built_in">F</span><span class="punctuation">,</span> <span class="built_in">T</span><span class="punctuation">,</span> <span class="built_in">T</span><span class="punctuation">,</span> <span class="built_in">F</span><span class="punctuation">,</span> <span class="built_in">F</span><span class="punctuation">)</span><span class="punctuation">]</span> <span class="comment"># 按逻辑索引提取</span></span><br><span class="line">world<span class="punctuation">[</span><span class="punctuation">,</span> <span class="number">888</span><span class="punctuation">]</span> <span class="comment"># 索引代表不存在的列</span></span><br></pre></td></tr></table></figure>
<p>下面的代码块演示了使用<code>logical</code>向量进行子集提取的实用性。这就创造了一个新的对象，<code>small_countries</code>，包括面积小于
10,000 <span class="math inline">\(km^2\)</span>的国家:</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">i_small <span class="operator">=</span> world<span class="operator">$</span>area_km2 <span class="operator">&lt;</span> <span class="number">10000</span></span><br><span class="line">summary<span class="punctuation">(</span>i_small<span class="punctuation">)</span> <span class="comment"># 逻辑向量</span></span><br><span class="line"><span class="comment">#&gt;    Mode   FALSE    TRUE </span></span><br><span class="line"><span class="comment">#&gt; logical     170       7</span></span><br><span class="line">small_countries <span class="operator">=</span> world<span class="punctuation">[</span>i_small<span class="punctuation">,</span> <span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<p>中间的<code>i_small</code>（表示小国家的索引的缩写）是一个逻辑向量，可用于按表面积对<strong>世界</strong>上最小的七个国家提取子集。更简洁的命令省略中间对象，生成相同的结果：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">small_countries <span class="operator">=</span> world<span class="punctuation">[</span>world<span class="operator">$</span>area_km2 <span class="operator">&lt;</span> <span class="number">10000</span><span class="punctuation">,</span> <span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<p>基础R函数<code>subset()</code>提供了另外一种方式：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">small_countries <span class="operator">=</span> subset<span class="punctuation">(</span>world<span class="punctuation">,</span> area_km2 <span class="operator">&lt;</span> <span class="number">10000</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>基础的R函数成熟、稳定且广泛使用，使它们成为一种非常可靠的选择，特别是在强调<strong>重现性</strong>和<strong>可靠性</strong>的情况下。<strong>dplyr</strong>
函数使得"tidy"的工作流成为可能，其中一些人（包括本书的作者）在交互式数据分析中发现这些函数直观且富有成效，特别与RStudio等代码编辑器相结合，可以实现列名的<a
href="https://support.posit.co/hc/en-us/articles/205273297-Code-Completion-in-the-RStudio-IDE"
title="auto-completion">auto-completion</a>。下面演示了使用<strong>dplyr</strong>函数进行子集提取中的关键函数，包括<code>sf</code>数据框架。</p>
<p>&lt;!-- 根据以下基准，下面的句子似乎是不真实的。 --&gt; &lt;!--
`dplyr`在某些操作中也比基础 R 快，因为它的 C++ 索引{C++}后端。 --&gt;
&lt;!--
关于dbplyr的一些问题？我从来没有见过有人在实际中经常使用它来处理空间数据，所以暂时先不涉及与数据库的集成部分。（RL
2021-10） --&gt; &lt;!-- 主要的 **dplyr** 子集提取功能包括 `select()`,
`slice()`, `filter()` and `pull()`。 --&gt;</p>
<p><code>select()</code>按照名称和位置选择列。例如，你可以利用下面的命令只选择<code>name_long</code>和<code>pop</code>两列：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">world1 <span class="operator">=</span> select<span class="punctuation">(</span>world<span class="punctuation">,</span> name_long<span class="punctuation">,</span> pop<span class="punctuation">)</span></span><br><span class="line"><span class="built_in">names</span><span class="punctuation">(</span>world1<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] &quot;name_long&quot; &quot;pop&quot;       &quot;geom&quot;</span></span><br></pre></td></tr></table></figure>
<p>注意：与基础R中的等效命令一样，（<code>world[, c("name_long", "pop")]</code>）,
"粘性"
<code>geom</code>列保留。<code>select()</code>还允许在<code>:</code>操作符的帮助下选择一系列列变量：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># name_long 和 pop (包括)之间的所有列</span></span><br><span class="line">world2 <span class="operator">=</span> select<span class="punctuation">(</span>world<span class="punctuation">,</span> name_long<span class="operator">:</span>pop<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>用<code>-</code>操作符去除特定的列：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 除了 subregion 和 area_km2 (包括)之外的所有列</span></span><br><span class="line">world3 <span class="operator">=</span> select<span class="punctuation">(</span>world<span class="punctuation">,</span> <span class="operator">-</span>subregion<span class="punctuation">,</span> <span class="operator">-</span>area_km2<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><code>new_name = old_name</code>语法可以同时提取子集和重命名列变量:</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">world4 <span class="operator">=</span> select<span class="punctuation">(</span>world<span class="punctuation">,</span> name_long<span class="punctuation">,</span> population <span class="operator">=</span> pop<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>值得注意的是：上面的命令比基础R等价的命令更简洁，基础R等价的命令需要两行代码：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">world5 <span class="operator">=</span> world<span class="punctuation">[</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;name_long&quot;</span><span class="punctuation">,</span> <span class="string">&quot;pop&quot;</span><span class="punctuation">)</span><span class="punctuation">]</span>                <span class="comment"># 通过名称提取子列</span></span><br><span class="line"><span class="built_in">names</span><span class="punctuation">(</span>world5<span class="punctuation">)</span><span class="punctuation">[</span><span class="built_in">names</span><span class="punctuation">(</span>world5<span class="punctuation">)</span> <span class="operator">==</span> <span class="string">&quot;pop&quot;</span><span class="punctuation">]</span> <span class="operator">=</span> <span class="string">&quot;population&quot;</span>   <span class="comment"># 手动重命名</span></span><br></pre></td></tr></table></figure>
<p><code>select()</code>还可以使用'helper functions'
进行更高级的自己提取操作，包括<code>contains()</code>，<code>starts_with()</code>和<code>num_range()</code>（用<code>?select</code>产看帮助页面获取更多细节）。</p>
<p>大部分 <strong>dplyr</strong>
函数返回数据框，但是你可以用<code>pull()</code>单独提取一列作为向量。&lt;!--注意：我注释掉下面的语句，因为它对`sf`对象不适用，而且数据框和`sf`对象的行为不同，有些令人困惑。--&gt;
&lt;!-- 相比之下，基础 R（参见`?
[`）中的子集运算符试图返回尽可能小维度的对象。 --&gt; &lt;!--
这意味着选择一列返回一个以 R
为基础的向量，如下面的代码块所示，它返回一个表示`world`中国家人口的数字向量:
--&gt;使用列表提取子集操作符<code>$</code>和<code>[[</code> ，可以在基础
R 中得到相同的结果，以下三个命令返回相同的数值向量:</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 结果返回为向量</span></span><br><span class="line">pull<span class="punctuation">(</span>world<span class="punctuation">,</span> pop<span class="punctuation">)</span></span><br><span class="line">world<span class="operator">$</span>pop</span><br><span class="line">world<span class="punctuation">[[</span><span class="string">&quot;pop&quot;</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<p>&lt;!--
以下内容已注释，因其容易引起困惑且在其他地方有更好的涵盖（RL，2021-10）。
--&gt;</p>
<p>&lt;!-- 要关闭此行为，请将`drop`参数设置为`FALSE`。 --&gt;</p>
<p><code>slice()</code>是行选择工具等同于
<code>select()</code>。例如，下面的代码块选择了1到6行：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">slice<span class="punctuation">(</span>world<span class="punctuation">,</span> <span class="number">1</span><span class="operator">:</span><span class="number">6</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><code>filter()</code>是<strong>dplyr</strong>等价于基础 R
的<code>subset()</code>函数。它只保留符合给定标准的行，例如，只保留面积低于某一阈值或平均预期寿命高的国家，如下例所示：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">world7 <span class="operator">=</span> filter<span class="punctuation">(</span>world<span class="punctuation">,</span> area_km2 <span class="operator">&lt;</span> <span class="number">10000</span><span class="punctuation">)</span>  <span class="comment"># 面积小的国家</span></span><br><span class="line">world7 <span class="operator">=</span> filter<span class="punctuation">(</span>world<span class="punctuation">,</span> lifeExp <span class="operator">&gt;</span> <span class="number">82</span><span class="punctuation">)</span>      <span class="comment"># 预期寿命高的国家</span></span><br></pre></td></tr></table></figure>
<p>比较运算符的标准集合可以在<code>filter()</code>函数中使用，如表所示：</p>
<table>
<caption>Comparison operators that return Booleans
(TRUE/FALSE).</caption>
<thead>
<tr class="header">
<th>Symbol</th>
<th>Name</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>==</code></td>
<td>Equal to</td>
</tr>
<tr class="even">
<td><code>!=</code></td>
<td>Not equal to</td>
</tr>
<tr class="odd">
<td><code>&gt;</code>, <code>&lt;</code></td>
<td>Greater/Less than</td>
</tr>
<tr class="even">
<td><code>&gt;=</code>, <code>&lt;=</code></td>
<td>Greater/Less than or equal</td>
</tr>
<tr class="odd">
<td><code>&amp;</code>,<code>|</code>,<code>!</code></td>
<td>Logical operators: And, Or, Not</td>
</tr>
</tbody>
</table>
<h2 id="管道连接命令">管道连接命令</h2>
<p>使用<strong>dplyr</strong>函数的工作流的关键是<a
href="http://r4ds.had.co.nz/pipes.html"
title="&#39;pipe&#39;">'pipe'</a>操作符<code>%&gt;%</code>（或者自R
<code>4.1.0</code>以来的内置管道<code>|&gt;</code>），名称取自Unix管道
<code>|</code>。管道启用表达式代码：前一个函数的输出成为下一个函数的第一个参数，从而启用<em>连接</em>。如下所示，其中只有来自亚洲的国家从<code>world</code>数据集中筛选，接下来对象是按列（<code>name_long</code>和<code>continent</code>）和前5行（结果未显示）分列的子集。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">world7 <span class="operator">=</span> world <span class="operator">|&gt;</span></span><br><span class="line">  filter<span class="punctuation">(</span>continent <span class="operator">==</span> <span class="string">&quot;Asia&quot;</span><span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">  select<span class="punctuation">(</span>name_long<span class="punctuation">,</span> continent<span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">  slice<span class="punctuation">(</span><span class="number">1</span><span class="operator">:</span><span class="number">5</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>上面的代码块显示了管道操作符如何允许以明确的顺序编写命令：从上到下（逐行）和从左到右运行。管道操作的另一种替代方法是嵌套函数调用，这种方法更难理解：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">world8 <span class="operator">=</span> slice<span class="punctuation">(</span></span><br><span class="line">  select<span class="punctuation">(</span></span><br><span class="line">    filter<span class="punctuation">(</span>world<span class="punctuation">,</span> continent <span class="operator">==</span> <span class="string">&quot;Asia&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">    name_long<span class="punctuation">,</span> continent<span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">  <span class="number">1</span><span class="operator">:</span><span class="number">5</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>另一种选择是将操作分为多个自包含行，特别是在开发新的 R
程序包时推荐使用此方法，这种方法的优点是可以通过具有不同名称的中间结果进行保存以便后续调试（但缺点是冗长，如果进行交互式分析时还会使全局环境凌乱）：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">world9_filtered <span class="operator">=</span> filter<span class="punctuation">(</span>world<span class="punctuation">,</span> continent <span class="operator">==</span> <span class="string">&quot;Asia&quot;</span><span class="punctuation">)</span></span><br><span class="line">world9_selected <span class="operator">=</span> select<span class="punctuation">(</span>world9_filtered<span class="punctuation">,</span> continent<span class="punctuation">)</span></span><br><span class="line">world9 <span class="operator">=</span> slice<span class="punctuation">(</span>world9_selected<span class="punctuation">,</span> <span class="number">1</span><span class="operator">:</span><span class="number">5</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>每种方法都有优缺点，其重要性取决于您的编程风格和应用程序。对于交互式数据分析（本章的重点），我们发现管道操作快速而直观，特别是与<a
href="https://support.posit.co/hc/en-us/articles/200711853-Keyboard-Shortcuts-in-the-RStudio-IDE"
title="RStudio">RStudio</a>/<a
href="https://github.com/REditorSupport/vscode-R/wiki/Keyboard-shortcuts"
title="VSCode">VSCode</a>快捷方式相结合时，可以创建管道并<a
href="https://support.posit.co/hc/en-us/articles/205273297-Code-Completion-in-the-RStudio-IDE"
title="自动完成">自动完成</a>变量名。</p>
<h2 id="矢量属性聚合">矢量属性聚合</h2>
<p>聚合涉及使用一个或多个"分组变量"对数据进行汇总，通常是从要进行聚合的数据框的列中选择的（地理聚合在下一章中介绍）。属性聚合的一个例子是根据以国家为单位的数据（每个国家一行）计算每个大洲的人口数量。<code>world</code>数据集包含了必要的要素：<code>pop</code>和<code>continent</code>列分别代表人口和分组变量。目的是找到每个大洲的国家人口总和（<code>sum()</code>），从而得到一个较小的数据框（聚合是一种数据缩减的形式，对于处理大型数据集时，聚合是有用的前期步骤）。可以使用基本R函数<code>aggregate()</code>来完成此操作，步骤如下所示：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">world_agg1 <span class="operator">=</span> aggregate<span class="punctuation">(</span>pop <span class="operator">~</span> continent<span class="punctuation">,</span> FUN <span class="operator">=</span> <span class="built_in">sum</span><span class="punctuation">,</span> data <span class="operator">=</span> world<span class="punctuation">,</span></span><br><span class="line">                       na.rm <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br><span class="line"><span class="built_in">class</span><span class="punctuation">(</span>world_agg1<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] &quot;data.frame&quot;</span></span><br></pre></td></tr></table></figure>
<p>结果是一个6行的非空间数据框，每一行代表一个大洲，两列分别报告了每个大洲的名称和人口（参见表)，显示前三个人口最多的大洲的结果）。</p>
<p><code>aggregate()</code>是一个<a
href="https://adv-r.hadley.nz/s3.html"
title="泛函数">泛函数</a>，这意味着它的行为取决于它的输入。<strong>sf</strong>提供了<code>aggregate.sf()</code>方法，当<code>x</code>是一个<code>sf</code>对象且提供了一个<code>by</code>参数时，它会自动激活：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">world_agg2 <span class="operator">=</span> aggregate<span class="punctuation">(</span>world<span class="punctuation">[</span><span class="string">&quot;pop&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="built_in">list</span><span class="punctuation">(</span>world<span class="operator">$</span>continent<span class="punctuation">)</span><span class="punctuation">,</span> FUN <span class="operator">=</span> <span class="built_in">sum</span><span class="punctuation">,</span> </span><br><span class="line">                       na.rm <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br><span class="line"><span class="built_in">class</span><span class="punctuation">(</span>world_agg2<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] &quot;sf&quot;         &quot;data.frame&quot;</span></span><br><span class="line">nrow<span class="punctuation">(</span>world_agg2<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] 8</span></span><br></pre></td></tr></table></figure>
<p>由此产生的<code>world_agg2</code>对象是一个包含8个特征的空间对象，这些特征代表世界的大陆(和开放的海洋)。</p>
<p><code>group_by() |&gt; summarize()</code>是 <strong>dplyr</strong>
中与<code>aggregate()</code>等效的函数，其中在<code>group_by()</code>函数中提供的变量名称指定了分组变量，而对要进行汇总的信息则是通过传递给
<code>summarize()</code>函数来指定的，如下所示：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">world_agg3 <span class="operator">=</span> world <span class="operator">|&gt;</span></span><br><span class="line">  group_by<span class="punctuation">(</span>continent<span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">  summarize<span class="punctuation">(</span>pop <span class="operator">=</span> <span class="built_in">sum</span><span class="punctuation">(</span>pop<span class="punctuation">,</span> na.rm <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>这种方法可能看起来更复杂，但它具有以下好处：灵活性、可读性以及对新列名称的控制。下面的命令示例展示了这种灵活性，它不仅计算了人口数量，还计算了每个大洲的面积和国家数量：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">world_agg4  <span class="operator">=</span> world <span class="operator">|&gt;</span> </span><br><span class="line">  group_by<span class="punctuation">(</span>continent<span class="punctuation">)</span> <span class="operator">|&gt;</span> </span><br><span class="line">  summarize<span class="punctuation">(</span>Pop <span class="operator">=</span> <span class="built_in">sum</span><span class="punctuation">(</span>pop<span class="punctuation">,</span> na.rm <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span><span class="punctuation">,</span> Area <span class="operator">=</span> <span class="built_in">sum</span><span class="punctuation">(</span>area_km2<span class="punctuation">)</span><span class="punctuation">,</span> N <span class="operator">=</span> n<span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>在前一个代码块中，<code>Pop</code>、<code>Area</code>和<code>N</code>是结果中的列名，<code>sum()</code>和<code>n()</code>是聚合函数。这些聚合函数返回的<code>sf</code>对象具有以大洲表示的行和包含每个陆地和相关岛屿的多个多边形的几何信息（这得益于几何操作<strong>union</strong>，如几何合并节所述）。</p>
<p>让我们结合目前已经学习到的<strong>dplyr</strong>函数知识，通过将多个命令链接起来以总结全球各大洲的属性数据。以下命令使用<code>mutate()</code>函数计算人口密度，使用<code>dplyr::arrange()</code>函数按国家数量排列大洲，使用<code>dplyr::slice_max()</code>函数保留人口最多的3个洲，并呈现结果简单表格：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">world_agg5 <span class="operator">=</span> world <span class="operator">|&gt;</span> </span><br><span class="line">  st_drop_geometry<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">|&gt;</span>                      <span class="comment"># 去掉几何</span></span><br><span class="line">  select<span class="punctuation">(</span>pop<span class="punctuation">,</span> continent<span class="punctuation">,</span> area_km2<span class="punctuation">)</span> <span class="operator">|&gt;</span>        <span class="comment"># 提取子集  </span></span><br><span class="line">  group_by<span class="punctuation">(</span>continent<span class="punctuation">)</span> <span class="operator">|&gt;</span>                     <span class="comment"># 分组、汇总</span></span><br><span class="line">  summarize<span class="punctuation">(</span>Pop <span class="operator">=</span> <span class="built_in">sum</span><span class="punctuation">(</span>pop<span class="punctuation">,</span> na.rm <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span><span class="punctuation">,</span> Area <span class="operator">=</span> <span class="built_in">sum</span><span class="punctuation">(</span>area_km2<span class="punctuation">)</span><span class="punctuation">,</span> N <span class="operator">=</span> n<span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">  mutate<span class="punctuation">(</span>Density <span class="operator">=</span> <span class="built_in">round</span><span class="punctuation">(</span>Pop <span class="operator">/</span> Area<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">|&gt;</span>     <span class="comment"># 计算人口密度</span></span><br><span class="line">  slice_max<span class="punctuation">(</span>Pop<span class="punctuation">,</span> n <span class="operator">=</span> <span class="number">3</span><span class="punctuation">)</span> <span class="operator">|&gt;</span>                   <span class="comment"># 保留最大的3行</span></span><br><span class="line">  arrange<span class="punctuation">(</span>desc<span class="punctuation">(</span>N<span class="punctuation">)</span><span class="punctuation">)</span>                           <span class="comment"># 国家数量降序</span></span><br></pre></td></tr></table></figure>
<table>
<caption>The top 3 most populous continents ordered by number of
countries.</caption>
<thead>
<tr class="header">
<th>continent</th>
<th>Pop</th>
<th>Area</th>
<th>N</th>
<th>Density</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Africa</td>
<td>1154946633</td>
<td>29946198</td>
<td>51</td>
<td>39</td>
</tr>
<tr class="even">
<td>Asia</td>
<td>4311408059</td>
<td>31252459</td>
<td>47</td>
<td>138</td>
</tr>
<tr class="odd">
<td>Europe</td>
<td>669036256</td>
<td>23065219</td>
<td>39</td>
<td>29</td>
</tr>
</tbody>
</table>
<blockquote>
<p>更多细节可在帮助页面中查看（可通过<code>?summarize</code>和<code>vignette(package = "dplyr")</code>访问）以及<a
href="http://r4ds.had.co.nz/transform.html#grouped-summaries-with-summarize"
title="R for Data Science">R for Data Science</a>第5章。</p>
</blockquote>
<h2 id="矢量属性连接">矢量属性连接</h2>
<p>在数据准备中，合并不同来源的数据是一种常见的任务。连接（<strong>Join</strong>）函数通过基于共享的"key"变量来合并表格。<strong>dplyr</strong>有多个连接函数，包括<code>left_join()</code>和<code>inner_join()</code>，详见<code>vignette("two-table")</code>以获取完整列表。这些函数名称遵循数据库语言<a
href="http://r4ds.had.co.nz/relational-data.html"
title="SQL">SQL</a>中使用的惯例。本部分重点讨论将非空间数据集与<code>sf</code>对象连接的过程。<strong>dplyr连接函数</strong>在数据框和<code>sf</code>对象上的操作相同，唯一重要的区别是<code>geometry</code>列表列。数据合并的结果可以是<code>sf</code>或<code>data.frame</code>对象。在空间数据中，最常见的属性合并类型是将<code>sf</code>对象作为第一个参数，并从作为第二个参数指定的<code>data.frame</code>中添加列。</p>
<p>为了展示连接，我们将把咖啡生产数据和<code>world</code>数据集合并。咖啡数据存储在一个名为<code>coffee_data</code>的数据框中，来自<strong>spData</strong>包（详情请参见<code>?coffee_data</code>）。它有3列：<code>name_long</code>列记录主要咖啡生产国家的名称，<code>coffee_production_2016</code>和<code>coffee_production_2017</code>列分别包含每年以60公斤袋为单位的咖啡生产估值。'left
join'保留第一个数据集，将<code>world</code>与<code>coffee_data</code>合并：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">world_coffee <span class="operator">=</span> left_join<span class="punctuation">(</span>world<span class="punctuation">,</span> coffee_data<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; Joining with `by = join_by(name_long)`</span></span><br><span class="line"><span class="built_in">class</span><span class="punctuation">(</span>world_coffee<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] &quot;sf&quot;         &quot;tbl_df&quot;     &quot;tbl&quot;        &quot;data.frame&quot;</span></span><br></pre></td></tr></table></figure>
<p>由于输入数据集共享'key
variable'（<code>name_long</code>），因此连接操作可以在不使用<code>by</code>参数的情况下完成（有关详细信息，请参见<code>?left_join</code>）。结果是一个与原始<code>world</code>对象相同的<code>sf</code>对象，但具有两个新变量（列索引为11和12）的咖啡产量。这可以绘制成地图，如下<a
href="https://scy11.oss-cn-beijing.aliyuncs.com/img/202308230009131.png"
title="🖼️ 图片">🖼️ 图片</a>的<code>plot()</code>函数所示：</p>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202308230009131.png" /></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="built_in">names</span><span class="punctuation">(</span>world_coffee<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt;  [1] &quot;iso_a2&quot;                 &quot;name_long&quot;              &quot;continent&quot;             </span></span><br><span class="line"><span class="comment">#&gt;  [4] &quot;region_un&quot;              &quot;subregion&quot;              &quot;type&quot;                  </span></span><br><span class="line"><span class="comment">#&gt;  [7] &quot;area_km2&quot;               &quot;pop&quot;                    &quot;lifeExp&quot;               </span></span><br><span class="line"><span class="comment">#&gt; [10] &quot;gdpPercap&quot;              &quot;geom&quot;                   &quot;coffee_production_2016&quot;</span></span><br><span class="line"><span class="comment">#&gt; [13] &quot;coffee_production_2017&quot;</span></span><br><span class="line">plot<span class="punctuation">(</span>world_coffee<span class="punctuation">[</span><span class="string">&quot;coffee_production_2017&quot;</span><span class="punctuation">]</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>为了使连接生效，两个数据集都必须提供'key variable'
。默认情况下，<strong>dplyr</strong>会使用所有名称匹配的变量。在这种情况下，<code>world_coffee</code>和<code>world</code>两个对象都包含一个名为<code>name_long</code>的变量，这解释了信息<code>Joining with</code>
<code>by = join_by(name_long)</code>。在大多数名称不同的情况下，您有两个选项：</p>
<ol type="1">
<li>重命名某个对象中的key variable，使其与其他对象匹配。</li>
<li>使用<code>by</code>参数指明连接变量。</li>
</ol>
<p>后一种方法在<code>coffee_data</code>的重命名版本中演示如下:</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">coffee_renamed <span class="operator">=</span> rename<span class="punctuation">(</span>coffee_data<span class="punctuation">,</span> nm <span class="operator">=</span> name_long<span class="punctuation">)</span></span><br><span class="line">world_coffee2 <span class="operator">=</span> left_join<span class="punctuation">(</span>world<span class="punctuation">,</span> coffee_renamed<span class="punctuation">,</span> by <span class="operator">=</span> join_by<span class="punctuation">(</span>name_long <span class="operator">==</span> nm<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">world_coffee100 <span class="operator">=</span> left_join<span class="punctuation">(</span>world<span class="punctuation">,</span> coffee_renamed<span class="punctuation">,</span> by <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;name_long&quot;</span> <span class="operator">=</span> <span class="string">&quot;nm&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>请注意，在原始对象中保留名称，意味着<code>world_coffee</code>和新对象<code>world_coffee2</code>是相同的。结果的另一个特点是具有与原始数据集相同的行数。尽管<code>coffee_data</code>中仅有47行数据，但<code>world_coffee</code>和<code>world_coffee2</code>中保留了所有177个国家记录：在原始数据集中没有匹配的行会被赋予新咖啡生产变量的<code>NA</code>值。如果我们只想保留具有键变量匹配的国家怎么办？在这种情况下，可以使用<strong>内连接</strong>：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">world_coffee_inner <span class="operator">=</span> inner_join<span class="punctuation">(</span>world<span class="punctuation">,</span> coffee_data<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; Joining with `by = join_by(name_long)`</span></span><br><span class="line">nrow<span class="punctuation">(</span>world_coffee_inner<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] 45</span></span><br></pre></td></tr></table></figure>
<p><code>inner_join()</code>的结果只有45行，而<code>coffee_data</code>中有47行。剩下的行发生了什么？我们可以使用<code>setdiff()</code>函数来<strong>识别未匹配行</strong>，如下所示：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">setdiff<span class="punctuation">(</span>coffee_data<span class="operator">$</span>name_long<span class="punctuation">,</span> world<span class="operator">$</span>name_long<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] &quot;Congo, Dem. Rep. of&quot; &quot;Others&quot;</span></span><br></pre></td></tr></table></figure>
<p>结果显示，<code>Others</code>占据了<code>world</code>数据集中不存在的一行，而<code>Democratic Republic of the Congo</code>的名称占据了另一行:
名称缩写，导致连接错误。下面的命令使用<strong>stringr</strong>包中的字符串匹配（<em>regex</em>）函数来确认<code>Congo, Dem. Rep. of</code>应为:</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">drc <span class="operator">=</span> stringr<span class="operator">::</span>str_subset<span class="punctuation">(</span>world<span class="operator">$</span>name_long<span class="punctuation">,</span> <span class="string">&quot;Dem*.+Congo&quot;</span><span class="punctuation">)</span></span><br><span class="line">drc</span><br><span class="line"><span class="comment">#&gt; [1] &quot;Democratic Republic of the Congo&quot;</span></span><br></pre></td></tr></table></figure>
<p>为了解决这个问题，我们将创建一个新版本的<code>coffee_data</code>并更新名称。<code>inner_join()</code>更新后的数据框返回一个包含所有46个咖啡生产国的结果:</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">coffee_data<span class="operator">$</span>name_long<span class="punctuation">[</span>grepl<span class="punctuation">(</span><span class="string">&quot;Congo,&quot;</span><span class="punctuation">,</span> coffee_data<span class="operator">$</span>name_long<span class="punctuation">)</span><span class="punctuation">]</span> <span class="operator">=</span> drc</span><br><span class="line">world_coffee_match <span class="operator">=</span> inner_join<span class="punctuation">(</span>world<span class="punctuation">,</span> coffee_data<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; Joining with `by = join_by(name_long)`</span></span><br><span class="line">nrow<span class="punctuation">(</span>world_coffee_match<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] 46</span></span><br></pre></td></tr></table></figure>
<p>也可以从另一个方向连接：从非空间数据集开始，并从简单要素对象中添加变量。下面演示了这一点，从<code>coffee_data</code>对象开始，并从原始<code>world</code>数据集中添加变量。与前面的连接相比，结果<strong>不是</strong>另一个简单要素对象，而是一个<strong>tidyverse</strong>数据框格式的tibble。连接的输出往往与其第一个参数相匹配：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">coffee_world <span class="operator">=</span> left_join<span class="punctuation">(</span>coffee_data<span class="punctuation">,</span> world<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; Joining with `by = join_by(name_long)`</span></span><br><span class="line"><span class="built_in">class</span><span class="punctuation">(</span>coffee_world<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] &quot;tbl_df&quot;     &quot;tbl&quot;        &quot;data.frame&quot;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>📌在大多数情况下，几何列只在<code>sf</code>对象中有用。
只有当R“知道”它是由如<code>sf</code>等空间包定义的空间对象时，几何列才能用于创建地图和空间操作。
幸运的是，具有几何列表列（如<code>coffee_world</code>）的非空间数据框可以如下方式强制转换为<code>sf</code>对象：<code>st_as_sf(coffee_world)</code>。</p>
</blockquote>
<p>本节涵盖了大部分的连接使用情况。如需更多信息，我们建议阅读<a
href="https://r4ds.had.co.nz/relational-data.html?q=join#relational-data"
title="Relational data">Relational
data</a>章节，本书附带的<strong>geocompkg</strong>包中的<a
href="https://geocompx.github.io/geocompkg/articles/join.html"
title="join vignette">join
vignette</a>，以及描述<strong>data.table</strong>和其他包中的连接方法的文档。<strong>空间连接</strong>将在下一章<em>空间连接</em>中讲述。</p>
<h2 id="创建属性移除空间信息">创建属性移除空间信息</h2>
<p>通常，我们想要根据已有的列创建新的列。例如，我们想要计算每个国家的人口密度。为此，我们需要将一个人口列（这里是<code>pop</code>）除以一个面积列（这里是<code>area_km2</code>），其中单位面积为平方千米。使用基础R，我们可以输入：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">world_new <span class="operator">=</span> world <span class="comment"># 不要覆盖原始数据</span></span><br><span class="line">world_new<span class="operator">$</span>pop_dens <span class="operator">=</span> world_new<span class="operator">$</span>pop <span class="operator">/</span> world_new<span class="operator">$</span>area_km2</span><br></pre></td></tr></table></figure>
<p>另外，我们还可以使用<strong>dplyr</strong>函数-<code>mutate()</code>或<code>transmute()</code>。<code>mutate()</code>在<code>sf</code>对象的倒数第二个位置添加新的列（最后一个位置是保留给几何图形的）：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">world_new2 <span class="operator">=</span> world <span class="operator">|&gt;</span> </span><br><span class="line">  mutate<span class="punctuation">(</span>pop_dens <span class="operator">=</span> pop <span class="operator">/</span> area_km2<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><code>mutate()</code>和<code>transmute()</code>的区别在于<code>transmute()</code>会删除所有其他已存在的列（除了<strong>sticky
geometry</strong>列）。</p>
<p><code>unite()</code>函数来自<strong>tidyr</strong>包（该包提供了许多重塑数据集的有用函数，包括<code>pivot_longer()</code>），<code>unite()</code>函数将现有的列拼接在一起。例如我们想要将<code>continent</code>和<code>region_un</code>列合并成一个名为<code>con_reg</code>的新列。另外，我们可以定义一个分隔符（这里是冒号<code>:</code>），用于定义输入列的值应该如何拼接，并且确定是否删除原始列（这里是<code>TRUE</code>）。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">world_unite <span class="operator">=</span> world <span class="operator">|&gt;</span></span><br><span class="line">  tidyr<span class="operator">::</span>unite<span class="punctuation">(</span><span class="string">&quot;con_reg&quot;</span><span class="punctuation">,</span> continent<span class="operator">:</span>region_un<span class="punctuation">,</span> sep <span class="operator">=</span> <span class="string">&quot;:&quot;</span><span class="punctuation">,</span> remove <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>生成的<code>sf</code>对象有一个名为<code>con_reg</code>的新列，代表每个国家的大陆和地区，例如，<code>South America:Americas</code>代表阿根廷和其他南美洲国家。<strong>tidyr</strong>
的<code>separate()</code>函数的作用与<code>unite()</code>相反:
它使用正则表达式或字符位置将一列拆分为多列。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">world_separate <span class="operator">=</span> world_unite <span class="operator">|&gt;</span></span><br><span class="line">  tidyr<span class="operator">::</span>separate<span class="punctuation">(</span>con_reg<span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;continent&quot;</span><span class="punctuation">,</span> <span class="string">&quot;region_un&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> sep <span class="operator">=</span> <span class="string">&quot;:&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><strong>dplyr函数</strong><code>rename()</code>和基础 R
中的<code>setNames()</code>函数用于重命名列变量。<code>rename()</code>函数用新名称代替就名称。例如，下面的命令重命名<code>name_long</code>列为<code>name</code>：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">world <span class="operator">|&gt;</span> </span><br><span class="line">  rename<span class="punctuation">(</span>name <span class="operator">=</span> name_long<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><code>setNames()</code>函数一次性改变全部列名，并需要一个与各列匹配的字符向量。下面的示例说明了这一点，输出相同的<code>world</code>对象，但列名变得非常简单：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">new_names <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;i&quot;</span><span class="punctuation">,</span> <span class="string">&quot;n&quot;</span><span class="punctuation">,</span> <span class="string">&quot;c&quot;</span><span class="punctuation">,</span> <span class="string">&quot;r&quot;</span><span class="punctuation">,</span> <span class="string">&quot;s&quot;</span><span class="punctuation">,</span> <span class="string">&quot;t&quot;</span><span class="punctuation">,</span> <span class="string">&quot;a&quot;</span><span class="punctuation">,</span> <span class="string">&quot;p&quot;</span><span class="punctuation">,</span> <span class="string">&quot;l&quot;</span><span class="punctuation">,</span> <span class="string">&quot;gP&quot;</span><span class="punctuation">,</span> <span class="string">&quot;geom&quot;</span><span class="punctuation">)</span></span><br><span class="line">world_new_names <span class="operator">=</span> world <span class="operator">|&gt;</span></span><br><span class="line">  setNames<span class="punctuation">(</span>new_names<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>每个属性数据操作都保留简单要素的几何特征。有时候去除几何特征是有意义的。例如，为了加快聚合速度。请使用<code>st_drop_geometry()</code>进行操作，而不是手动使用诸如<code>select(world, -geom)</code>等命令，如下所示。</p>
<p><code>st_geometry(world_st) = NULL</code> also works to remove the
geometry from <code>world</code>, but overwrites the original
object.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">world_data <span class="operator">=</span> world <span class="operator">|&gt;</span> st_drop_geometry<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line"><span class="built_in">class</span><span class="punctuation">(</span>world_data<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] &quot;tbl_df&quot;     &quot;tbl&quot;     &quot;data.frame&quot;</span></span><br></pre></td></tr></table></figure>
<h1 id="栅格数据操作">栅格数据操作</h1>
<p>与简单要素基础下的矢量数据模型相反（它将点、线和多边形表示为空间中的离散实体），栅格数据表示连续表面。本节将展示如何<em>从头</em>开始创建栅格对象，并基于<em>terra介绍</em>章节进行构建。由于它们独特的结构，对栅格数据集的子集提取和其他操作以不同的方式进行，在栅格数据提取子集章节中展示。</p>
<p>以下代码重新创建了在<em>栅格类</em>节使用的栅格数据集，其结果在<a
href="https://scy11.oss-cn-beijing.aliyuncs.com/img/202308230031352.png"
title="🖼️ 图片">🖼️
图片</a>中展示。这展示了<code>rast()</code>函数如何工作来创建一个名为<code>elev</code>的示例栅格（表示高程）的示例。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">elev <span class="operator">=</span> rast<span class="punctuation">(</span>nrows <span class="operator">=</span> <span class="number">6</span><span class="punctuation">,</span> ncols <span class="operator">=</span> <span class="number">6</span><span class="punctuation">,</span></span><br><span class="line">            xmin <span class="operator">=</span> <span class="operator">-</span><span class="number">1.5</span><span class="punctuation">,</span> xmax <span class="operator">=</span> <span class="number">1.5</span><span class="punctuation">,</span> ymin <span class="operator">=</span> <span class="operator">-</span><span class="number">1.5</span><span class="punctuation">,</span> ymax <span class="operator">=</span> <span class="number">1.5</span><span class="punctuation">,</span></span><br><span class="line">            vals <span class="operator">=</span> <span class="number">1</span><span class="operator">:</span><span class="number">36</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202308230031352.png" /></p>
<p>结果是一个具有6行和6列的栅格对象（由<code>nrow</code>和<code>ncol</code>参数指定），以及x和y方向上的最小和最大空间范围（<code>xmin</code>，<code>xmax</code>，<code>ymin</code>，<code>ymax</code>）。<code>vals</code>参数设置每个单元格包含的值：在这种情况下，是从1到36的数值数据。Raster对象还可以包含在R中<code>logical</code>或<code>factor</code>类变量形式表示的分类值。以下代码创建了图所示的栅格数据集：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">grain_order <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;clay&quot;</span><span class="punctuation">,</span> <span class="string">&quot;silt&quot;</span><span class="punctuation">,</span> <span class="string">&quot;sand&quot;</span><span class="punctuation">)</span></span><br><span class="line">grain_char <span class="operator">=</span> sample<span class="punctuation">(</span>grain_order<span class="punctuation">,</span> <span class="number">36</span><span class="punctuation">,</span> replace <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br><span class="line">grain_fact <span class="operator">=</span> factor<span class="punctuation">(</span>grain_char<span class="punctuation">,</span> levels <span class="operator">=</span> grain_order<span class="punctuation">)</span></span><br><span class="line">grain <span class="operator">=</span> rast<span class="punctuation">(</span>nrows <span class="operator">=</span> <span class="number">6</span><span class="punctuation">,</span> ncols <span class="operator">=</span> <span class="number">6</span><span class="punctuation">,</span> </span><br><span class="line">             xmin <span class="operator">=</span> <span class="operator">-</span><span class="number">1.5</span><span class="punctuation">,</span> xmax <span class="operator">=</span> <span class="number">1.5</span><span class="punctuation">,</span> ymin <span class="operator">=</span> <span class="operator">-</span><span class="number">1.5</span><span class="punctuation">,</span> ymax <span class="operator">=</span> <span class="number">1.5</span><span class="punctuation">,</span></span><br><span class="line">             vals <span class="operator">=</span> grain_fact<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>栅格对象将相应的查找表或"栅格属性表"（RAT）存储为数据框列表，可以使用<code>cats(grain)</code>查看（有关更多信息，请参见<code>?cats()</code>）。该列表的每个元素都是一个栅格层。还可以使用<code>levels()</code>函数检索和添加新的或替换现有的因子级别：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">levels<span class="punctuation">(</span>grain<span class="punctuation">)</span> <span class="operator">=</span> data.frame<span class="punctuation">(</span>value <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">)</span><span class="punctuation">,</span> wetness <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;wet&quot;</span><span class="punctuation">,</span> <span class="string">&quot;moist&quot;</span><span class="punctuation">,</span> <span class="string">&quot;dry&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">levels<span class="punctuation">(</span>grain<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [[1]]</span></span><br><span class="line"><span class="comment">#&gt;   value wetness</span></span><br><span class="line"><span class="comment">#&gt; 1     0     wet</span></span><br><span class="line"><span class="comment">#&gt; 2     1   moist</span></span><br><span class="line"><span class="comment">#&gt; 3     2     dry</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>📌分类栅格对象还可以使用颜色表存储与每个值相关联的颜色信息。
颜色表是一个数据框，有三个（红色、绿色、蓝色）或四个（Alpha）列，其中每一行与一个值相关联。
在<strong>terra</strong>中，可以使用<code>coltab()</code>函数查看或设置颜色表（请参阅
<code>?coltab</code>）。
需要注意的是，将带有颜色表的栅格对象保存到文件（例如GeoTIFF）中也会保存颜色信息。</p>
</blockquote>
<h2 id="栅格数据提取子集">栅格数据提取子集</h2>
<p>用基础R中的<code>[</code>操作符提取栅格数据子集，改运算符接受多种输入：</p>
<ul>
<li>行-列索引</li>
<li>单元格 IDs</li>
<li>坐标系（见<em>空间栅格子集提取</em>节）</li>
<li>其他的空间对象（见<em>空间栅格子集提取</em>节）</li>
</ul>
<p>在这里，我们只展示前两个选项，因为它们可以被视为非空间操作。如果我们需要一个空间对象来对另一个对象进行子集提取，或者输出是一个空间对象，我们将其称为空间子集操作。因此，后两个选项将在下一章中进行展示（见<em>空间栅格子集提取</em>节）。</p>
<p>前两个子集操作选项在下面的命令中进行了演示——两者都返回栅格对象<code>elev</code>中左上角像素的值（结果未显示）：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># row 1, column 1</span></span><br><span class="line">elev<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">]</span></span><br><span class="line"><span class="comment"># cell ID 1</span></span><br><span class="line">elev<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<p>多层栅格对象的子集提取将返回每层的单元格值。例如，<code>two_layers = c(grain, elev)</code>；<code>two_layers[1]</code>返回一个包含一行两列的数据框架——每层一列。若要提取所有值或完整行，还可以使用<code>values()</code>。</p>
<p>可以通过与子集提取操作一起覆盖现有值来修改单元格值。例如，下面的代码块将<code>elev</code>的左上单元格设置为0（结果未显示）：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">elev<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">]</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">elev<span class="punctuation">[</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<p>留空方括号是使用<code>values()</code>检索栅格的所有值的快捷方式，通过此方式也可以修改多个单元格:</p>
<p>替换多层栅格的值可以使用矩阵，其列数与层数相同，行数与可替换单元格数相同（结果未显示）：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">two_layers <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span>grain<span class="punctuation">,</span> elev<span class="punctuation">)</span> </span><br><span class="line">two_layers<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="operator">=</span> cbind<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">4</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">two_layers<span class="punctuation">[</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<h2 id="栅格数据汇总">栅格数据汇总</h2>
<p>terra包含提取整个栅格数据描述性统计信息的功能。通过输入栅格对象的名称并将其打印到控制台，可以返回栅格的最小值和最大值。<code>summary()</code>提供了常见的描述性统计量——最小值、最大值、四分位数以及连续型栅格<code>NA</code>的数量，以及分类型栅格中每个类别的单元格数量。进一步的总结操作，例如标准偏差（见下文）或自定义总结统计量，可以通过<code>global()</code>计算得出。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">global<span class="punctuation">(</span>elev<span class="punctuation">,</span> sd<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果您向<code>summary()</code>和<code>global()</code>函数提供一个多层栅格对象，它们将分别总结每一个层次，可以通过运行以下命令进行演示：<code>summary(c(elev, grain))</code>。</p>
</blockquote>
<p>此外，<code>freq()</code>函数允许获取分类值的频率表。栅格值统计可以以多种方式进行可视化。特定的函数，如<code>boxplot()</code>、<code>density()</code>、<code>hist()</code>和<code>pairs()</code>也适用于栅格对象，如下方命令创建的直方图所示（未显示）：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">hist<span class="punctuation">(</span>elev<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>如果所需的可视化函数无法与栅格对象一起使用，可以使用<code>values()</code>函数提取要绘制的栅格数据（参见栅格数据提取子集节）。</p>
<p>描述性栅格统计属于所谓的<strong>全局</strong>栅格操作。这些以及其他典型的栅格处理操作是<strong>地图代数</strong>方案的一部分，将在下一章（<em>地图代数</em>节）中介绍。</p>
<blockquote>
<p>📌一些函数名在包之间发生了冲突（例如，<code>extract()</code>函数在<strong>terra</strong>和<strong>tidyr</strong>包中都有）。
除了不通过引用函数来加载包（例如，<code>tidyr::extract()</code>），还有一种避免函数名冲突的方法是使用<code>detach()</code>取消加载引起问题的包。
例如，下面的命令可以卸载<code>terra</code>包（这也可以在
RStudio的默认右下角窗格中的<em>package</em>选项卡中完成）：<code>detach("package:terra", unload = TRUE, force = TRUE)</code>。在使用<code>force</code>参数时，即使其他包依赖于该包，也可以确保分离该包。
然而，这可能会导致依赖于已分离包的包受到限制的可用性，因此不建议使用该参数。</p>
</blockquote>
<h2 id="练习">练习</h2>
<p>For these exercises we will use the <code>us_states</code> and
<code>us_states_df</code> datasets from the <strong>spData</strong>
package. You must have attached the package, and other packages used in
the attribute operations chapter (<strong>sf</strong>,
<strong>dplyr</strong>, <strong>terra</strong>) with commands such as
<code>library(spData)</code> before attempting these exercises:</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>sf<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>dplyr<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>terra<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>spData<span class="punctuation">)</span></span><br><span class="line">data<span class="punctuation">(</span>us_states<span class="punctuation">)</span></span><br><span class="line">data<span class="punctuation">(</span>us_states_df<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><code>us_states</code> is a spatial object (of class
<code>sf</code>), containing geometry and a few attributes (including
name, region, area, and population) of states within the contiguous
United States. <code>us_states_df</code> is a data frame (of class
<code>data.frame</code>) containing the name and additional variables
(including median income and poverty level, for the years 2010 and 2015)
of US states, including Alaska, Hawaii and Puerto Rico. The data comes
from the United States Census Bureau, and is documented in
<code>?us_states</code> and <code>?us_states_df</code>.</p>
<p>E1. Create a new object called <code>us_states_name</code> that
contains only the <code>NAME</code> column from the
<code>us_states</code> object using either base R (<code>[</code>) or
tidyverse (<code>select()</code>) syntax. What is the class of the new
object and what makes it geographic?</p>
<p>E2. Select columns from the <code>us_states</code> object which
contain population data. Obtain the same result using a different
command (bonus: try to find three ways of obtaining the same result).
Hint: try to use helper functions, such as <code>contains</code> or
<code>matches</code> from <strong>dplyr</strong> (see
<code>?contains</code>).</p>
<p>E3. Find all states with the following characteristics (bonus find
<em>and</em> plot them):</p>
<ul>
<li>Belong to the Midwest region.</li>
<li>Belong to the West region, have an area below 250,000 km<sup>2</sup>
<em>and</em> in 2015 a population greater than 5,000,000 residents
(hint: you may need to use the function <code>units::set_units()</code>
or <code>as.numeric()</code>).</li>
<li>Belong to the South region, had an area larger than 150,000
km<sup>2</sup> or a total population in 2015 larger than 7,000,000
residents.</li>
</ul>
<p>E4. What was the total population in 2015 in the
<code>us_states</code> dataset? What was the minimum and maximum total
population in 2015?</p>
<p>E5. How many states are there in each region?</p>
<p>E6. What was the minimum and maximum total population in 2015 in each
region? What was the total population in 2015 in each region?</p>
<p>E7. Add variables from <code>us_states_df</code> to
<code>us_states</code>, and create a new object called
<code>us_states_stats</code>. What function did you use and why? Which
variable is the key in both datasets? What is the class of the new
object?</p>
<p>E8. <code>us_states_df</code> has two more rows than
<code>us_states</code>. How can you find them? (hint: try to use the
<code>dplyr::anti_join()</code> function)</p>
<p>E9. What was the population density in 2015 in each state? What was
the population density in 2010 in each state?</p>
<p>E10. How much has population density changed between 2010 and 2015 in
each state? Calculate the change in percentages and map them.</p>
<p>E11. Change the columns' names in <code>us_states</code> to
lowercase. (Hint: helper functions - <code>tolower()</code> and
<code>colnames()</code> may help.)</p>
<p>E12. Using <code>us_states</code> and <code>us_states_df</code>
create a new object called <code>us_states_sel</code>. The new object
should have only two variables - <code>median_income_15</code> and
<code>geometry</code>. Change the name of the
<code>median_income_15</code> column to <code>Income</code>.</p>
<p>E13. Calculate the change in the number of residents living below the
poverty level between 2010 and 2015 for each state. (Hint: See
?us_states_df for documentation on the poverty level columns.) Bonus:
Calculate the change in the <em>percentage</em> of residents living
below the poverty level in each state.</p>
<p>E14. What was the minimum, average and maximum state's number of
people living below the poverty line in 2015 for each region? Bonus:
What is the region with the largest increase in people living below the
poverty line?</p>
<p>E15. Create a raster from scratch with nine rows and columns and a
resolution of 0.5 decimal degrees (WGS84). Fill it with random numbers.
Extract the values of the four corner cells.</p>
<p>E16. What is the most common class of our example raster
<code>grain</code>?</p>
<p>E17. Plot the histogram and the boxplot of the <code>dem.tif</code>
file from the <strong>spDataLarge</strong> package
(<code>system.file("raster/dem.tif", package = "spDataLarge")</code>).</p>
]]></content>
      <categories>
        <category>R</category>
        <category>Geocomputaion</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>Geocomputaion</tag>
      </tags>
  </entry>
  <entry>
    <title>空间操作</title>
    <url>/2023/08/27/2023-8-27-%E7%A9%BA%E9%97%B4%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>空间操作，包括矢量数据集之间的空间连接以及栅格数据集上的局部和焦点操作，是地理计算的重要部分。本章展示了如何基于空间对象的位置和形状以多种方式进行修改。许多空间操作有与之对应的非空间（属性）操作，因此上一章中演示的如子集提取和数据集连接等概念在此也适用。
<span id="more"></span></p>
<h1 id="前提条件">前提条件</h1>
<ul>
<li>此章节需要使用和之前章节相同的包。</li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>sf<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>terra<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>dplyr<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>spData<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<h1 id="引言">引言</h1>
<p>空间操作，包括矢量数据集之间的空间连接以及栅格数据集上的局部和焦点操作，是地理计算的重要部分。本章展示了如何基于空间对象的位置和形状以多种方式进行修改。许多空间操作有与之对应的非空间（属性）操作，因此上一章中演示的如子集提取和数据集连接等概念在此也适用。对于矢量操作来说，这一点尤为适用：矢量属性操作为理解空间对应关系——即空间子集（在空间矢量提取部分中介绍）提供了基础。空间连接和空间聚合也具有非空间相似操作，已在上一章中介绍。</p>
<p>空间操作与非空间操作在许多方面有所不同，例如：空间连接可以通过多种方式进行，包括匹配与目标数据集相交或位于目标数据集一定距离范围内的实体，而上一章节矢量属性连接中讨论的属性连接只能通过一种方式进行（除非使用模糊连接，如
<a href="https://cran.r-project.org/package=fuzzyjoin"
title="fuzzyjoin"><strong>fuzzyjoin</strong></a>
包的文档所述）。对象之间不同类型的空间关系，包括相交和分离，均在章节拓扑关系中描述。空间对象的另一个独特之处在于距离，所有的空间对象都通过空间相关联，距离计算可用于探索这种关联的强度，正如在距离关系节中描述的矢量数据的情况一样。</p>
<p>栅格对象上的空间操作包括子集提取——在空间栅格子集提取节中进行了介绍-以及将多个栅格"瓦片"合并成一个对象，在合并栅格节中演示。地图代数涵盖了一系列修改栅格单元值的操作，可以参考周围单元值，也可以不参考周围单元值。地图代数的概念对许多应用至关重要，本节介绍了地图代数，并分别在地图代数节介绍了局部、焦点和分区地图代数操作。全局地图代数操作会生成代表整个栅格数据集的汇总统计数据，与栅格数据的距离计算在全局操作和距离章节中进行了讨论。在章节中，讨论了合并两个栅格数据集的过程，并结合一个可重现的示例进行演示。</p>
<blockquote>
<p>📌需要注意的是，使用两个空间对象进行空间操作需要这两个对象具有相同的坐标参考系统。这个话题在<em>crs介绍</em>中引入，并在<em>地理数据重投影</em>中进行了更详细的讨论。</p>
</blockquote>
<h1 id="矢量数据空间操作">矢量数据空间操作</h1>
<p>本节概述了在<strong>sf</strong>包中表示为简单要素的矢量地理数据上的空间操作。<em>栅格数据空间操作</em>节使用
terra 包中的类和函数对栅格数据集进行空间操作。</p>
<h2 id="空间矢量提取">空间矢量提取</h2>
<p>空间子集提取是将空间对象进行处理并返回一个包含与另一个对象空间相关特征的新对象的过程。类似于属性子集提取（在矢量属性提取子集）节中介绍），可使用方括号（<code>[</code>）运算符来创建
sf
数据框的子集，其语法为<code>x[y, , op = st_intersects]</code>，其中<code>x</code>是
sf
对象的一个子集，<code>y</code>是"子集对象"，<code>op = st_intersects</code>是一个可选参数，用于指定进行子集提取处理的拓扑关系（也称为二元谓词）。当未提供<code>op</code>参数时，<code>st_intersects()</code>是默认的拓扑关系。命令<code>x[y, ]</code>与上述<code>x[y, , op = st_intersects]</code>完全相同，但不同于<code>x[y, , op = st_disjoint]</code>（这些以及其他拓扑关系的含义在下一节中描述）。tidyverse中的<code>filter()</code>函数也可以使用，但这种方法更冗长，如下例所示。</p>
<p>为了演示空间子集提取，我们将使用 spData
包中的<code>nz</code>和<code>nz_height</code>数据集，它们分别包含新西兰16个主要地区和101个最高点的地理数据，以投影坐标系为基础。以下代码块创建的对象表示Canterbury，然后使用<strong>空间子集提取</strong>返回该区域内所有的高点：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">canterbury <span class="operator">=</span> nz <span class="operator">|&gt;</span> filter<span class="punctuation">(</span>Name <span class="operator">==</span> <span class="string">&quot;Canterbury&quot;</span><span class="punctuation">)</span></span><br><span class="line">canterbury_height <span class="operator">=</span> nz_height<span class="punctuation">[</span>canterbury<span class="punctuation">,</span> <span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<figure>
<img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202308232057538.png"
title="Illustration of spatial subsetting with red triangles representing 101 high points in New Zealand, clustered near the central Canterbuy region (left). The points in Canterbury were created with the `[` subsetting operator (highlighted in gray, right)."
alt="Illustration of spatial subsetting with red triangles representing 101 high points in New Zealand, clustered near the central Canterbuy region (left). The points in Canterbury were created with the `[` subsetting operator (highlighted in gray, right)." />
<figcaption aria-hidden="true">Illustration of spatial subsetting with
red triangles representing 101 high points in New Zealand, clustered
near the central Canterbuy region (left). The points in Canterbury were
created with the `[` subsetting operator (highlighted in gray,
right).</figcaption>
</figure>
<p>就像属性子集提取一样，命令<code>x[y, ]</code>（相当于<code>nz_height[canterbury, ]</code>）使用源对象<code>y</code>的内容对目标<code>x</code>进行特征子集提取。然而，与<code>y</code>是逻辑或整数类的向量不同的是，对于空间子集提取，<code>x</code>和<code>y</code>都必须是地理对象。具体而言，以这种方式用于空间子集提取的对象必须具有类<code>sf</code>或<code>sfc</code>。<code>nz</code>和<code>nz_height</code>都是地理向量数据框，具有类<code>sf</code>，操作的结果将返回另一个<code>sf</code>对象，表示目标<code>nz_height</code>对象中与（在本例中位于）canterbury地区相交的特征（即位于高处的点）。</p>
<p>用于空间子集提取的<strong>各种拓扑关系</strong>决定了目标对象中的特征，必须与要选择的子集对象具有的空间关系类型。这些关系包括<em>接触</em>、<em>交叉</em>或<em>包含</em>，在拓扑关系部分中我们将很快看到。默认设置<code>st_intersects</code>是一个"全包括"的拓扑关系，它将返回与源"子集"对象<em>接触</em>、<em>交叉</em>或<em>包含</em>的目标中的特征。如上所示，可以用<code>op=</code>参数指定其他空间运算符，如下面的命令所示，该命令返回<code>st_intersects()</code>的相反内容，即与坎特伯雷不相交的点（请参阅部分）：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">nz_height<span class="punctuation">[</span>canterbury<span class="punctuation">,</span> <span class="punctuation">,</span> op <span class="operator">=</span> st_disjoint<span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>📌请注意前面代码块中的空参数用 <code>, ,</code> 表示是为了突出
<code>op</code>，即 <code>sf</code> 对象 <code>[</code> 的第三个参数。
可以使用这个参数以多种方式改变子集操作。
例如，<code>nz_height[canterbury, 2, op = st_disjoint]</code>
返回相同的行，但仅包括第二个属性列（详见 <code>sf:::`[.sf`</code> 和
<code>?sf</code>）。</p>
</blockquote>
<p>对于许多应用而言，关于矢量数据的空间子集提取的知识就是你需要了解的全部内容：它只会按预期工作。如果你急于了解更多拓扑关系，超出了
<code>st_intersects()</code>和<code>st_disjoint()</code>的范围，请跳到下一节拓扑关系。如果你对细节感兴趣，包括其他子集方式，请继续阅读。</p>
<p>另一种进行空间子集提取的方法是使用拓扑操作返回的对象。这些对象本身就很有用，例如在探索相邻区域之间的关系图网络时，但它们也可以用于子集操作，如下方的代码块中所演示的：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">sel_sgbp <span class="operator">=</span> st_intersects<span class="punctuation">(</span>x <span class="operator">=</span> nz_height<span class="punctuation">,</span> y <span class="operator">=</span> canterbury<span class="punctuation">)</span></span><br><span class="line"><span class="built_in">class</span><span class="punctuation">(</span>sel_sgbp<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] &quot;sgbp&quot; &quot;list&quot;</span></span><br><span class="line">sel_sgbp</span><br><span class="line"><span class="comment">#&gt; Sparse geometry binary predicate list of length 101, where the</span></span><br><span class="line"><span class="comment">#&gt; predicate was `intersects&#x27;</span></span><br><span class="line"><span class="comment">#&gt; first 10 elements:</span></span><br><span class="line"><span class="comment">#&gt;  1: (empty)</span></span><br><span class="line"><span class="comment">#&gt;  2: (empty)</span></span><br><span class="line"><span class="comment">#&gt;  3: (empty)</span></span><br><span class="line"><span class="comment">#&gt;  4: (empty)</span></span><br><span class="line"><span class="comment">#&gt;  5: 1</span></span><br><span class="line"><span class="comment">#&gt;  6: 1</span></span><br><span class="line"><span class="comment">#&gt;  7: 1</span></span><br><span class="line"><span class="comment">#&gt;  8: 1</span></span><br><span class="line"><span class="comment">#&gt;  9: 1</span></span><br><span class="line"><span class="comment">#&gt;  10: 1</span></span><br><span class="line">sel_logical <span class="operator">=</span> lengths<span class="punctuation">(</span>sel_sgbp<span class="punctuation">)</span> <span class="operator">&gt;</span> <span class="number">0</span></span><br><span class="line">canterbury_height2 <span class="operator">=</span> nz_height<span class="punctuation">[</span>sel_logical<span class="punctuation">,</span> <span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<p>以上代码块创建一个 <code>sgbp</code> 类的对象
(一个稀疏几何二元谓词，一个在空间操作中长度为 <code>x</code>
的列表)，然后将其转换为逻辑向量 <code>sel_logical</code>（包含仅为
<code>TRUE</code> 和 <code>FALSE</code> 的值，这也可以由 dplyr 的 filter
函数使用）。<code>lengths()</code>识别<code>nz_height</code>中的哪些要素与
<code>y</code> 中的任何对象相交。在这种情况下，1
是最大可能值，但对于更复杂的操作，可以使用该方法仅对与源对象中的 2
个或更多个要素相交的要素进行子集操作。</p>
<blockquote>
<p>📌注意：通过在<code>st_intersects()</code>等运算符中设置<code>sparse = FALSE</code>（意思是“返回密集矩阵而不是稀疏矩阵”）也可以返回逻辑输出。例如，命令<code>st_intersects(x = nz_height, y = canterbury, sparse = FALSE)[, 1]</code>将返回与<code>sel_logical</code>相同的输出。
注意：涉及<code>sgbp</code>对象的解决方案更具普遍性，因为它适用于多对多的操作并且对内存要求较低。</p>
</blockquote>
<p>使用 sf
函数<code>st_filter()</code>可以实现相同的结果，该函数是为了增加<code>sf</code>对象与dplyr数据操作代码之间的兼容性而创建的：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">canterbury_height3 <span class="operator">=</span> nz_height <span class="operator">|&gt;</span></span><br><span class="line">  st_filter<span class="punctuation">(</span>y <span class="operator">=</span> canterbury<span class="punctuation">,</span> .predicate <span class="operator">=</span> st_intersects<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>到目前为止，有三个完全相同（除了行名）的<code>canterbury_height</code>版本，一个使用<code>[</code>操作符创建，一个通过中间选择对象创建，另一个使用sf的便捷函数<code>st_filter()</code>创建。</p>
<p>下一节探讨了不同类型的空间关系，也称为<strong>二元谓词</strong>，可以用来确定两个特征是否存在空间关系。</p>
<h2 id="拓扑关系">拓扑关系</h2>
<p>拓扑关系描述了对象之间的空间关系。完整称呼为"二元拓扑关系"，是关于由有序点集（通常形成点、线和多边形）在两个或多个维度中定义的两个对象之间的空间关系的逻辑陈述（答案只能是<code>TRUE</code>或<code>FALSE</code>）。这听起来可能相当抽象，实际上，拓扑关系的定义和分类是基于1966年首次以书籍形式出版的数学基础，代数拓扑领域一直延续到21世纪。</p>
<p>尽管拓扑关系起源于数学，但通过参考常用函数的可视化，可以直观地理解用于测试常见空间关系类型的拓扑关系。显示了各种几何对及其关联关系。图中的第三和第四对（从左到右然后向下）表明，对于某些关系，顺序很重要：虽然等于、相交、交叉、接触和重叠的关系是对称的，意味着如果<code>function(x, y)</code>为真，则<code>function(y, x)</code>也为真，但包含和内部等顺序重要的几何关系则不是。注意，每一对几何图形都有一个"DE-9IM"字符串，例如FF2F11212，将在下一节中描述。</p>
<figure>
<img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202308232211273.png"
title="Topological relations between vector geometries, inspired by Figures 1 and 2 in Egenhofer and Herring (1990). The relations for which the function(x, y) is true are printed for each geometry pair, with x represented in pink and y represented in blue. The nature of the spatial relationship for each pair is described by the Dimensionally Extended 9-Intersection Model string."
alt="Topological relations between vector geometries, inspired by Figures 1 and 2 in Egenhofer and Herring (1990). The relations for which the function(x, y) is true are printed for each geometry pair, with x represented in pink and y represented in blue. The nature of the spatial relationship for each pair is described by the Dimensionally Extended 9-Intersection Model string." />
<figcaption aria-hidden="true">Topological relations between vector
geometries, inspired by Figures 1 and 2 in Egenhofer and Herring (1990).
The relations for which the function(x, y) is true are printed for each
geometry pair, with x represented in pink and y represented in blue. The
nature of the spatial relationship for each pair is described by the
Dimensionally Extended 9-Intersection Model string.</figcaption>
</figure>
<p>在<code>sf</code>中，测试不同拓扑关系的函数被称为"二元谓词"，如在操作简单要素几何的文献
Manipulating Simple Feature Geometries 中所述，可以使用命令 <a
href="https://r-spatial.github.io/sf/articles/sf3.html"
title="vignette(&quot;sf3&quot;)">vignette("sf3")</a>查看，也可以在帮助页面中查看<a
href="https://r-spatial.github.io/sf/reference/geos_binary_ops.html"
title="?geos_binary_pred">?geos_binary_pred</a>。为了更好地理解拓扑关系的实用性，我们将建立一个简单可重现的例子，基于上图中所述的关系，巩固了前一章节<em>几何</em>所介绍的矢量几何图形表示的知识。请注意，为了创建代表多边形顶点坐标（x
和 y）的表格数据，我们使用基本 R 函数 <code>cbind()</code>
创建表示坐标点的矩阵，一个<code>POLYGON</code>，最后是 <code>sfc</code>
对象，如<em>空间类</em>所述：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">polygon_matrix <span class="operator">=</span> cbind<span class="punctuation">(</span></span><br><span class="line">  x <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span> <span class="number">0</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span>   <span class="number">0</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">  y <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">0.5</span><span class="punctuation">,</span> <span class="number">0</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">)</span></span><br><span class="line">polygon_sfc <span class="operator">=</span> st_sfc<span class="punctuation">(</span>st_polygon<span class="punctuation">(</span><span class="built_in">list</span><span class="punctuation">(</span>polygon_matrix<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>请注意在上面创建的多边形之上，我们将创建额外的几何体来展示它们在空间中的关系。所示的命令在绘制时与该多边形相关联。请注意在转换数据框时使用了函数<code>st_as_sf()</code>和参数<code>coords</code>，以高效地将包含坐标列的数据框转换为包含点的<code>sf</code>对象：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">line_sfc <span class="operator">=</span> st_sfc<span class="punctuation">(</span>st_linestring<span class="punctuation">(</span>cbind<span class="punctuation">(</span></span><br><span class="line">  x <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0.4</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">  y <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0.2</span><span class="punctuation">,</span> <span class="number">0.5</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 创建点</span></span><br><span class="line">point_df <span class="operator">=</span> data.frame<span class="punctuation">(</span></span><br><span class="line">  x <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0.2</span><span class="punctuation">,</span> <span class="number">0.7</span><span class="punctuation">,</span> <span class="number">0.4</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">  y <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0.1</span><span class="punctuation">,</span> <span class="number">0.2</span><span class="punctuation">,</span> <span class="number">0.8</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">)</span></span><br><span class="line">point_sf <span class="operator">=</span> st_as_sf<span class="punctuation">(</span>point_df<span class="punctuation">,</span> coords <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;x&quot;</span><span class="punctuation">,</span> <span class="string">&quot;y&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<figure>
<img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202308232229968.png"
title="Points, line and polygon objects arranged to illustrate topological relations."
alt="Points, line and polygon objects arranged to illustrate topological relations." />
<figcaption aria-hidden="true">Points, line and polygon objects arranged
to illustrate topological relations.</figcaption>
</figure>
<p>一个简单查询是：<code>point_sf</code> 中的哪些点与多边形
<code>polygon_sfc</code>
以某种方式相交？此问题通过检查可得到答案（点1和点3分别与多边形相切和在多边形内）。可以使用空间谓词
<code>st_intersects()</code>，如下所示：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">st_intersects<span class="punctuation">(</span>point_sf<span class="punctuation">,</span> polygon_sfc<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; Sparse geometry binary predicate... `intersects&#x27;</span></span><br><span class="line"><span class="comment">#&gt;  1: 1</span></span><br><span class="line"><span class="comment">#&gt;  2: (empty)</span></span><br><span class="line"><span class="comment">#&gt;  3: 1</span></span><br></pre></td></tr></table></figure>
<p>结果应该符合你的直觉：第一个和第三个点返回正（<code>1</code>）的结果，第二个点在多边形的边界之外返回负结果（用一个空向量表示）。而令人意想不到的是，结果以向量列表的形式呈现。这个<em>稀疏矩阵</em>输出只记录存在关系的部分，减少了对多要素对象进行拓扑操作时的内存需求。正如我们在前面的部分中所看到的，当<code>sparse = FALSE</code>时，返回的是一个由<code>TRUE</code>或<code>FALSE</code>值组成的<em>稠密矩阵</em>：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">st_intersects<span class="punctuation">(</span>point_sf<span class="punctuation">,</span> polygon_sfc<span class="punctuation">,</span> sparse <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt;       [,1]</span></span><br><span class="line"><span class="comment">#&gt; [1,]  TRUE</span></span><br><span class="line"><span class="comment">#&gt; [2,] FALSE</span></span><br><span class="line"><span class="comment">#&gt; [3,]  TRUE</span></span><br></pre></td></tr></table></figure>
<p>在上述输出中，每一行代表目标（参数<code>x</code>）对象中的一个特征，每一列代表选择对象（<code>y</code>）中的一个特征。在这个情况下，<code>y</code>对象<code>polygon_sfc</code>中只有一个特征，所以结果只有一列，这个结果可以用于我们在<em>空间子集提取</em>部分所看到的子集提取。</p>
<p><code>st_intersects()</code>即使在特征只是相切的情况下也返回<code>TRUE</code>，<code>intersects</code>是一种"全能"的拓扑操作，它识别许多类型的空间关系，如下图所示。更有限制的问题包括哪些点位于多边形内，以及哪些特征在<code>y</code>上或包含与<code>y</code>共享的边界？这些问题可以如下回答（结果未显示）：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">st_within<span class="punctuation">(</span>point_sf<span class="punctuation">,</span> polygon_sfc<span class="punctuation">)</span>    <span class="comment"># 在范围内</span></span><br><span class="line">st_touches<span class="punctuation">(</span>point_sf<span class="punctuation">,</span> polygon_sfc<span class="punctuation">)</span>   <span class="comment"># 相切</span></span><br></pre></td></tr></table></figure>
<p>请注意，尽管第一个点<em>接触</em>多边形的边界，但它并不在其中；第三个点在多边形内部，但不接触其边界的任何部分。<code>st_intersects()</code>的反义词是<code>st_disjoint()</code>，它只返回与选择对象在空间上完全不相关的对象（注意<code>[,  1]</code>将结果转换为向量）：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">st_disjoint<span class="punctuation">(</span>point_sf<span class="punctuation">,</span> polygon_sfc<span class="punctuation">,</span> sparse <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">)</span><span class="punctuation">[</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">]</span></span><br><span class="line"><span class="comment">#&gt; [1] FALSE  TRUE FALSE</span></span><br></pre></td></tr></table></figure>
<p>函数<code>st_is_within_distance()</code>检测到那些<em>几乎接触</em>选择对象的特征，它有一个额外的<code>dist</code>参数。它可以用来设置目标对象需要多近才能被选择。请注意，尽管点2距离<code>polygon_sfc</code>的最近顶点的距离超过0.2个单位，但当距离设置为0.2时，它仍然被选择。这是因为距离是测量到最近的边缘，在这种情况下是多边形直接在点2上方的部分，如下图所示。（你可以用命令<code>st_distance(point_sf, polygon_sfc)</code>来验证点2和多边形之间的实际距离是0.13。）下面的代码块演示了'is
within
distance'二元空间谓词，其结果显示每个点都在多边形的0.2个单位内：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">st_is_within_distance<span class="punctuation">(</span>point_sf<span class="punctuation">,</span> polygon_sfc<span class="punctuation">,</span> dist <span class="operator">=</span> <span class="number">0.2</span><span class="punctuation">,</span> sparse <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">)</span><span class="punctuation">[</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">]</span></span><br><span class="line"><span class="comment">#&gt; [1] TRUE TRUE TRUE</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>📌算拓扑关系的函数使用空间索引来大大提高空间查询性能。
它们使用Sort-Tile-Recursive（STR）算法来实现。
下一节中提到的<code>st_join</code>函数也使用空间索引。 您可以在<a
href="https://www.r-spatial.org/r/2017/06/22/spatial-index.html">https://www.r-spatial.org/r/2017/06/22/spatial-index.html</a>中了解更多信息。</p>
</blockquote>
<h2 id="de-9im-strings">DE-9IM strings</h2>
<p>在前一节所示的二元谓词之下，隐含的是Dimensionally Extended
9-Intersection Model
(DE-9IM)。正如这个神秘的名字所暗示的那样，这并不是一个容易的话题。不过，学习它有可能更好地理解空间关系。此外，DE-9IM的高级用途还包括创建自定义空间谓词。该模型最初被其发明者标记为"DE
+ 9IM"，指的是"两个要素的边界、内部和外部的交界面的维度"
，但现在被称为DE-9IM 。</p>
<p>为了演示DE-9IM
strings的工作原理，让我们看看中第一个几何对之间的各种关系。下图展示了9
intersection model
(9IM)，显示了每个对象的内部、边界和外部之间的交点，当第一个对象<code>x</code>的每个组件被排列为列，而<code>y</code>的每个组件被排列为行时，会创建出一个带有每个元素交点突出显示的分面图形。</p>
<figure>
<img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202308232332970.png"
title="Illustration of how the Dimensionally Extended 9 Intersection Model (DE-9IM) works. Colors not in the legend represent the overlap between different components. The thick lines highlight 2 dimensional intesections, e.g. between the boundary of object x and the interior of object y, shown in the middle top facet."
alt="Illustration of how the Dimensionally Extended 9 Intersection Model (DE-9IM) works. Colors not in the legend represent the overlap between different components. The thick lines highlight 2 dimensional intesections, e.g. between the boundary of object x and the interior of object y, shown in the middle top facet." />
<figcaption aria-hidden="true">Illustration of how the Dimensionally
Extended 9 Intersection Model (DE-9IM) works. Colors not in the legend
represent the overlap between different components. The thick lines
highlight 2 dimensional intesections, e.g. between the boundary of
object x and the interior of object y, shown in the middle top
facet.</figcaption>
</figure>
<p>DE-9IM
strings是基于每种关系的不同维度而产生的。在这种情况下，图中的红色交点分别有着0（点）、1（线）和2（多边形）不同的维度，如简单表格所示。</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>Interior (x)</th>
<th>Boundary (x)</th>
<th>Exterior (x)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Interior (y)</td>
<td>2</td>
<td>1</td>
<td>2</td>
</tr>
<tr class="even">
<td>Boundary (y)</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="odd">
<td>Exterior (y)</td>
<td>2</td>
<td>1</td>
<td>2</td>
</tr>
</tbody>
</table>
<p>按行展开这个矩阵（即按顺序连接第一行、第二行、第三行）得到字符串<code>212111212</code>。另一个例子可以用来说明该系统：下图中展示的关系（第三列和第一行中的第三个多边形对）可以用DE-9IM系统定义如下：</p>
<ul>
<li>较大对象<code>x</code>的<em>内部</em>与<code>y</code>的内部、边界和外部之间的交集分别有维数2、1和2</li>
<li>较大对象<code>x</code>的<em>边界</em>与<code>y</code>的内部、边界和外部之间的交叉点分别有F，F
和1的维度，其中<code>F</code>表示<code>false</code>，物体是不相交的</li>
<li><code>x</code>的<em>外部</em>与<code>y</code>的内部、边界和外部之间的交集分别具有F、F和2的维度，更大对象的外部不接触<code>y</code>的内部或边界，但更小和更大对象的外部覆盖相同的区域</li>
</ul>
<p>当这三个组件连接在一起时，创建字符串<code>212</code>、<code>FF1</code>和<code>FF2</code>。这与从函数<code>st_relations()</code>获得的结果相同(参见本章的源代码，查看图)
中的其他几何图形是如何创建的) :</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">xy2sfc <span class="operator">=</span> <span class="keyword">function</span><span class="punctuation">(</span>x<span class="punctuation">,</span> y<span class="punctuation">)</span> st_sfc<span class="punctuation">(</span>st_polygon<span class="punctuation">(</span><span class="built_in">list</span><span class="punctuation">(</span>cbind<span class="punctuation">(</span>x<span class="punctuation">,</span> y<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">x <span class="operator">=</span> xy2sfc<span class="punctuation">(</span>x <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span> <span class="number">0</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">0</span><span class="punctuation">)</span><span class="punctuation">,</span> y <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">0.5</span><span class="punctuation">,</span> <span class="number">0</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">y <span class="operator">=</span> xy2sfc<span class="punctuation">(</span>x <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0.7</span><span class="punctuation">,</span> <span class="number">0.7</span><span class="punctuation">,</span> <span class="number">0.9</span><span class="punctuation">,</span> <span class="number">0.7</span><span class="punctuation">)</span><span class="punctuation">,</span> y <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0.8</span><span class="punctuation">,</span> <span class="number">0.5</span><span class="punctuation">,</span> <span class="number">0.5</span><span class="punctuation">,</span> <span class="number">0.8</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">st_relate<span class="punctuation">(</span>x<span class="punctuation">,</span> y<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt;      [,1]       </span></span><br><span class="line"><span class="comment">#&gt; [1,] &quot;212FF1FF2&quot;</span></span><br></pre></td></tr></table></figure>
<p>理解DE-9IM strings可以推出新的二元空间谓词。<code>?st_relate</code>
帮助页面包含'Queen'关系和'rook'关系的函数定义，其中多边形共享边界或仅共享一个点。'Queen'关系意味着"边界-边界"关系(简单表格中第二列和第二行的单元格或
DE-9IM string的第五个元素)不能是空的，它相当于模式
<code>F***T****</code>，而对于'rook'关系，则相同的元素必须是1（表示线性相交）。这些措施的执行情况如下:</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">st_queen <span class="operator">=</span> <span class="keyword">function</span><span class="punctuation">(</span>x<span class="punctuation">,</span> y<span class="punctuation">)</span> st_relate<span class="punctuation">(</span>x<span class="punctuation">,</span> y<span class="punctuation">,</span> pattern <span class="operator">=</span> <span class="string">&quot;F***T****&quot;</span><span class="punctuation">)</span></span><br><span class="line">st_rook <span class="operator">=</span> <span class="keyword">function</span><span class="punctuation">(</span>x<span class="punctuation">,</span> y<span class="punctuation">)</span> st_relate<span class="punctuation">(</span>x<span class="punctuation">,</span> y<span class="punctuation">,</span> pattern <span class="operator">=</span> <span class="string">&quot;F***1****&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>在先前创建的对象<code>x</code>的基础上，我们可以使用新创建的函数来找出网格中哪些元素是'queen'和'rook'相对于网格中间的正方形，如下所示:</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">grid <span class="operator">=</span> st_make_grid<span class="punctuation">(</span>x<span class="punctuation">,</span> n <span class="operator">=</span> <span class="number">3</span><span class="punctuation">)</span></span><br><span class="line">grid_sf <span class="operator">=</span> st_sf<span class="punctuation">(</span>grid<span class="punctuation">)</span></span><br><span class="line">grid_sf<span class="operator">$</span>queens <span class="operator">=</span> lengths<span class="punctuation">(</span>st_queen<span class="punctuation">(</span>grid<span class="punctuation">,</span> grid<span class="punctuation">[</span><span class="number">5</span><span class="punctuation">]</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">&gt;</span> <span class="number">0</span></span><br><span class="line">plot<span class="punctuation">(</span>grid<span class="punctuation">,</span> col <span class="operator">=</span> grid_sf<span class="operator">$</span>queens<span class="punctuation">)</span></span><br><span class="line">grid_sf<span class="operator">$</span>rooks <span class="operator">=</span> lengths<span class="punctuation">(</span>st_rook<span class="punctuation">(</span>grid<span class="punctuation">,</span> grid<span class="punctuation">[</span><span class="number">5</span><span class="punctuation">]</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">&gt;</span> <span class="number">0</span></span><br><span class="line">plot<span class="punctuation">(</span>grid<span class="punctuation">,</span> col <span class="operator">=</span> grid_sf<span class="operator">$</span>rooks<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<figure>
<img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202308240039875.png"
title="Demonstration of custom binary spatial predicates for finding ‘queen’ (left) and ‘rook’ (right) relations to the central square in a grid with 9 geometries."
alt="Demonstration of custom binary spatial predicates for finding ‘queen’ (left) and ‘rook’ (right) relations to the central square in a grid with 9 geometries." />
<figcaption aria-hidden="true">Demonstration of custom binary spatial
predicates for finding ‘queen’ (left) and ‘rook’ (right) relations to
the central square in a grid with 9 geometries.</figcaption>
</figure>
<h2 id="空间连接">空间连接</h2>
<p>连接两个非空间数据集依赖于一个共享的'key'变量，如矢量属性连接节中所述。空间数据连接应用了相同的概念，但是依赖于前面部分描述的空间关系。与属性数据一样，连接从源对象(<code>y</code>)向目标对象(参数<code>x</code>在联接函数中)添加新的列。</p>
<p>这个过程可以通过以下例子来说明：假设你在地球表面随机分布了十个点，问这些点中哪些在陆地上，属于哪些国家。在<a
href="https://github.com/geocompx/geocompr/blob/main/code/04-spatial-join.R"
title="reproducible example">reproducible
example</a>中实现这个想法将会提高你的地理数据处理技能，并演示空间连接的运作方式。首先，需要创建随机分布在地球表面的点：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">set.seed<span class="punctuation">(</span><span class="number">2018</span><span class="punctuation">)</span> <span class="comment"># set seed for reproducibility</span></span><br><span class="line"><span class="punctuation">(</span>bb <span class="operator">=</span> st_bbox<span class="punctuation">(</span>world<span class="punctuation">)</span><span class="punctuation">)</span> <span class="comment"># the world&#x27;s bounds</span></span><br><span class="line"><span class="comment">#&gt;   xmin   ymin   xmax   ymax </span></span><br><span class="line"><span class="comment">#&gt; -180.0  -89.9  180.0   83.6</span></span><br><span class="line">random_df <span class="operator">=</span> data.frame<span class="punctuation">(</span></span><br><span class="line">  x <span class="operator">=</span> runif<span class="punctuation">(</span>n <span class="operator">=</span> <span class="number">10</span><span class="punctuation">,</span> <span class="built_in">min</span> <span class="operator">=</span> bb<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="built_in">max</span> <span class="operator">=</span> bb<span class="punctuation">[</span><span class="number">3</span><span class="punctuation">]</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">  y <span class="operator">=</span> runif<span class="punctuation">(</span>n <span class="operator">=</span> <span class="number">10</span><span class="punctuation">,</span> <span class="built_in">min</span> <span class="operator">=</span> bb<span class="punctuation">[</span><span class="number">2</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="built_in">max</span> <span class="operator">=</span> bb<span class="punctuation">[</span><span class="number">4</span><span class="punctuation">]</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">)</span></span><br><span class="line">random_points <span class="operator">=</span> random_df <span class="operator">|&gt;</span> </span><br><span class="line">  st_as_sf<span class="punctuation">(</span>coords <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;x&quot;</span><span class="punctuation">,</span> <span class="string">&quot;y&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> crs <span class="operator">=</span> <span class="string">&quot;EPSG:4326&quot;</span><span class="punctuation">)</span> <span class="comment"># set coordinates and CRS</span></span><br></pre></td></tr></table></figure>
<p>下图中的场景显示，<code>Random_points</code>对象(左上)缺乏属性数据，而<code>world</code>(右上)具有属性，包括图例中显示的国家样本的国家名称。空间连接使用<code>st_join()</code>实现，如下面的代码块所示。输出是<code>Random_join</code>对象，如图(左下)。在创建连接的数据集之前，我们使用空间子集提取来创建<code>world_random</code>，其中只包含含有随机点的国家，以验证在连接的数据集中返回的国家名称数量应该是4(参见下图的右上面板)。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">world_random <span class="operator">=</span> world<span class="punctuation">[</span>random_points<span class="punctuation">,</span> <span class="punctuation">]</span></span><br><span class="line">nrow<span class="punctuation">(</span>world_random<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] 4</span></span><br><span class="line">random_joined <span class="operator">=</span> st_join<span class="punctuation">(</span>random_points<span class="punctuation">,</span> world<span class="punctuation">[</span><span class="string">&quot;name_long&quot;</span><span class="punctuation">]</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<figure>
<img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202308271029710.png"
title="Illustration of a spatial join. A new attribute variable is added to random points (top left) from source world object (top right) resulting in the data represented in the final panel."
alt="Illustration of a spatial join. A new attribute variable is added to random points (top left) from source world object (top right) resulting in the data represented in the final panel." />
<figcaption aria-hidden="true">Illustration of a spatial join. A new
attribute variable is added to random points (top left) from source
world object (top right) resulting in the data represented in the final
panel.</figcaption>
</figure>
<p>默认情况下，<code>st_join()</code>执行<em>左连接</em>，这意味着结果是一个包含来自
<code>x</code> 的所有行的对象，其中包括没有匹配 <code>y</code>
的行（请参见矢量属性连接），但是也可以通过设置参数
<code>left = FALSE</code>
进行内连接。与空间子集提取相似，<code>st_join()</code>
默认使用的拓扑运算符是 <code>st_intersects()</code>，可以通过设置
<code>join</code> 参数来更改（详见
<code>?st_join</code>）。上面的示例演示了将多边形图层的一列添加到点图层的方法，但是该方法适用于任何几何类型。在这种情况下，例如当<code>x</code>包含多边形，每个多边形都与<code>y</code>中多个对象匹配时，空间连接将通过为每个<code>y</code>的匹配创建新行而导致重复的要素。</p>
<h2 id="非重叠连接">非重叠连接</h2>
<p>有时候，两个地理数据集虽然没有触碰，但仍然存在着强烈的地理关系。<code>cycle_hire</code>和<code>cycle_hire_osm</code>这两个数据集已经被附加在<strong>spData</strong>包中，它们提供了很好的例子。将它们绘制出来可以发现它们经常密切相关，但并不触碰，如下图所示。以下代码创建了基础图：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">plot<span class="punctuation">(</span>st_geometry<span class="punctuation">(</span>cycle_hire<span class="punctuation">)</span><span class="punctuation">,</span> col <span class="operator">=</span> <span class="string">&quot;blue&quot;</span><span class="punctuation">)</span></span><br><span class="line">plot<span class="punctuation">(</span>st_geometry<span class="punctuation">(</span>cycle_hire_osm<span class="punctuation">)</span><span class="punctuation">,</span> add <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> pch <span class="operator">=</span> <span class="number">3</span><span class="punctuation">,</span> col <span class="operator">=</span> <span class="string">&quot;red&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>我们可以检查是否有任何点与下面所示的<code>st_intersect()</code>相同:</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="built_in">any</span><span class="punctuation">(</span>st_touches<span class="punctuation">(</span>cycle_hire<span class="punctuation">,</span> cycle_hire_osm<span class="punctuation">,</span> sparse <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] FALSE</span></span><br></pre></td></tr></table></figure>
<figure>
<img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202308241315813.png"
title="The spatial distribution of cycle hire points in London based on official data (blue) and OpenStreetMap data (red)."
alt="The spatial distribution of cycle hire points in London based on official data (blue) and OpenStreetMap data (red)." />
<figcaption aria-hidden="true">The spatial distribution of cycle hire
points in London based on official data (blue) and OpenStreetMap data
(red).</figcaption>
</figure>
<p>想象一下，我们需要将<code>cycle_hire_osm</code>中的<code>capacity</code>变量与官方"目标"数据中的
<code>cycle_hire</code>进行连接，此时需要使用<em>非重叠连接</em>。最简单的方法是使用二元谓词
<code>st_is_within_distance()</code>，如下所示，使用20米的阈值距离。如果启用了球面几何引擎（s2），则可以将度量单位的阈值距离设置为<em>未投影数据</em>（例如
lon/lat CRSs，如
WGS84），因为它在<strong>sf</strong>中默认启用（请参见<em>s2</em>节）。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">sel <span class="operator">=</span> st_is_within_distance<span class="punctuation">(</span>cycle_hire<span class="punctuation">,</span> cycle_hire_osm<span class="punctuation">,</span> </span><br><span class="line">                            dist <span class="operator">=</span> units<span class="operator">::</span>set_units<span class="punctuation">(</span><span class="number">20</span><span class="punctuation">,</span> <span class="string">&quot;m&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">summary<span class="punctuation">(</span>lengths<span class="punctuation">(</span>sel<span class="punctuation">)</span> <span class="operator">&gt;</span> <span class="number">0</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt;    Mode   FALSE    TRUE </span></span><br><span class="line"><span class="comment">#&gt; logical     304     438</span></span><br></pre></td></tr></table></figure>
<p>这表明，目标对象<code>cycle_hire</code>内有438个点位于与<code>cycle_hire_osm</code>的阈值距离内。如何检索与各个<code>cycle_hire_osm</code>点相关联的<em>值</em>？解决方案即为使用<code>st_join()</code>，但添加了一个<code>dist</code>参数（设为20
m）：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">z <span class="operator">=</span> st_join<span class="punctuation">(</span>cycle_hire<span class="punctuation">,</span> cycle_hire_osm<span class="punctuation">,</span> st_is_within_distance<span class="punctuation">,</span> </span><br><span class="line">            dist <span class="operator">=</span> units<span class="operator">::</span>set_units<span class="punctuation">(</span><span class="number">20</span><span class="punctuation">,</span> <span class="string">&quot;m&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">nrow<span class="punctuation">(</span>cycle_hire<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] 742</span></span><br><span class="line">nrow<span class="punctuation">(</span>z<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] 762</span></span><br></pre></td></tr></table></figure>
<p>请注意，连接结果中的行数大于目标行数。这是因为在<code>cycle_hire</code>中的某些自行车租赁站在<code>cycle_hire_osm</code>中有多个匹配项。为了聚合重叠点的值并返回平均值，我们可以使用属性章节学习到的<em>聚合</em>方法，得到行数与目标相同的对象：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">z <span class="operator">=</span> z <span class="operator">|&gt;</span> </span><br><span class="line">  group_by<span class="punctuation">(</span>id<span class="punctuation">)</span> <span class="operator">|&gt;</span> </span><br><span class="line">  summarize<span class="punctuation">(</span>capacity <span class="operator">=</span> mean<span class="punctuation">(</span>capacity<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">nrow<span class="punctuation">(</span>z<span class="punctuation">)</span> <span class="operator">==</span> nrow<span class="punctuation">(</span>cycle_hire<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] TRUE</span></span><br></pre></td></tr></table></figure>
<p>附近站点的容量可以通过比较源数据<code>cycle_hire_osm</code>的容量绘图和这个新对象的结果来进行验证(图表未显示)。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">plot<span class="punctuation">(</span>cycle_hire_osm<span class="punctuation">[</span><span class="string">&quot;capacity&quot;</span><span class="punctuation">]</span><span class="punctuation">)</span></span><br><span class="line">plot<span class="punctuation">(</span>z<span class="punctuation">[</span><span class="string">&quot;capacity&quot;</span><span class="punctuation">]</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>这种连接的结果使用了空间操作，以改变与简单要素相关的属性数据；而与每个要素相关的几何体保持不变。</p>
<h2 id="空间聚合">空间聚合</h2>
<p>与属性数据聚合相同，空间数据聚合也可以<em>压缩</em>数据：聚合结果的行数比非聚合输入要少。统计学的<em>聚合函数</em>（如平均数或总和）可以总结变量的多个数值，并返回每个<em>分组变量</em>的单个值。在矢量属性聚合节中，我们演示了如何使用<code>aggregate()</code>和<code>group_by() |&gt; summarize()</code>根据属性变量压缩数据，本节介绍了相同的函数如何与空间对象一起工作。</p>
<p>回到新西兰的例子中，假设您想要查找每个地区高峰的平均高度，源对象（在这种情况下是
<code>y</code> 或 <code>nz</code>）定义了如何将目标对象（<code>x</code>
或 <code>nz_height</code>）中的价值分组。使用基础 R 的
<code>aggregate()</code> 方法可以在一行代码中完成此操作：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">nz_agg <span class="operator">=</span> aggregate<span class="punctuation">(</span>x <span class="operator">=</span> nz_height<span class="punctuation">,</span> by <span class="operator">=</span> nz<span class="punctuation">,</span> FUN <span class="operator">=</span> mean<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>前一条命令的结果是一个具有与（空间）聚合对象（<code>nz</code>）相同几何形状的<code>sf</code>对象，您可以使用命令<code>identical(st_geometry(nz),st_geometry(nz_agg))</code>来验证。前一操作的结果如下图所示，该图显示了在新西兰的16个地区中，<code>nz_height</code>每个要素的平均值。同样的结果也可以通过将<code>st_join()</code>的输出导入到"tidy"函数<code>group_by()</code>和<code>summarize()</code>中来生成，具体如下：</p>
<figure>
<img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202308241401703.png"
title="Average height of the top 101 high points across the regions of New Zealand."
alt="Average height of the top 101 high points across the regions of New Zealand." />
<figcaption aria-hidden="true">Average height of the top 101 high points
across the regions of New Zealand.</figcaption>
</figure>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">nz_agg2 <span class="operator">=</span> st_join<span class="punctuation">(</span>x <span class="operator">=</span> nz<span class="punctuation">,</span> y <span class="operator">=</span> nz_height<span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">  group_by<span class="punctuation">(</span>Name<span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">  summarize<span class="punctuation">(</span>elevation <span class="operator">=</span> mean<span class="punctuation">(</span>elevation<span class="punctuation">,</span> na.rm <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>通过使用函数<code>mean()</code>，<code>nz_agg</code>对象与分组对象<code>nz</code>具有相同的几何形状，但增加了一个新列，该列汇总每个地区中<code>x</code>的值。其他函数也可以用于此处，包括<code>median()</code>、<code>sd()</code>和其他每个组返回单个值的函数。需要注意的是，<code>aggregate()</code>与<code>group_by() |&gt; summarize()</code>方法之间的一个区别是前者在不匹配的区域名称上显示<code>NA</code>值，而后者保留区域名称。因此，"tidy"方法在聚合功能和结果列名称方面更具灵活性。同时，也在合并节涵盖了创建新几何体的聚合操作。</p>
<h2 id="连接不一致图层">连接不一致图层</h2>
<p>空间一致性是与空间聚合相关的重要概念。<em>聚合对象</em>（我们将其称为<code>y</code>）与目标对象（<code>x</code>）是<em>一致的</em>，如果这两个对象有共享的边界。通常情况下，行政边界数据满足此条件，其中大单位——例如英国的中层超输出区（<a
href="https://www.ons.gov.uk/methodology/geography/ukgeographies/censusgeography"
title="MSOAs">MSOAs</a>）或许多其他欧洲国家的区域——由许多较小单位组成。</p>
<p>相比之下，<em>不一致</em>聚合对象与目标对象没有共同的边界。这对于空间聚合(和其他空间操作)是有问题的，如下图所示。聚合每个子区域的质心将不会返回准确的结果。面积插值通过将值从一组面积单位转移到另一组面积单位来克服这个问题，使用一系列算法，包括简单的面积加权方法和更复杂的方法，如"pycnophylactic"方法。</p>
<figure>
<img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202308251643479.png"
title="Illustration of congruent (left) and incongruent (right) areal units with respect to larger aggregating zones (translucent ted borders)."
alt="Illustration of congruent (left) and incongruent (right) areal units with respect to larger aggregating zones (translucent ted borders)." />
<figcaption aria-hidden="true">Illustration of congruent (left) and
incongruent (right) areal units with respect to larger aggregating zones
(translucent ted borders).</figcaption>
</figure>
<p><strong>spData</strong>包有一个名为<code>incongruent</code>的数据集（在上图的右面板中带有黑色边框的彩色多边形），以及一个名为<code>aggregating_zones</code>的数据集（在的右面板中带有半透明蓝色边框的两个多边形）。假设<code>incongruent</code>的<code>value</code>列指的是以百万欧元为单位的总区域收入。我们如何将九个基础空间多边形的值转换为<code>aggregating_zones</code>中的两个多边形？</p>
<p>这个最简单、有用的方法是<em>面积加权</em>空间插值方法，它按照重叠面积的比例，将值从<em>不相容</em>对象传递到<em>聚合区域</em>中的一个新列中：输入和输出要素之间的空间交叉越大，相应的值也越大。这在下面的代码片段中通过<code>st_interpolate_aw()</code>实现。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">iv <span class="operator">=</span> incongruent<span class="punctuation">[</span><span class="string">&quot;value&quot;</span><span class="punctuation">]</span> <span class="comment"># keep only the values to be transferred</span></span><br><span class="line">agg_aw <span class="operator">=</span> st_interpolate_aw<span class="punctuation">(</span>iv<span class="punctuation">,</span> aggregating_zones<span class="punctuation">,</span> extensive <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; Warning in st_interpolate_aw.sf(iv, aggregating_zones, extensive = TRUE):</span></span><br><span class="line"><span class="comment">#&gt; st_interpolate_aw assumes attributes are constant or uniform over areas of x</span></span><br><span class="line">agg_aw<span class="operator">$</span>value</span><br><span class="line"><span class="comment">#&gt; [1] 19.6 25.7</span></span><br></pre></td></tr></table></figure>
<p>案例中，由于总收入是一种所谓的空间广泛变量（随着地区增大而增加），所以将落入聚合区域的交叉值进行总结是有意义的。这里假设收入在较小的区域内均匀分布（所以有上面的警告信息）。但对于空间密集变量<a
href="https://geodacenter.github.io/workbook/3b_rates/lab3b.html#spatially-extensive-and-spatially-intensive-variables"
title="intensive">intensive</a>（如<em>平均</em>收入或百分比），情况会有所不同，它们不会随着区域的增加而增加。<code>st_interpolate_aw()</code>在处理空间密集变量时同样有效：将<code>extensive</code>参数设置为<code>FALSE</code>，它将在执行聚合时使用平均函数而非求和函数。</p>
<h2 id="距离关系">距离关系</h2>
<p>拓扑关系是二元的──一个要素要么相交，要么不相交──而距离关系是连续的。两个对象之间的距离是用<code>st_distance()</code>函数计算的。下面的代码块说明了这一点，找到了新西兰最高点与坎特伯雷地区地理重心之间的距离，该地理重心是在<em>空间子集提取</em>中创建的：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">nz_highest <span class="operator">=</span> nz_height <span class="operator">|&gt;</span> slice_max<span class="punctuation">(</span>n <span class="operator">=</span> <span class="number">1</span><span class="punctuation">,</span> order_by <span class="operator">=</span> elevation<span class="punctuation">)</span></span><br><span class="line">canterbury_centroid <span class="operator">=</span> st_centroid<span class="punctuation">(</span>canterbury<span class="punctuation">)</span></span><br><span class="line">st_distance<span class="punctuation">(</span>nz_highest<span class="punctuation">,</span> canterbury_centroid<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; Units: [m]</span></span><br><span class="line"><span class="comment">#&gt;        [,1]</span></span><br><span class="line"><span class="comment">#&gt; [1,] 115540</span></span><br></pre></td></tr></table></figure>
<p>这个结果有两个令人惊讶之处:</p>
<ul>
<li>它具有<code>units</code>，告诉我们距离是100,000米，而不是100,000英寸或任何其他距离的度量。</li>
<li>即使结果只包含一个单一值，它仍以矩阵形式返回</li>
</ul>
<p>第二个特性暗示了<code>st_length()</code>的另一个有用的特性，它能够在对象<code>x</code>和<code>y</code>中的所有特征组合之间返回<em>距离矩阵</em>。下面的命令说明了这一点，它找出了<code>nz_height</code>中前三个特征与<code>co</code>所代表的奥塔戈和坎特伯雷地区之间的距离。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">co <span class="operator">=</span> filter<span class="punctuation">(</span>nz<span class="punctuation">,</span> grepl<span class="punctuation">(</span><span class="string">&quot;Canter|Otag&quot;</span><span class="punctuation">,</span> Name<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">st_distance<span class="punctuation">(</span>nz_height<span class="punctuation">[</span><span class="number">1</span><span class="operator">:</span><span class="number">3</span><span class="punctuation">,</span> <span class="punctuation">]</span><span class="punctuation">,</span> co<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; Units: [m]</span></span><br><span class="line"><span class="comment">#&gt;        [,1]  [,2]</span></span><br><span class="line"><span class="comment">#&gt; [1,] 123537 15498</span></span><br><span class="line"><span class="comment">#&gt; [2,]  94283     0</span></span><br><span class="line"><span class="comment">#&gt; [3,]  93019     0</span></span><br></pre></td></tr></table></figure>
<p>请注意，<code>nz_height</code>中第二和第三个要素以及<code>co</code>中第二个要素之间的距离为零。这证明了点与多边形之间的距离是指到<em>多边形的任何部分</em>的距离。<code>nz_height</code>中第二个和第三个点位于奥塔哥地区，这可以通过绘制它们来验证（结果未显示）：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">plot<span class="punctuation">(</span>st_geometry<span class="punctuation">(</span>co<span class="punctuation">)</span><span class="punctuation">[</span><span class="number">2</span><span class="punctuation">]</span><span class="punctuation">)</span></span><br><span class="line">plot<span class="punctuation">(</span>st_geometry<span class="punctuation">(</span>nz_height<span class="punctuation">)</span><span class="punctuation">[</span><span class="number">2</span><span class="operator">:</span><span class="number">3</span><span class="punctuation">]</span><span class="punctuation">,</span> add <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<h1 id="栅格数据空间操作">栅格数据空间操作</h1>
<p>本节建立在栅格数据操作基础上，该节重点介绍了处理栅格数据的各种基本方法，以便展示更高级和明确的空间栅格操作，并使用在本节中手动创建的<code>elev</code>和<code>grain</code>对象。为了方便读者，这些数据集也可以在<strong>spData</strong>包中找到。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">elev <span class="operator">=</span> rast<span class="punctuation">(</span>system.file<span class="punctuation">(</span><span class="string">&quot;raster/elev.tif&quot;</span><span class="punctuation">,</span> package <span class="operator">=</span> <span class="string">&quot;spData&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">grain <span class="operator">=</span> rast<span class="punctuation">(</span>system.file<span class="punctuation">(</span><span class="string">&quot;raster/grain.tif&quot;</span><span class="punctuation">,</span> package <span class="operator">=</span> <span class="string">&quot;spData&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<h2 id="空间栅格提取">空间栅格提取</h2>
<p>前一章栅格数据操作展示了如何检索与特定单元格ID或行列组合相关联的值。栅格对象也可以通过位置（坐标）和其他空间对象进行提取。要使用坐标进行子集提取，可以使用<strong>terra</strong>函数<code>cellFromXY()</code>将坐标'translate'为单元格ID。另一种方法是使用<code>terra::extract()</code>（请注意，在<strong>tidyverse</strong>中还有一个名为<code>extract()</code>的函数）来提取值。下面展示了两种方法来找到覆盖在坐标为0.1，0.1的点上的单元格的值。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">id <span class="operator">=</span> cellFromXY<span class="punctuation">(</span>elev<span class="punctuation">,</span> xy <span class="operator">=</span> matrix<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">0.1</span><span class="punctuation">,</span> <span class="number">0.1</span><span class="punctuation">)</span><span class="punctuation">,</span> ncol <span class="operator">=</span> <span class="number">2</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">elev<span class="punctuation">[</span>id<span class="punctuation">]</span></span><br><span class="line"><span class="comment"># the same as</span></span><br><span class="line">terra<span class="operator">::</span>extract<span class="punctuation">(</span>elev<span class="punctuation">,</span> matrix<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">0.1</span><span class="punctuation">,</span> <span class="number">0.1</span><span class="punctuation">)</span><span class="punctuation">,</span> ncol <span class="operator">=</span> <span class="number">2</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>栅格对象可以与另一个栅格对象进行子集提取，示例如下：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">clip <span class="operator">=</span> rast<span class="punctuation">(</span>xmin <span class="operator">=</span> <span class="number">0.9</span><span class="punctuation">,</span> xmax <span class="operator">=</span> <span class="number">1.8</span><span class="punctuation">,</span> ymin <span class="operator">=</span> <span class="operator">-</span><span class="number">0.45</span><span class="punctuation">,</span> ymax <span class="operator">=</span> <span class="number">0.45</span><span class="punctuation">,</span></span><br><span class="line">            resolution <span class="operator">=</span> <span class="number">0.3</span><span class="punctuation">,</span> vals <span class="operator">=</span> <span class="built_in">rep</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">9</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">elev<span class="punctuation">[</span>clip<span class="punctuation">]</span></span><br><span class="line"><span class="comment"># we can also use extract</span></span><br><span class="line">terra<span class="operator">::</span>extract<span class="punctuation">(</span>elev<span class="punctuation">,</span> ext<span class="punctuation">(</span>clip<span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>这等于获取第一个栅格对象（在本例中为<code>elev</code>）的值，这些值落在第二个栅格（即<code>clip</code>）的范围内，如下图所示。</p>
<figure>
<img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202308251958656.png"
title="Original raster (left). Raster mask (middle). Output of masking a raster (right)."
alt="Original raster (left). Raster mask (middle). Output of masking a raster (right)." />
<figcaption aria-hidden="true">Original raster (left). Raster mask
(middle). Output of masking a raster (right).</figcaption>
</figure>
<p>上述示例返回了特定单元格的值，但在许多情况下，需要对栅格数据集进行子集提取得到空间输出。这可以通过将<code>[</code>运算符的<code>drop</code>参数设置为<code>FALSE</code>来实现。下面的代码返回<code>elev</code>的前两个单元（即顶部行的前两个单元格），并作为栅格对象返回（仅显示输出的前两行）：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">elev<span class="punctuation">[</span><span class="number">1</span><span class="operator">:</span><span class="number">2</span><span class="punctuation">,</span> drop <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">]</span>    <span class="comment"># spatial subsetting with cell IDs</span></span><br><span class="line"><span class="comment">#&gt; class       : SpatRaster </span></span><br><span class="line"><span class="comment">#&gt; dimensions  : 1, 2, 1  (nrow, ncol, nlyr)</span></span><br><span class="line"><span class="comment">#&gt; ...</span></span><br></pre></td></tr></table></figure>
<p>另一个常见的空间子集提取例子是当一个具有<code>logical</code>（或<code>NA</code>）值的栅格用于掩膜具有相同范围和分辨率的另一个栅格，如上图所示。在这种情况下，可以使用<code>[</code>和
<code>mask()</code>函数（结果未显示）:</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># create raster mask</span></span><br><span class="line">rmask <span class="operator">=</span> elev</span><br><span class="line">values<span class="punctuation">(</span>rmask<span class="punctuation">)</span> <span class="operator">=</span> sample<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="literal">NA</span><span class="punctuation">,</span> <span class="literal">TRUE</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="number">36</span><span class="punctuation">,</span> replace <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>在上面的代码块中，我们创建了一个名为<code>rmask</code>的掩膜对象，其值被随机分配为<code>NA</code>和<code>TRUE</code>。接下来，我们想要保留那些在<code>rmask</code>中为<code>TRUE</code>的<code>elev</code>值。换句话说，我们想要使用<code>rmask</code>屏蔽<code>elev</code>。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># spatial subsetting</span></span><br><span class="line">elev<span class="punctuation">[</span>rmask<span class="punctuation">,</span> drop <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">]</span>           <span class="comment"># with [ operator</span></span><br><span class="line">mask<span class="punctuation">(</span>elev<span class="punctuation">,</span> rmask<span class="punctuation">)</span>                   <span class="comment"># with mask()</span></span><br></pre></td></tr></table></figure>
<p>以上方法还可用于使用<code>NA</code>替换某些值（例如，预计出现错误）。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">elev<span class="punctuation">[</span>elev <span class="operator">&lt;</span> <span class="number">20</span><span class="punctuation">]</span> <span class="operator">=</span> <span class="literal">NA</span></span><br></pre></td></tr></table></figure>
<p>这些操作实际上是布尔局部操作，因为我们逐单元格比较了两个栅格。下一小节将更详细地探讨这些和相关的操作。</p>
<h2 id="地图代数">地图代数</h2>
<p>"地图代数"是在上世纪70年代末提出的，用于描述地理栅格数据和（虽然不那么突出）矢量数据的分析的"一套约定、功能和技术"。在这个背景下，我们更加明确地定义地图代数，作为一种修改或汇总栅格单元值的操作，涉及周围单元、区域或应用于每个单元的统计函数。</p>
<p>地图代数操作往往是快速的，因为栅格数据集只隐式地存储坐标，因此有一句<a
href="https://geozoneblog.wordpress.com/2013/04/19/raster-vs-vector/"
title="古老格言">古老格言</a>
"栅格更快，但矢量更正确"。栅格数据集中单元的位置可以通过使用其矩阵位置和数据集的分辨率和原点（存储在标头中）来计算。然而，就处理而言，只要我们确保处理后单元格位置不变，单元格的地理位置就几乎不相关。此外，如果两个或多个栅格数据集具有相同的范围、投影和分辨率，可以将它们视为矩阵进行处理。</p>
<p>这是使用<strong>terra</strong>包进行地图代数的方法。首先，会查询栅格数据集的标头，并（在需要处理多个数据集的地图代数运算中）检查数据集是否兼容。其次，地图代数保留所谓的一对一定位对应关系，这意味着单元格不能移动。这与矩阵代数不同，矩阵代数中，例如在矩阵乘法或除法时，值会改变位置。</p>
<p>地图代数（或栅格数据的制图建模）将栅格操作分为四个子类，每个子类同时在一个或多个栅格上进行操作：</p>
<ol type="1">
<li><em>局部</em>或逐单元格操作</li>
<li><em>焦点</em>或邻域操作。最常见的输出单元格值是3x3输入单元格块的结果</li>
<li><em>区域</em>操作与焦点操作相似，但计算新值的周围像素网格可能具有不规则的大小和形状</li>
<li><em>全局</em>或逐栅格操作。这意味着输出单元格可能从一个或多个整个栅格派生其值</li>
</ol>
<p>这种分类按照用于每个像素处理步骤的<strong>单元格数量</strong>和<strong>输出类型</strong>对地图代数操作进行分类。为了完整起见，我们应该提到栅格操作还可以按学科分类，例如地形、水文分析或图像分类。以下部分解释了每种类型的地图代数操作如何使用，参考了实际示例。</p>
<h2 id="局部操作">局部操作</h2>
<p><strong>局部</strong>操作包括在一个或多个层上的所有逐单元格操作。栅格代数是局部操作的典型用例——这包括从栅格中添加或减去值，平方和乘以栅格。栅格代数还允许逻辑操作，例如查找大于特定值的所有栅格单元格（在我们下面的示例中为5）。<strong>terra</strong>包支持所有这些操作及更多，如下图所示：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">elev <span class="operator">+</span> elev</span><br><span class="line">elev<span class="operator">^</span><span class="number">2</span></span><br><span class="line"><span class="built_in">log</span><span class="punctuation">(</span>elev<span class="punctuation">)</span></span><br><span class="line">elev <span class="operator">&gt;</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>
<figure>
<img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202308262241490.png"
title="Examples of different local operations of the elev raster object: adding two rasters, squaring, applying logarithmic transformation, and performing a logical operation."
alt="Examples of different local operations of the elev raster object: adding two rasters, squaring, applying logarithmic transformation, and performing a logical operation." />
<figcaption aria-hidden="true">Examples of different local operations of
the elev raster object: adding two rasters, squaring, applying
logarithmic transformation, and performing a logical
operation.</figcaption>
</figure>
<p><em>局部操作</em>的另一个很好的例子是将数字值的区间分为诸如将数字高程模型分为低（类别1）、中（类别2）和高（类别3）海拔的组。使用<code>classify()</code>命令，我们首先需要构建一个重分类矩阵，其中第一列对应于类别的下限，第二列对应于上限。第三列代表第一和第二列中指定范围的新值。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">rcl <span class="operator">=</span> matrix<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span> <span class="number">12</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">12</span><span class="punctuation">,</span> <span class="number">24</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">,</span> <span class="number">24</span><span class="punctuation">,</span> <span class="number">36</span><span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">)</span><span class="punctuation">,</span> ncol <span class="operator">=</span> <span class="number">3</span><span class="punctuation">,</span> byrow <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br><span class="line">rcl</span><br><span class="line"><span class="comment">#&gt;      [,1] [,2] [,3]</span></span><br><span class="line"><span class="comment">#&gt; [1,]    0   12    1</span></span><br><span class="line"><span class="comment">#&gt; [2,]   12   24    2</span></span><br><span class="line"><span class="comment">#&gt; [3,]   24   36    3</span></span><br></pre></td></tr></table></figure>
<p>在这里，我们将范围为0-12、12-24和24-36的栅格值进行了<em>重分类</em>，分别赋值为1、2和3。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">recl <span class="operator">=</span> classify<span class="punctuation">(</span>elev<span class="punctuation">,</span> rcl <span class="operator">=</span> rcl<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><code>classify()</code>函数也可以用于我们想要减少分类栅格中类别数量的情况。我们将在<em>地理营销</em>中执行几个附加的重分类操作。</p>
<p>除了算术运算符外，还可以使用<code>app()</code>、<code>tapp()</code>和<code>lapp()</code>函数。它们更有效率，因此，在大型栅格数据集存在的情况下，它们是首选。此外，它们允许你直接保存输出文件。<code>app()</code>函数将一个函数应用到栅格的每个单元格，并用于将多个图层的值汇总（例如，计算总和）到一个图层。<code>tapp()</code>是<code>app()</code>的扩展，允许我们选择要执行某个操作的图层子集（参见<code>index</code>参数）。最后，<code>lapp()</code>函数允许使用图层作为参数将一个函数应用到每个单元格——下面将介绍<code>lapp()</code>的一个应用。</p>
<p>归一化植被指数（NDVI）的计算是一种众所周知的局部（逐像素）栅格操作。它返回一个值介于-1和1之间的栅格；正值表示存在活植物（通常
&gt;
0.2）。NDVI是从遥感影像的红色和近红外（NIR）波段计算的，通常来自Landsat或Sentinel等卫星系统。植被在可见光光谱中大量吸收光线，特别是在红色通道中，同时反射NIR光线，从而解释了NVDI公式：</p>
<p><span class="math display">\[
\begin{split}
NDVI&amp;= \frac{\text{NIR} - \text{Red}}{\text{NIR} + \text{Red}}\\
\end{split}
\]</span></p>
<p>让我们计算锡安国家公园的多光谱卫星影像的NDVI。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">multi_raster_file <span class="operator">=</span> system.file<span class="punctuation">(</span><span class="string">&quot;raster/landsat.tif&quot;</span><span class="punctuation">,</span> package <span class="operator">=</span> <span class="string">&quot;spDataLarge&quot;</span><span class="punctuation">)</span></span><br><span class="line">multi_rast <span class="operator">=</span> rast<span class="punctuation">(</span>multi_raster_file<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>栅格对象具有四个卫星波段：蓝、绿、红和近红外（NIR）。我们下一步应该在
R 函数中使用NDVI公式：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ndvi_fun <span class="operator">=</span> <span class="keyword">function</span><span class="punctuation">(</span>nir<span class="punctuation">,</span> red<span class="punctuation">)</span><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="punctuation">(</span>nir <span class="operator">-</span> red<span class="punctuation">)</span> <span class="operator">/</span> <span class="punctuation">(</span>nir <span class="operator">+</span> red<span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>这个函数接受两个数值参数，<code>nir</code>和<code>red</code>，并返回一个带有NDVI值的数值向量。它可以用作<code>lapp()</code>的<code>fun</code>参数。我们只需记住，我们的函数只需要两个波段（不是原始栅格的四个），并且它们需要按<code>NIR</code>、<code>red</code>的顺序排列。这就是为什么我们在进行任何计算之前，使用<code>multi_rast[[c(4, 3)]]</code>来提取输入栅格的子集。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ndvi_rast <span class="operator">=</span> lapp<span class="punctuation">(</span>multi_rast<span class="punctuation">[[</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">4</span><span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">)</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">,</span> fun <span class="operator">=</span> ndvi_fun<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>结果显示在下图的右侧面板上，可以与同一区域的RGB图像（同一图的左侧面板）进行比较。这让我们看到最大的NDVI值与该区域北部的密集森林区域相连，而最低的值则与北部的湖泊和积雪覆盖的山脊有关。</p>
<figure>
<img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202308262308411.png"
title="RGB image (left) and NDVI values (right) calculated for the example satellite file of the Zion National Park"
alt="RGB image (left) and NDVI values (right) calculated for the example satellite file of the Zion National Park" />
<figcaption aria-hidden="true">RGB image (left) and NDVI values (right)
calculated for the example satellite file of the Zion National
Park</figcaption>
</figure>
<p>预测映射是局部栅格操作的另一个有趣应用。响应变量对应于空间中测量或观察到的点，例如物种丰富度、滑坡的存在、树木疾病或农作物产量。因此，我们可以轻松从各种栅格（例如海拔、pH值、降水量、温度、土地覆盖、土壤类型等）检索空间或预测变量。随后，我们使用<code>lm()</code>、<code>glm()</code>、<code>gam()</code>或机器学习技术将响应建模为预测因子的函数。因此，将估计系数应用于预测栅格值，并对输出栅格值求和（参见
<em>生态</em>章节），可以对栅格对象进行空间预测。</p>
<h2 id="焦点操作">焦点操作</h2>
<p>虽然<em>局部</em>函数可能在多个层上操作一个单元格，但<em>焦点</em>操作会考虑中心（焦点）单元格及其邻居。通常考虑的邻域（也称为内核、滤波器或移动窗口）大小为3x3个单元格（即中心单元格及其周围的八个邻居），但可以根据用户的定义采用任何其他（不一定是矩形的）形状。焦点操作将一个聚合函数应用于指定邻域内的所有单元格，将相应的输出用作中心单元格的新值，然后移至下一个中心单元格，如下图所示。此操作的其他名称是空间滤波和卷积。</p>
<p>在R中，我们可以使用<code>focal()</code>函数来执行空间滤波。我们通过一个<code>matrix</code>定义移动窗口的形状，其值对应于权重（参见下面代码块中的<code>w</code>参数）。其次，<code>fun</code>参数让我们指定我们希望应用于这个邻域的函数。这里，我们选择最小值，但可以使用任何其他汇总函数，包括<code>sum()</code>、<code>mean()</code>或<code>var()</code>。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">r_focal <span class="operator">=</span> focal<span class="punctuation">(</span>elev<span class="punctuation">,</span> w <span class="operator">=</span> matrix<span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span> nrow <span class="operator">=</span> <span class="number">3</span><span class="punctuation">,</span> ncol <span class="operator">=</span> <span class="number">3</span><span class="punctuation">)</span><span class="punctuation">,</span> fun <span class="operator">=</span> <span class="built_in">min</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>这个函数还接受其他参数，例如，在过程中是否应删除<code>NA</code>值（<code>na.rm = TRUE</code>）或不删除（<code>na.rm = FALSE</code>）。</p>
<figure>
<img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202308262319552.png"
title="Input raster (left) and resulting output raster (right) due to a focal operation - finding the minimum value in 3-by-3 moving windows."
alt="Input raster (left) and resulting output raster (right) due to a focal operation - finding the minimum value in 3-by-3 moving windows." />
<figcaption aria-hidden="true">Input raster (left) and resulting output
raster (right) due to a focal operation - finding the minimum value in
3-by-3 moving windows.</figcaption>
</figure>
<p>我们可以快速检查输出是否符合我们的预期。在我们的示例中，最小值必须始终位于移动窗口的左上角（请记住，我们通过从左上角开始逐行增加单元格值来创建输入栅格）。在此示例中，权重矩阵只包括1，这意味着每个单元格对输出具有相同的权重，但这可以更改。</p>
<p><em>焦点</em>函数或滤波器在图像处理中起着主导作用。低通或平滑滤波使用平均函数来消除极值。在分类数据的情况下，我们可以用众数（最常见的值）替换平均数。相反，高通滤波强调特征。此处，线检测的拉普拉斯和索贝尔滤波可以作为例子。你可以查看<code>focal()</code>的帮助页面了解如何在
R 中使用它们（这也将在本章节结束时的练习中使用）。</p>
<p>地形处理，计算地形特性如坡度、方向和流向，依赖于<em>焦点</em>函数。虽然<code>terrain()</code>可用于计算这些指标，但一些地形算法（包括用于计算坡度的Zevenbergen和Thorne方法）并未在这个<strong>terra</strong>函数中实现。许多其他算法——包括曲率、贡献区域和湿度指数
——是在开源桌面地理信息系统（GIS）软件中实现的。<em>GIS桥梁</em>章介绍了如何从R内部访问这样的GIS功能。</p>
<h2 id="区域操作">区域操作</h2>
<p>与焦点操作一样，<em>区域</em>操作将聚合函数应用于多个栅格单元格。然而，在<em>区域</em>操作的情况下，第二个栅格（通常具有分类值）定义了<em>分区滤波器</em>（或"区域"），与上一节中呈现的<em>焦点</em>操作的预定义邻域窗口相对。因此，定义<em>区域</em>滤波器的栅格单元格不一定要相邻。grain
栅格就是一个很好的例子，不同的粒度大小在整个栅格中不规则地分布。最后，<em>区域</em>操作的结果是按区域分组的汇总表，这就是为什么这个操作在GIS世界中也被称为<em>分区统计</em>。这与返回栅格对象的焦点操作形成了对比。</p>
<p>以下代码块使用<code>zonal()</code>函数来计算与每个粒度类别相关的平均海拔。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">z <span class="operator">=</span> zonal<span class="punctuation">(</span>elev<span class="punctuation">,</span> grain<span class="punctuation">,</span> fun <span class="operator">=</span> <span class="string">&quot;mean&quot;</span><span class="punctuation">)</span></span><br><span class="line">z</span><br><span class="line"><span class="comment">#&gt;   grain elev</span></span><br><span class="line"><span class="comment">#&gt; 1  clay 14.8</span></span><br><span class="line"><span class="comment">#&gt; 2  silt 21.2</span></span><br><span class="line"><span class="comment">#&gt; 3  sand 18.7</span></span><br></pre></td></tr></table></figure>
<p>这将返回每个类别的统计，在这里是每个粒度大小类别的平均海拔。注意：通过将<code>as.raster</code>参数设置为<code>TRUE</code>，也可以获得每个区域的计算统计数据的栅格。</p>
<h2 id="全局操作和距离">全局操作和距离</h2>
<p><em>全局</em>操作是分区操作的特殊情况，整个栅格数据集代表单个区域。整个栅格数据集的描述性统计是最常见的全局操作，例如最小值或最大值——我们已经在章节栅格数据汇总中讨论过这些。</p>
<p>除此之外，全局操作还可用于计算距离和权重栅格。在第一种情况下，可以计算每个单元格到特定目标单元格的距离。例如，人们可能想要计算到最近海岸的距离（参见<code>terra::distance()</code>）。我们也可能想要考虑地形，这意味着，我们不仅对纯粹的距离感兴趣，而且还想避免在前往海岸时穿越山脉。为此，我们可以通过海拔为距离赋权，以便每增加一个海拔米就"延长"欧氏距离。可见性和视域计算也属于全局操作的一类。</p>
<h2 id="矢量数据的地图代数">矢量数据的"地图代数"</h2>
<p>许多地图代数操作在矢量处理中有对应操作。在仅考虑最大距离（逻辑焦点操作）的情况下计算距离栅格（全局操作）等同于矢量缓冲操作（裁剪章节）。重分类栅格数据（根据输入是局部还是区域函数）等同于溶解矢量数据（空间连接章节）。将两个栅格叠加（局部操作），其中一个包含表示遮罩的<code>NULL</code>或<code>NA</code>值，类似于矢量裁剪（章节）。与空间裁剪非常相似的是交叉两个图层（空间矢量提取章节）。区别在于这两个图层（矢量或栅格）仅共享重叠区域。不过，要小心措辞。有时相同的词在栅格和矢量数据模型中具有略有不同的含义。虽然聚合多边形几何意味着溶解边界，但对于栅格数据几何，它意味着增加单元格大小，从而降低空间分辨率。区域操作根据另一个栅格数据集的区域（类别）使用聚合函数溶解一个栅格的单元格。</p>
<h2 id="合并栅格">合并栅格</h2>
<p>假设我们想计算NDVI（见局部操作章节），并且还想从高程数据中计算研究区域内观测的地形属性。这些计算依赖于遥感信息。相应的图像常常被分割成覆盖特定空间范围的场景，而研究区域通常覆盖多个场景。那么，我们就需要合并研究区域所覆盖的场景。在最简单的情况下，我们可以只是合并这些场景，即将它们并排放置。例如，可以使用数字高程数据（SRTM，ASTER）来实现。在下面的代码块中，我们首先下载了奥地利和瑞士的SRTM高程数据（有关国家代码，请参见<strong>geodata</strong>函数
<code>country_codes()</code>）。第二步，我们将这两个栅格合并为一个。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">aut <span class="operator">=</span> geodata<span class="operator">::</span>elevation_30s<span class="punctuation">(</span>country <span class="operator">=</span> <span class="string">&quot;AUT&quot;</span><span class="punctuation">,</span> path <span class="operator">=</span> tempdir<span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">ch <span class="operator">=</span> geodata<span class="operator">::</span>elevation_30s<span class="punctuation">(</span>country <span class="operator">=</span> <span class="string">&quot;CHE&quot;</span><span class="punctuation">,</span> path <span class="operator">=</span> tempdir<span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">aut_ch <span class="operator">=</span> merge<span class="punctuation">(</span>aut<span class="punctuation">,</span> ch<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><strong>terra</strong> 的
<code>merge()</code>命令结合了两个图像，如果它们重叠，则使用第一个栅格的值。</p>
<p>当重叠的值彼此不对应时，这种合并方法用处不大。当您想合并在不同日期拍摄的场景的光谱图像时，通常会出现这种情况。<code>merge()</code>
命令仍然会工作，但在结果图像中您会看到一个明显的边界。另一方面，<code>mosaic()</code>
命令允许您为重叠区域定义一个函数。例如，我们可以计算平均值 --
这可能会平滑合并结果中的明显边界，但最有可能的是它不会让其消失。</p>
<h1 id="练习">练习</h1>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>sf<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>dplyr<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>spData<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>E1. It was established in Section <span class="citation"
data-cites="ref">@ref</span>(spatial-vec) that Canterbury was the region
of New Zealand containing most of the 100 highest points in the country.
How many of these high points does the Canterbury region contain?</p>
<p><strong>Bonus:</strong> plot the result using the <code>plot()</code>
function to show all of New Zealand, <code>canterbury</code> region
highlighted in yellow, high points in Canterbury represented by red
crosses (hint: <code>pch = 7</code>) and high points in other parts of
New Zealand represented by blue circles. See the help page
<code>?points</code> for details with an illustration of different
<code>pch</code> values.</p>
<p>E2. Which region has the second highest number of
<code>nz_height</code> points, and how many does it have?</p>
<p>E3. Generalizing the question to all regions: how many of New
Zealand's 16 regions contain points which belong to the top 100 highest
points in the country? Which regions?</p>
<ul>
<li>Bonus: create a table listing these regions in order of the number
of points and their name.</li>
</ul>
<p>E4. Test your knowledge of spatial predicates by finding out and
plotting how US states relate to each other and other spatial
objects.</p>
<p>The starting point of this exercise is to create an object
representing Colorado state in the USA. Do this with the command
<code>colorado = us_states[us_states$NAME == "Colorado",]</code> (base
R) or with with the <code>filter()</code> function (tidyverse) and plot
the resulting object in the context of US states.</p>
<ul>
<li>Create a new object representing all the states that geographically
intersect with Colorado and plot the result (hint: the most concise way
to do this is with the subsetting method <code>[</code>).</li>
<li>Create another object representing all the objects that touch (have
a shared boundary with) Colorado and plot the result (hint: remember you
can use the argument <code>op = st_intersects</code> and other spatial
relations during spatial subsetting operations in base R).</li>
<li>Bonus: create a straight line from the centroid of the District of
Columbia near the East coast to the centroid of California near the West
coast of the USA (hint: functions <code>st_centroid()</code>,
<code>st_union()</code> and <code>st_cast()</code> described in Chapter
5 may help) and identify which states this long East-West line
crosses.</li>
</ul>
<p>E5. Use
<code>dem = rast(system.file("raster/dem.tif", package = "spDataLarge"))</code>,
and reclassify the elevation in three classes: low (&lt;300), medium and
high (&gt;500). Secondly, read the NDVI raster
(<code>ndvi = rast(system.file("raster/ndvi.tif", package = "spDataLarge"))</code>)
and compute the mean NDVI and the mean elevation for each altitudinal
class.</p>
<p>E6. Apply a line detection filter to
<code>rast(system.file("ex/logo.tif", package = "terra"))</code>. Plot
the result. Hint: Read <code>?terra::focal()</code>.</p>
<p>E7. Calculate the Normalized Difference Water Index (NDWI;
<code>(green - nir)/(green + nir)</code>) of a Landsat image. Use the
Landsat image provided by the <strong>spDataLarge</strong> package
(<code>system.file("raster/landsat.tif", package = "spDataLarge")</code>).
Also, calculate a correlation between NDVI and NDWI for this area (hint:
you can use the <code>layerCor()</code> function).</p>
<p>E8. A StackOverflow <a
href="https://stackoverflow.com/questions/35555709/global-raster-of-geographic-distances"
title="post">post</a> shows how to compute distances to the nearest
coastline using <code>raster::distance()</code>. Try to do something
similar but with <code>terra::distance()</code>: retrieve a digital
elevation model of Spain, and compute a raster which represents
distances to the coast across the country (hint: use
<code>geodata::elevation_30s()</code>). Convert the resulting distances
from meters to kilometers. Note: it may be wise to increase the cell
size of the input raster to reduce compute time during this operation
(<code>aggregate()</code>).</p>
<p>E9. Try to modify the approach used in the above exercise by
weighting the distance raster with the elevation raster; every 100
altitudinal meters should increase the distance to the coast by 10 km.
Next, compute and visualize the difference between the raster created
using the Euclidean distance (E7) and the raster weighted by
elevation.</p>
]]></content>
      <categories>
        <category>R</category>
        <category>Geocomputaion</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>Geocomputaion</tag>
      </tags>
  </entry>
</search>
