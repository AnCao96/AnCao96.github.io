<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>(01) 欢迎（空间数据科学——R语言应用）</title>
    <url>/2023/10/15/21-hello/</url>
    <content><![CDATA[<blockquote><p>本文由SCY翻译，转载注明出处。</p>
</blockquote>
<p>本章介绍了一系列与处理空间和时空数据相关的概念，并指向后续章节，其中这些概念将会被更详细地讨论。它还介绍了一系列构成所有空间数据科学语言实现基础的开源技术。</p>
<span id="more"></span>
<h2 id="第一张地图">第一张地图</h2>
<p>绘制空间数据的典型方法是创建一张地图。让我们考虑一张简单的地图，如下图所示。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>tidyverse<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>sf<span class="punctuation">)</span></span><br><span class="line">system.file<span class="punctuation">(</span><span class="string">&quot;gpkg/nc.gpkg&quot;</span><span class="punctuation">,</span> package<span class="operator">=</span><span class="string">&quot;sf&quot;</span><span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">	read_sf<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">-&gt;</span> nc</span><br><span class="line">nc.32119 <span class="operator">&lt;-</span> st_transform<span class="punctuation">(</span>nc<span class="punctuation">,</span> <span class="string">&#x27;EPSG:32119&#x27;</span><span class="punctuation">)</span></span><br><span class="line">nc.32119 <span class="operator">|&gt;</span></span><br><span class="line">	select<span class="punctuation">(</span>BIR74<span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">	plot<span class="punctuation">(</span>graticule <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> axes <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202310151341171.png" alt="图1.1：第一张地图：1974-78年北卡罗来纳州各县出生人数"></p>
<p>在这个例子中，有多个图形元素存在：</p>
<ul>
<li>多边形用黑色轮廓绘制，并根据一个名为<code>BIR74</code>的变量用颜色进行填充，该变量的名字出现在标题中。</li>
<li>图例键解释了颜色的含义，并具有特定的<em>色彩调色板</em>和<em>色彩断点</em>，也就是颜色变化的值。</li>
<li>地图的背景显示了具有恒定纬度或经度的曲线（经纬网）。</li>
<li>坐标轴刻度显示了纬度和经度的值。</li>
</ul>
<p><em>多边形</em>是一种特殊形式的<em>几何体</em>；空间几何体（点、线、多边形、像素）将在<strong>几何章节</strong>中详细讨论。多边形由点的序列组成，通过直线连接。空间数据的点位置如何表示或测量，在<strong>坐标系章节</strong>中有讨论。从上图可以看出，相等的纬度和经度并没有形成直线，这表明在绘图之前进行了某种投影；投影也在<strong>坐标系章节</strong>和<strong>投影章节</strong>中讨论。</p>
<p>在上图中的颜色值来自一个变量<code>BIR74</code>的数值，该变量与每个几何体或<em>特征</em>有一个单一的关联值。<strong>属性和支持章节</strong>讨论了这样的特征属性，以及它们如何与特征几何体相关联。在这个例子中，<code>BIR74</code>是出生人数，即<em>该区域</em>的人数。这意味着这个计数并不是指多边形内每个点关联的一个值，如连续颜色可能暗示的那样，而是测量了多边形上的积分（总和）。</p>
<p>在绘制上图之前，我们需要读取数据，在这个例子中是从一个文件中读取的（<strong>sf包</strong>）。打印前三条记录的三个属性变量的数据摘要显示：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">nc <span class="operator">|&gt;</span> select<span class="punctuation">(</span>AREA<span class="punctuation">,</span> BIR74<span class="punctuation">,</span> SID74<span class="punctuation">)</span> <span class="operator">|&gt;</span> print<span class="punctuation">(</span>n <span class="operator">=</span> <span class="number">3</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## Simple feature collection with 100 features and 3 fields</span><br><span class="line">## Geometry type: MULTIPOLYGON</span><br><span class="line">## Dimension:     XY</span><br><span class="line">## Bounding box:  xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965</span><br><span class="line">## Geodetic CRS:  NAD27</span><br><span class="line">## # A tibble: 100 × 4</span><br><span class="line">##    AREA BIR74 SID74                                                                              geom</span><br><span class="line">##   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;                                                                &lt;MULTIPOLYGON [°]&gt;</span><br><span class="line">## 1 0.114  1091     1 (((-81.47276 36.23436, -81.54084 36.27251, -81.56198 36.27359, -81.63306 36.3406…</span><br><span class="line">## 2 0.061   487     0 (((-81.23989 36.36536, -81.24069 36.37942, -81.26284 36.40504, -81.26624 36.4372…</span><br><span class="line">## 3 0.143  3188     5 (((-80.45634 36.24256, -80.47639 36.25473, -80.53688 36.25674, -80.54501 36.2766…</span><br><span class="line">## # ℹ 97 more rows</span><br></pre></td></tr></table></figure>
<p>打印输出结果如下所示:</p>
<ul>
<li>（选择）的数据集包含 100 个要素（条记录）和 3 个字段（属性）。</li>
<li>几何类型是 <code>MULTIPOLYGON</code> （详见<strong>几何章节</strong>）。</li>
<li>其维度为<code>XY</code>，表明每个点由2个坐标值组成。</li>
<li>几何的$x$和$y$值的范围。</li>
<li>坐标参考系统（CRS）是大地坐标系统，其坐标以经度和纬度表示，与<code>NAD27</code>基准相关联（<strong>坐标系章节</strong>）。</li>
<li>三个选定的属性变量后面是一个名为<code>geom</code>的<code>MULTIPOLYGON</code>类型变量，单位为度，包含多边形信息</li>
</ul>
<p>更复杂的图表可能涉及到每个方面都有一张地图的分面图，如下图所示。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">year_labels <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;SID74&quot;</span> <span class="operator">=</span> <span class="string">&quot;1974 - 1978&quot;</span><span class="punctuation">,</span> <span class="string">&quot;SID79&quot;</span> <span class="operator">=</span> <span class="string">&quot;1979 - 1984&quot;</span><span class="punctuation">)</span></span><br><span class="line">nc.32119 <span class="operator">|&gt;</span> select<span class="punctuation">(</span>SID74<span class="punctuation">,</span> SID79<span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">	pivot_longer<span class="punctuation">(</span>starts_with<span class="punctuation">(</span><span class="string">&quot;SID&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">-&gt;</span> nc_longer</span><br><span class="line">ggplot<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">+</span> geom_sf<span class="punctuation">(</span>data <span class="operator">=</span> nc_longer<span class="punctuation">,</span> aes<span class="punctuation">(</span>fill <span class="operator">=</span> value<span class="punctuation">)</span><span class="punctuation">,</span> linewidth <span class="operator">=</span> <span class="number">0.4</span><span class="punctuation">)</span> <span class="operator">+</span> </span><br><span class="line">  facet_wrap<span class="punctuation">(</span><span class="operator">~</span> name<span class="punctuation">,</span> ncol <span class="operator">=</span> <span class="number">1</span><span class="punctuation">,</span> labeller <span class="operator">=</span> labeller<span class="punctuation">(</span>name <span class="operator">=</span> year_labels<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  scale_y_continuous<span class="punctuation">(</span>breaks <span class="operator">=</span> <span class="number">34</span><span class="operator">:</span><span class="number">36</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  scale_fill_gradientn<span class="punctuation">(</span>colors <span class="operator">=</span> sf.colors<span class="punctuation">(</span><span class="number">20</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  theme<span class="punctuation">(</span>panel.grid.major <span class="operator">=</span> element_line<span class="punctuation">(</span>color <span class="operator">=</span> <span class="string">&quot;white&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202310151359633.png" alt="图1.2：1974-78年和1979-84年北卡罗来纳州各县突发性婴儿死亡综合症计数的分面地图"></p>
<p>::: {.content-visible when-format=“html”}</p>
<p>leaflet 交互式地图如下所示。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>mapview<span class="punctuation">)</span> <span class="operator">|&gt;</span> suppressPackageStartupMessages<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line">mapviewOptions<span class="punctuation">(</span>fgb <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">)</span></span><br><span class="line">nc.32119 <span class="operator">|&gt;</span> mapview<span class="punctuation">(</span>zcol <span class="operator">=</span> <span class="string">&quot;BIR74&quot;</span><span class="punctuation">,</span> legend <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> col.regions <span class="operator">=</span> sf.colors<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## PhantomJS未找到。你可以通过`webshot::install_phantomjs()`进行安装。如果已经安装，请确保PhantomJS可执行文件可以通过PATH变量找到。</span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202310151457725.png" alt="图1.3：使用mapview创建的交互式地图：拖动和缩放可移动地图并更改比例；点击一个县将弹出一个窗口，显示可用的县属性。"></p>
<h2 id="坐标参考系">坐标参考系</h2>
<p>在<strong>第一张图</strong>中，灰色线表示<em>经纬网</em>，即沿着恒定的纬度或经度的网格。显然，这些线并不是直的，这表明数据使用了一种$x$和$y$轴与经度和纬度不对齐的<em>投影</em>。在**<em>交互式地图</em>中，我们看到北卡罗来纳州的北界再次被绘制成一条直线，这表明使用了另一种投影。</p>
<p><strong>第一张图</strong>的椭球坐标与特定的<em>基准</em>（这里是：NAD27）关联，这涉及到一组规则，即地球的形状是什么，以及它如何与地球相连接（与地球的哪个点关联的原点，以及如何指向）。如果有人用GPS设备（如手机）测量坐标，它通常会报告与世界大地测量系统1984年（WGS84）基准关联的坐标，与北美大地测量基准1927年（NAD27）关联的相同坐标值相比，可能有约30米的差距。</p>
<p>投影描述了我们如何在以下两者之间来回转换：</p>
<ul>
<li>
<p><strong>椭球坐标</strong>，以经度和纬度的度数表示，指向一个近似于地球形状（椭球或球体）的位置，以及</p>
</li>
<li>
<p><strong>投影坐标</strong>，这是在绘制地图时使用的平面的二维坐标系统。</p>
</li>
</ul>
<p>基准转换与从一个基准转移到另一个基准有关。两个主题都由_空间参考系统_涵盖，并在<strong>坐标系章节</strong>中更详细地描述。</p>
<h2 id="栅格数据和矢量数据">栅格数据和矢量数据</h2>
<p>多边形、点和线几何体是<em>矢量</em>数据的例子：点坐标描述了可以位于任何地方的&quot;精确&quot;位置。另一方面，栅格数据描述了值对齐在一个<em>栅格</em>上，意味着在一个通常是方形像素的规则排列的点阵上。一个例子显示在下图中。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>stars<span class="punctuation">)</span></span><br><span class="line">par<span class="punctuation">(</span>mfrow <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">2</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">par<span class="punctuation">(</span>mar <span class="operator">=</span> <span class="built_in">rep</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">4</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">tif <span class="operator">&lt;-</span> system.file<span class="punctuation">(</span><span class="string">&quot;tif/L7_ETMs.tif&quot;</span><span class="punctuation">,</span> package <span class="operator">=</span> <span class="string">&quot;stars&quot;</span><span class="punctuation">)</span></span><br><span class="line">x <span class="operator">&lt;-</span> read_stars<span class="punctuation">(</span>tif<span class="punctuation">)</span><span class="punctuation">[</span><span class="punctuation">,</span><span class="punctuation">,</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">]</span></span><br><span class="line">image<span class="punctuation">(</span>x<span class="punctuation">,</span> main <span class="operator">=</span> <span class="string">&quot;(a)&quot;</span><span class="punctuation">)</span></span><br><span class="line">image<span class="punctuation">(</span>x<span class="punctuation">[</span><span class="punctuation">,</span><span class="number">1</span><span class="operator">:</span><span class="number">10</span><span class="punctuation">,</span><span class="number">1</span><span class="operator">:</span><span class="number">10</span><span class="punctuation">]</span><span class="punctuation">,</span> text_values <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> border <span class="operator">=</span> <span class="string">&#x27;grey&#x27;</span><span class="punctuation">,</span> main <span class="operator">=</span> <span class="string">&quot;(b)&quot;</span><span class="punctuation">)</span></span><br><span class="line">image<span class="punctuation">(</span>x<span class="punctuation">,</span> main <span class="operator">=</span> <span class="string">&quot;(c)&quot;</span><span class="punctuation">)</span></span><br><span class="line">set.seed<span class="punctuation">(</span><span class="number">131</span><span class="punctuation">)</span></span><br><span class="line">pts <span class="operator">&lt;-</span> st_sample<span class="punctuation">(</span>st_as_sfc<span class="punctuation">(</span>st_bbox<span class="punctuation">(</span>x<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">)</span></span><br><span class="line">plot<span class="punctuation">(</span>pts<span class="punctuation">,</span> add <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> pch <span class="operator">=</span> <span class="number">3</span><span class="punctuation">,</span> col <span class="operator">=</span> <span class="string">&#x27;blue&#x27;</span><span class="punctuation">)</span></span><br><span class="line">image<span class="punctuation">(</span>x<span class="punctuation">,</span> main <span class="operator">=</span> <span class="string">&quot;(d)&quot;</span><span class="punctuation">)</span></span><br><span class="line">plot<span class="punctuation">(</span>st_buffer<span class="punctuation">(</span>pts<span class="punctuation">,</span> <span class="number">500</span><span class="punctuation">)</span><span class="punctuation">,</span> add <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> pch <span class="operator">=</span> <span class="number">3</span><span class="punctuation">,</span> border <span class="operator">=</span> <span class="string">&#x27;blue&#x27;</span><span class="punctuation">,</span> col <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">,</span> lwd <span class="operator">=</span> <span class="number">2</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202310151417019.png" alt="图1.4：巴西大西洋海岸Olinda的栅格地图：Landsat-7蓝色波段，颜色值来源于数据值（a），来自（a）的左上角$10 imes 10$子图像，显示数值（b），并由两种不同类型的矢量数据叠加：三个样本点（c），以及以点为中心的500米半径的多边形（d）"></p>
<p>矢量和栅格数据可以以不同的方式组合；例如，我们可以在上图©的三个点处查询栅格，或者计算一个聚合值，比如在上图(d)中显示的圆形区域内的平均值。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">st_extract<span class="punctuation">(</span>x<span class="punctuation">,</span> pts<span class="punctuation">)</span> <span class="comment"># query at points</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## Simple feature collection with 3 features and 1 field</span><br><span class="line">## Geometry type: POINT</span><br><span class="line">## Dimension:     XY</span><br><span class="line">## Bounding box:  xmin: 290019 ymin: 9114499 xmax: 291693.3 ymax: 9119219</span><br><span class="line">## Projected CRS: SIRGAS 2000 / UTM zone 25S</span><br><span class="line">##   L7_ETMs.tif                 geometry</span><br><span class="line">## 1          80 POINT (290829.6 9114499)</span><br><span class="line">## 2          58   POINT (290019 9119219)</span><br><span class="line">## 3          63 POINT (291693.3 9116038)</span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">aggregate<span class="punctuation">(</span>x<span class="punctuation">,</span> st_buffer<span class="punctuation">(</span>pts<span class="punctuation">,</span> <span class="number">500</span><span class="punctuation">)</span><span class="punctuation">,</span> FUN <span class="operator">=</span> mean<span class="punctuation">)</span> <span class="operator">|&gt;</span> st_as_sf<span class="punctuation">(</span><span class="punctuation">)</span> <span class="comment"># aggregate over circles</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## Simple feature collection with 3 features and 1 field</span><br><span class="line">## Geometry type: POLYGON</span><br><span class="line">## Dimension:     XY</span><br><span class="line">## Bounding box:  xmin: 289519 ymin: 9113999 xmax: 292193.3 ymax: 9119719</span><br><span class="line">## Projected CRS: SIRGAS 2000 / UTM zone 25S</span><br><span class="line">##         V1                       geometry</span><br><span class="line">## 1 77.18201 POLYGON ((291329.6 9114499,...</span><br><span class="line">## 2 60.12603 POLYGON ((290519 9119219, 2...</span><br><span class="line">## 3 71.57808 POLYGON ((292193.3 9116038,...</span><br></pre></td></tr></table></figure>
<p>在<strong>栅格矢量转化</strong>中讨论了其他栅格到矢量的转换，包括：</p>
<ul>
<li>将栅格像素转换为点值</li>
<li>将栅格像素转换为小多边形，可能合并具有相同值的多边形（“多边形化”）</li>
<li>生成描绘具有某一值<em>范围</em>的连续像素区域的线或多边形（“等高线”）</li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">plot<span class="punctuation">(</span>st_rasterize<span class="punctuation">(</span>nc<span class="punctuation">[</span><span class="string">&quot;BIR74&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span> dx <span class="operator">=</span> <span class="number">0.1</span><span class="punctuation">)</span><span class="punctuation">,</span> col <span class="operator">=</span> sf.colors<span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">,</span> breaks <span class="operator">=</span> <span class="string">&quot;equal&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202310151425334.png" alt="图1.5：通过栅格化1974-1978年期间县出生计数而获得的地图，显示在1.1中"></p>
<p>矢量到栅格的转换可以像栅格化多边形一样简单，如上图所示。其他更一般的涉及统计建模的矢量到栅格转换包括：</p>
<ul>
<li>将点值插值到规则网格上的点（<strong>空间差值章节</strong>）</li>
<li>估计规则网格上点的密度（<strong>点格局分析章节</strong>）</li>
<li>将多边形值通过面积加权插值到网格单元（<strong>面积加权差值</strong>）</li>
<li>点、线或多边形的直接栅格化（<strong>栅格矢量转化</strong>）</li>
</ul>
<h2 id="栅格类型">栅格类型</h2>
<p>栅格维度描述了行和列如何与空间坐标相关联。下图展示了几种不同的可能性。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">x <span class="operator">&lt;-</span> 1<span class="operator">:</span><span class="number">5</span></span><br><span class="line">y <span class="operator">&lt;-</span> 1<span class="operator">:</span><span class="number">4</span></span><br><span class="line">d <span class="operator">&lt;-</span> st_dimensions<span class="punctuation">(</span>x <span class="operator">=</span> x<span class="punctuation">,</span> y <span class="operator">=</span> y<span class="punctuation">,</span> .raster <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;x&quot;</span><span class="punctuation">,</span> <span class="string">&quot;y&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">m <span class="operator">&lt;-</span> matrix<span class="punctuation">(</span>runif<span class="punctuation">(</span><span class="number">20</span><span class="punctuation">)</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">)</span></span><br><span class="line">r1 <span class="operator">&lt;-</span> st_as_stars<span class="punctuation">(</span>r <span class="operator">=</span> m<span class="punctuation">,</span> dimensions <span class="operator">=</span> d<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">r <span class="operator">&lt;-</span> <span class="built_in">attr</span><span class="punctuation">(</span>d<span class="punctuation">,</span> <span class="string">&quot;raster&quot;</span><span class="punctuation">)</span></span><br><span class="line">r<span class="operator">$</span>affine <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0.2</span><span class="punctuation">,</span> <span class="operator">-</span><span class="number">0.2</span><span class="punctuation">)</span></span><br><span class="line"><span class="built_in">attr</span><span class="punctuation">(</span>d<span class="punctuation">,</span> <span class="string">&quot;raster&quot;</span><span class="punctuation">)</span> <span class="operator">=</span> r</span><br><span class="line">r2 <span class="operator">&lt;-</span> st_as_stars<span class="punctuation">(</span>r <span class="operator">=</span> m<span class="punctuation">,</span> dimensions <span class="operator">=</span> d<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">r <span class="operator">&lt;-</span> <span class="built_in">attr</span><span class="punctuation">(</span>d<span class="punctuation">,</span> <span class="string">&quot;raster&quot;</span><span class="punctuation">)</span></span><br><span class="line">r<span class="operator">$</span>affine <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0.1</span><span class="punctuation">,</span> <span class="operator">-</span><span class="number">0.3</span><span class="punctuation">)</span></span><br><span class="line"><span class="built_in">attr</span><span class="punctuation">(</span>d<span class="punctuation">,</span> <span class="string">&quot;raster&quot;</span><span class="punctuation">)</span> <span class="operator">=</span> r</span><br><span class="line">r3 <span class="operator">=</span> st_as_stars<span class="punctuation">(</span>r <span class="operator">=</span> m<span class="punctuation">,</span> dimensions <span class="operator">=</span> d<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">x <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">,</span> <span class="number">3.5</span><span class="punctuation">,</span> <span class="number">5</span><span class="punctuation">,</span> <span class="number">6</span><span class="punctuation">)</span></span><br><span class="line">y <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">1.5</span><span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">,</span> <span class="number">3.5</span><span class="punctuation">)</span></span><br><span class="line">d <span class="operator">&lt;-</span> st_dimensions<span class="punctuation">(</span>x <span class="operator">=</span> x<span class="punctuation">,</span> y <span class="operator">=</span> y<span class="punctuation">,</span> .raster <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;x&quot;</span><span class="punctuation">,</span> <span class="string">&quot;y&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">r4 <span class="operator">&lt;-</span> st_as_stars<span class="punctuation">(</span>r <span class="operator">=</span> m<span class="punctuation">,</span> dimensions <span class="operator">=</span> d<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">grd <span class="operator">&lt;-</span> st_make_grid<span class="punctuation">(</span>cellsize <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">10</span><span class="punctuation">,</span><span class="number">10</span><span class="punctuation">)</span><span class="punctuation">,</span> offset <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="operator">-</span><span class="number">130</span><span class="punctuation">,</span><span class="number">10</span><span class="punctuation">)</span><span class="punctuation">,</span> n <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">8</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">)</span><span class="punctuation">,</span> crs <span class="operator">=</span> st_crs<span class="punctuation">(</span><span class="string">&#x27;OGC:CRS84&#x27;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">r5 <span class="operator">&lt;-</span> st_transform<span class="punctuation">(</span>grd<span class="punctuation">,</span> <span class="string">&quot;+proj=laea +lon_0=-70 +lat_0=35&quot;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">par<span class="punctuation">(</span>mfrow <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">)</span><span class="punctuation">,</span> mar <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0.1</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">1.1</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">r1 <span class="operator">&lt;-</span> st_make_grid<span class="punctuation">(</span>cellsize <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">)</span><span class="punctuation">,</span> n <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">5</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">)</span><span class="punctuation">,</span> offset <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">plot<span class="punctuation">(</span>r1<span class="punctuation">,</span> main <span class="operator">=</span> <span class="string">&quot;regular&quot;</span><span class="punctuation">)</span></span><br><span class="line">plot<span class="punctuation">(</span>st_geometry<span class="punctuation">(</span>st_as_sf<span class="punctuation">(</span>r2<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span> main <span class="operator">=</span> <span class="string">&quot;rotated&quot;</span><span class="punctuation">)</span></span><br><span class="line">plot<span class="punctuation">(</span>st_geometry<span class="punctuation">(</span>st_as_sf<span class="punctuation">(</span>r3<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span> main <span class="operator">=</span> <span class="string">&quot;sheared&quot;</span><span class="punctuation">)</span></span><br><span class="line">plot<span class="punctuation">(</span>st_geometry<span class="punctuation">(</span>st_as_sf<span class="punctuation">(</span>r4<span class="punctuation">,</span> as_points <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span> main <span class="operator">=</span> <span class="string">&quot;rectilinear&quot;</span><span class="punctuation">)</span></span><br><span class="line">plot<span class="punctuation">(</span>st_geometry<span class="punctuation">(</span><span class="punctuation">(</span>r5<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span> main <span class="operator">=</span> <span class="string">&quot;curvilinear&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202310151430509.png" alt="图1.6：多种栅格几何类型"></p>
<p>像上图中展示的规则栅格具有恒定的、不一定是正方形的单元格大小，以及与$x$和$y$（东经和北纬）轴对齐。其他类型的栅格包括那些轴不再与$x$和$y$对齐（<em>旋转</em>）、轴不再垂直（<em>倾斜</em>）或者单元格大小沿一个维度变化（<em>矩形</em>）的情况。最后，<em>曲线</em>栅格具有单元格大小或方向属性，这些属性不再独立于其他栅格维度。</p>
<p>当一个在给定坐标参考系统中是规则的栅格投影到另一个栅格上，同时保持每个栅格单元格完好无损时，它会改变形状，并可能变成矩形（例如，从椭球坐标到墨卡托投影，如<strong>图3</strong>所示）或曲线（例如，从椭球坐标到兰伯特圆锥保角投影，如在<strong>图1</strong>中使用）。当撤销这一过程时，人们可以恢复到精确的原始栅格。</p>
<p>在新的投影中创建一个新的、规则的网格被称为栅格（或图像）<em>重新投影</em>或者<em>扭曲</em>（<strong>变换和扭曲栅格</strong>）。扭曲是有损的、不可逆的，并且需要指明是否应对栅格单元格进行插值、平均或求和，或者是否应使用最近邻居进行重新采样。对于这种选择，单元格值是反映分类变量还是连续变量是有关系的（另见<strong>支持章节</strong>）。</p>
<h2 id="时间序列、数组、数据立方体">时间序列、数组、数据立方体</h2>
<p>许多空间数据不仅仅是空间性的，还具有时间性。就像任何观察都与一个观察地点相关，同样也与一个观察时间或周期相关。上面显示的关于北卡罗来纳州各县的数据集包含了在两个时间段内计数的疾病案例（如<strong>图2</strong>所示）。尽管原始数据集中的这些变量分布在两个不同的列中，但为了绘制它们，这些列首先必须被堆叠起来，同时重复关联的几何形状——这种形式被称为<em>整洁（tidy）</em>。当我们有与几何形状关联的更长的时间序列时，两种选项——在多个列上分布时间，或者在重复几何形状的同时堆叠列——都不是很理想，更有效的存储这种数据的方式将是一个矩阵或数组，其中一个维度指代时间，其他维度指代空间。对于图像或栅格数据来说，自然的存储方式已经是矩阵；然后，栅格的时间序列会导致一个三维数组。这种数据的一般术语是（时空的）<strong>数据立方体（data cube）</strong>，其中立方体指代具有任意数量维度的数组。数据立方体可以指代栅格和矢量数据，例子在<strong>数据立方体章节</strong>中给出。</p>
<h2 id="支持">支持</h2>
<p>当我们拥有的空间数据的几何形状不是点，而是点的集合（多点、线、多边形、像素）时，与这些几何形状关联的属性可能有几种不同的关系。一个属性可以具有：</p>
<ul>
<li>几何形状每个点的<strong>常量</strong>值</li>
<li>几何形状所有点的**汇总（aggregate）**单一值</li>
<li>仅用于描述此几何形状<strong>身份</strong>的唯一值</li>
</ul>
<p>一个常量的例子是多边形的土地利用或基岩类型。汇总的一个例子是在给定时间段内某个县的出生人数。身份的一个例子是县的名称。</p>
<p>属性值所指的空间区域被称为其<strong>支持（support）</strong>：汇总属性具有“块”（或区域、或线）支持，常数属性具有“点”支持（它们适用于每个点）。在操作数据时，支持很重要。例如，<strong>图5</strong>源自具有多边形支持的变量：每个县的出生人数。栅格化这些值会得到仍与各县相关联的像素值。栅格化的结果是一个无意义的地图：数值值（“出生总数”）与栅格单元格没有关联，县界也不再存在。全州的出生总数或出生密度无法从像素值中恢复。忽略支持很容易导致无意义的结果。<strong>属性和支持章节</strong>进一步讨论了这一点。</p>
<p>栅格单元格值可能具有点支持或块支持。点支持的一个例子是高程，当单元格在数字高程模型中记录单元格中心点的高程时。块（或单元格）支持的一个例子是卫星图像像素，该像素给出了（与像素相似区域的）平均颜色值。大多数文件格式并不提供这种信息，但在聚合、重新网格化或扭曲栅格，提取点位置的值时，了解这一点可能很重要。</p>
<h2 id="空间数据科学软件">空间数据科学软件</h2>
<p>Although this book largely uses R and R packages for spatial data<br>
science, a number of these packages use software libraries that were<br>
not developed for R specifically.  As an example, the dependency<br>
of R package <strong>sf</strong> on other R packages and system libraries is shown<br>
in @fig-gdal-fig-nodetails.</p>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202310151447368.png" alt="图1.7：sf 包及其依赖；箭头表示强依赖，虚线箭头表示弱依赖。"></p>
<p>使用的C或C++库（GDAL、GEOS、PROJ、liblwgeom、s2geometry、NetCDF、udunits2）都是由（空间）数据科学社群开发、维护和使用的，这些社群大都与R社群不同。通过使用这些库，R用户与这些其他社群共享我们对所做工作的理解。因为R、Python和Julia为这些软件提供交互式接口，许多用户比使用基于这些库的其他软件的用户更接近这些库。本书的第一部分描述了这些库中实现的许多概念，这些概念对空间数据科学有一般的相关性。</p>
<h3 id="GDAL">GDAL</h3>
<p>GDAL（地理空间数据抽象库）可以看作是空间数据的瑞士军刀；除了在R中使用外，还用于Python、QGIS、PostGIS以及100多个<a href="https://gdal.org/software_using_gdal.html">其他软件项目</a>。</p>
<p>GDAL是一个“库中的库”——为了读取和写入这些数据，它需要大量的其他库。它通常链接到超过100个其他库，每个库可能提供对特定数据文件格式、数据库、网络服务或特定压缩编解码器的访问。</p>
<p>由CRAN分发的二进制R包仅包含静态链接的代码：CRAN不想对主机系统上第三方库的存在做任何假设。因此，当从CRAN以二进制形式安装<code>sf</code>包时，它包括所有所需的外部库以及它们的依赖项，总量可能达到100 Mb。</p>
<h3 id="PROJ">PROJ</h3>
<p>PROJ（或PR$\phi$J）是一个用于地图投影和基准转换的库：它将空间坐标从一个坐标参考系统转换到另一个坐标参考系统。它配备了大量已知投影的数据库，并可访问基准网格（用于基准转换的高精度、预先计算的值）。它符合坐标参考系统的国际标准。<strong>坐标系章节</strong>处理坐标系统和PROJ。</p>
<h3 id="GEOS-and-s2geometry">GEOS and s2geometry</h3>
<p>GEOS（Geometry Engine Open Source）和s2geometry是两个用于几何操作的库。它们用于找到测量值（长度、面积、距离），并计算谓词（两个几何体是否有任何共同点？）或新几何体（这两个几何体有哪些共同点？）。GEOS针对的是平面的二维空间（由$R^2$表示），而s2geometry针对的是球面上的几何体（由$S^2$表示）。@sec-cs介绍了坐标参考系统，而<strong>球状几何章节</strong>更多地讨论了在这两个空间中工作的区别。</p>
<h3 id="NetCDF-udunits2-liblwgeom">NetCDF, udunits2, liblwgeom</h3>
<p>NetCDF 既指一种文件格式，也指用于读取和写入NetCDF文件的C库。它允许定义任何维度的数组，并广泛用于空间和时空信息，特别是在（气候）建模社群中。Udunits2 是一个单位测量的数据库和软件库，允许单位转换，处理派生单位，并支持用户定义的单位。liblwgeom“库”是PostGIS 的一个软件组件，其中包含了GDAL或GEOS缺失的若干例程，包括方便地访问随PROJ一同提供的GeographicLib例程。</p>
<h2 id="练习">练习</h2>
<ol>
<li>
<p>列举五个raster（栅格）和vector（矢量）数据之间的差异：</p>
</li>
<li>
<p>除了<strong>图1</strong>下面列出的以外，常见于地图上的五个其他图形组件：</p>
</li>
<li>
<p>为什么在<strong>图5</strong>中显示的数字信息是误导性的（或无意义的）：</p>
</li>
<li>
<p>在哪些情况下，你期望在进行$S^2$上的几何操作时与在$R^2$上进行它们时有很大的不同？</p>
</li>
</ol>
]]></content>
      <categories>
        <category>R</category>
        <category>Spatial Data Science</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>Spatial Data Science</tag>
      </tags>
  </entry>
  <entry>
    <title>(20)一元线性回归及显著性检验（Slope趋势分析）</title>
    <url>/2023/10/05/2023-10-5-20%E4%B8%80%E5%85%83%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/</url>
    <content><![CDATA[<blockquote><p>本文由SCY原创，转载注明出处。</p>
</blockquote>
<h1>时间序列趋势分析</h1>
<p>时序趋势分析是一种重要的统计技术，用于分析随时间变化的数据模式。以下是一些常用的时序趋势分析方法：</p>
<ul>
<li>
<p><strong>线性和非线性趋势分析</strong>：</p>
<p>通过线性回归或非线性回归模型，可以估计时间序列数据的趋势。例如，<em>一元线性回归</em>可以用来估计线性趋势，而多项式回归或指数回归可以用来估计非线性趋势。</p>
</li>
<li>
<p><strong>季节分解（Seasonal Decomposition）</strong>：</p>
<p>季节分解可以分离出时序数据中的趋势、季节性和随机组成部分。例如，可以使用STL（Seasonal and Trend decomposition using Loess）或季节分解的经典方法。</p>
</li>
<li>
<p><strong>时间序列平滑（Time Series Smoothing）</strong>：</p>
<p>时间序列平滑方法，如移动平均和指数平滑，可以用来估计时间序列数据的趋势。</p>
</li>
<li>
<p><strong>自相关和偏自相关分析（Autocorrelation and Partial Autocorrelation Analysis）</strong>：</p>
<p>通过计算时间序列数据的自相关和偏自相关函数，可以识别数据中的循环模式和趋势。</p>
</li>
<li>
<p><strong>时间序列分解（Time Series Decomposition）</strong>：</p>
<p>将时间序列分解为趋势、周期和随机噪声组件，通常使用模型如X-12-ARIMA或其变体。</p>
</li>
<li>
<p><strong>时间序列模型（Time Series Modeling）</strong>：</p>
<p>ARIMA（自回归整合移动平均模型）、ETS（错误、趋势、季节性模型）和状态空间模型等可以用于分析时间序列的趋势和周期性。</p>
</li>
<li>
<p><strong>波段分析（Wavelet Analysis）</strong>：</p>
<p>波段分析可以在不同的时间尺度上识别时序数据的趋势和周期性。</p>
</li>
<li>
<p><strong>Mann-Kendall趋势检验和Sen的斜率估计</strong>：</p>
<p>这些非参数方法用于检测时间序列数据的趋势并估计变化的速度。</p>
</li>
<li>
<p><strong>突变点分析（Changepoint Analysis）</strong>：</p>
<p>用于识别时间序列数据中的结构变化，例如趋势的改变或方差的改变。</p>
</li>
<li>
<p><strong>谱分析（Spectral Analysis）</strong>：</p>
<p>通过分析时序数据的频率域特性来识别周期性和趋势。</p>
</li>
</ul>
<h1>一元线性回归和Mann-Kendall检验</h1>
<p>本文重点介绍<strong>一元线性回归</strong>和<strong>Mann-Kendall检验</strong>的原理和R语言实现步骤，以1980——2020年的降雨数据为例。</p>
<p>一元线性回归和Mann-Kendall检验是分析时间序列趋势的两种不同方法，它们各自有其特点和适用场景。下面是对它们的比较和联系的说明：</p>
<ol>
<li><strong>基本原理</strong>：</li>
</ol>
<p><strong>一元线性回归</strong>是基于参数的统计方法，它假设数据之间存在线性关系，并试图找到描述这种关系的线性方程。它提供了估计的斜率和截距，以及相关的统计测试，以评估这种关系的显著性和强度。</p>
<p><strong>Mann-Kendall检验</strong>是一种非参数的统计方法，用于检测时间序列数据中的单调趋势，而不假设数据之间的特定关系。它基于数据的秩次，而不是数据的实际值。</p>
<ol start="2">
<li><strong>假设</strong>：</li>
</ol>
<p><strong>一元线性回归</strong>通常需要满足一些基本假设，例如误差的<em>正态性</em>和<em>独立性</em>，以及数据的<em>线性关系</em>。当数据不满足这些假设时，线性回归的结果可能会受到影响。</p>
<p><strong>Mann-Kendall检验</strong>作为非参数检验，不需要数据满足<em>正态分布</em>或其他分布假设，因此它对<em>异常值</em>和<em>非正态</em>数据更具<strong>鲁棒性</strong>。</p>
<ol start="3">
<li><strong>输出</strong>：</li>
</ol>
<p><strong>一元线性回归</strong>提供了详细的模型参数（例如斜率和截距）和预测值，同时也提供了模型的显著性检验结果。</p>
<p><strong>Mann-Kendall检验</strong>主要提供了趋势的显著性检验结果，但不提供具体的模型参数或预测值。</p>
<ol start="4">
<li><strong>适用场景</strong>：</li>
</ol>
<p>当数据具有明确的线性关系，并且满足线性回归的基本假设时，<strong>一元线性回归</strong>是一个很好的选择。</p>
<p>当数据可能有单调趋势，但不一定是线性的，或者当数据可能包含异常值或不满足正态分布假设时，<strong>Mann-Kendall检验</strong>可能是一个更好的选择。</p>
<ol start="5">
<li><strong>联系</strong>：</li>
</ol>
<p>两者都可以用于分析时间序列数据中的趋势，但方法和假设有很大的不同。</p>
<p>在某些情况下，它们可以互补使用。例如，可以首先使用<strong>Mann-Kendall检验</strong>来确定是否存在显著的趋势，然后使用一元线性回归来估计趋势的具体参数。</p>
<ol start="6">
<li><strong>扩展</strong>：</li>
</ol>
<p><strong>Mann-Kendall检验</strong>可以与<strong>Sen的斜率估计</strong>结合使用，以提供趋势的斜率估计，这在一定程度上类似于一元线性回归提供的斜率估计。</p>
<h1>一元线性回归</h1>
<p>一元线性回归用于研究一个变量（自变量）如何线性影响另一个变量（因变量）。以下是一元线性回归的基本原理和步骤：</p>
<h2 id="数学模型："><strong>数学模型</strong>：</h2>
<p>一元线性回归假设两个变量之间存在线性关系，可以用下面的方程式表示：<br>
$$ Y = \beta_0 + \beta_1X + \varepsilon $$</p>
<p>其中：</p>
<ul>
<li>( Y ) 是因变量的值，</li>
<li>( X ) 是自变量的值，</li>
<li>( $\beta_0$ ) 是截距项，</li>
<li>( $\beta_1$ ) 是斜率项，</li>
<li>( $\varepsilon$ ) 是误差项。</li>
</ul>
<h2 id="参数估计："><strong>参数估计</strong>：</h2>
<p>一元线性回归的目标是找到最佳的 ( $\beta_0$ ) 和 ( $\beta_1$ )，使得模型的预测值与实际值的差异（误差平方和，$SSE$）最小。这通常通过最小二乘法（OLS）实现，它的基本思想是最小化所有观测值的残差平方和，即：<br>
$$SSE = \sum_{i=1}^n (Y_i - (\beta_0 + \beta_1X_i))^2 $$</p>
<p>通过对 $SSE$ 关于 $\beta_0$ 和 $\beta_1$ 的偏导数并令其为零，可以解得 $\beta_0$ 和 $\beta_1$ 的估计值。</p>
<h2 id="显著性检验："><strong>显著性检验</strong>：</h2>
<p>一旦得到了 $\beta_0$ 和 $\beta_1$ 的估计值，通常会进行假设检验来评估这些参数是否显著不为零。这涉及到计算$t$统计量和对应的$p$值。如果$p$值低于某个预定的显著性水平（通常为0.05），则认为参数是显著的。</p>
<h2 id="模型评估："><strong>模型评估</strong>：</h2>
<p>模型评估通常包括计算 $R^2$ （决定系数）和调整 $R^2$，以评估模型对数据的拟合程度。$R^2$ 表示模型解释的数据变异的比例。</p>
<h2 id="预测："><strong>预测</strong>：</h2>
<p>使用得到的 $\beta_0$ 和 $\beta_1$ 估计值，可以对新的 $X$ 值做预测，并计算预测区间，以估计预测的不确定性。</p>
<h2 id="模型诊断："><strong>模型诊断</strong>：</h2>
<p>模型诊断是检查模型是否满足回归分析的基本假设，例如误差的正态性、独立性和方差齐性。这可以通过残差图、正态概率图和其他诊断图来完成。</p>
<h2 id="案例分析">案例分析</h2>
<h1>Mann-Kendall检验和Sen斜率估计</h1>
<p>Mann-Kendall（MK）检验和Sen的斜率估计是两种常用的非参数方法，用于分析时间序列数据中的趋势。下面是它们的基本原理介绍：</p>
<h2 id="Mann-Kendall检验：">Mann-Kendall检验：</h2>
<p>Mann-Kendall检验是一种非参数检验，用于确定一个数据序列中是否存在单调的趋势。它不需要数据满足特定的分布假设，因此对于非正态分布的数据很有用。MK检验的基本步骤如下：</p>
<ol>
<li>
<p>对于序列中的每一对数据点($x_i$, $x_j$)，计算符号统计量 ($S$)：<br>
$$S = \sum_{i=1}^{n-1} \sum_{j=i+1}^n \text{sign}(x_j - x_i)$$<br>
其中$\text{sign}(x_j - x_i)$是符号函数，如果 $x_j$ &gt; $x_i$ 则值为 +1，如果 $x_j$ &lt; $x_i$ 则值为 -1，如果 $x_j$ = $x_i$ 则值为 0。</p>
</li>
<li>
<p>计算检验统计量 $U$ 和对应的 $p$ 值以判断趋势是否显著。</p>
</li>
</ol>
<h2 id="Sen的斜率估计：">Sen的斜率估计：</h2>
<p>Sen的斜率估计是一种非参数方法，用于估计数据序列中的趋势斜率。它通过计算所有可能的数据点对之间的斜率，然后取这些斜率的<em>中位数</em>作为趋势斜率的估计。Sen的斜率估计的基本步骤如下：</p>
<ol>
<li>
<p>对于序列中的每一对数据点$(x_i, y_i)$ 和 $(x_j, y_j)$，计算斜率：<br>
$$d_k = \frac{(y_j - y_i)}{(x_j - x_i)}$$<br>
其中 $1 \leq i &lt; j \leq n$。</p>
</li>
<li>
<p>从所有计算得到的斜率 $d_k$ 中，取中位数作为Sen的斜率估计：<br>
$$b_{\text{Sen}} = \text{median}(d_k)$$<br>
Sen的斜率估计可以提供一个关于时间序列数据趋势的稳健（对异常值不敏感）的估计，而Mann-Kendall检验可以提供这种趋势是否显著的证据。通常，这两种方法可以结合使用，以提供对数据趋势的全面理解。在时间序列趋势分析中，MK检验通常用于检测趋势的显著性，而Sen的斜率估计用于量化趋势的大小。</p>
</li>
</ol>
<h2 id="案例分析-2">案例分析</h2>
]]></content>
      <categories>
        <category>R</category>
        <category>Statistic</category>
        <category>Regression</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>Statistic</tag>
        <tag>Regression</tag>
      </tags>
  </entry>
  <entry>
    <title>(1)引言</title>
    <url>/2023/08/10/2023-8-10-1%E5%BC%95%E8%A8%80/</url>
    <content><![CDATA[<blockquote><p>本文由SCY翻译自《Geocomputation with R》<a href="https://r.geocompx.org/intro#intro">第一章</a></p>
</blockquote>
<p>这本书是关于使用计算机的力量来处理地理数据的。它教授一系列的空间技能，包括：读、写和操作地理数据；制作静态和交互式地图；应用地理计算解决现实问题；并对地理现象进行建模。通过展示各种地理操作是如何联系在一起的，在穿插的可复制&quot;代码块&quot;中，本书还教授了一个透明而科学的工作流程。学习如何使用R命令行提供的丰富的地理空间工具令人兴奋，但创建新的工具可以真正解放。使用贯穿始终的命令行驱动方法，以及章节所涵盖的编程技术，可以帮助消除软件对您的创造力施加的限制。在读完这本书和完成练习后，你应该对R令人印象深刻的地理能力所开辟的可能性有很强的理解，用地理数据解决现实世界问题的新技能，以及用地图和可复制的代码来交流你的工作的能力。</p>
<span id="more"></span>
<h1>引言</h1>
<p>这本书是关于使用计算机的力量来处理地理数据的。它教授一系列的空间技能，包括：读、写和操作地理数据；制作静态和交互式地图；应用地理计算解决现实问题；并对地理现象进行建模。通过展示各种地理操作是如何联系在一起的，在穿插的可复制&quot;代码块&quot;中，本书还教授了一个透明而科学的工作流程。学习如何使用R命令行提供的丰富的地理空间工具令人兴奋，但创建新的工具可以真正解放。使用贯穿始终的命令行驱动方法，以及<a href="/2023/08/20/2023-8-20-11%E8%84%9A%E6%9C%AC%E3%80%81%E7%AE%97%E6%B3%95%E5%92%8C%E5%87%BD%E6%95%B0/" title="(11)脚本、算法和函数">11</a>章节所涵盖的编程技术，可以帮助消除软件对您的创造力施加的限制。在读完这本书和完成练习后，你应该对R令人印象深刻的地理能力所开辟的可能性有很强的理解，用地理数据解决现实世界问题的新技能，以及用地图和可复制的代码来交流你的工作的能力。</p>
<p>在过去的几十年中，自由和开源的地理空间软件（FOSS4G）以惊人的速度发展。得益于OSGeo等组织，地理数据分析不再是拥有昂贵硬件和软件的人的专利，现在任何人都可以下载和运行高性能的空间库。开源地理信息系统(GIS)，如 <a href="http://qgis.org/en/site/">QGIS</a>，使地理分析在全球范围内变得可访问。GIS程序倾向于强调图形用户界面(GUIs)，但是阻碍可重复性(尽管许多可以从命令行中使用，正如我们在第<a href="/2023/08/19/2023-8-19-10%E8%BF%9E%E6%8E%A5%E5%88%B0GIS%E8%BD%AF%E4%BB%B6%E7%9A%84%E6%A1%A5%E6%A2%81/" title="(10)连接到GIS的桥梁">10</a>章中看到的那样)。而R则强调命令行界面(CLI)。不同方法之间的简单比较见表1.1。</p>
<p>表1.1: 不同软件包（地理信息系统（GIS）的图形用户界面（GUI）和R语言）之间的重点差异。</p>
<table>
<thead>
<tr>
<th style="text-align:left">Attribute</th>
<th style="text-align:left">Desktop GIS (GUI)</th>
<th style="text-align:left">R</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Home disciplines</td>
<td style="text-align:left">Geography</td>
<td style="text-align:left">Computing, Statistics</td>
</tr>
<tr>
<td style="text-align:left">Software focus</td>
<td style="text-align:left">Graphical User Interface</td>
<td style="text-align:left">Command line</td>
</tr>
<tr>
<td style="text-align:left">Reproducibility</td>
<td style="text-align:left">Minimal</td>
<td style="text-align:left">Maximal</td>
</tr>
</tbody>
</table>
<p>编撰本书的动力源于科学研究的可重复的重要性（见下面的注释）。它旨在使可重复的地理数据分析工作流更易于访问，并展示从命令行可用的开源地理空间软件的力量。“其他软件的接口是R的一部分”。这意味着除了出色的“内部”功能外，R还允许访问其他许多空间软件库，这在第<a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9r%E8%BF%9B%E8%A1%8C%E5%9C%B0%E7%90%86%E8%AE%A1%E7%AE%97">1.2</a>节中有解释，在第<a href="/2023/08/19/2023-8-19-10%E8%BF%9E%E6%8E%A5%E5%88%B0GIS%E8%BD%AF%E4%BB%B6%E7%9A%84%E6%A1%A5%E6%A2%81/" title="(10)连接到GIS的桥梁">10</a>章中有示例。然而，在深入软件的细节之前，值得先退一步思考我们所说的地理计算是什么意思。</p>
<blockquote>
<p>📌可重复性是命令行界面的一大优势，但实际上它意味着什么？<br>
我们将其定义为：“一个通过使用公开可访问的代码，能够由其他人生成相同结果的过程。”<br>
这听起来可能很简单，也容易实现（如果你仔细地维护你的R代码脚本文件的话），但对于教学和科学过程有着深远的影响。</p>
</blockquote>
<h2 id="什么是地理计算？">什么是地理计算？</h2>
<!--rl-->
<p>地理计算是一个年轻的术语，可以追溯到1996年该主题的第一次会议<a href="%E8%AF%A5%E4%BC%9A%E8%AE%AE%E5%9C%A8%E5%88%A9%E5%85%B9%E5%A4%A7%E5%AD%A6%E4%B8%BE%E8%A1%8C%EF%BC%8C%E5%85%B6%E4%B8%AD%E4%B8%80%E4%BD%8D%E4%BD%9C%E8%80%85%EF%BC%88Robin%EF%BC%89%E7%9B%AE%E5%89%8D%E5%B0%B1%E8%81%8C%E4%BA%8E%E6%AD%A4%E3%80%82">^01-introduction-1</a>。与当时常用术语’量化地理学’不同，其早期倡导者提出，地理计算强调的是&quot;富有创意和实验性&quot;的应用和新工具和方法的开发。 “地理计算是关于使用各种不同类型的地理数据，并在’科学’方法的总体背景下开发相关的地理工具。” 本书的目标不仅是教授方法和代码；在本书结束时，你应该能够使用你的地理计算技能，做出&quot;有益或有用的实际工作&quot;。</p>
<p>第21届地理计算会议也在利兹大学举行，期间Robin和Jakub进行了演讲，主持了一个关于’tidy’空间数据分析的研讨会，并在书中进行了合作（更多关于会议系列和跨越两个世纪的论文/演示，<a href="http://xn--www-7n0j5iy14c.geocomputation.org">请访问www.geocomputation.org</a>）。</p>
<p>我们的方法与早期采用者如Stan Openshaw的强调点不同，它强调可重复性和合作。在21世纪初，由于无法获得必要的硬件、软件和数据，期望读者能够重复代码示例是不现实的。快进两个世纪，情况发展迅速。任何有足够RAM（至少推荐8GB）的笔记本电脑都可以安装和运行地理计算软件，并重现本书的内容。1990年代和21世纪初，高性能计算机对大多数人来说过于昂贵，因此地理计算的财务和硬件障碍已经消除。[^01-introduction-2]地理计算也更容易访问，因为公开可访问的数据集比以往任何时候都更广泛地可用，我们将在第<a href="/2023/08/17/2023-8-17-8%E5%9C%B0%E7%90%86%E6%95%B0%E6%8D%AEIO/" title="(8)地理数据 I&#x2F;O">8</a>章中看到。与该领域的早期作品不同，本书中所有的工作都可以使用代码和与书籍一起提供的示例数据进行重现，例如在R包如<strong>spData</strong>中，其安装将在第<a href="/2023/08/11/2023-8-11-2%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE/" title="(2)R中的地理数据">2</a>章中介绍。</p>
<p>[^01-introduction-2]: 在大多数国家，今天可以从如<a href="https://www.ebay.com/sch/i.html?_from=R40&amp;_nkw=laptop&amp;_sacat=0&amp;_oaa=1&amp;_udhi=100&amp;rt=nc&amp;RAM%2520Size=4%2520GB%7C16%2520GB%7C8%2520GB&amp;_dcat=177">Ebay</a>这类似的网站上以100美元或更低的价格购买合适的二手笔记本电脑。有关在现代操作系统如<a href="https://rtask.thinkr.fr/installation-of-r-4-2-on-ubuntu-22-04-lts-and-tips-for-spatial-packages/">Ubuntu 22.04</a>上安装R的更多信息，请参见章节<em>空间类</em>。</p>
<p>每个术语都强调了受GIS影响的’科学’（即可重复和可证伪）方法，尽管它们的起源和主要应用领域不同。例如，GDS强调’数据科学’技能和大型数据集，而地理信息学则更侧重于数据结构。但是，这些术语之间的重叠比它们之间的差异更大，我们将地理计算用作涵盖所有这些术语的粗略同义词，它们都寻求用地理数据进行应用科学工作。然而，与早期使用这个术语的人不同，我们并不寻求暗示存在任何名为’地理计算’（或’Stan Openshaw称之为’GeoComputation’）的连贯的学术领域。相反，我们将这个术语定义如下：以计算方式处理地理数据，专注于代码、可重复性和模块化。</p>
<p>地理计算是一个新近的术语，但受到了古老观念的影响。它可以看作是地理学的一部分，地理学有2000多年的历史；以及<em>地理信息系统</em>（GIS）的延伸，该系统诞生于1960年代。</p>
<p>地理学在计算机发明之前就在解释和影响人类与自然世界的关系方面发挥了重要作用。例如，亚历山大·冯·洪堡在19世纪初对南美洲的旅行说明了这一点：不仅观察结果为物理和植物地理学的传统奠定了基础，而且还为保护自然世界的政策铺平了道路。本书旨在通过利用现代计算机和开源软件的力量，为’地理传统’做出贡献。</p>
<p>本书与较早的学科之间的联系反映在本书的建议标题中：<em>用R学地理学</em>和<em>R用于GIS</em>。每个标题都有优点。前者传达了这样一个信息，即它包含的内容远不止空间数据。非空间属性数据与几何数据不可避免地交织在一起，地理学不仅仅是关于地图上某个东西的位置。后者则传达了这是一本关于使用R作为GI来执行<em>地理数据</em>上的空间操作的书。</p>
<p>然而，GIS这个术语传达了一些含义（见表1.1），这些含义简单地无法传达R最大的优点之一：其基于控制台的能力可以无缝地在地理和非地理数据处理、可视化和建模之间转换。因此，我们选择了一个更中性和包容性的标题。相对而言，地理计算意味着可复制和富有创造性的编程。当然，（地理计算的）算法是强大的工具，可能会变得非常复杂。然而，所有算法都由更小的部分组成。通过教授您其基础和底层结构，我们的目标是赋予您创造自己的地理数据问题创新解决方案的能力。</p>
<h2 id="为什么选择R进行地理计算">为什么选择R进行地理计算?</h2>
<!--rl-->
<p>早期地理学家使用各种工具，包括气压计、指南针和<a href="https://en.wikipedia.org/wiki/Sextant">六分仪</a>，以增进对世界的了解。直到1761年海洋<a href="https://en.wikipedia.org/wiki/Marine_chronometer">天文钟</a>的发明，人们才能在海上计算经度，从而使船只能够采取更直接的航线。</p>
<p>如今，很难想象会缺乏地理数据。每部智能手机都有全球定位（GPS）接收器，从卫星和半自动车辆到公民科学家的多种传感器不断测量世界的每一个部分。数据生成的速度是惊人的。<br>
例如，一个自动驾驶车辆每天可以生成 100 GB的数据。卫星的遥感数据已经太大，无法用单台计算机分析相应的数据，因此出现了例如<a href="http://r-spatial.org/2016/11/29/openeo.html">OpenEO</a>之类的计划。</p>
<p>这场“地理数据革命”推动了对高性能计算硬件和高效、可扩展软件的需求，以从噪音中提取信号，了解甚至可能改变世界。空间数据库能够存储和生成大量地理数据集的可管理子集，使得从其中获取知识的界面成为未来的重要工具。R就是这样一种工具，具有先进的分析、建模和可视化能力。在这个背景下，本书的重点不在于语言本身。相反，我们使用R作为理解世界的“行业工具”，类似于洪堡使用工具深入了解自然界所有的复杂性和相互联系。尽管编程看似是一种还原主义活动，目标是教授地理计算与R，不仅仅是为了乐趣，还是为了理解世界。</p>
<p>R是一个多平台的开源语言和环境，用于统计计算和图形（<a href="https://www.r-project.org/">r-project.org/</a>）。通过广泛的包，R还支持先进的地理空间统计、建模和可视化。新的集成开发环境（IDEs}）如RStudio已使R对许多人更加用户友好，通过专门用于交互式可视化的面板简化了制图工作。</p>
<p>在其核心，R是一个面向对象的<a href="https://adv-r.hadley.nz/fp.html">函数式编程语言</a>，特别设计为其他软件的交互式接口。后者还包括许多到GIS软件、“地理库&quot;和功能（见第<a href="/2023/08/19/2023-8-19-10%E8%BF%9E%E6%8E%A5%E5%88%B0GIS%E8%BD%AF%E4%BB%B6%E7%9A%84%E6%A1%A5%E6%A2%81/" title="(10)连接到GIS的桥梁">10</a>章）的&quot;桥梁”。因此，它是快速创建&quot;地理工具&quot;的理想选择，无需掌握低级语言（相对于R）如C、FORTRAN或Java（见<a href="#%E5%9C%B0%E7%90%86%E8%AE%A1%E7%AE%97%E8%BD%AF%E4%BB%B6">1.3</a>节）。这可能感觉像是从基于GUI或专有地理信息系统，以查看GUI的定义，施加的比喻性&quot;玻璃天花板&quot;中挣脱出来(见表1.1GUI定义)。此外，R便于访问其他语言：例如，<strong>Rcpp</strong>和<strong>reticulate</strong>包允许访问C++和Python代码。这意味着R可以用作通往各种地理空间程序的&quot;桥梁&quot;（见<a href="#%E5%9C%B0%E7%90%86%E8%AE%A1%E7%AE%97%E8%BD%AF%E4%BB%B6">1.3</a>节）。</p>
<p>另一个显示R灵活性和不断发展的地理能力的例子是交互式地图制作。如我们将在第<a href="/2023/08/18/2023-8-18-9%E5%9C%B0%E7%90%86%E6%95%B0%E6%8D%AE%E5%88%B6%E5%9B%BE/" title="(9)地理数据制图">9</a>章中看到，R具有“有限的交互式[绘图]功能”的说法已经不再成立。这通过以下的代码块得到证明，该代码块创建了图1.1（生成该图的函数将在第9.4节中介绍）。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>leaflet<span class="punctuation">)</span></span><br><span class="line">popup <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;Robin&quot;</span><span class="punctuation">,</span> <span class="string">&quot;Jakub&quot;</span><span class="punctuation">,</span> <span class="string">&quot;Jannes&quot;</span><span class="punctuation">)</span></span><br><span class="line">leaflet<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">  addProviderTiles<span class="punctuation">(</span><span class="string">&quot;NASAGIBS.ViirsEarthAtNight2012&quot;</span><span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">  addMarkers<span class="punctuation">(</span>lng <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="operator">-</span><span class="number">3</span><span class="punctuation">,</span> <span class="number">23</span><span class="punctuation">,</span> <span class="number">11</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">             lat <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">52</span><span class="punctuation">,</span> <span class="number">53</span><span class="punctuation">,</span> <span class="number">49</span><span class="punctuation">)</span><span class="punctuation">,</span> </span><br><span class="line">             popup <span class="operator">=</span> popup<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<div class="figure" style="text-align: center">
<iframe src="https://geocompr.github.io/img/interactive.html" width="100%" height="400px" data-external="1"></iframe>
<p class="caption">图1.1：蓝色标记指示了作者来自哪里。底图是由NASA提供的夜晚地球的平铺图像。通过在r.geocompx.org上与在线版本进行交互，例如通过放大和点击弹出窗口。</p>
</div>
<p>几年前，使用R制作图本身就会很困难，更不用说作为一个交互式地图1.1了。这展示了R的灵活性，以及多亏了如<strong>knitr</strong>和<strong>leaflet</strong>等发展，它可以用作与其他软件的接口，这是贯穿本书始终的一个主题。因此，R代码的使用使得可以通过参考代表现实世界现象的可复现示例来教授地理计算，而不仅仅是抽象概念。</p>
<h2 id="地理计算软件">地理计算软件</h2>
<!--rl-->
<p>R是一个用于地理计算的强大语言，但也有许多其他用于地理数据分析的选项，提供了数千个地理函数。了解其他用于地理计算的语言将有助于决定何时使用其他工具可能更适合特定任务，并将R置于更广泛的地理空间生态系统中。本节简要介绍了用于地理计算的语言<a href="https://isocpp.org/">C++</a>，<a href="https://www.oracle.com/java/index.html">Java</a>和<a href="https://www.python.org/">Python</a>，为第<a href="/2023/08/19/2023-8-19-10%E8%BF%9E%E6%8E%A5%E5%88%B0GIS%E8%BD%AF%E4%BB%B6%E7%9A%84%E6%A1%A5%E6%A2%81/" title="(10)连接到GIS的桥梁">10</a>章做准备。</p>
<p>R（和Python）的一个重要特性是它是一种解释型语言。这是有利的，因为它允许在读取——求值——打印循环（REPL）中进行交互式编程。输入到控制台的代码立即执行并打印结果，而不是等待编译的中间阶段。另一方面，编译型语言如C++和Java倾向于运行更快（一旦它们已经被编译）。</p>
<p>C++为许多GIS软件包（如<a href="https://www.qgis.org/">QGIS</a>，<a href="https://grass.osgeo.org/">GRASS</a>和<a href="http://www.saga-gis.org/">SAGA</a>）提供了基础，因此它是一个明智的起点。精心编写的C++速度非常快，使其成为处理大型地理数据集等性能关键应用的好选择，但比Python或R更难学。通过<strong>Rcpp</strong>包，C++已经变得更容易接近，为R用户提供了一个很好的C编程的’切入点’。熟练掌握这种低级语言增加了创建新的高性能’地理算法’以及更好地理解GIS软件如何工作的可能性（见第<a href="/2023/08/19/2023-8-19-10%E8%BF%9E%E6%8E%A5%E5%88%B0GIS%E8%BD%AF%E4%BB%B6%E7%9A%84%E6%A1%A5%E6%A2%81/" title="(10)连接到GIS的桥梁">11</a>章）。</p>
<p>Java是用于地理计算的另一种重要和多功能的语言。GIS软件包gvSig、OpenJump和uDig都是用Java编写的。Java有许多GIS库，包括GeoTools和JTSJava拓扑套件，（GEOS是JTS的C++的部分）。此外，许多地图服务器应用程序使用Java，包括Geoserver/Geonode、deegree和52°North WPS。</p>
<p>Java的面向对象语法与C++相似。Java的一个主要优点是它是平台独立的（这对于编译语言来说是不寻常的）并且具有很高的可扩展性，使其成为像RStudio这样的IDE的适当语言，用它写了这本书。与Python或R相比，Java在统计建模和可视化方面的工具较少，尽管它可用于数据科学。</p>
<p>Python是用于地理计算的重要语言，特别是因为许多桌面GIS，如GRASS、SAGA和QGIS，提供了Python API（见第<a href="/2023/08/19/2023-8-19-10%E8%BF%9E%E6%8E%A5%E5%88%B0GIS%E8%BD%AF%E4%BB%B6%E7%9A%84%E6%A1%A5%E6%A2%81/" title="(10)连接到GIS的桥梁">10</a>章）。与R一样，它是一个流行的数据科学工具。这两种语言都是面向对象的，并且有许多重叠区域，导致了诸如reticulate这样的项目，促进了从R访问Python，以及Ursa Labs计划，以支持便携式库，使整个开源数据科学生态系统受益。</p>
<p>实际上，R和Python各有优点，某种程度上你使用哪个不如应用领域和结果传播重要。学习其中一个将为学习另一个提供先行优势。然而，R相对于Python在地理计算方面有主要优势。这包括其对语言本身中地理数据模型矢量和栅格的更好支持以及相应的可视化可能性（见第<a href="/2023/08/19/2023-8-19-10%E8%BF%9E%E6%8E%A5%E5%88%B0GIS%E8%BD%AF%E4%BB%B6%E7%9A%84%E6%A1%A5%E6%A2%81/" title="(10)连接到GIS的桥梁">2</a>和<a href="/2023/08/18/2023-8-18-9%E5%9C%B0%E7%90%86%E6%95%B0%E6%8D%AE%E5%88%B6%E5%9B%BE/" title="(9)地理数据制图">9</a>章）。同样重要的是，R具有无与伦比的统计支持，包括空间统计，有数百个包支持数千种统计方法。</p>
<p>Python的主要优点是它是一种<em>通用</em>编程语言。它用于许多领域，包括桌面软件、电脑游戏、网站和数据科学。Python通常是不同（地理计算）社群之间唯一共享的语言，并可视为许多GIS程序的“粘合剂”。许多地理算法，包括QGIS和ArcMap中的那些，都可以从Python命令行访问，使其非常适合作为命令行GIS的入门语言。<a href="Python%E6%A8%A1%E5%9D%97%E6%8F%90%E4%BE%9B%E8%AE%BF%E9%97%AE%E5%9C%B0%E7%90%86%E7%AE%97%E6%B3%95%E7%9A%84Python%E6%A8%A1%E5%9D%97%E5%8C%85%E6%8B%ACgrass.script%E7%94%A8%E4%BA%8EGRASS%EF%BC%8Csaga-python%E7%94%A8%E4%BA%8ESAGA-GIS%EF%BC%8Cprocessing%E7%94%A8%E4%BA%8EQGIS%E5%92%8Carcpy%E7%94%A8%E4%BA%8EArcGIS%E3%80%82">^01-introduction-3</a></p>
<p>然而，在空间统计和预测建模方面，R是无与伦比的。这并不意味着你必须选择R或Python：Python支持大多数常见的统计技术（尽管R倾向于更早地支持空间统计的新发展），许多从Python学到的概念可以应用到R世界。</p>
<!--rl:toDo--> <!--to update! -->
<p>与R一样，Python还支持地理数据分析和处理，使用诸如<strong>shapely</strong>、<strong>geopandas</strong>、<strong>rasterio</strong>和<strong>xarray</strong>等包。</p>
<h2 id="R-空间生态系统">R 空间生态系统</h2>
<!--rl-->
<p>在R中处理地理数据有很多方法，该领域有几十个软件包。<a href="R%E7%9A%84%E7%A9%BA%E9%97%B4%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%A7%88%E5%8F%AF%E4%BB%A5%E5%9C%A8CRAN%E4%BB%BB%E5%8A%A1%E8%A7%86%E5%9B%BE%E4%B8%AD%E6%89%BE%E5%88%B0%EF%BC%8C%E5%85%B3%E4%BA%8E%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%EF%BC%88%E8%A7%81%3Chttps://cran.r-project.org/web/views/Spatial.html%3E%EF%BC%89%E3%80%82">^01-introduction-4</a>在本书中，我们努力教授该领域的最新技术，同时确保这些方法是面向未来的。与软件开发的许多其他领域一样，R的空间生态系统正在迅速发展。由于R是开源的，这些发展可以轻易地建立在之前的工作上，正如艾萨克·牛顿在<a href="http://digitallibrary.hsp.org/index.php/Detail/Object/Show/object_id/9285">1675年</a>所说的“站在巨人的肩膀上”。这种方法有优势，因为它鼓励合作并避免“重复发明轮子”。例如，<strong>sf</strong>软件包（在<em>空间数据</em>章中介绍）建立在其前身<strong>sp</strong>上。</p>
<p>在R协会为支持Simple Features（一种存储和访问矢量几何的开源标准和模型）的开发授予了一笔资金后，“R-spatial”的开发时间（和兴趣）有了激增。这导致了<strong>sf</strong>软件包的出现。多个场合反映了对<strong>sf</strong>的巨大兴趣。这一点在<a href="https://stat.ethz.ch/pipermail/r-sig-geo/">R-sig-Geo Archives</a>中尤为明显，这是一个长期开放访问的电子邮件列表，其中包含了多年来积累的大量R-spatial智慧成果。</p>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309061131739.png" alt=""><br>
图1.2: 从2013年初至今，选定的用于处理地理数据的R软件包的下载情况。<a href="http://xn--ycloud-3e8i923n5fcu6wgzy3nheq4aw0t7qy.r-project.org">y轴显示了来自流行的cloud.r-project.org</a> CRAN镜像站的每日平均下载量，采用91天的滚动窗口（对数尺度）。</p>
<p>值得注意的是，更广泛的R社群中的变化，如由数据处理包<strong>dplyr</strong>（在<a href="https://cran.r-project.org/src/contrib/Archive/dplyr/">2014</a>年发布）所示，影响了R的空间生态系统的变化。与其他具有共同风格和强调“整洁数据”的包（包括例如<strong>ggplot2</strong>）一同，<strong>dplyr</strong>在<a href="https://cran.r-project.org/src/contrib/Archive/tidyverse/">2016</a>年底被置于 <strong>tidyverse</strong> '元包’中。<!--rl:toDo--> <!-- 添加参考 --><strong>tidyverse</strong>方法，其关注长格式数据和快速直观命名的函数，已变得非常受欢迎。这导致了对“整洁地理数据”的需求，这部分需求已经由<strong>sf</strong>得到满足。<strong>tidyverse</strong>的一个明显特点是包之间有和谐地工作的趋势。<!--rl:toDo--> <!--下一句还有效吗？-->尚无等同于<strong>geoverse</strong>的东西，但在<a href="https://github.com/r-spatial/discuss/issues/11">r-spatial</a> 组织托管的包之间有着协调的尝试，并且越来越多的包使用 <strong>sf</strong>（见表1.2）。</p>
<p>表1.2: 截至2022-04-22，有332个软件包导入sf。根据前一个月每天的平均下载量，依赖于sf的前5个最多下载的软件包。</p>
<table>
<thead>
<tr>
<th style="text-align:left">Package</th>
<th style="text-align:right">Downloads</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">spdep</td>
<td style="text-align:right">1419</td>
</tr>
<tr>
<td style="text-align:left">lwgeom</td>
<td style="text-align:right">1000</td>
</tr>
<tr>
<td style="text-align:left">stars</td>
<td style="text-align:right">940</td>
</tr>
<tr>
<td style="text-align:left">leafem</td>
<td style="text-align:right">863</td>
</tr>
<tr>
<td style="text-align:left">mapview</td>
<td style="text-align:right">760</td>
</tr>
</tbody>
</table>
<p>与此相关的是一组并行的发展，涉及到 <a href="https://github.com/rspatial">rspatial</a> 的一系列包。[^01-introduction-5]其主要成员是用于空间栅格处理的 <strong>terra</strong> 包。</p>
<p>[^01-introduction-5]: 注意 “r-spatial” 和 “rspatial” 之间的区别，前者是包含如 <strong>sf</strong> 等包的组织，后者是负责 <strong>terra</strong> 的组织。</p>
<h2 id="R-spatial-历史">R-spatial 历史</h2>
<!-- jn -->
<p>使用如<strong>sf</strong>这样的最新空间包有很多好处，但也很重要的是要了解R在空间能力方面的历史：许多函数、用例和教学材料都包含在较旧的包中。只要你知道在哪里查找，这些依然是今天有用的。</p>
<p>在1990年代，出现了大量的S脚本和少数几个用于空间统计的包。R包从这些发展而来，到2000年，已经有多个用于各种空间方法的R包，如&quot;点模式分析、地统计学、探索性空间数据分析和空间计量经济学&quot;，根据 GeoComputation 2000 上呈现的一篇<a href="http://www.geocomputation.org/2000/GC009/Gc009.htm">文章</a>。其中一些，尤其<strong>spatial</strong>，<strong>sgeostat</strong>和<strong>splancs</strong>仍然可以在CRAN上找到。</p>
<p>一个后续的 R News 文章（<a href="https://journal.r-project.org/">The R Journal</a>的前身）包含了当时R中空间统计软件的概览，其中很多都是基于之前为 S/S-PLUS 编写的代码。这个概览描述了用于空间平滑和插值的包，包括<strong>akima</strong>和<strong>geoR</strong>，以及用于点模式分析的包，包括<strong>splancs</strong> 和<strong>spatstat</strong>[。</p>
<p>接下来的 R News 期刊（第1卷/第3期）再次将空间包置于聚光灯下，对<strong>splancs</strong>进行了更详细的介绍，并对空间统计的未来前景发表了评论。此外，该期还介绍了最终成为<strong>spdep</strong>一部分的两个用于测试空间自相关的包。值得注意的是，评论提到了对空间接口的标准化、与GIS交换数据的高效机制和处理空间元数据（如坐标参考系统（CRS）的需求。</p>
<p><strong>maptools</strong>（由 Nicholas Lewin-Koh 编写）是这个时期的另一个重要包。最初，<strong>maptools</strong> 只包含了一个围绕 <a href="http://shapelib.maptools.org/">shapelib</a> 的包装器，并允许将ESRI Shapefiles读入到嵌套的几何列表中。相应的，现在已经过时的 S3 类名为 “Map”，它将这个列表与一个属性数据框存储在一起。“Map” 类表示法尽管如此重要，因为它直接为<strong>sp</strong>提供了营养，这是在其发布到 CRAN 之前的事。</p>
<p>2003年，Roger Bivand 发表了一个关于空间包的扩展评论。它提出了一个类系统，以支持 “GDAL 提供的数据对象”，包括 ‘基础的’ 点、线、多边形和栅格类型。此外，它建议与外部库的接口应构成模块化 R 包的基础。在很大程度上，这些想法在 <strong>rgdal</strong> 和 <strong>sp</strong> 包中得到了实现。这些为 R 的空间数据分析提供了基础，正如在 <em>Applied Spatial Data Analysis with R</em> (ASDAR)中描述的，该书于2008年首次出版。十年后，R 的空间能力已经大大发展，但它们仍然建立在Bivand (2003)提出的想法之上：例如，GDAL和PROJ的接口仍然是R高性能地理数据 I/O 和 CRS变换能力的动力。</p>
<p><strong>rgdal</strong> 包于2003年发布，为R提供了与GDAL（地理空间数据抽象库）的绑定，极大地增强了R从以前无法使用的地理数据格式中导入数据的能力。最初的发布仅支持栅格驱动，但后续的增强功能通过PROJ库提供了对坐标参考系统的支持，重新投影以及导入矢量文件格式。这些额外的功能大部分由Barry Rowlingson开发，并在2006年发布在<strong>rgdal</strong>的代码库中[参见 B. Rowlingson 等 2003以及<a href="https://stat.ethz.ch/pipermail/r-help/2003-January/028413.html">R-help</a> 邮件列表以获取上下文信息]。</p>
<p><strong>sp</strong>包于2005年发布，解决了R无法区分空间和非空间对象的问题。<strong>sp</strong>起源于2003年在维也纳举行的一个<a href="http://spatial.nhh.no/meetings/vienna/index.html">研讨会</a>，最初托管在sourceforge，后来迁移到<a href="https://r-forge.r-project.org">R-Forge</a>。在2005年之前，地理坐标通常被视为普通的数字。</p>
<p><strong>sp</strong>使用S4类系统在<code>Spatial</code>对象的槽中存储诸如边界框、坐标参考系统和属性等信息，使得数据操作能够应用于地理数据（见第<a href="/2023/08/11/2023-8-11-2%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE/" title="(2)R中的地理数据">2</a>章)。 此外，<strong>sp</strong> 为地理数据提供了一些通用方法，如<code>summary()</code> 和 <code>plot()</code>。在接下来的十年里，<strong>sp</strong>类迅速成为R中地理数据的流行选择，依赖它的包数量从2008年的大约20个增加到2013年的超过100个。现在，依赖<strong>sp</strong>的包数量已经超过500个（与正在更快增长的 <strong>sf</strong> 包的数量相似），使其成为R生态系统的重要组成部分。使用<strong>sp</strong>的著名R包包括：<strong>gstat</strong>，用于空间和时空地理统计；<strong>geosphere</strong>，用于球面三角学；以及 <strong>adehabitat</strong>，用于分析动物对栖息地的选择。</p>
<p>尽管<strong>rgdal</strong>和<strong>sp</strong>解决了许多空间问题，但直到2010年在Google Summer of Code项目中开发了<strong>rgeos</strong>，才能在<strong>sp</strong>对象上进行几何操作。诸如<code>gIntersection()</code>这样的函数使用户能够找到地理对象之间的空间关系，并修改其几何形状（有关使用<strong>sf</strong>进行几何操作的详细信息，请参见第<a href="/2023/08/14/2023-8-14-5%E5%87%A0%E4%BD%95%E6%93%8D%E4%BD%9C/" title="(5)几何操作">5</a>章）。</p>
<p><strong>sp</strong>生态系统的一个局限性是其对栅格数据的有限支持。这一问题由2010年首次发布的<strong>raster</strong>得到了解决。<strong>raster</strong>的类系统和函数使一系列栅格操作成为可能，这些功能现已在<strong>terra</strong>包中实现，该包取代了<strong>raster</strong>，如第<a href="/2023/08/11/2023-8-11-2%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE/" title="(2)R中的地理数据">2</a>章所示。<strong>raster</strong>和<strong>terra</strong>的一个重要功能是能够处理过大以至于无法装入RAM的数据集（R对PostGIS的接口也支持对地理矢量数据集的磁盘外操作）。<strong>raster</strong>和<strong>terra</strong>还支持地图代数。</p>
<p>与这些类系统和方法的开发并行，是R作为专用GIS软件接口的支持。<strong>GRASS</strong>和后续的<strong>spgrass6</strong>和<strong>rgrass7</strong>包（分别用于GRASS GIS 6和7）是这个方向的突出例子。R和GIS之间的其他桥梁例子包括<strong>RSAGA</strong>，<strong>RPyGeo</strong>，<strong>RQGIS</strong>，以及<strong>rqgisprocess</strong>。</p>
<!--toDo--> <!-- rqgisprocess ref! -->
<p>最初，可视化并不是重点，大部分R空间开发都集中在分析和地理操作上。<strong>sp</strong>提供了使用基础和格子绘图系统进行地图制作的方法，但对高级地图制作能力的需求正在增加。2009年首次发布的<strong>RgoogleMaps</strong>允许将R的空间数据覆盖在来自诸如Google Maps或OpenStreetMap等在线服务的’底图’瓦片上 。随后发布的<strong>ggmap</strong>包为<strong>ggplot2</strong>添加了类似的’底图’瓦片功能。尽管<strong>ggmap</strong>便于使用<strong>ggplot2</strong>进行地图制作，但其实用性受到需要<code>fortify</code>空间对象的限制，这意味着将它们转换成长数据框。这种方法对点来说效果很好，但对于线和多边形来说计算效率不高，因为每个坐标（顶点）都转换成一行，导致用于表示复杂几何形状的数据框非常庞大。尽管地理可视化倾向于专注于矢量数据，但栅格可视化在<strong>raster</strong>中得到了支持，并在<strong>rasterVis</strong>的发布后得到了提升，该包在一本关于空间和时间数据可视化主题的书中有描述。从那时起，R中的地图制作成为了一个热门话题，专用的包如<strong>tmap</strong>、<strong>leaflet</strong>、<strong>rayshader</strong>和<strong>mapview</strong>越来越受欢迎。</p>
<p>自2018年Geocomputation with R的第一版发布以来，地理R包的开发已经加速。<strong>terra</strong>，<strong>raster</strong>包的继任者，首次在2020年发布，为使用栅格数据集的R用户带来了多个好处：它比前身更快，用户界面也更直接，如第2.3节所示。</p>
<p>在2021年中期，<strong>sf</strong>包通过整合球面几何计算进行了实质性（在某些情况下是破坏性）的更改。从那时起，默认情况下，许多具有地理CRS的数据上的空间操作使用S2球面几何引擎作为后端，见第2.2.9节。自2018年以来，用R表示和处理地理数据的其他方式还包括<strong>stars</strong>和<strong>lidR</strong>包。<strong>stars</strong>与<strong>sf</strong>紧密集成，处理栅格和矢量数据立方体。<strong>lidR</strong>处理基于飞机的LiDAR（光探测与测距）点云。</p>
<p>此次现代化有多个动机，包括新技术和标准的出现，以及R环境之外的空间软件开发的影响。最重要的外部因素影响了大多数空间软件，包括R空间包，这些因素是始于2018年的PROJ库的重大更新，其中包括许多破坏性的变化。最重要的是，这些变化迫使用’Well Known Text’替换坐标参考系统的’proj-string’表示，如第2.4节和第<a href="/2023/08/16/2023-8-16-7%E5%9C%B0%E7%90%86%E6%95%B0%E6%8D%AE%E9%87%8D%E6%8A%95%E5%BD%B1/" title="(7)地理数据重投影">7</a>章所示。</p>
<p>自2018年以来，R中空间可视化工具的进展与几个因素有关。首先，开发了新类型的空间图，包括<strong>rayshader</strong>包，它提供了光线追踪和多种山体阴影方法的组合，以生成2D和3D数据可视化 。其次，<strong>ggplot2</strong>获得了新的空间功能，主要归功于<strong>ggspatial</strong>包，该包添加了一些空间可视化元素，包括比例尺和北箭头，以及<strong>gganimate</strong>，该包允许平滑和可定制的空间动画 。第三，提高了可视化大型空间数据集的性能。这尤其与<strong>tmap</strong>中自动绘制缩小比例的栅格以及在<strong>mapview</strong>包中使用高性能交互式渲染平台的可能性有关，例如<code>&quot;leafgl&quot;</code>和<code>&quot;mapdeck&quot;</code>。最后，一些现有的映射工具已被重写，以最小化依赖性，改进用户界面或允许更容易地创建扩展。这包括<strong>mapsf</strong>包（<strong>cartography</strong>的继任者）以及<strong>tmap</strong>包的第4版，在该版本中大多数内部代码都经过了修订。</p>
<!-- toDo: rl-->
<!-- question: should we add a paragraph about the following stuff here?-->
<!-- add info about specialized packages - sfnetworks, landscapemetrics, gdalcubes, rgee, etc. -->
<!-- better to add review papers, including Robin's, mine, etc. -->
<!-- interoperbility? -->
<!-- @hesselbarth_opensource_2021 -->
<!-- @lovelace_open_2021a -->
<!-- spatstat?? -->
<p>在2021年底，Roger Bivand 在<a href="https://stat.ethz.ch/pipermail/r-sig-geo/2021-September/028760.html">R-sig-Geo 邮件列表</a>上宣布了 <strong>rgdal</strong>、<strong>rgeos</strong> 和 <strong>maptools</strong> 将于2023年底退役的计划。这不仅会对现有使用这些包的工作流程产生重大影响，也将影响依赖于 <strong>rgdal</strong>、<strong>rgeos</strong> 或 <strong>maptools</strong> 的包。因此，Bivand 的建议是转向更现代的工具，包括 <strong>sf</strong> 和 <strong>terra</strong>，正如本书接下来的章节中所解释的。</p>
<h2 id="练习">练习</h2>
<p>E1. 考虑上面描述的’GIS’（地理信息系统）、‘GDS’（地理数据科学）和’地理计算’这几个术语。哪个（如果有的话）最能描述你想通过使用地理*方法和软件来做的工作？为什么？</p>
<p>E2. 提供使用可编程语言（如R）进行地理计算而不是使用基于图形用户界面（GUI）的GIS（如QGIS）的三个理由。</p>
<p>E3. 在2000年，Stan Openshaw写道，地理计算涉及对其他人有&quot;实际益处或用处&quot;的工作。考虑一个实际问题和可能的解决方案，这些解决方案可以通过分析、可视化或模拟地理数据获得新证据来指导。用纸和笔（或其他用于计算的东西）勾画输入和可能的输出，说明地理计算如何有助于解决问题。</p>
<!--toDo: rl -->
<!--add solutions!-->
]]></content>
      <categories>
        <category>R</category>
        <category>Geocomputaion</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>Geocomputaion</tag>
      </tags>
  </entry>
  <entry>
    <title>(2)R中的地理数据</title>
    <url>/2023/08/11/2023-8-11-2%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<blockquote><p>本文由SCY翻译自《Geocomputation with R》<a href="https://r.geocompx.org/spatial-class#spatial-class">第二章</a></p>
</blockquote>
<h1>R中的地理数据</h1>
<p>本章将简要介绍两种基本的地理数据模型：矢量和栅格。我们将介绍每种数据模型背后的理论以及它们在哪些学科中占主导地位,然后演示它们在R中的实现。</p>
<span id="more"></span>
<p>前提条件</p>
<!--rl-->
<p>这是本书的第一章实践内容,因此它带有一些软件需求。</p>
<!-- toDo: rl-->
<!-- should we be that specific regarding the r version?-->
<p>您需要能够访问安装了最新版本R的计算机(R<a href="https://stat.ethz.ch/pipermail/r-announce/2022/000683.html">4.2.0</a> 或更高版本)。我们建议不仅阅读文本内容,也<em>运行每章的代码</em>,以建立您的地理计算技能。</p>
<p>为了跟踪您的学习过程,值得在计算机上新建一个文件夹来保存您的R脚本、输出和其他在学习《用R进行地理计算》过程中产生的东西。您也可以<a href="https://github.com/geocompx/geocompr/archive/refs/heads/main.zip">下载</a>或<a href="https://docs.github.com/en/repositories/creating-and-managing-repositories/cloning-a-repository">克隆</a>本书背后的<a href="https://github.com/geocompx/geocompr">源代码</a>以支持您的学习。我们强烈建议在编写/运行/测试R代码时安装集成开发环境(IDE),如<a href="https://posit.co/download/rstudio-desktop/#download">RStudio</a>(针对大多数人推荐)或<a href="https://github.com/REditorSupport/vscode-R">VS Code</a>。^[我们建议使用<a href="https://r4ds.had.co.nz/workflow-projects.html">RStudio项目</a>、<a href="https://code.visualstudio.com/docs/editor/workspaces">VS Code工作区</a>或类似系统来管理项目。通过RStudio中的R控制台,可以使用<strong>rstudioapi</strong>包快速完成此操作。例如,使用以下命令在主目录中打开一个名为“geocompr-learning”的新项目:<code>rstudioapi::openProject(&quot;~/geocompr-learning&quot;)</code>。]</p>
<p>如果您是R的新手,我们建议您在深入学习《用R进行地理计算》代码之前,首先学习一些R入门资源,比如Garrett Grolemund的<a href="https://rstudio-education.github.io/hopr/starting.html">《用R学习编程》</a>或Claudia Engel的<a href="https://cengel.github.io/R-intro/">《R语言入门》</a> 。组织好您的工作(例如使用RStudio项目),并给脚本起合理的名称,如<code>chapter-02-notes.R</code>,以记录您在学习过程中的代码。</p>
<p>安装好环境后,是时候运行一些代码了!除非您已经安装了这些包,否则第一件事是使用以下命令安装本章需要的基础R包:^[<strong>spDataLarge</strong> 不存在于CRAN上,意味着必须通过<em>r-universe</em>或以下命令安装:<code>remotes::install_github(&quot;Nowosad/spDataLarge&quot;)</code>。]</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">install.packages<span class="punctuation">(</span><span class="string">&quot;sf&quot;</span><span class="punctuation">)</span></span><br><span class="line">install.packages<span class="punctuation">(</span><span class="string">&quot;terra&quot;</span><span class="punctuation">)</span></span><br><span class="line">install.packages<span class="punctuation">(</span><span class="string">&quot;spData&quot;</span><span class="punctuation">)</span></span><br><span class="line">install.packages<span class="punctuation">(</span><span class="string">&quot;spDataLarge&quot;</span><span class="punctuation">,</span> repos <span class="operator">=</span> <span class="string">&quot;https://nowosad.r-universe.dev&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>📌我们建议按照<a href="https://cran.r-project.org/">CRAN</a>上的R安装说明进行操作。<br>
如果您使用Mac或Linux,上述安装<strong>sf</strong>的命令第一次可能不会起作用。<br>
这些操作系统 (OSs) 都有一些“系统需求”,在该包的<a href="https://github.com/r-spatial/sf">README</a>中有描述。<br>
网上可以找到其他特定操作系统的安装说明,包括<a href="https://rtask.thinkr.fr/installation-of-r-4-2-on-ubuntu-22-04-lts-and-tips-for-spatial-packages/">rtask.thinkr.fr</a>网站上的文章<em>在Ubuntu 22.04.1 LTS上安装R 4.2及空间包提示</em>。</p>
</blockquote>
<p>复现本书第1部分内容所需的包可以通过以下命令安装:<code>remotes::install_github(&quot;geocompx/geocompkg&quot;)</code>。这个命令使用<strong>remotes</strong>包中的<code>install_packages()</code>函数来安装托管在GitHub代码托管、版本控制和协作平台上的源代码。以下命令将安装复现整本书所需的<strong>所有</strong>依赖项(警告:这可能需要几分钟):<code>remotes::install_github(&quot;geocompx/geocompkg&quot;, dependencies = TRUE)</code>本章中提出的代码所需的包可以通过<code>library()</code>函数“加载”(技术上是附加)如下:</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>sf<span class="punctuation">)</span>          <span class="comment"># classes and functions for vector data</span></span><br><span class="line"><span class="comment">#&gt; Linking to GEOS 3.11.0, GDAL 3.5.3, PROJ 9.1.0; sf_use_s2() is TRUE</span></span><br></pre></td></tr></table></figure>
<p><code>library(sf)</code>的输出将报告该包正在使用的关键地理库(如GEOS)的版本,如第<a href="#%E7%AE%80%E5%8D%95%E7%89%B9%E5%BE%81%E4%BB%8B%E7%BB%8D">2.2.1</a>节所述。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>terra<span class="punctuation">)</span>      <span class="comment"># classes and functions for raster data</span></span><br></pre></td></tr></table></figure>
<p>我们安装的其他R包包含了书中将使用的数据:</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>spData<span class="punctuation">)</span>        <span class="comment"># load geographic data</span></span><br><span class="line"><span class="comment">#&gt; The legacy packages maptools, rgdal, and rgeos, underpinning the sp package,</span></span><br><span class="line"><span class="comment">#&gt; which was just loaded, will retire in October 2023.</span></span><br><span class="line"><span class="comment">#&gt; Please refer to R-spatial evolution reports for details, especially</span></span><br><span class="line"><span class="comment">#&gt; https://r-spatial.org/r/2023/05/15/evolution4.html.</span></span><br><span class="line"><span class="comment">#&gt; It may be desirable to make the sf package available;</span></span><br><span class="line"><span class="comment">#&gt; package maintainers should consider adding sf to Suggests:.</span></span><br><span class="line"><span class="comment">#&gt; The sp package is now running under evolution status 2</span></span><br><span class="line"><span class="comment">#&gt;      (status 2 uses the sf package in place of rgdal)</span></span><br><span class="line">library<span class="punctuation">(</span>spDataLarge<span class="punctuation">)</span>   <span class="comment"># load larger geographic data</span></span><br></pre></td></tr></table></figure>
<h2 id="引言">引言</h2>
<p>本章将简要介绍两种基本的地理数据模型:矢量和栅格。我们将介绍每种数据模型背后的理论以及它们在哪些学科中占主导地位,然后演示它们在R中的实现。</p>
<p><em>矢量数据模型</em>使用点、线和多边形来表示世界。这些要素具有明确定义的边界,这意味着矢量数据集通常具有很高的精度(但不一定是准确性,我们将在第<a href="#%E5%8D%95%E4%BD%8D">2.5</a>节中看到)。<em>栅格数据模型</em>将表面划分为大小恒定的单元格。栅格数据集是 web 地图中使用的背景图像的基础,自航空摄影和卫星遥感设备起源以来,它一直是地理数据的重要来源。栅格将空间特定特征聚合到给定分辨率,这意味着它们在空间上是一致的并且可扩展的(许多全球栅格数据集都是可用的)。</p>
<p>使用哪种模型呢?答案可能取决于您的应用领域:</p>
<ul>
<li>矢量数据在社会科学中占主导地位,因为人类定居点往往有明确的边界</li>
<li>栅格在许多环境科学中占主导地位,因为它们依赖遥感数据</li>
</ul>
<p>在一些领域中两者有很大的重叠,矢量和栅格数据集可以一起使用:例如,生态学家和人口统计学家通常同时使用矢量和栅格数据。此外,可以在两种形式之间进行转换。无论您的工作更多地使用矢量数据集还是栅格数据集,在使用它们之前理解其基本数据模型都是值得的,这将在后续章节中讨论。本书使用 <strong>sf</strong> 和 <strong>terra</strong> 包分别处理矢量数据和栅格数据集。</p>
<h2 id="矢量数据">矢量数据</h2>
<blockquote>
<p>📌在本书中使用“矢量”一词时要注意它有两层含义:<br>
地理矢量数据和 R 中的<code>vector</code>类(注意<code>等宽字体</code>字体)。<br>
前者是一个数据模型,后者是一个R类,就像 <code>data.frame</code> 和 <code>matrix</code>。<br>
但两者之间还是有联系的:地理矢量数据模型的核心空间坐标可以用R中的<code>vector</code>对象来表示。<br>
所以在阅读时要注意上下文,区分这两层含义。一般来说,没有特别说明时,“矢量”指的都是地理矢量数据模型。</p>
</blockquote>
<p>地理矢量数据模型基于坐标参考系统(CRS)内的点。点可以代表独立的要素(例如公交车站的位置),也可以链接在一起形成更复杂的几何形状,如线和多边形。大多数点几何只包含两个维度(三维坐标参考系统包含额外的$z$值,通常代表海拔高度)。</p>
<p>在这种系统中,例如伦敦可以用坐标<code>c(-0.1, 51.5)</code>表示。这意味着它相对于原点向东-0.1度,向北51.5度。在这种情况下,原点位于地理坐标系(“经纬度”)中的0度经线(本初子午线)和0度纬线(赤道)上（图2.1，左面板）。在投影坐标系中,同一点也可以用“东向/北向”值为<code>c(530000,180000)</code>来概括表示,在<a href="https://en.wikipedia.org/wiki/Ordnance_Survey_National_Grid">英国国家网格</a>中,这意味着伦敦位于CRS$原点$以<em>东</em>530公里,以<em>北</em>180公里。这可以从视觉上进行验证:与表示伦敦的点略微相隔超过5个“框”——由宽度为100公里的灰色网格线划定的正方形区域——从原点（图2.1，右面板）。</p>
<p>英国国家网格原点位于西南半岛以外的海域,以确保英国内陆的大多数位置都具有正的东向和北向值。^[我们提到的原点,在图中用蓝色表示,事实上是“伪”原点。 真正的原点,也就是畸变最小的位置,位于2°W 49°N。这是英国测绘局选择的位置,在经度上大致位于不列颠岛的中心。简而言之,坐标由两个数字组成,表示距离一个原点的距离,通常是在$x$然后$y$维度上。]关于坐标参考系统的更多内容,将在第<a href="#%E5%9C%B0%E7%90%86%E6%8A%95%E5%BD%B1%E5%9D%90%E6%A0%87%E5%8F%82%E8%80%83%E7%B3%BB"></a>节和第<a href="/2023/08/16/2023-8-16-7%E5%9C%B0%E7%90%86%E6%95%B0%E6%8D%AE%E9%87%8D%E6%8A%95%E5%BD%B1/" title="(7)地理数据重投影">7</a>章详细描述,但就本节而言,知道这些坐标原理就足够了。</p>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309012154114.png" alt=""><br>
图2.1：矢量（点）数据的示例，其中伦敦的位置（红色X）相对于一个原点（蓝色圆圈）进行了表示。左图代表了一个地理坐标参照系统（CRS），其原点位于0°经度和纬度。右图代表了一个投影坐标参照系统（CRS），其原点位于西南半岛西海域。</p>
<p><strong>sf</strong>为地理矢量数据提供了类,并为地理计算的重要底层库提供了一致的命令行接口:</p>
<ul>
<li>
<p><a href="https://gdal.org/">GDAL</a>,用于读写和操作各种地理数据格式（第<a href="/2023/08/17/2023-8-17-8%E5%9C%B0%E7%90%86%E6%95%B0%E6%8D%AEIO/" title="(8)地理数据 I&#x2F;O">8</a>章）。</p>
</li>
<li>
<p><a href="https://proj.org/">PROJ</a>,一个强大的坐标系统转换库（第<a href="/2023/08/16/2023-8-16-7%E5%9C%B0%E7%90%86%E6%95%B0%E6%8D%AE%E9%87%8D%E6%8A%95%E5%BD%B1/" title="(7)地理数据重投影">7</a>章）。</p>
</li>
<li>
<p><a href="https://libgeos.org/">GEOS</a>,一个平面几何引擎,用于计算缓冲区和投影坐标系数据的质心等操作（第<a href="/2023/08/14/2023-8-14-5%E5%87%A0%E4%BD%95%E6%93%8D%E4%BD%9C/" title="(5)几何操作">5</a>章）。</p>
</li>
<li>
<p><a href="https://s2geometry.io/">S2</a>,由Google开发的用C++编写的球面几何引擎,通过<a href="https://r-spatial.github.io/s2/"><strong>s2</strong></a>包（见下文<a href="#s2%E7%90%83%E9%9D%A2%E5%87%A0%E4%BD%95%E8%BF%90%E7%AE%97">2.2.9</a>节和第<a href="/2023/08/16/2023-8-16-7%E5%9C%B0%E7%90%86%E6%95%B0%E6%8D%AE%E9%87%8D%E6%8A%95%E5%BD%B1/" title="(7)地理数据重投影">7</a>章）。</p>
</li>
</ul>
<!-- - [liblwgeom](https://github.com/postgis/postgis/tree/master/liblwgeom), a geometry engine used by PostGIS, via the [**lwgeom**](https://r-spatial.github.io/lwgeom/) package -->
<p>这些接口的信息会在<strong>sf</strong>包首次加载时打印出来:在本章开头<code>library(sf)</code>命令下方出现的消息告诉我们连接的GEOS、GDAL和PROJ库的版本(这在不同计算机和时间上有所不同),以及是否开启了S2接口。当今我们认为理所应当,但是只有与不同地理库的紧密集成,才使R中的可重现地理计算成为可能。</p>
<p><strong>sf</strong>的一个漂亮功能是您可以更改在未投影数据上使用的默认几何引擎:使用<code>sf::sf_use_s2(FALSE)</code>命令可以“关闭”S2,这意味着所有几何操作(包括未投影数据上的几何操作)将默认使用平面几何引擎GEOS，平面几何基于二维空间（见第<a href="#s2%E7%90%83%E9%9D%A2%E5%87%A0%E4%BD%95%E8%BF%90%E7%AE%97">2.2.9</a>节）。平面几何引擎(如GEOS)假设“平面”(投影)坐标,而球面几何引擎(如S2)假设未投影(经纬度)坐标。</p>
<p>本节将介绍<strong>sf</strong>类,为后续章节做准备（（第<a href="/2023/08/14/2023-8-14-5%E5%87%A0%E4%BD%95%E6%93%8D%E4%BD%9C/" title="(5)几何操作">5</a>章和第<a href="/2023/08/17/2023-8-17-8%E5%9C%B0%E7%90%86%E6%95%B0%E6%8D%AEIO/" title="(8)地理数据 I&#x2F;O">8</a>章分别介绍了GEOS和GDAL接口））。</p>
<h3 id="简单特征介绍">简单特征介绍</h3>
<p>Simple Features 是一个由开放地理空间联盟（OGC）开发和认可的<a href="http://portal.opengeospatial.org/files/?artifact_id=25355">开放标准</a>，这是一个非营利组织，我们将在第8.5节中再次讨论其活动。Simple Features 是一个分层数据模型，代表了各种几何类型。规范支持的 18 种几何类型中，只有 7 种在大多数地理研究中被使用（如图2.2所示）。这些核心几何类型得到了 R 包 <strong>sf</strong> 的完全支持。^[完整的 OGC 标准包括一些相当不寻常的几何类型，包括 ‘surface’ 和 ‘curve’ 几何类型，这些在现实世界应用中目前用途有限。所有 18 种类型都可以用<strong>sf</strong>包来表示，尽管在写作时（2022年），绘图只适用于“核心 7 种”。]</p>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309012200006.png" alt=""><br>
图2.2：Simple feature types fully supported by sf.</p>
<p><strong>sf</strong>可以表示所有常见的矢量几何类型（栅格数据类别不受<strong>sf</strong>支持）：点、线、多边形及其各自的’multi’版本（将同一类型的特征组合成单一特征）。<strong>sf</strong> 还支持几何集合，可以在单一对象中包含多种几何类型。<strong>sf</strong> 提供了以前在三个包中提供的相同（甚至更多）功能—— <strong>sp</strong> 用于数据类别，<strong>rgdal</strong>用于通过接口到GDAL和PROJ进行数据读写，以及<strong>rgeos</strong>用于通过接口到GEOS进行空间操作。</p>
<p>为了重申第一章的信息，地理R包有着与低级库接口的悠久历史，而<strong>sf</strong>通过统一的接口延续了这一传统，该接口适用于GEOS的近期版本进行几何操作，GDAL库用于读取和写入地理数据文件，以及PROJ库用于表示和转换投影坐标参考系统。</p>
<!-- **s2** functions have replaced **lwgeom** ones (Bivand 2021). -->
<!-- and **lwgeom**, **sf** also has an inter to PostGIS's [`liblwgeom`](https://github.com/postgis/postgis/tree/master/liblwgeom) library  -->
<p>通过对 Google’s 球面几何库 <a href="https://s2geometry.io/"><code>s2</code></a>的R接口，<strong>sf</strong>还能快速且准确地进行“在非平面几何上的测量和操作”。自从 1.0.0 版的<strong>sf</strong>在<a href="https://cran.r-project.org/src/contrib/Archive/sf/">2021年6月</a>发布以来，<strong>s2</strong>的功能现在默认用于具有地理（经度/纬度）坐标系统的几何体，这是<strong>sf</strong>的一个独特特性，与仅支持用于几何操作的GEOS的空间库不同，例如Python包<a href="geopandas/geopandas/issues/2098">GeoPandas</a>。我们将在后续章节中讨论<strong>s2</strong>。</p>
<!-- Todo: link to them, e.g. (RL 2021-11) -->
<!-- See sections \@ref(s2) and \@ref(buffers) for further details. -->
<p><strong>sf</strong>能够将多个强大的地理计算库整合到一个框架中，这是一个值得注意的成就，它降低了使用高性能库进行可重复地理数据分析的“准入门槛”。<strong>sf</strong>的功能在其网站<a href="https://r-spatial.github.io/sf/index.html">r-spatial.github.io/sf/</a> 上有详细的文档，包含7篇专题文章。这些可以按如下方式离线查看：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">vignette<span class="punctuation">(</span>package <span class="operator">=</span> <span class="string">&quot;sf&quot;</span><span class="punctuation">)</span> <span class="comment"># see which vignettes are available</span></span><br><span class="line">vignette<span class="punctuation">(</span><span class="string">&quot;sf1&quot;</span><span class="punctuation">)</span>          <span class="comment"># an introduction to the package</span></span><br></pre></td></tr></table></figure>
<p>正如第一篇专题文章解释的，R中的简单特征对象存储在数据框中，地理数据占据一个特殊的列，通常命名为’geom’或’geometry’。我们将使用本章开始时加载的<strong>spData</strong>提供的<code>world</code>数据集，来展示什么是<code>sf</code>对象以及它们是如何工作的。<code>world</code>是一个’<code>sf</code>数据框’，包含空间和属性列，这些列的名称由函数<code>names()</code>返回（在本例中，最后一列包含地理信息）：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="built_in">class</span><span class="punctuation">(</span>world<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] &quot;sf&quot;         &quot;tbl_df&quot;     &quot;tbl&quot;        &quot;data.frame&quot;</span></span><br><span class="line"><span class="built_in">names</span><span class="punctuation">(</span>world<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt;  [1] &quot;iso_a2&quot;    &quot;name_long&quot; &quot;continent&quot; &quot;region_un&quot; &quot;subregion&quot; &quot;type&quot;     </span></span><br><span class="line"><span class="comment">#&gt;  [7] &quot;area_km2&quot;  &quot;pop&quot;       &quot;lifeExp&quot;   &quot;gdpPercap&quot; &quot;geom&quot;</span></span><br></pre></td></tr></table></figure>
<p>这个<code>geom</code>列中的内容赋予了<code>sf</code>对象它们的空间能力：<code>world$geom</code>是一个’<a href="https://adv-r.hadley.nz/vectors-chap.html#list-columns">list column</a>’，其中包含了国家多边形的所有坐标。<code>sf</code>对象可以通过函数<code>plot()</code>快速绘制。尽管<code>plot()</code>是R默认安装（基础 R）的一部分，它是一个 <a href="https://adv-r.hadley.nz/s3.html#s3-methods"><em>generic</em></a> 函数，可被其他包扩展。<strong>sf</strong>包含非导出的（大多数时间对用户隐藏的）<code>plot.sf()</code>函数，这是在以下命令中幕后调用的，该命令创建了图2.3。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">plot<span class="punctuation">(</span>world<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309012229579.png" alt=""><br>
图2.3：A spatial plot of the world using the sf package, with a facet for each attribute.</p>
<p>注意，与大多数GIS程序默认为地理对象创建单一地图不同，对<code>sf</code>对象进行<code>plot()</code>操作会导致数据集中每个变量都有一个地图。这种行为在探索不同变量的空间分布方面可能很有用，并将在<a href="#%E7%BB%98%E5%88%B6%E5%9F%BA%E7%A1%80%E7%9F%A2%E9%87%8F%E5%9C%B0%E5%9B%BE"></a>节进一步讨论。</p>
<p>更广泛地说，将地理对象视为具有空间能力的常规数据框有很多优点，特别是如果您已经习惯于使用数据框。例如，常用的<code>summary()</code>函数提供了<code>world</code>对象内变量的有用概览。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">summary<span class="punctuation">(</span>world<span class="punctuation">[</span><span class="string">&quot;lifeExp&quot;</span><span class="punctuation">]</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt;     lifeExp                geom    </span></span><br><span class="line"><span class="comment">#&gt;  Min.   :50.6   MULTIPOLYGON :177  </span></span><br><span class="line"><span class="comment">#&gt;  1st Qu.:65.0   epsg:4326    :  0  </span></span><br><span class="line"><span class="comment">#&gt;  Median :72.9   +proj=long...:  0  </span></span><br><span class="line"><span class="comment">#&gt;  Mean   :70.9                      </span></span><br><span class="line"><span class="comment">#&gt;  3rd Qu.:76.8                      </span></span><br><span class="line"><span class="comment">#&gt;  Max.   :83.6                      </span></span><br><span class="line"><span class="comment">#&gt;  NA&#x27;s   :10</span></span><br></pre></td></tr></table></figure>
<p>尽管我们只为<code>summary()</code>命令选择了一个变量，它还输出了关于几何的报告。这演示了<strong>sf</strong>对象的几何列的“粘性”行为，意味着除非用户故意移除它们，否则几何体将被保留，正如我们将在第3.2节看到的。该结果提供了<code>world</code>中包含的非空间和空间数据的快速总结：所有国家的平均预期寿命为71岁（范围从不到51岁到超过83岁，中位数为73岁）。</p>
<blockquote>
<p>📌上面摘要输出中的<code>MULTIPOLYGON</code>一词指的是<code>world</code>对象中特征（国家）的几何类型。对于像印度尼西亚和希腊这样有岛屿的国家，这种表示是必要的。其他几何类型在<a href="#%E5%87%A0%E4%BD%95%E7%B1%BB%E5%9E%8B">2.2.4</a>部分有描述。</p>
</blockquote>
<p>这个简单特征对象的基础行为和内容值得更深入地了解，这可以视为一个“<strong>s</strong>patial data <strong>f</strong>rame（空间数据框）”。</p>
<p><code>sf</code>对象很容易进行子集操作：下面的代码展示了如何返回一个仅包含<code>world</code>对象的前两行和前三列的对象。输出显示了与常规<code>data.frame</code>相比有两个主要差异：包含额外的地理元数据（<code>Geometry type</code>、<code>Dimension</code>、<code>Bounding box</code>以及以<code>Geodetic CRS</code>开始的线上的坐标参考系统信息），以及存在一个名为<code>geom</code>的’几何列’。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">world_mini <span class="operator">=</span> world<span class="punctuation">[</span><span class="number">1</span><span class="operator">:</span><span class="number">2</span><span class="punctuation">,</span> <span class="number">1</span><span class="operator">:</span><span class="number">3</span><span class="punctuation">]</span></span><br><span class="line">world_mini</span><br><span class="line"><span class="comment">#&gt; Simple feature collection with 2 features and 3 fields</span></span><br><span class="line"><span class="comment">#&gt; Geometry type: MULTIPOLYGON</span></span><br><span class="line"><span class="comment">#&gt; Dimension:     XY</span></span><br><span class="line"><span class="comment">#&gt; Bounding box:  xmin: -180 ymin: -18.3 xmax: 180 ymax: -0.95</span></span><br><span class="line"><span class="comment">#&gt; Geodetic CRS:  WGS 84</span></span><br><span class="line"><span class="comment">#&gt; # A tibble: 2 × 4</span></span><br><span class="line"><span class="comment">#&gt;   iso_a2 name_long continent                                                geom</span></span><br><span class="line"><span class="comment">#&gt;   &lt;chr&gt;  &lt;chr&gt;     &lt;chr&gt;                                      &lt;MULTIPOLYGON [°]&gt;</span></span><br><span class="line"><span class="comment">#&gt; 1 FJ     Fiji      Oceania   (((-180 -16.6, -180 -16.5, -180 -16, -180 -16.1, -…</span></span><br><span class="line"><span class="comment">#&gt; 2 TZ     Tanzania  Africa    (((33.9 -0.95, 31.9 -1.03, 30.8 -1.01, 30.4 -1.13,…</span></span><br></pre></td></tr></table></figure>
<p>所有这些可能看起来相当复杂，尤其是对于一个“简单”的类系统！然而，用这种方式组织事物并使用<strong>sf</strong>处理矢量地理数据集是有充分理由的。</p>
<p>在描述 <strong>sf</strong> 包支持的每一种几何类型之前，有必要先了解 <code>sf</code> 对象的基础组成元素。<a href="#sf%E7%B1%BB"></a>节展示了简单特征对象是数据框，具有特殊的几何列。这些空间列通常被称为 <code>geom</code> 或 <code>geometry</code>：<code>world$geom</code> 是指上文中描述的 <code>world</code> 对象中的空间元素。这些几何列是 <code>sfc</code> 类的“列表列”（见第<a href="#%E7%AE%80%E5%8D%95%E7%89%B9%E5%BE%81%E5%88%97-sfc"></a>节）。反过来，<code>sfc</code> 对象由一个或多个 <code>sfg</code> 类的对象组成：我们在<a href="#%E7%AE%80%E5%8D%95%E7%89%B9%E5%BE%81%E5%87%A0%E4%BD%95-sfg"></a>节中描述的简单特征几何。</p>
<p>要理解简单特征的空间组件是如何工作的，了解简单特征几何体是至关重要的。因此，在继续描述如何用基于<code>sfg</code>和<code>sfc</code>对象的<code>sf</code>对象在R中表示这些几何体之前，我们将在<a href="#%E5%87%A0%E4%BD%95%E7%B1%BB%E5%9E%8B">2.2.4</a>节中介绍当前支持的每一种简单特征几何类型。</p>
<blockquote>
<p>📌前面的代码块使用 <code>=</code> 在命令 <code>world_mini = world[1:2, 1:3]</code> 中创建了一个名为 <code>world_mini</code> 的新对象。<br>
这被称为赋值。<br>
实现相同结果的等价命令是 <code>world_mini &lt;- world[1:2, 1:3]</code>。<br>
尽管“箭头赋值”更为常用，我们使用“等号赋值”，因为它打字稍微快一些，而且由于与常用语言如 Python 和 JavaScript 的兼容性，更容易教授。<br>
使用哪一个主要是个人偏好的问题，只要你保持一致（像 <strong>styler</strong> 这样的包可以用来改变风格）。</p>
</blockquote>
<h3 id="为什么是简单特征">为什么是简单特征?</h3>
<p>简单特征（Simple features）是一种得到广泛支持的数据模型，它是包括 QGIS 和 PostGIS 在内的许多 GIS 应用程序中的数据结构基础。这一模型的一个主要优点是，使用这种数据模型确保了你的工作可以在其他设置中进行交叉转移，例如从空间数据库导入和导出。</p>
<p>从R的角度来看，一个更具体的问题是“为什么要使用<strong>sf</strong>包，而<strong>sp</strong>包已经经过了反复测试”？有很多原因（与简单特征模型的优点有关）：</p>
<ul>
<li>快速地读取和写入数据</li>
<li>提升了绘图性能</li>
<li><strong>sf</strong> 对象在大多数操作中可以被视为数据框</li>
<li><strong>sf</strong> 函数名相对一致和直观（所有函数名都以 <code>st_</code> 开头）</li>
<li><strong>sf</strong> 函数可以与 <code>|&gt;</code> 操作符结合使用，并且与 <a href="http://tidyverse.org/">tidyverse</a> 的 R 包集合非常兼容。</li>
</ul>
<p><strong>sf</strong> 对 <strong>tidyverse</strong> 包的支持通过 <code>read_sf()</code> 函数体现，这是一个第8.6.1节中详细介绍的用于导入地理矢量数据的函数。与返回存储在基础 R <code>data.frame</code> 中的属性的函数 <code>st_read()</code> 不同（该函数发出详细的消息，在下面的代码块中未显示），<code>read_sf()</code> 会无声地返回数据作为一个 <strong>tidyverse</strong> <code>tibble</code>。下面展示了这一点：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">world_dfr <span class="operator">=</span> st_read<span class="punctuation">(</span>system.file<span class="punctuation">(</span><span class="string">&quot;shapes/world.shp&quot;</span><span class="punctuation">,</span> package <span class="operator">=</span> <span class="string">&quot;spData&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; Reading layer `world&#x27; from data source </span></span><br><span class="line"><span class="comment">#&gt;   `/Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/library/spData/shapes/world.shp&#x27; </span></span><br><span class="line"><span class="comment">#&gt;   using driver `ESRI Shapefile&#x27;</span></span><br><span class="line"><span class="comment">#&gt; Simple feature collection with 177 features and 10 fields</span></span><br><span class="line"><span class="comment">#&gt; Geometry type: MULTIPOLYGON</span></span><br><span class="line"><span class="comment">#&gt; Dimension:     XY</span></span><br><span class="line"><span class="comment">#&gt; Bounding box:  xmin: -180 ymin: -89.9 xmax: 180 ymax: 83.6</span></span><br><span class="line"><span class="comment">#&gt; Geodetic CRS:  WGS 84</span></span><br><span class="line">world_tbl <span class="operator">=</span> read_sf<span class="punctuation">(</span>system.file<span class="punctuation">(</span><span class="string">&quot;shapes/world.shp&quot;</span><span class="punctuation">,</span> package <span class="operator">=</span> <span class="string">&quot;spData&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="built_in">class</span><span class="punctuation">(</span>world_dfr<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] &quot;sf&quot;         &quot;data.frame&quot;</span></span><br><span class="line"><span class="built_in">class</span><span class="punctuation">(</span>world_tbl<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] &quot;sf&quot;         &quot;tbl_df&quot;     &quot;tbl&quot;        &quot;data.frame&quot;</span></span><br></pre></td></tr></table></figure>
<p>第<a href="/2023/08/12/2023-8-12-3%E5%B1%9E%E6%80%A7%E6%93%8D%E4%BD%9C/" title="(3)属性操作">3</a>章展示了如何使用<strong>tidyverse</strong>函数操作<code>sf</code>对象，<strong>sf</strong>现在是R中进行空间矢量数据分析的首选包。<strong>spatstat</strong>是一个提供众多空间统计函数的软件包生态系统，而<strong>terra</strong>也有矢量地理数据类，但它们在处理矢量数据方面都没有达到与<strong>sf</strong>相同的普及程度。许多受欢迎的包都基于<strong>sf</strong>构建，正如在上一章节中所示，其在每天的下载次数方面的流行程度正在上升。从传统包<strong>rgeos</strong>和<strong>rgdal</strong>迁移到已建立的包和工作流程需要时间，但当它们被加载时，打印出的信息指出它们“将在2023年底之前被退役”赋予了这个过程一种紧迫感。这意味着任何仍在使用这些包的人都应该“<strong>尽早转向使用 GDAL 和 PROJ 的 sf/stars/terra 函数</strong>”。换句话说，<strong>sf</strong>是对未来有保证的，而<strong>sp</strong>则不是。对于依赖传统类系统的工作流程，可以按照如下方式将<code>sf</code>对象从<strong>sp</strong>包的<code>Spatial</code>类中转换和转换为：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>sp<span class="punctuation">)</span></span><br><span class="line">world_sp <span class="operator">=</span> as<span class="punctuation">(</span>world<span class="punctuation">,</span> <span class="string">&quot;Spatial&quot;</span><span class="punctuation">)</span> <span class="comment"># from an sf object to sp</span></span><br><span class="line"><span class="comment"># sp functions ...</span></span><br><span class="line">world_sf <span class="operator">=</span> st_as_sf<span class="punctuation">(</span>world_sp<span class="punctuation">)</span>           <span class="comment"># from sp to sf</span></span><br></pre></td></tr></table></figure>
<h3 id="绘制基础矢量地图">绘制基础矢量地图</h3>
<p>在<strong>sf</strong>中，使用<code>plot()</code>创建基础地图。默认情况下，这会创建一个多面板图，每个对象的变量各对应一个子图，如图2.4的左侧面板所示。如果要绘制的对象只有一个变量，将生成一个带有连续颜色的图例或“键”（见右侧面板）。颜色也可以通过<code>col = </code>来设置，尽管这样做不会创建一个连续的调色板或图例。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">plot<span class="punctuation">(</span>world<span class="punctuation">[</span><span class="number">3</span><span class="operator">:</span><span class="number">6</span><span class="punctuation">]</span><span class="punctuation">)</span></span><br><span class="line">plot<span class="punctuation">(</span>world<span class="punctuation">[</span><span class="string">&quot;pop&quot;</span><span class="punctuation">]</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309012235874.png" alt=""><br>
图2.4：Plotting with sf, with multiple variables (left) and a single variable (right).</p>
<p>通过设置<code>add = TRUE</code>，图层会被添加到现有的图像上。^[在幕后，<strong>sf</strong>对象的<code>plot()</code>使用的是<code>sf:::plot.sf()</code>。<code>plot()</code> 是一个通用方法，其行为因要绘制的对象的类别而有所不同。]为了演示这一点，并提供关于属性和空间操作（涉及属性和空间数据操作）内容的洞见，以下代码块过滤出亚洲的国家，并将它们合并为一个单一的特征：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">world_asia <span class="operator">=</span> world<span class="punctuation">[</span>world<span class="operator">$</span>continent <span class="operator">==</span> <span class="string">&quot;Asia&quot;</span><span class="punctuation">,</span> <span class="punctuation">]</span></span><br><span class="line">asia <span class="operator">=</span> st_union<span class="punctuation">(</span>world_asia<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>现在我们可以在世界地图上绘制亚洲大陆。请注意，第一个图只能有一个面板，这样<code>add = TRUE</code>才能起作用。如果第一个图有一个图例，必须使用<code>reset = FALSE</code>：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">plot<span class="punctuation">(</span>world<span class="punctuation">[</span><span class="string">&quot;pop&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span> reset <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">)</span></span><br><span class="line">plot<span class="punctuation">(</span>asia<span class="punctuation">,</span> add <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> col <span class="operator">=</span> <span class="string">&quot;red&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309012237207.png" alt=""><br>
图2.5：A plot of Asia added as a layer on top of countries worldwide.</p>
<p>通过这种方式添加图层可以用于验证图层之间的地理对应关系：<code>plot()</code>函数执行速度快，需要的代码行数少，但不会创建具有广泛选项的交互式地图。对于更高级的地图制作，我们推荐使用专用的可视化包，如 <strong>tmap</strong>（见第<a href="/2023/08/18/2023-8-18-9%E5%9C%B0%E7%90%86%E6%95%B0%E6%8D%AE%E5%88%B6%E5%9B%BE/" title="(9)地理数据制图">9</a>章）。</p>
<p>有多种方式可以通过<strong>sf</strong>的<code>plot()</code>方法修改地图。因为<strong>sf</strong>扩展了基础R绘图方法，<code>plot()</code>的参数（如<code>main =</code>，用于指定地图的标题）也适用于<code>sf</code>对象（参见<code>?graphics::plot</code>和<code>?par</code>）。^[注意：当绘制多个 <code>sf</code> 列时，许多绘图参数在面板图中会被忽略。]</p>
<p>图2.6通过在世界地图上叠加圆圈来展示这种灵活性，这些圆圈的直径（由<code>cex =</code>设置）代表各国的人口。这个图的未投影版本可以用以下命令创建（参见本章末尾的练习和脚本<a href="https://github.com/geocompx/geocompr/blob/main/code/02-contpop.R"><code>02-contplot.R</code></a>，以复现图2.6：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">plot<span class="punctuation">(</span>world<span class="punctuation">[</span><span class="string">&quot;continent&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span> reset <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">)</span></span><br><span class="line">cex <span class="operator">=</span> <span class="built_in">sqrt</span><span class="punctuation">(</span>world<span class="operator">$</span>pop<span class="punctuation">)</span> <span class="operator">/</span> <span class="number">10000</span></span><br><span class="line">world_cents <span class="operator">=</span> st_centroid<span class="punctuation">(</span>world<span class="punctuation">,</span> of_largest <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br><span class="line">plot<span class="punctuation">(</span>st_geometry<span class="punctuation">(</span>world_cents<span class="punctuation">)</span><span class="punctuation">,</span> add <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> cex <span class="operator">=</span> cex<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309012239755.png" alt=""><br>
图2.6：Country continents (represented by fill color) and 2015 populations (represented by circles, with area proportional to population).</p>
<p>上面的代码使用了函数<code>st_centroid()</code>来将一种几何类型（多边形）转换为另一种（点）（参见第<a href="/2023/08/14/2023-8-14-5%E5%87%A0%E4%BD%95%E6%93%8D%E4%BD%9C/" title="(5)几何操作">5</a>章），其美学效果通过<code>cex</code>参数进行变化。</p>
<p><strong>sf</strong>的绘图方法也有针对地理数据的特定参数。例如，<code>expandBB</code>可以用于在上下文中绘制一个<code>sf</code>对象。它接受一个长度为四的数值向量，相对于零在以下顺序扩展绘图的边界框：底部、左侧、顶部、右侧。这用于在下面的代码块中绘制印度及其庞大的亚洲邻国的上下文，特别强调了东边的中国，该代码块生成了图（有关在绘图中添加文本的练习见下文）：^[注意使用<code>st_geometry(india)</code>仅返回与对象关联的几何形状，以防止在简单特征列（<code>sfc</code>）对象中绘制属性。另一种选择是使用<code>india[0]</code>，它返回一个不包含属性数据的<code>sf</code>对象。]</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">india <span class="operator">=</span> world<span class="punctuation">[</span>world<span class="operator">$</span>name_long <span class="operator">==</span> <span class="string">&quot;India&quot;</span><span class="punctuation">,</span> <span class="punctuation">]</span></span><br><span class="line">plot<span class="punctuation">(</span>st_geometry<span class="punctuation">(</span>india<span class="punctuation">)</span><span class="punctuation">,</span> expandBB <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span> <span class="number">0.2</span><span class="punctuation">,</span> <span class="number">0.1</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">)</span><span class="punctuation">,</span> col <span class="operator">=</span> <span class="string">&quot;gray&quot;</span><span class="punctuation">,</span> lwd <span class="operator">=</span> <span class="number">3</span><span class="punctuation">)</span></span><br><span class="line">plot<span class="punctuation">(</span>st_geometry<span class="punctuation">(</span>world_asia<span class="punctuation">)</span><span class="punctuation">,</span> add <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309012244405.png" alt="">India in context, demonstrating the expandBB argument.<br>
图2.7：注意在绘图代码中使用<code>lwd</code>来强调印度。了解用于表示各种几何类型的其他可视化技术，这是下一节的主题。</p>
<h3 id="几何类型">几何类型</h3>
<p>几何体是简单特征（Simple Features）的基础构建块。在R中的简单特征可以采用由<strong>sf</strong>包支持的18种几何类型之一。在本章中，我们将重点介绍七种最常用的类型：<code>POINT</code>、<code>LINESTRING</code>、<code>POLYGON</code>、<code>MULTIPOINT</code>、<code>MULTILINESTRING</code>、<code>MULTIPOLYGON</code> 和 <code>GEOMETRYCOLLECTION</code>。在<a href="http://postgis.net/docs/using_postgis_dbmanagement.html">PostGIS手册</a>中找到可能的特征类型的完整列表。</p>
<p>通常，Well-Known Binary（WKB）或Well-Known Text（WKT）是简单特征几何体的标准编码。WKB表示通常是计算机容易读取的十六进制字符串。这就是为什么GIS和空间数据库使用WKB来传输和存储几何对象。另一方面，WKT是简单特征的人类可读文本标记描述。两种格式都是可交换的，如果我们展示其中一个，我们自然会选择WKT表示。</p>
<p>每种几何类型的基础是点。点只是2D、3D或4D空间中的一个坐标（有关更多信息，请参见<code>vignette(&quot;sf1&quot;)</code>）（见图2.8，左侧面板）：</p>
<ul>
<li><code>POINT (5 2)</code></li>
</ul>
<p>线串是一系列点与直线相连的序列（见图2.8，中间面板）。</p>
<ul>
<li><code>LINESTRING (1 5, 4 4, 4 1, 2 2, 3 2)</code></li>
</ul>
<p>多边形是形成一个封闭、不相交环的点序列。封闭意味着多边形的第一个点和最后一个点具有相同的坐标（见图2.8，右侧面板）。</p>
<ul>
<li>没有孔的多边形：<code>POLYGON ((1 5, 2 2, 4 1, 4 4, 1 5))</code></li>
</ul>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309012247519.png" alt=""><br>
图2.8：Illustration of point, linestring and polygon geometries.</p>
<p>到目前为止，我们创建的几何体每个特征只包含一个几何实体。<strong>sf</strong>也允许在单一特征内存在单一类型的多个几何体，即每种几何类型的“多”版本：</p>
<ul>
<li>多点：<code>MULTIPOINT (5 2, 1 3, 3 4, 3 2)</code></li>
<li>多线串：<code>MULTILINESTRING ((1 5, 4 4, 4 1, 2 2, 3 2), (1 2, 2 4))</code></li>
<li>多多边形：<code>MULTIPOLYGON (((1 5, 2 2, 4 1, 4 4, 1 5), (0 2, 1 2, 1 3, 0 3, 0 2)))</code></li>
</ul>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309012249418.png" alt=""><br>
图2.9：Illustration of multi* geometries.</p>
<p>最后，几何集合可以包含任何组合的几何体，包括（多）点和线串（见图2.10）：</p>
<ul>
<li>几何集合：<code>GEOMETRYCOLLECTION (MULTIPOINT (5 2, 1 3, 3 4, 3 2), LINESTRING (1 5, 4 4, 4 1, 2 2, 3 2))</code></li>
</ul>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309012249187.png" alt=""><br>
图2.10：Illustration of a geometry collection.</p>
<h3 id="sf类">sf类</h3>
<p>简单特征由两个主要部分组成：几何体和非地理属性。图2.11展示了如何创建一个sf对象——几何体来自一个<code>sfc</code>对象，而属性则取自<code>data.frame</code>或<code>tibble</code>。要了解更多关于从零开始构建sf几何体的信息，请阅读以下第<a href="#%E7%AE%80%E5%8D%95%E7%89%B9%E5%BE%81%E5%87%A0%E4%BD%95-sfg">2.2.6</a>节和<a href="#%E7%AE%80%E5%8D%95%E7%89%B9%E5%BE%81%E5%88%97-sfc">2.2.7</a>节。</p>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309012251893.png" alt=""><br>
图2.11：Building blocks of sf objects.</p>
<p>非地理属性代表特征的名称或其他属性，如测量值、组别和其他事项。为了说明属性，我们将表示2017年6月21日在伦敦的25°C温度。这个例子包含一个几何体（坐标），以及三个具有三个不同类别（地点名称、温度和日期）的属性。^[其他属性可能包括城市性质类别（城市或村庄），或者如果测量是通过自动站进行的，则包括一个备注。]<code>sf</code>类的对象通过将属性（<code>data.frame</code>）与简单特征几何列（<code>sfc</code>）组合来表示这样的数据。它们是通过下面所示的<code>st_sf()</code>创建的，该函数创建了上面描述的伦敦示例：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">lnd_point <span class="operator">=</span> st_point<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">0.1</span><span class="punctuation">,</span> <span class="number">51.5</span><span class="punctuation">)</span><span class="punctuation">)</span>                 <span class="comment"># sfg object</span></span><br><span class="line">lnd_geom <span class="operator">=</span> st_sfc<span class="punctuation">(</span>lnd_point<span class="punctuation">,</span> crs <span class="operator">=</span> <span class="string">&quot;EPSG:4326&quot;</span><span class="punctuation">)</span>    <span class="comment"># sfc object</span></span><br><span class="line">lnd_attrib <span class="operator">=</span> data.frame<span class="punctuation">(</span>                           <span class="comment"># data.frame object</span></span><br><span class="line">  name <span class="operator">=</span> <span class="string">&quot;London&quot;</span><span class="punctuation">,</span></span><br><span class="line">  temperature <span class="operator">=</span> <span class="number">25</span><span class="punctuation">,</span></span><br><span class="line">  date <span class="operator">=</span> as.Date<span class="punctuation">(</span><span class="string">&quot;2017-06-21&quot;</span><span class="punctuation">)</span></span><br><span class="line">  <span class="punctuation">)</span></span><br><span class="line">lnd_sf <span class="operator">=</span> st_sf<span class="punctuation">(</span>lnd_attrib<span class="punctuation">,</span> geometry <span class="operator">=</span> lnd_geom<span class="punctuation">)</span>    <span class="comment"># sf object</span></span><br></pre></td></tr></table></figure>
<p>发生了什么？首先，坐标被用来创建简单特征几何体（<code>sfg</code>）。其次，几何体被转换成一个带有坐标参考系统（CRS）的简单特征几何列（<code>sfc</code>）。第三，属性被存储在一个<code>data.frame</code>中，该<code>data.frame</code>与<code>st_sf()</code>一起与<code>sfc</code>对象组合。这导致了一个<code>sf</code>对象，如下面所示（省略了部分输出）：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">lnd_sf</span><br><span class="line"><span class="comment">#&gt; Simple feature collection with 1 features and 3 fields</span></span><br><span class="line"><span class="comment">#&gt; ...</span></span><br><span class="line"><span class="comment">#&gt;     name temperature       date         geometry</span></span><br><span class="line"><span class="comment">#&gt; 1 London          25 2017-06-21 POINT (0.1 51.5)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="built_in">class</span><span class="punctuation">(</span>lnd_sf<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] &quot;sf&quot;         &quot;data.frame&quot;</span></span><br></pre></td></tr></table></figure>
<p>结果显示<code>sf</code>对象实际上有两个类别，<code>sf</code>和<code>data.frame</code>。简单特征实际上就是数据框（方形表格），但是具有存储在通常称为<code>geometry</code>的列表列中的空间属性（见<a href="#%E7%AE%80%E5%8D%95%E7%89%B9%E5%BE%81%E4%BB%8B%E7%BB%8D">2.2.1</a>）。这种二元性是简单特征概念的核心：大多数时候，<code>sf</code>可以被视为并且表现得像一个<code>data.frame</code>。简单特征本质上是带有空间扩展的数据框。</p>
<h3 id="简单特征几何-sfg">简单特征几何 (sfg)</h3>
<p><code>sfg</code>类在R中代表不同的简单特征几何类型：点、线串、多边形（以及它们的“多”等效项，如多点）或几何集合。</p>
<p>通常，您不需要进行繁琐的任务来自己创建几何体，因为您可以简单地导入一个已经存在的空间文件。然而，如果需要，有一组函数可以从零开始创建简单特征几何对象（<code>sfg</code>）。这些函数的名称简单且一致，因为它们都以<code>st_</code>前缀开头，并以几何类型的小写字母名称结尾：</p>
<ul>
<li>一个点：<code>st_point()</code></li>
<li>一个线串：<code>st_linestring()</code></li>
<li>一个多边形：<code>st_polygon()</code></li>
<li>一个多点：<code>st_multipoint()</code></li>
<li>一个多线串：<code>st_multilinestring()</code></li>
<li>一个多多边形：<code>st_multipolygon()</code></li>
<li>一个几何集合：<code>st_geometrycollection()</code></li>
</ul>
<p><code>sfg</code>对象可以从三种基础的R数据类型创建：</p>
<ol>
<li>数值向量：一个单一点</li>
<li>矩阵：一组点，其中每一行代表一个点、一个多点或线串</li>
<li>列表：一组对象的集合，如矩阵、多线串或几何集合</li>
</ol>
<p>函数<code>st_point()</code>从数值向量创建单一点：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">st_point<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">5</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">)</span><span class="punctuation">)</span>                 <span class="comment"># XY point</span></span><br><span class="line"><span class="comment">#&gt; POINT (5 2)</span></span><br><span class="line">st_point<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">5</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">)</span><span class="punctuation">)</span>              <span class="comment"># XYZ point</span></span><br><span class="line"><span class="comment">#&gt; POINT Z (5 2 3)</span></span><br><span class="line">st_point<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">5</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">dim</span> <span class="operator">=</span> <span class="string">&quot;XYM&quot;</span><span class="punctuation">)</span> <span class="comment"># XYM point</span></span><br><span class="line"><span class="comment">#&gt; POINT M (5 2 1)</span></span><br><span class="line">st_point<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">5</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">)</span><span class="punctuation">)</span>           <span class="comment"># XYZM point</span></span><br><span class="line"><span class="comment">#&gt; POINT ZM (5 2 3 1)</span></span><br></pre></td></tr></table></figure>
<p>结果显示，XY（2D坐标）、XYZ（3D坐标）和XYZM（带有额外变量的3D，通常是测量精度）点类型分别从长度为2、3和4的向量创建。XYM类型必须使用<code>dim</code>参数（代表维度）来指定。</p>
<p>相比之下，在多点（<code>st_multipoint()</code>）和线串（<code>st_linestring()</code>）对象的情况下，使用矩阵：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># the rbind function simplifies the creation of matrices</span></span><br><span class="line"><span class="comment">## MULTIPOINT</span></span><br><span class="line">multipoint_matrix <span class="operator">=</span> rbind<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">5</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">3</span><span class="punctuation">,</span> <span class="number">4</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">3</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">st_multipoint<span class="punctuation">(</span>multipoint_matrix<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; MULTIPOINT ((5 2), (1 3), (3 4), (3 2))</span></span><br><span class="line"><span class="comment">## LINESTRING</span></span><br><span class="line">linestring_matrix <span class="operator">=</span> rbind<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">5</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">4</span><span class="punctuation">,</span> <span class="number">4</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">4</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">2</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">3</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">st_linestring<span class="punctuation">(</span>linestring_matrix<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; LINESTRING (1 5, 4 4, 4 1, 2 2, 3 2)</span></span><br></pre></td></tr></table></figure>
<p>最后，使用列表来创建多线串、（多）多边形和几何集合：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">## POLYGON</span></span><br><span class="line">polygon_list <span class="operator">=</span> <span class="built_in">list</span><span class="punctuation">(</span>rbind<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">5</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">2</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">4</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">4</span><span class="punctuation">,</span> <span class="number">4</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">5</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">st_polygon<span class="punctuation">(</span>polygon_list<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; POLYGON ((1 5, 2 2, 4 1, 4 4, 1 5))</span></span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">## POLYGON with a hole</span></span><br><span class="line">polygon_border <span class="operator">=</span> rbind<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">5</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">2</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">4</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">4</span><span class="punctuation">,</span> <span class="number">4</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">5</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">polygon_hole <span class="operator">=</span> rbind<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">2</span><span class="punctuation">,</span> <span class="number">4</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">3</span><span class="punctuation">,</span> <span class="number">4</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">3</span><span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">2</span><span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">2</span><span class="punctuation">,</span> <span class="number">4</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">polygon_with_hole_list <span class="operator">=</span> <span class="built_in">list</span><span class="punctuation">(</span>polygon_border<span class="punctuation">,</span> polygon_hole<span class="punctuation">)</span></span><br><span class="line">st_polygon<span class="punctuation">(</span>polygon_with_hole_list<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; POLYGON ((1 5, 2 2, 4 1, 4 4, 1 5), (2 4, 3 4, 3 3, 2 3, 2 4))</span></span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">## MULTILINESTRING</span></span><br><span class="line">multilinestring_list <span class="operator">=</span> <span class="built_in">list</span><span class="punctuation">(</span>rbind<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">5</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">4</span><span class="punctuation">,</span> <span class="number">4</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">4</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">2</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">3</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span> </span><br><span class="line">                            rbind<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">2</span><span class="punctuation">,</span> <span class="number">4</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">st_multilinestring<span class="punctuation">(</span><span class="punctuation">(</span>multilinestring_list<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; MULTILINESTRING ((1 5, 4 4, 4 1, 2 2, 3 2), (1 2, 2 4))</span></span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">## MULTIPOLYGON</span></span><br><span class="line">multipolygon_list <span class="operator">=</span> <span class="built_in">list</span><span class="punctuation">(</span><span class="built_in">list</span><span class="punctuation">(</span>rbind<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">5</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">2</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">4</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">4</span><span class="punctuation">,</span> <span class="number">4</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">5</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">                         <span class="built_in">list</span><span class="punctuation">(</span>rbind<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">st_multipolygon<span class="punctuation">(</span>multipolygon_list<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; MULTIPOLYGON (((1 5, 2 2, 4 1, 4 4, 1 5)), ((0 2, 1 2, 1 3, 0 3, 0 2)))</span></span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">## GEOMETRYCOLLECTION</span></span><br><span class="line">geometrycollection_list <span class="operator">=</span> <span class="built_in">list</span><span class="punctuation">(</span>st_multipoint<span class="punctuation">(</span>multipoint_matrix<span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">                              st_linestring<span class="punctuation">(</span>linestring_matrix<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">st_geometrycollection<span class="punctuation">(</span>geometrycollection_list<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; GEOMETRYCOLLECTION (MULTIPOINT (5 2, 1 3, 3 4, 3 2),</span></span><br><span class="line"><span class="comment">#&gt;   LINESTRING (1 5, 4 4, 4 1, 2 2, 3 2))</span></span><br></pre></td></tr></table></figure>
<h3 id="简单特征列-sfc">简单特征列 (sfc)</h3>
<p>一个<code>sfg</code>对象只包含一个单一的简单特征几何。简单特征几何列（<code>sfc</code>）是一个<code>sfg</code>对象的列表，此外还能包含有关正在使用的坐标参考系统的信息。例如，要将两个简单特征组合成一个具有两个特征的对象，我们可以使用<code>st_sfc()</code>函数。这一点很重要，因为<code>sfc</code>代表了<strong>sf</strong>数据框中的几何列：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sfc POINT</span></span><br><span class="line">point1 <span class="operator">=</span> st_point<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">5</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">point2 <span class="operator">=</span> st_point<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">points_sfc <span class="operator">=</span> st_sfc<span class="punctuation">(</span>point1<span class="punctuation">,</span> point2<span class="punctuation">)</span></span><br><span class="line">points_sfc</span><br><span class="line"><span class="comment">#&gt; Geometry set for 2 features </span></span><br><span class="line"><span class="comment">#&gt; Geometry type: POINT</span></span><br><span class="line"><span class="comment">#&gt; Dimension:     XY</span></span><br><span class="line"><span class="comment">#&gt; Bounding box:  xmin: 1 ymin: 2 xmax: 5 ymax: 3</span></span><br><span class="line"><span class="comment">#&gt; CRS:           NA</span></span><br><span class="line"><span class="comment">#&gt; POINT (5 2)</span></span><br><span class="line"><span class="comment">#&gt; POINT (1 3)</span></span><br></pre></td></tr></table></figure>
<p>在大多数情况下，一个<code>sfc</code>对象包含相同几何类型的对象。因此，当我们将多边形类型的<code>sfg</code>对象转换为一个简单特征几何列时，我们也会得到一个多边形类型的<code>sfc</code>对象，这可以通过<code>st_geometry_type()</code>来验证。同样地，一个多线串的几何列将导致一个多线串类型的<code>sfc</code>对象：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sfc POLYGON</span></span><br><span class="line">polygon_list1 <span class="operator">=</span> <span class="built_in">list</span><span class="punctuation">(</span>rbind<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">5</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">2</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">4</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">4</span><span class="punctuation">,</span> <span class="number">4</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">5</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">polygon1 <span class="operator">=</span> st_polygon<span class="punctuation">(</span>polygon_list1<span class="punctuation">)</span></span><br><span class="line">polygon_list2 <span class="operator">=</span> <span class="built_in">list</span><span class="punctuation">(</span>rbind<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">polygon2 <span class="operator">=</span> st_polygon<span class="punctuation">(</span>polygon_list2<span class="punctuation">)</span></span><br><span class="line">polygon_sfc <span class="operator">=</span> st_sfc<span class="punctuation">(</span>polygon1<span class="punctuation">,</span> polygon2<span class="punctuation">)</span></span><br><span class="line">st_geometry_type<span class="punctuation">(</span>polygon_sfc<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] POLYGON POLYGON</span></span><br><span class="line"><span class="comment">#&gt; 18 Levels: GEOMETRY POINT LINESTRING POLYGON MULTIPOINT ... TRIANGLE</span></span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sfc MULTILINESTRING</span></span><br><span class="line">multilinestring_list1 <span class="operator">=</span> <span class="built_in">list</span><span class="punctuation">(</span>rbind<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">5</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">4</span><span class="punctuation">,</span> <span class="number">4</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">4</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">2</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">3</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span> </span><br><span class="line">                            rbind<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">2</span><span class="punctuation">,</span> <span class="number">4</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">multilinestring1 <span class="operator">=</span> st_multilinestring<span class="punctuation">(</span><span class="punctuation">(</span>multilinestring_list1<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">multilinestring_list2 <span class="operator">=</span> <span class="built_in">list</span><span class="punctuation">(</span>rbind<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">2</span><span class="punctuation">,</span> <span class="number">9</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">7</span><span class="punctuation">,</span> <span class="number">9</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">5</span><span class="punctuation">,</span> <span class="number">6</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">4</span><span class="punctuation">,</span> <span class="number">7</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">2</span><span class="punctuation">,</span> <span class="number">7</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span> </span><br><span class="line">                            rbind<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">7</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">3</span><span class="punctuation">,</span> <span class="number">8</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">multilinestring2 <span class="operator">=</span> st_multilinestring<span class="punctuation">(</span><span class="punctuation">(</span>multilinestring_list2<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">multilinestring_sfc <span class="operator">=</span> st_sfc<span class="punctuation">(</span>multilinestring1<span class="punctuation">,</span> multilinestring2<span class="punctuation">)</span></span><br><span class="line">st_geometry_type<span class="punctuation">(</span>multilinestring_sfc<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] MULTILINESTRING MULTILINESTRING</span></span><br><span class="line"><span class="comment">#&gt; 18 Levels: GEOMETRY POINT LINESTRING POLYGON MULTIPOINT ... TRIANGLE</span></span><br></pre></td></tr></table></figure>
<p>也可以从具有不同几何类型的<code>sfg</code>对象创建一个<code>sfc</code>对象：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sfc GEOMETRY</span></span><br><span class="line">point_multilinestring_sfc <span class="operator">=</span> st_sfc<span class="punctuation">(</span>point1<span class="punctuation">,</span> multilinestring1<span class="punctuation">)</span></span><br><span class="line">st_geometry_type<span class="punctuation">(</span>point_multilinestring_sfc<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] POINT           MULTILINESTRING</span></span><br><span class="line"><span class="comment">#&gt; 18 Levels: GEOMETRY POINT LINESTRING POLYGON MULTIPOINT ... TRIANGLE</span></span><br></pre></td></tr></table></figure>
<p>如前所述，<code>sfc</code>对象还可以额外存储有关坐标参考系统（CRS）的信息。默认值是<code>NA</code>（<em>Not Available</em>，不可用），这可以通过<code>st_crs()</code>来验证：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">st_crs<span class="punctuation">(</span>points_sfc<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; Coordinate Reference System: NA</span></span><br></pre></td></tr></table></figure>
<p><code>sfc</code>对象中的所有几何体必须具有相同的CRS。可以使用<code>st_sfc()</code>（或<code>st_sf()</code>）的<code>crs</code>参数来指定CRS，该参数接受一个以文本字符串形式提供的<strong>CRS标识符</strong>，例如<code>crs=&quot;EPSG:4326&quot;</code>。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Set the CRS with an identifier referring to an &#x27;EPSG&#x27; CRS code:</span></span><br><span class="line">points_sfc_wgs <span class="operator">=</span> st_sfc<span class="punctuation">(</span>point1<span class="punctuation">,</span> point2<span class="punctuation">,</span> crs <span class="operator">=</span> <span class="string">&quot;EPSG:4326&quot;</span><span class="punctuation">)</span></span><br><span class="line">st_crs<span class="punctuation">(</span>points_sfc_wgs<span class="punctuation">)</span> <span class="comment"># print CRS (only first 4 lines of output shown)</span></span><br><span class="line"><span class="comment">#&gt; Coordinate Reference System:</span></span><br><span class="line"><span class="comment">#&gt;   User input: EPSG:4326 </span></span><br><span class="line"><span class="comment">#&gt;   wkt:</span></span><br><span class="line"><span class="comment">#&gt; GEOGCRS[&quot;WGS 84&quot;,</span></span><br><span class="line"><span class="comment">#&gt; ...</span></span><br></pre></td></tr></table></figure>
<h3 id="sfheaders包">sfheaders包</h3>
<p><strong>sfheaders</strong>是一个R包，用于加速构建、转换和操作<code>sf</code>对象。它专注于从向量、矩阵和数据框快速构建<code>sf</code>对象，而无需依赖<strong>sf</strong>库；并通过头文件（因此得名<strong>sfheaders</strong>）公开其底层的C++代码。这种方法使其他人能够使用编译和快速运行的代码来扩展它。每个核心的<strong>sfheaders</strong>函数都有一个相应的C++实现，如<a href="https://dcooley.github.io/sfheaders/articles/Cpp.html">the <code>Cpp</code> vignette</a>中所描述。对于大多数人来说，R函数将足以从该包的计算速度中受益。<strong>sfheaders</strong>是独立于<strong>sf</strong>开发的，但旨在完全兼容，创建有效的<code>sf</code>对象，其类型如前面的章节所述。</p>
<p><strong>sfheaders</strong>最简单的用例在下面的代码块中有示例，其中展示了构建<code>sfg</code>、<code>sfc</code>和<code>sf</code>对象：</p>
<ul>
<li>向量转换为<code>sfg_POINT</code></li>
<li>矩阵转换为<code>sfg_LINESTRING</code></li>
<li>数据框转换为<code>sfg_POLYGON</code></li>
</ul>
<p>我们将从创建最简单可能的<code>sfg</code>对象开始，即一个单一的坐标对，赋值给名为<code>v</code>的向量：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">v <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">)</span></span><br><span class="line">v_sfg_sfh <span class="operator">=</span> sfheaders<span class="operator">::</span>sfg_point<span class="punctuation">(</span>obj <span class="operator">=</span> v<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">v_sfg_sfh <span class="comment"># printing without sf loaded</span></span><br><span class="line"><span class="comment">#&gt;      [,1] [,2]</span></span><br><span class="line"><span class="comment">#&gt; [1,]    1    1</span></span><br><span class="line"><span class="comment">#&gt; attr(,&quot;class&quot;)</span></span><br><span class="line"><span class="comment">#&gt; [1] &quot;XY&quot;    &quot;POINT&quot; &quot;sfg&quot; </span></span><br></pre></td></tr></table></figure>
<p>上面的示例展示了当<strong>sf</strong>未加载时，<code>sfg</code>对象<code>v_sfg_sfh</code>是如何打印的，展示了其底层结构。当<strong>sf</strong>被加载（如这里的情况）时，上述命令的结果与<code>sf</code>对象无法区分：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">v_sfg_sf <span class="operator">=</span> st_point<span class="punctuation">(</span>v<span class="punctuation">)</span></span><br><span class="line">print<span class="punctuation">(</span>v_sfg_sf<span class="punctuation">)</span> <span class="operator">==</span> print<span class="punctuation">(</span>v_sfg_sfh<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; POINT (1 1)</span></span><br><span class="line"><span class="comment">#&gt; POINT (1 1)</span></span><br><span class="line"><span class="comment">#&gt; [1] TRUE</span></span><br></pre></td></tr></table></figure>
<p>下一个示例展示了<strong>sfheaders</strong>如何从矩阵和数据框创建<code>sfg</code>对象：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># matrices</span></span><br><span class="line">m <span class="operator">=</span> matrix<span class="punctuation">(</span><span class="number">1</span><span class="operator">:</span><span class="number">8</span><span class="punctuation">,</span> ncol <span class="operator">=</span> <span class="number">2</span><span class="punctuation">)</span></span><br><span class="line">sfheaders<span class="operator">::</span>sfg_linestring<span class="punctuation">(</span>obj <span class="operator">=</span> m<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; LINESTRING (1 5, 2 6, 3 7, 4 8)</span></span><br><span class="line"><span class="comment"># data.frames</span></span><br><span class="line">df <span class="operator">=</span> data.frame<span class="punctuation">(</span>x <span class="operator">=</span> <span class="number">1</span><span class="operator">:</span><span class="number">4</span><span class="punctuation">,</span> y <span class="operator">=</span> <span class="number">4</span><span class="operator">:</span><span class="number">1</span><span class="punctuation">)</span></span><br><span class="line">sfheaders<span class="operator">::</span>sfg_polygon<span class="punctuation">(</span>obj <span class="operator">=</span> df<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; POLYGON ((1 4, 2 3, 3 2, 4 1, 1 4))</span></span><br></pre></td></tr></table></figure>
<p>重用对象<code>v</code>、<code>m</code>和<code>df</code>，我们也可以如下构建简单特征列（<code>sfc</code>）（输出未显示）：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">sfheaders<span class="operator">::</span>sfc_point<span class="punctuation">(</span>obj <span class="operator">=</span> v<span class="punctuation">)</span></span><br><span class="line">sfheaders<span class="operator">::</span>sfc_linestring<span class="punctuation">(</span>obj <span class="operator">=</span> m<span class="punctuation">)</span></span><br><span class="line">sfheaders<span class="operator">::</span>sfc_polygon<span class="punctuation">(</span>obj <span class="operator">=</span> df<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>同样地，<code>sf</code>对象可以如下创建：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">sfheaders<span class="operator">::</span>sf_point<span class="punctuation">(</span>obj <span class="operator">=</span> v<span class="punctuation">)</span></span><br><span class="line">sfheaders<span class="operator">::</span>sf_linestring<span class="punctuation">(</span>obj <span class="operator">=</span> m<span class="punctuation">)</span></span><br><span class="line">sfheaders<span class="operator">::</span>sf_polygon<span class="punctuation">(</span>obj <span class="operator">=</span> df<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>在这些示例中，CRS（坐标参考系统）都没有定义。如果您计划使用<strong>sf</strong>函数进行任何计算或几何操作，我们建议您设置CRS（有关详细信息，请参见章节@ref(reproj-geo-data)）：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">df_sf <span class="operator">=</span> sfheaders<span class="operator">::</span>sf_polygon<span class="punctuation">(</span>obj <span class="operator">=</span> df<span class="punctuation">)</span></span><br><span class="line">st_crs<span class="punctuation">(</span>df_sf<span class="punctuation">)</span> <span class="operator">=</span> <span class="string">&quot;EPSG:4326&quot;</span></span><br></pre></td></tr></table></figure>
<p><strong>sfheaders</strong>也擅长“解构”和“重构”<code>sf</code>对象，即将几何列转换为包含每个顶点和几何特征（以及多特征）ID的坐标数据的数据框。它在将几何列“转换”为不同类型方面非常快速和可靠。该包的<a href="https://dcooley.github.io/sfheaders/articles/examples.html#performance">文档</a>和为本书开发的测试代码中的基准测试显示，它比<code>sf</code>包在这类操作上要快得多。</p>
<h3 id="S2球面几何运算">S2球面几何运算</h3>
<p>球面几何引擎基于世界是圆形的这一事实，而用于地理计算的简单数学程序，如计算两点之间的直线或多边形所围成的面积，假设是平面（投影）几何。自<strong>sf</strong>版本1.0.0以来，R通过<strong>s2</strong>接口包支持“开箱即用”的球面几何操作，该接口连接到Google的S2球面几何引擎。S2可能最为人所知的是作为一个离散全球网格系统（DGGS）的例子。另一个例子是<a href="https://eng.uber.com/h3/">Uber的H3</a>全球六边形分层空间索引。</p>
<p>尽管用于描述地球上任何地方的位置可能很有用，例如使用诸如<a href="https://developers.google.com/maps/documentation/gaming/concepts_playable_locations">e66ef376f790adf8a5af7fca9e6e422c03c9143f</a>这样的字符串，但<strong>sf</strong>与S2的接口的主要优点是它提供了用于距离、缓冲区和面积计算等的即插即用函数，如在<strong>sf</strong>的内置文档中所描述，该文档可以通过命令<a href="https://r-spatial.github.io/sf/articles/sf7.html"><code>vignette(&quot;sf7&quot;)</code></a>打开。</p>
<p><strong>sf</strong>可以在两种模式下运行，分别是开启和关闭S2。默认情况下，S2几何引擎是开启的，如下面的命令所验证：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">sf_use_s2<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] TRUE</span></span><br></pre></td></tr></table></figure>
<p>通过在本章早些时候创建的<code>india</code>对象周围创建缓冲区，下面展示了关闭几何引擎的后果（注意当S2关闭时发出的警告）：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">india_buffer_with_s2 <span class="operator">=</span> st_buffer<span class="punctuation">(</span>india<span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">)</span></span><br><span class="line">sf_use_s2<span class="punctuation">(</span><span class="literal">FALSE</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; Spherical geometry (s2) switched off</span></span><br><span class="line">india_buffer_without_s2 <span class="operator">=</span> st_buffer<span class="punctuation">(</span>india<span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; Warning in st_buffer.sfc(st_geometry(x), dist, nQuadSegs, endCapStyle =</span></span><br><span class="line"><span class="comment">#&gt; endCapStyle, : st_buffer does not correctly buffer longitude/latitude data</span></span><br><span class="line"><span class="comment">#&gt; dist is assumed to be in decimal degrees (arc_degrees).</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309020020296.png" alt=""><br>
图2.12：Example of the consequences of turning off the S2 geometry engine. Both representations of a buffer around India were created with the same command but the purple polygon object was created with S2 switched on, resulting in a buffer of 1 m. The larger light green polygon was created with S2 switched off, resulting in a buffer with inaccurate units of degrees longitude/latitude.</p>
<p>在整本书中，我们将假设S2是开启的，除非明确说明。用以下命令再次开启它。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">sf_use_s2<span class="punctuation">(</span><span class="literal">TRUE</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; Spherical geometry (s2) switched on</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>📌尽管在许多情况下，<strong>sf</strong>使用S2是有道理的，但在某些情况下，有充分的理由在一个R会话或整个项目的过程中关闭S2。<br>
如<strong>sf</strong>的GitHub仓库中的问题<a href="https://github.com/r-spatial/sf/issues/1771">1771</a>所记录，这种默认行为可能会导致在关闭S2（以及使用旧版本的<strong>sf</strong>）时可以运行的代码失败。<br>
这些边缘情况包括对不符合S2更严格定义的多边形的操作。<br>
如果你看到像<code>#&gt; Error in s2_geography_from_wkb ...</code>这样的错误消息，关闭S2后再尝试生成错误消息的命令可能是值得的。<br>
要在整个项目中关闭S2，你可以在项目的根目录（主文件夹）中创建一个名为.Rprofile的文件，其中包含命令<code>sf::sf_use_s2(FALSE)</code>。</p>
</blockquote>
<h2 id="栅格数据">栅格数据</h2>
<p>空间栅格数据模型用连续的单元格网格（通常也称为像素；图2.13-A）来表示世界。这种数据模型通常指的是所谓的规则网格，其中每个单元格具有相同的、恒定的大小——在这本书中，我们只会关注规则网格。然而，还存在几种其他类型的网格，包括旋转的、剪切的、直线的和曲线的网格（参见Pebesma and Bivand（2022）的第1章或Tennekes and Nowosad (2022)的第2章）。</p>
<p>栅格数据模型通常由一个栅格头和一个矩阵（带有行和列）组成，该矩阵表示等间隔的单元格（通常也称为像素，图2.13-A）。^[根据文件格式，头部是实际图像数据文件的一部分，例如GeoTIFF，或存储在一个额外的头部或世界文件中，例如ASCII网格格式。还有无头（平面）二进制栅格格式，应便于导入到各种软件程序中。]栅格头定义了坐标参考系统、范围和原点。原点（或起点）通常是矩阵左下角的坐标（然而，<strong>terra</strong>包默认使用左上角，图2.13-B）。头通过列数、行数和单元格大小分辨率来定义范围。因此，从原点开始，我们可以通过使用单元格的ID或通过明确指定行和列来轻松访问和修改每个单个单元格（图2.13-B）。这种矩阵表示法避免了明确存储每个单元格角的四个角点的坐标（实际上它只存储一个坐标，即原点），就像矩形矢量多边形的情况那样。这一点和地图代数（见第4.3.2节）使栅格处理比矢量数据处理更高效、更快。然而，与矢量数据相比，一个栅格层的单元格只能容纳一个值。该值可能是数值或分类的（图2.13-C）。</p>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309020024034.png" alt=""><br>
图2.13：Raster data types: (A) cell IDs, (B) cell values, © a colored raster map.</p>
<p>栅格地图通常表示连续的现象，如海拔、温度、人口密度或光谱数据。离散特征，如土壤或土地覆盖类别，也可以在栅格数据模型中表示。栅格数据集的这两种用途都在图2.14中有所说明，该图显示了离散特征的边界在栅格数据集中可能会变得模糊。根据应用的性质，离散特征的矢量表示可能更为合适。</p>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309020025749.png" alt=""><br>
图2.14：Examples of continuous and categorical rasters.</p>
<h3 id="处理栅格数据的R包">处理栅格数据的R包</h3>
<p>在过去的二十年里，已经开发了几个用于读取和处理栅格数据集的包。如第1.5节所示其中最主要的是<strong>raster</strong>，它在2010年推出后使R的栅格处理能力发生了质的飞跃，并一直是这一领域的主要包，直到<strong>terra</strong>和<strong>stars</strong>的开发。这两个较新开发的包都提供了强大和高效的函数，用于处理栅格数据集，并且它们可能的用例之间有很大的重叠。在本书中，我们将重点介绍<strong>terra</strong>，它取代了较旧且（在大多数情况下）较慢的<strong>raster</strong>。在了解<strong>terra</strong>的类系统如何工作之前，本节将描述<strong>terra</strong>和<strong>stars</strong>之间的相似性和差异；这些知识将有助于决定在不同情况下哪个更合适。</p>
<p>首先，<strong>terra</strong>专注于最常见的栅格数据模型（规则网格），而<strong>stars</strong>还允许存储较不流行的模型（包括规则的、旋转的、剪切的、直线的和曲线的网格）。虽然<strong>terra</strong>通常处理一个或多层的栅格^[它还有一个额外的类<code>SpatRasterDataset</code>，用于存储许多数据集的集合。]，<strong>stars</strong>包提供了存储栅格数据立方体的方法——一个具有多层（例如，波段）、多个时间点（例如，月份）和多个属性（例如，传感器类型A和传感器类型B）的栅格对象。重要的是，在这两个包中，所有层或数据立方体的元素都必须具有相同的空间尺寸和范围。其次，这两个包都允许将所有栅格数据读入内存，或者只读取其元数据——这通常是根据输入文件大小自动完成的。然而，它们存储栅格值的方式非常不同。<strong>terra</strong>基于C++代码，主要使用C++指针。<strong>stars</strong>将值存储为较小栅格的数组列表或较大栅格的文件路径。第三，<strong>stars</strong>的函数与<strong>sf</strong>中的矢量对象和函数密切相关，而<strong>terra</strong>使用其自己的矢量数据对象类，即<code>SpatVector</code>。第四，这两个包对各种函数如何作用于它们的对象有不同的方法。<strong>terra</strong>包主要依赖于大量的内置函数，其中每个函数都有一个特定的目的（例如，重新采样或裁剪）。另一方面，<strong>stars</strong>使用一些内置函数（通常名称以<code>st_</code>开头），有其自己的现有R函数（例如，<code>split()</code>或<code>aggregate()</code>）的方法，以及现有的<strong>dplyr</strong>函数（例如，<code>filter()</code>或<code>slice()</code>）的方法。</p>
<p>重要的是，将对象从<strong>terra</strong>转换为<strong>stars</strong>（使用<code>st_as_stars()</code>）以及反过来（使用<code>rast()</code>）都是非常简单的。我们还鼓励您阅读@pebesma_spatial_2022，以获得对<strong>stars</strong>包最全面的介绍。</p>
<h3 id="terra包介绍">terra包介绍</h3>
<p><strong>terra</strong>包在R中支持栅格对象。与其前身<strong>raster</strong>（由同一开发者Robert Hijmans创建）一样，它提供了一整套广泛的函数，用于创建、读取、导出、操作和处理栅格数据集<strong>terra</strong>的功能在很大程度上与更成熟的<strong>raster</strong>包相同，但也有一些差异：<strong>terra</strong>的函数通常比<strong>raster</strong>的等效函数更具计算效率。另一方面，<strong>raster</strong>的类系统很受欢迎，并被许多其他包使用。您可以无缝地在这两种类型的对象之间进行转换，以确保与旧脚本和包的向后兼容性，例如，使用<strong>raster</strong>包中的<a href="https://rspatial.github.io/raster/reference/raster.html"><code>raster()</code></a>、<a href="https://rspatial.github.io/raster/reference/stack.html"><code>stack()</code></a>和<code>brick()</code>函数（有关使用地理数据的R包演变的更多信息，请参见前一章）。</p>
<p>除了用于栅格数据操作的函数外，<strong>terra</strong>还提供了许多低级函数，这些函数可以作为开发用于处理栅格数据集的新工具的基础。<strong>terra</strong>还允许您处理过大以至于无法装入主内存的大型栅格数据集。在这种情况下，<strong>terra</strong>提供了将栅格划分为更小块的可能性，并迭代地处理这些块，而不是将整个栅格文件加载到RAM中。</p>
<p>为了说明<strong>terra</strong>的概念，我们将使用<strong>spDataLarge</strong>中的数据集。它包括几个栅格对象和一个覆盖锡安国家公园（美国犹他州）地区的矢量对象。例如，<code>srtm.tif</code>是该地区的数字高程模型（有关更多详细信息，请参见其文档<code>?srtm</code>）。首先，让我们创建一个名为<code>my_rast</code>的<code>SpatRaster</code>对象：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">raster_filepath <span class="operator">=</span> system.file<span class="punctuation">(</span><span class="string">&quot;raster/srtm.tif&quot;</span><span class="punctuation">,</span> package <span class="operator">=</span> <span class="string">&quot;spDataLarge&quot;</span><span class="punctuation">)</span></span><br><span class="line">my_rast <span class="operator">=</span> rast<span class="punctuation">(</span>raster_filepath<span class="punctuation">)</span></span><br><span class="line"><span class="built_in">class</span><span class="punctuation">(</span>my_rast<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] &quot;SpatRaster&quot;</span></span><br><span class="line"><span class="comment">#&gt; attr(,&quot;package&quot;)</span></span><br><span class="line"><span class="comment">#&gt; [1] &quot;terra&quot;</span></span><br></pre></td></tr></table></figure>
<p>在控制台中输入栅格的名称，将打印出栅格头部信息（尺寸、分辨率、范围、坐标参考系统）以及一些额外信息（类别、数据源、栅格值的摘要）。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">my_rast</span><br><span class="line"><span class="comment">#&gt; class       : SpatRaster </span></span><br><span class="line"><span class="comment">#&gt; dimensions  : 457, 465, 1  (nrow, ncol, nlyr)</span></span><br><span class="line"><span class="comment">#&gt; resolution  : 0.000833, 0.000833  (x, y)</span></span><br><span class="line"><span class="comment">#&gt; extent      : -113, -113, 37.1, 37.5  (xmin, xmax, ymin, ymax)</span></span><br><span class="line"><span class="comment">#&gt; coord. ref. : lon/lat WGS 84 (EPSG:4326) </span></span><br><span class="line"><span class="comment">#&gt; source      : srtm.tif </span></span><br><span class="line"><span class="comment">#&gt; name        : srtm </span></span><br><span class="line"><span class="comment">#&gt; min value   : 1024 </span></span><br><span class="line"><span class="comment">#&gt; max value   : 2892</span></span><br></pre></td></tr></table></figure>
<p>专用函数报告每个组件：<code>dim()</code>返回行数、列数和图层数；<code>ncell()</code>返回单元格（像素）数；<code>res()</code>返回空间分辨率；<code>ext()</code>返回其空间范围；<code>crs()</code>返回其坐标参考系统。<code>inMemory()</code>报告栅格数据是存储在内存中还是磁盘上。</p>
<p><code>help(&quot;terra-package&quot;)</code>返回所有可用的<strong>terra</strong>函数的完整列表。</p>
<h3 id="绘制基础栅格地图">绘制基础栅格地图</h3>
<p>与<strong>sf</strong>包类似，<strong>terra</strong>也为其自己的类提供了<code>plot()</code>方法。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">plot<span class="punctuation">(</span>my_rast<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309020028094.png" alt=""><br>
图2.15：Basic raster plot.</p>
<p>还有几种在R中绘制栅格数据的方法，这些方法不在本节的讨论范围内，包括：</p>
<ul>
<li>来自<strong>terra</strong>包的<code>plotRGB()</code>函数，用于基于<code>SpatRaster</code>对象中的三个图层创建<em>红-绿-蓝图</em>。</li>
<li>诸如<strong>tmap</strong>之类的包，用于创建栅格和矢量对象的静态和交互式地图（参见第<a href="/2023/08/18/2023-8-18-9%E5%9C%B0%E7%90%86%E6%95%B0%E6%8D%AE%E5%88%B6%E5%9B%BE/" title="(9)地理数据制图">9</a>章）。</li>
<li>函数，例如来自<strong>rasterVis</strong>包的<code>levelplot()</code>，用于创建分面图，这是一种常用于可视化随时间变化的技术。</li>
</ul>
<h3 id="栅格类">栅格类</h3>
<p><code>SpatRaster</code>类在<strong>terra</strong>中代表栅格对象。在R中创建栅格对象的最简单方法是从磁盘或服务器中读入一个栅格文件（第8.6.2章）。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">single_raster_file <span class="operator">=</span> system.file<span class="punctuation">(</span><span class="string">&quot;raster/srtm.tif&quot;</span><span class="punctuation">,</span> package <span class="operator">=</span> <span class="string">&quot;spDataLarge&quot;</span><span class="punctuation">)</span></span><br><span class="line">single_rast <span class="operator">=</span> rast<span class="punctuation">(</span>raster_filepath<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><strong>terra</strong> 包在 GDAL 库的帮助下支持众多的驱动程序。文件中的栅格通常不会完全读入RAM，除了它们的头部和指向文件本身的指针。</p>
<p>也可以使用相同的 <code>rast()</code> 函数从零开始创建栅格。这在后续的代码块中有所展示，该代码块生成一个新的 <code>SpatRaster</code> 对象。生成的栅格包含36个单元格（由 <code>nrows</code> 和 <code>ncols</code> 指定的6列和6行），围绕本初子午线和赤道居中（参见 <code>xmin</code>、<code>xmax</code>、<code>ymin</code> 和 <code>ymax</code> 参数）。值（<code>vals</code>）被分配给每个单元格：1分配给单元格1，2分配给单元格2，依此类推。记住：<code>rast()</code> 按行填充单元格（与 <code>matrix()</code> 不同），从左上角开始，这意味着顶行包含值1至6，第二行包含值7至12，等等。有关创建栅格对象的其他方法，请参见 <code>?rast</code>。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">new_raster <span class="operator">=</span> rast<span class="punctuation">(</span>nrows <span class="operator">=</span> <span class="number">6</span><span class="punctuation">,</span> ncols <span class="operator">=</span> <span class="number">6</span><span class="punctuation">,</span> </span><br><span class="line">                  xmin <span class="operator">=</span> <span class="operator">-</span><span class="number">1.5</span><span class="punctuation">,</span> xmax <span class="operator">=</span> <span class="number">1.5</span><span class="punctuation">,</span> ymin <span class="operator">=</span> <span class="operator">-</span><span class="number">1.5</span><span class="punctuation">,</span> ymax <span class="operator">=</span> <span class="number">1.5</span><span class="punctuation">,</span></span><br><span class="line">                  vals <span class="operator">=</span> <span class="number">1</span><span class="operator">:</span><span class="number">36</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>给定行数和列数以及范围（<code>xmin</code>、<code>xmax</code>、<code>ymin</code>、<code>ymax</code>），分辨率必须为0.5。分辨率的单位是底层 CRS 的单位。在这里，它是度数，因为栅格对象的默认 CRS 是 WGS84。然而，可以用 <code>crs</code> 参数指定任何其他 CRS。</p>
<p><code>SpatRaster</code> 类还处理多个图层，这些图层通常对应于一个单一的多光谱卫星文件或一系列的栅格。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">multi_raster_file <span class="operator">=</span> system.file<span class="punctuation">(</span><span class="string">&quot;raster/landsat.tif&quot;</span><span class="punctuation">,</span> package <span class="operator">=</span> <span class="string">&quot;spDataLarge&quot;</span><span class="punctuation">)</span></span><br><span class="line">multi_rast <span class="operator">=</span> rast<span class="punctuation">(</span>multi_raster_file<span class="punctuation">)</span></span><br><span class="line">multi_rast</span><br><span class="line"><span class="comment">#&gt; class       : SpatRaster </span></span><br><span class="line"><span class="comment">#&gt; dimensions  : 1428, 1128, 4  (nrow, ncol, nlyr)</span></span><br><span class="line"><span class="comment">#&gt; resolution  : 30, 30  (x, y)</span></span><br><span class="line"><span class="comment">#&gt; extent      : 301905, 335745, 4111245, 4154085  (xmin, xmax, ymin, ymax)</span></span><br><span class="line"><span class="comment">#&gt; coord. ref. : WGS 84 / UTM zone 12N (EPSG:32612) </span></span><br><span class="line"><span class="comment">#&gt; source      : landsat.tif </span></span><br><span class="line"><span class="comment">#&gt; names       : landsat_1, landsat_2, landsat_3, landsat_4 </span></span><br><span class="line"><span class="comment">#&gt; min values  :      7550,      6404,      5678,      5252 </span></span><br><span class="line"><span class="comment">#&gt; max values  :     19071,     22051,     25780,     31961</span></span><br></pre></td></tr></table></figure>
<p><code>nlyr()</code>用于获取存储在<code>SpatRaster</code>对象中的图层数量：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">nlyr<span class="punctuation">(</span>multi_rast<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] 4</span></span><br></pre></td></tr></table></figure>
<p>对于多层栅格对象，可以使用<code>terra::subset()</code>来选择图层。^[<code>[[</code> 和 <code>$</code> 操作符也可以用来选择图层，例如通过命令<code>multi_rast$landsat_1</code>和<code>multi_rast[[&quot;landsat_1&quot;]]</code>。]它接受图层编号或其名称作为第二个参数：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">multi_rast3 <span class="operator">=</span> subset<span class="punctuation">(</span>multi_rast<span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">)</span></span><br><span class="line">multi_rast4 <span class="operator">=</span> subset<span class="punctuation">(</span>multi_rast<span class="punctuation">,</span> <span class="string">&quot;landsat_4&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>相反的操作，即将多个<code>SpatRaster</code>对象合并为一个，可以使用<code>c</code>函数来完成：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">multi_rast34 <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span>multi_rast3<span class="punctuation">,</span> multi_rast4<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>📌大多数<code>SpatRaster</code>对象并不存储栅格值，而是存储指向文件本身的指针。<br>
这有一个显著的副作用——它们不能直接保存为<code>&quot;.rds&quot;</code>或<code>&quot;.rda&quot;</code>文件，也不能用于集群计算。<br>
在这些情况下，有两种可能的解决方案：（1）使用<code>wrap()</code>函数，该函数创建一种特殊类型的临时对象，该对象可以作为R对象保存或用于集群计算；（2）使用<code>writeRaster()</code>将对象保存为常规栅格。</p>
</blockquote>
<!--jn:toDo-->
<!--consider new section with other data models-->
<!-- e.g. point clouds, data cubes, meshes, etc. -->
<h2 id="地理、投影坐标参考系">地理、投影坐标参考系</h2>
<p>矢量和栅格空间数据类型共享空间数据本质上的概念。其中最基础的概念便是坐标参照系统（CRS），它定义了数据的空间元素与地球（或其他天体）表面的关系。CRS分为地理或投影两种，正如本章开头所介绍。本节解释每种类型，为后面章节奠定基础，该章将深入讨论设置、转换和查询CRS。</p>
<h3 id="地理坐标系">地理坐标系</h3>
<p>地理坐标系统使用两个值——经度和纬度来标识地球表面上的任何位置（见图2.17）。<em>经度</em> 是从本初子午线平面到东西方向的角距离。<em>纬度</em> 是从赤道平面向北或向南的角距离。因此，地理CRS中的距离不是以米为单位度量的这有重要的影响，如第<a href="/2023/08/16/2023-8-16-7%E5%9C%B0%E7%90%86%E6%95%B0%E6%8D%AE%E9%87%8D%E6%8A%95%E5%BD%B1/" title="(7)地理数据重投影">7</a>章所示。</p>
<p>在地理坐标系统中，地球表面由球体或椭球体表面表示。球体模型假设地球是一个给定半径的完美球体——它们具有简单性的优点，但同时也是不准确的：地球不是一个球体！椭球体模型由两个参数定义：赤道半径和极半径。这些是合适的，因为地球是压缩的：赤道半径比极半径长约11.5公里。^[压缩的程度通常被称为 <em>扁平度</em>，用赤道半径（$a$）和极半径（$b$）来定义：$f = (a - b) / a$。术语 <em>椭圆度</em> 和 <em>压缩</em> 也可以使用。由于 $f$ 是一个相当小的值，数字椭球体模型使用 ‘逆扁平度’（$rf = 1/f$）来定义地球的压缩。通过执行 <code>sf_proj_info(type = &quot;ellps&quot;)</code>，可以看到各种椭球体模型中的 $a$ 和 $rf$ 的值。]</p>
<p>椭球体是CRSs的一个更广泛组成部分：<em>基准</em>。这包含有关使用哪个椭球体以及笛卡尔坐标和地球表面位置之间精确关系的信息。有两种类型的基准——地心（如 <code>WGS84</code>）和局部（如 <code>NAD83</code>）。图2.16中可以看到这两种基准的示例。黑线代表一个 <em>地心基准</em>，其中心位于地球重力中心，没有针对特定位置进行优化。在 <em>局部基准</em> 中，如紫色虚线所示，椭球体表面被移动以与特定位置的表面对齐。这允许局部CRS考虑地球表面的局部变化，例如由于大山脉造成的。这可以在图中看到，其中局部基准适合于菲律宾地区，但与地球表面的大部分其他区域不对齐。图2.16中的两个基准都放置在一个大地水准面（geoid）之上——一个全球平均海平面的模型。^[请注意，图中的大地水准面通过放大因子10,000来夸大了大地水准面的凹凸不平表面，以突出地球的不规则形状。]</p>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309020033471.png" alt=""><br>
图2.16：地心和局部大地基准显示在大地水准面之上（以错误的颜色和垂直夸张的10,000倍比例因子）。大地水准面的图像改编自 @essd-11-647-2019 的作品。</p>
<h3 id="投影坐标系">投影坐标系</h3>
<p>所有的投影坐标系统（Projected CRSs）都基于前一节中描述的地理坐标系统，并依赖于地图投影将地球的三维表面转换为投影坐标系统中的东坐标和北坐标（x和y值）。投影坐标系统基于笛卡尔坐标，在一个隐含的平面表面上（见图2.17的右侧面板）。它们有一个原点、x和y轴，以及一个如米这样的线性度量单位。</p>
<p>这种转换不能在不添加一些形变的情况下完成。因此，在这个过程中，地球表面的一些属性会被扭曲，比如面积、方向、距离和形状。一个投影坐标系统只能保留这些属性中的一个或两个。投影通常根据它们保留的属性来命名：等面积投影保留面积，方位投影保留方向，等距投影保留距离，和保角投影保留局部形状。</p>
<p>有三大主要的投影类型——圆锥投影、圆柱投影和平面投影（方位投影）。在一个圆锥投影中，地球表面被投影到一个沿着一个或两个切线的圆锥上。在这种投影中，扭曲是沿着切线最小化的，并且随着与这些线的距离增加而增加。因此，它最适合用于中纬度地区的地图。圆柱投影将表面映射到一个圆柱上。这种投影也可以通过沿着一个或两个切线与地球表面接触来创建。圆柱投影最常用于整个世界的制图。平面投影将数据投影到一个与地球在一个点或沿一个切线接触的平面上。它通常用于极地地区的制图。使用<code>sf_proj_info(type = &quot;proj&quot;)</code>可以获得PROJ库支持的可用投影的列表。</p>
<p>关于不同投影、它们的类型、属性和适用性的快速概要可以在 “Map Projections”（1993）和 <a href="https://www.geo-projections.com/">https://www.geo-projections.com/</a> 上找到。我们将在后面章节中详细讨论坐标参照系统（CRSs）并解释如何从一个CRS投影到另一个CRS（见第<a href="/2023/08/16/2023-8-16-7%E5%9C%B0%E7%90%86%E6%95%B0%E6%8D%AE%E9%87%8D%E6%8A%95%E5%BD%B1/" title="(7)地理数据重投影">7</a>章）。目前，足够了解：</p>
<ul>
<li>坐标系统是地理对象的一个关键组成部分</li>
<li>知道你的数据处于哪种CRS中，以及它是在地理坐标（经/纬度）还是投影坐标（通常是米）中，对于R如何处理空间和几何操作是重要的</li>
<li><code>sf</code> 对象的CRS可以使用 <code>st_crs()</code> 函数查询，<code>terra</code> 对象的CRS可以使用 <code>crs()</code> 函数查询。</li>
</ul>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309020036403.png" alt=""><br>
图2.17：Examples of geographic (WGS 84; left) and projected (NAD83 / UTM zone 12N; right) coordinate systems for a vector data type.</p>
<h2 id="单位">单位</h2>
<!--rl-->
<!-- https://cran.r-project.org/web/packages/units/vignettes/measurement_units_in_R.html -->
<p>坐标参考系统（CRS）的一个重要特点是它们包含有关空间单位的信息。很明显，知道一个房屋的测量单位是英尺还是米是至关重要的，地图也同样如此。在地图上添加<em>比例尺</em>或其他距离指示器是良好的制图实践，以展示页面或屏幕上的距离与地面上的距离之间的关系。同样，正式指定几何数据或单元格以何种单位进行测量也是重要的，以提供上下文，并确保后续的计算是在这一上下文中进行的。</p>
<p><code>sf</code>对象中的几何数据有一个新颖的特点，即它们对单位有<em>原生支持</em>。这意味着在<strong>sf</strong>中进行的距离、面积和其他几何计算返回的值附带有一个由<strong>units</strong>软件包定义的<code>units</code>属性。这是有利的，因为它防止了由于不同单位（大多数CRS使用米，一些使用英尺）引起的混淆，并提供了有关尺寸的信息。下面的代码块演示了如何计算卢森堡的面积：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">luxembourg <span class="operator">=</span> world<span class="punctuation">[</span>world<span class="operator">$</span>name_long <span class="operator">==</span> <span class="string">&quot;Luxembourg&quot;</span><span class="punctuation">,</span> <span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">st_area<span class="punctuation">(</span>luxembourg<span class="punctuation">)</span> <span class="comment"># requires the s2 package in recent versions of sf</span></span><br><span class="line"><span class="comment">#&gt; 2.41e+09 [m^2]</span></span><br></pre></td></tr></table></figure>
<p>输出的单位是平方米（m^2^），显示该结果表示二维空间。这些信息存储为一个属性（有兴趣的读者可以通过<code>attributes(st_area(luxembourg))</code>来发现这一点），可以用于后续使用单位的计算，例如人口密度（通常以每平方千米的人数来衡量）。报告单位可以防止混淆。以卢森堡为例，如果单位保持未指定，人们可能错误地假设单位是公顷。为了将这个巨大的数字转换为更易消化的大小，人们可能会受到将结果除以一百万（一个平方千米中的平方米数量）的诱惑：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">st_area<span class="punctuation">(</span>luxembourg<span class="punctuation">)</span> <span class="operator">/</span> <span class="number">1000000</span></span><br><span class="line"><span class="comment">#&gt; 2409 [m^2]</span></span><br></pre></td></tr></table></figure>
<p>然而，结果再次错误地以平方米为单位给出。解决方案是使用 <strong>units</strong> 包来设置正确的单位：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">units<span class="operator">::</span>set_units<span class="punctuation">(</span>st_area<span class="punctuation">(</span>luxembourg<span class="punctuation">)</span><span class="punctuation">,</span> km<span class="operator">^</span><span class="number">2</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; 2409 [km^2]</span></span><br></pre></td></tr></table></figure>
<p>在栅格数据的情况下，单位同样非常重要。然而，到目前为止，<strong>sf</strong> 是唯一支持单位的空间包，这意味着处理栅格数据的人应该谨慎地处理单位变换（例如，将像素宽度从英制单位转换为十进制单位）。<code>my_rast</code> 对象（见上文）使用的是WGS84投影，单位是十进制度。因此，其分辨率也以十进制度给出，但你需要知道它，因为 <code>res()</code> 函数仅返回一个数值向量。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">res<span class="punctuation">(</span>my_rast<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] 0.000833 0.000833</span></span><br></pre></td></tr></table></figure>
<p>如果我们使用UTM（通用横轴墨卡托）投影，单位会发生变化。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">repr <span class="operator">=</span> project<span class="punctuation">(</span>my_rast<span class="punctuation">,</span> <span class="string">&quot;EPSG:26912&quot;</span><span class="punctuation">)</span></span><br><span class="line">res<span class="punctuation">(</span>repr<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] 83.5 83.5</span></span><br></pre></td></tr></table></figure>
<p>再次强调，<code>res()</code> 命令返回的是一个没有任何单位的数值向量，这就迫使我们必须知道UTM投影的单位是米。</p>
<h2 id="练习">练习</h2>
<p>E1. 在<strong>spData</strong>包中包含的<code>world</code>数据对象的几何列上使用<code>summary()</code>。输出告诉我们关于：</p>
<ul>
<li>它的几何类型是什么？</li>
<li>有多少个国家？</li>
<li>它的坐标参考系统（CRS）是什么？</li>
</ul>
<p>E2. 运行在2.2.3节（基础地图制作）中“生成”世界地图的代码。<br>
找出你电脑上的图像与书中的图像之间的两个相似点和两个不同点。</p>
<ul>
<li><code>cex</code>参数是做什么用的（参见<code>?plot</code>）？</li>
<li>为什么<code>cex</code>被设置为<code>sqrt(world$pop) / 10000</code>？</li>
<li>奖励：尝试用不同的方式可视化全球人口。</li>
</ul>
<p>E3. 使用<code>plot()</code>创建尼日利亚的上下文地图（参见2.2.3节）。</p>
<ul>
<li>调整<code>plot()</code>的<code>lwd</code>、<code>col</code>和<code>expandBB</code>参数。</li>
<li>挑战：阅读<code>text()</code>的文档并标注地图。</li>
</ul>
<p>E4. 创建一个名为<code>my_raster</code>的空<code>SpatRaster</code>对象，具有10列和10行。<br>
为新的光栅分配0到10之间的随机值并绘制它。</p>
<p>E5. 从<strong>spDataLarge</strong>包中读取<code>raster/nlcd.tif</code>文件。<br>
你能从这个文件的属性中获取哪些信息？</p>
<p>E6. 检查来自<strong>spDataLarge</strong>包的<code>raster/nlcd.tif</code>文件的CRS。<br>
你能从中了解到哪些信息？</p>
]]></content>
      <categories>
        <category>R</category>
        <category>Geocomputaion</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>Geocomputaion</tag>
      </tags>
  </entry>
  <entry>
    <title>(3)属性操作</title>
    <url>/2023/08/12/2023-8-12-3%E5%B1%9E%E6%80%A7%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<blockquote><p>本文由SCY翻译自《Geocomputation with R》<a href="https://r.geocompx.org/attr">第三章</a></p>
</blockquote>
<p>本章讲授如何基于属性来操作地理对象，例如矢量数据集中的公交站名和栅格数据集中像素的高程。对于矢量数据，意味着应用例如<code>subsetting</code>和<code>aggregation</code>方法（参见矢量属性提取子集和矢量属性聚合章节）。和创建属性移除空间信息章节演示了如何通过共享<strong>ID</strong>将数据连接到简单要素对象以及如何创建新变量。这些操作都有空间等效功能：例如，基于属性和空间对象的<code>subsetting</code>操作都可以使用R中的<code>[</code>运算符；您还可以使用<code>spatial joins</code>将两个地理数据集的属性进行连接。本章所培养的技能具有交叉传递性。<em>空间数据操作</em>章节将本章介绍的方法扩展到空间方面。</p>
<span id="more"></span>
<h1>前提条件</h1>
<ul>
<li>本章要求安装并且连接以下包：</li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>sf<span class="punctuation">)</span> </span><br><span class="line">library<span class="punctuation">(</span>terra<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>dplyr<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>依赖于 <strong>spData</strong> 包，该包装载了本章代码示例所使用的数据集：</li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>spData<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>另外，如果您希望在栅格数据汇总章节中运行数据&quot;整理&quot;操作，请确保已安装了<strong>tidyr</strong>包，或者安装了其所属的<strong>tidyverse</strong>包。</li>
</ul>
<h1>引言</h1>
<p>属性数据是与地理（几何）数据相关联的非空间信息。公共汽车站提供了一个简单的例子：除了名称之外，它的位置通常用经纬度坐标(几何数据)来表示。例如，位于伦敦<a href="https://www.openstreetmap.org/relation/6610626" title="Elephant &amp; Castle / New Kent Road">Elephant &amp; Castle / New Kent Road</a> 站的坐标为：经度 -0.098和纬度 51.495，在<em>空间数据类型</em>章节描述的 <code>sfc</code>表示中可以表示为<code>POINT (-0.098 51.495)</code>。诸如点属性的<code>name</code>属性（使用 Simple Features 术语）之类的属性是本章的主题。</p>
<p>另一个示例是栅格数据中特定网格单元的海拔值（属性）。与矢量数据模型不同，栅格数据模型间接存储了网格单元的坐标，这意味着属性和空间信息之间的区分不太清晰。为了阐明这一观点，可以想象一下栅格矩阵中第3行第4列的像素点。其空间位置由其在矩阵中的索引确定：在<code>x</code>方向上从原点向右（通常是东方和地图上的右方）移动四个单元格，在<code>y</code>方向上从原点向下（通常是南方和向下）移动三个单元格。栅格的分辨率定义了每个<code>x</code>和<code>y</code>步的距离，这些距离在头部文件中指定。头部文件是栅格数据集的关键组成部分，它指定了像素与地理坐标的关系（另见<em>空间数据操作</em>章节）。</p>
<p>本章讲授如何基于属性来操作地理对象，例如矢量数据集中的公交站名和栅格数据集中像素的高程。对于矢量数据，意味着应用例如<code>subsetting</code>和<code>aggregation</code>方法（参见矢量属性提取子集和矢量属性聚合章节。）和创建属性移除空间信息章节演示了如何通过共享<strong>ID</strong>将数据连接到简单要素对象以及如何创建新变量。这些操作都有空间等效功能：例如，基于属性和空间对象的<code>subsetting</code>操作都可以使用R中的<code>[</code>运算符；您还可以使用<code>spatial joins</code>将两个地理数据集的属性进行连接。本章所培养的技能具有交叉传递性。<em>空间数据操作</em>章节将本章介绍的方法扩展到空间方面。</p>
<p>在下一节深入探讨各种类型的<strong>矢量属性</strong>操作后，栅格数据操作章节介绍了<strong>栅格属性</strong>数据操作，演示了如何创建包含连续和分类属性的栅格图层，并从一个或多个图层中提取单元格的值（栅格子集）。栅格数据汇总章节提供了<strong>全局</strong>栅格操作的概述，这些操作可以用于总结整个栅格数据集。</p>
<h1>矢量数据操作</h1>
<p>地理矢量数据集在R中得到了很好的支持，这得益于<code>sf</code>类的出现，它是基于R的<code>data.frame</code>进行扩展的。与数据框类似，<code>sf</code>对象每列都有一个属性变量（例如&quot;name&quot;），每行代表一个观测值或<code>feature</code>（例如每个公交车站）。与基本数据框不同的是，<code>sf</code>对象具有一个<strong>几何列</strong>，其类型为<code>sfc</code>，每个行可以包含多个地理实体（单个和&quot;多&quot;点，线，多边形要素）。<em>空间类</em>中进行了描述，演示了<code>plot()</code>和<code>Summary()</code>等<strong>通用</strong>方法是如何处理<code>sf</code>对象的。<code>sf</code>还提供了<strong>通用方法</strong>，允许<code>sf</code>对象像常规数据框一样运行，如<em>打印</em><strong>类</strong>的方法所示：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">methods<span class="punctuation">(</span><span class="built_in">class</span> <span class="operator">=</span> <span class="string">&quot;sf&quot;</span><span class="punctuation">)</span> </span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#&gt; [1] [             [[&lt;-          $&lt;-           aggregate    </span></span><br><span class="line"><span class="comment">#&gt; [5] as.data.frame cbind         coerce        filter       </span></span><br><span class="line"><span class="comment">#&gt; [9] identify      initialize    merge         plot        </span></span><br></pre></td></tr></table></figure>
<p>其中许多函数（<code>aggregate()</code>，<code>cbind()</code>，<code>merge()</code>，<code>rbind()</code>和<code>[</code>）用于操作数据框。例如，<code>rbind()</code>会将数据框的行&quot;一上一下&quot;连接在一起。<code>$</code><br>
<code>&lt;-</code>可以创建新的列。<code>sf</code> 对象的一个重要特征是它们以相同的方式将<strong>空间数据</strong>和<strong>非空间数据</strong>存储为<code>data.frame</code>中的列。</p>
<blockquote>
<p>📌对象的几何列通常称为<code>geometry</code>或<code>geom</code>，但可以使用任何名称。例<br>
如，下面的命令创建了一个名为<code>g</code>的几何列: <code>st_sf(data.frame(n = world$name_long), g = world$geom)</code> 这使得从空间数据库导入的几何图形具有多种名称，如<code>wkb_geometry</code>和<code>The_geom</code>。</p>
</blockquote>
<p><code>sf</code>对象对于数据框可以扩展<code>tidyverse</code>类，<code>tbl_df</code>和<code>tbl</code>。因此，无论您使用基础R还是tidyverse函数进行数据分析，<code>sf</code>都可以释放R数据分析能力对地理数据的全部威力。<br>
<code>sf</code>对象还可以与高性能数据处理软件包<code>data.table</code>一起使用，尽管文献中有记载说明，它与<code>sf</code>对象不完全兼容，<a href="https://github.com/Rdatatable/data.table/issues/2273" title="Rdatatable/data.table#2273">Rdatatable/data.table#2273</a>。在使用这些功能之前，回顾怎样探索矢量数据对象的基本属性。让我们开始使用基本R函数来了解从 <strong>spData</strong> 软件包中的<code>world</code>数据集：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="built_in">class</span><span class="punctuation">(</span>world<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] &quot;sf&quot;         &quot;tbl_df&quot;     &quot;tbl&quot;        &quot;data.frame&quot;</span></span><br><span class="line"><span class="built_in">dim</span><span class="punctuation">(</span>world<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] 177  11</span></span><br></pre></td></tr></table></figure>
<p><code>world</code>含有十个非地理列（以及一个几何列表列），共有近200行代表各个世界国家。函数<code>st_drop_geometry()</code>可保留仅为<code>sf</code>对象的属性数据，也就是删除其几何学属性：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">world_df <span class="operator">=</span> st_drop_geometry<span class="punctuation">(</span>world<span class="punctuation">)</span></span><br><span class="line"><span class="built_in">class</span><span class="punctuation">(</span>world_df<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] &quot;tbl_df&quot;     &quot;tbl&quot;        &quot;data.frame&quot;</span></span><br><span class="line">ncol<span class="punctuation">(</span>world_df<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] 10</span></span><br></pre></td></tr></table></figure>
<p>在使用属性数据之前，删除几何列可能会很有用；当数据处理过程仅涉及属性数据时，处理速度可以更快，并且不一定总需要几何列。然而，在大多数情况下，保留几何列是有意义的，解释为什么几何列具有&quot;粘性&quot;（大多数属性操作之后仍然存在，除非特别删除。）。在<code>sf</code>对象上进行非空间数据操作仅在适当时更改对象的几何结构（例如，在聚合后消除相邻多边形之间的边界）。掌握地理属性数据操作技能意味着掌握操作数据框的技能。</p>
<p>对于许多应用程序来说，tidyverse中的<strong>dplyr</strong> 包为处理数据框提供了有效的方法。与其前身<strong>sp</strong>相比，<strong>sf</strong>具有<strong>tidyverse</strong>兼容性的优势，但需要避免一些陷阱（详情请参见 <a href="https://geocompx.github.io/geocompkg/articles/tidyverse-pitfalls.html" title="geocompx.org">geocompx.org</a> 上的补充<code>tidyverse-pitfalls</code>文献）。</p>
<h2 id="矢量属性提取子集">矢量属性提取子集</h2>
<p>基础R的子集提取方法包括<code>[</code>和<code>subset()</code>。在<strong>dplyr</strong>中，子集提取数据的关键函数是<code>filter()</code>和<code>slice()</code>用于子集提取行，而<code>select()</code>用于子集提取列。两<br>
种方法都可以保持 <code>sf</code>对象中属性数据的空间组件不变。然而，使用运算符<code>$</code>或<strong>dplyr</strong>函数<code>pull()</code>提取单个属性列作为向量会导致几何数据的丢失，我们将在后文中进一步阐述。本<br>
节重点关注如何对<code>sf</code>数据框进行子集提取，如果进一步了解如何对向量和非地理数据框进行子集提取，建议参考《An Introduction to R》第<a href="https://cran.r-project.org/doc/manuals/r-release/R-intro.html#Index-vectors" title="2.7">2.7</a> 节以及《Advanced R Programming》第<a href="https://adv-r.hadley.nz/subsetting.html" title="4">4</a>章。</p>
<p><code>[</code>操作符可以对行和列提取子集。方括号直接放在数据框对象名称之后，里面的索引指定要保留的元素。命令<code>object[i, j]</code>意味着：返回由<code>i</code>表示的行和由<code>j</code>表示的列，其中<code>i</code>和<code>j</code>通常包含整数或<code>TRUE</code>和<code>FALSE</code>（索引也可以是字符串，表示行或列名称）。例如，<code>object[5, 1:3]</code>意味着：返回包含第5行和第1到第3列的数据，结果应该是一个只有1行和3列的数据框，如果是<code>sf</code>对象，则还要包含第4个几何列。留下<code>i</code>或<code>j</code>为空会返回所有的行或列，因此<code>world[1:5, ]</code>返回前5行和所有11列。下面的示例演示了使用基本<strong>R</strong>进行子集提取的方法。猜测每个命令返回的<code>sf</code>数据框的行数和列数，并在自己的计算机上检查结果（更多练习请参见本章末尾）：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">world<span class="punctuation">[</span><span class="number">1</span><span class="operator">:</span><span class="number">6</span><span class="punctuation">,</span> <span class="punctuation">]</span>    <span class="comment"># 按位置提取行</span></span><br><span class="line">world<span class="punctuation">[</span><span class="punctuation">,</span> <span class="number">1</span><span class="operator">:</span><span class="number">3</span><span class="punctuation">]</span>    <span class="comment"># 按位置提取列</span></span><br><span class="line">world<span class="punctuation">[</span><span class="number">1</span><span class="operator">:</span><span class="number">6</span><span class="punctuation">,</span> <span class="number">1</span><span class="operator">:</span><span class="number">3</span><span class="punctuation">]</span> <span class="comment"># 按位置提取行和列</span></span><br><span class="line">world<span class="punctuation">[</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;name_long&quot;</span><span class="punctuation">,</span> <span class="string">&quot;pop&quot;</span><span class="punctuation">)</span><span class="punctuation">]</span> <span class="comment"># 按名称提取列</span></span><br><span class="line">world<span class="punctuation">[</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="built_in">T</span><span class="punctuation">,</span> <span class="built_in">T</span><span class="punctuation">,</span> <span class="built_in">F</span><span class="punctuation">,</span> <span class="built_in">F</span><span class="punctuation">,</span> <span class="built_in">F</span><span class="punctuation">,</span> <span class="built_in">F</span><span class="punctuation">,</span> <span class="built_in">F</span><span class="punctuation">,</span> <span class="built_in">T</span><span class="punctuation">,</span> <span class="built_in">T</span><span class="punctuation">,</span> <span class="built_in">F</span><span class="punctuation">,</span> <span class="built_in">F</span><span class="punctuation">)</span><span class="punctuation">]</span> <span class="comment"># 按逻辑索引提取</span></span><br><span class="line">world<span class="punctuation">[</span><span class="punctuation">,</span> <span class="number">888</span><span class="punctuation">]</span> <span class="comment"># 索引代表不存在的列</span></span><br></pre></td></tr></table></figure>
<p>下面的代码块演示了使用<code>logical</code>向量进行子集提取的实用性。这就创造了一个新的对象，<code>small_countries</code>，包括面积小于 10,000 $km^2$的国家:</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">i_small <span class="operator">=</span> world<span class="operator">$</span>area_km2 <span class="operator">&lt;</span> <span class="number">10000</span></span><br><span class="line">summary<span class="punctuation">(</span>i_small<span class="punctuation">)</span> <span class="comment"># 逻辑向量</span></span><br><span class="line"><span class="comment">#&gt;    Mode   FALSE    TRUE </span></span><br><span class="line"><span class="comment">#&gt; logical     170       7</span></span><br><span class="line">small_countries <span class="operator">=</span> world<span class="punctuation">[</span>i_small<span class="punctuation">,</span> <span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<p>中间的<code>i_small</code>（表示小国家的索引的缩写）是一个逻辑向量，可用于按表面积对<strong>世界</strong>上最小的七个国家提取子集。更简洁的命令省略中间对象，生成相同的结果：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">small_countries <span class="operator">=</span> world<span class="punctuation">[</span>world<span class="operator">$</span>area_km2 <span class="operator">&lt;</span> <span class="number">10000</span><span class="punctuation">,</span> <span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<p>基础R函数<code>subset()</code>提供了另外一种方式：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">small_countries <span class="operator">=</span> subset<span class="punctuation">(</span>world<span class="punctuation">,</span> area_km2 <span class="operator">&lt;</span> <span class="number">10000</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>基础的R函数成熟、稳定且广泛使用，使它们成为一种非常可靠的选择，特别是在强调<strong>重现性</strong>和<strong>可靠性</strong>的情况下。<strong>dplyr</strong> 函数使得&quot;tidy&quot;的工作流成为可能，其中一些人（包括本书的作者）在交互式数据分析中发现这些函数直观且富有成效，特别与RStudio等代码编辑器相结合，可以实现列名的<a href="https://support.posit.co/hc/en-us/articles/205273297-Code-Completion-in-the-RStudio-IDE" title="auto-completion">auto-completion</a>。下面演示了使用<strong>dplyr</strong>函数进行子集提取中的关键函数，包括<code>sf</code>数据框架。</p>
<!--根据以下基准，下面的句子似乎是不真实的。--> 
<!--`dplyr`在某些操作中也比基础 R 快，因为它的 C++ 索引{C++}后端。--> 
<!--关于dbplyr的一些问题？我从来没有见过有人在实际中经常使用它来处理空间数据，所以暂时先不涉及与数据库的集成部分。（RL 2021-10） -->
<!--主要的 **dplyr** 子集提取功能包括`select()`, `slice()`, `filter()` and `pull()`。-->
<p><code>select()</code>按照名称和位置选择列。例如，你可以利用下面的命令只选择<code>name_long</code>和<code>pop</code>两列：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">world1 <span class="operator">=</span> select<span class="punctuation">(</span>world<span class="punctuation">,</span> name_long<span class="punctuation">,</span> pop<span class="punctuation">)</span></span><br><span class="line"><span class="built_in">names</span><span class="punctuation">(</span>world1<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] &quot;name_long&quot; &quot;pop&quot;       &quot;geom&quot;</span></span><br></pre></td></tr></table></figure>
<p>注意：与基础R中的等效命令一样，（<code>world[, c(&quot;name_long&quot;, &quot;pop&quot;)]</code>）, “粘性” <code>geom</code>列保留。<code>select()</code>还允许在<code>:</code>操作符的帮助下选择一系列列变量：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># name_long 和 pop (包括)之间的所有列</span></span><br><span class="line">world2 <span class="operator">=</span> select<span class="punctuation">(</span>world<span class="punctuation">,</span> name_long<span class="operator">:</span>pop<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>用<code>-</code>操作符去除特定的列：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 除了 subregion 和 area_km2 (包括)之外的所有列</span></span><br><span class="line">world3 <span class="operator">=</span> select<span class="punctuation">(</span>world<span class="punctuation">,</span> <span class="operator">-</span>subregion<span class="punctuation">,</span> <span class="operator">-</span>area_km2<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><code>new_name = old_name</code>语法可以同时提取子集和重命名列变量:</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">world4 <span class="operator">=</span> select<span class="punctuation">(</span>world<span class="punctuation">,</span> name_long<span class="punctuation">,</span> population <span class="operator">=</span> pop<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>值得注意的是：上面的命令比基础R等价的命令更简洁，基础R等价的命令需要两行代码：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">world5 <span class="operator">=</span> world<span class="punctuation">[</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;name_long&quot;</span><span class="punctuation">,</span> <span class="string">&quot;pop&quot;</span><span class="punctuation">)</span><span class="punctuation">]</span>                <span class="comment"># 通过名称提取子列</span></span><br><span class="line"><span class="built_in">names</span><span class="punctuation">(</span>world5<span class="punctuation">)</span><span class="punctuation">[</span><span class="built_in">names</span><span class="punctuation">(</span>world5<span class="punctuation">)</span> <span class="operator">==</span> <span class="string">&quot;pop&quot;</span><span class="punctuation">]</span> <span class="operator">=</span> <span class="string">&quot;population&quot;</span>   <span class="comment"># 手动重命名</span></span><br></pre></td></tr></table></figure>
<p><code>select()</code>还可以使用’helper functions’ 进行更高级的自己提取操作，包括<code>contains()</code>，<code>starts_with()</code>和<code>num_range()</code>（用<code>?select</code>产看帮助页面获取更多细节）。</p>
<p>大部分 <strong>dplyr</strong> 函数返回数据框，但是你可以用<code>pull()</code>单独提取一列作为向量。</p>
<!--注意：我注释掉下面的语句，因为它对\`sf\`对象不适用，而且数据框和\`sf\`对象的行为不同，有些令人困惑。-->
<!--相比之下，基础 R（参见`? [`）中的子集运算符试图返回尽可能小维度的对象。--> 
<!--这意味着选择一列返回一个以 R 为基础的向量，如下面的代码块所示，它返回一个表示`world`中国家人口的数字向量: -->
<p>使用列表提取子集操作符<code>$</code>和<code>[[</code> ，可以在基础 R 中得到相同的结果，以下三个命令返回相同的数值向量:</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 结果返回为向量</span></span><br><span class="line">pull<span class="punctuation">(</span>world<span class="punctuation">,</span> pop<span class="punctuation">)</span></span><br><span class="line">world<span class="operator">$</span>pop</span><br><span class="line">world<span class="punctuation">[[</span><span class="string">&quot;pop&quot;</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<!--以下内容已注释，因其容易引起困惑且在其他地方有更好的涵盖（RL，2021-10）。-->
<!--要关闭此行为，请将`drop`参数设置为`FALSE`。-->
<p><code>slice()</code>是行选择工具等同于 <code>select()</code>。例如，下面的代码块选择了1到6行：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">slice<span class="punctuation">(</span>world<span class="punctuation">,</span> <span class="number">1</span><span class="operator">:</span><span class="number">6</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><code>filter()</code>是<strong>dplyr</strong>等价于基础 R 的<code>subset()</code>函数。它只保留符合给定标准的行，例如，只保留面积低于某一阈值或平均预期寿命高的国家，如下例所示：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">world7 <span class="operator">=</span> filter<span class="punctuation">(</span>world<span class="punctuation">,</span> area_km2 <span class="operator">&lt;</span> <span class="number">10000</span><span class="punctuation">)</span>  <span class="comment"># 面积小的国家</span></span><br><span class="line">world7 <span class="operator">=</span> filter<span class="punctuation">(</span>world<span class="punctuation">,</span> lifeExp <span class="operator">&gt;</span> <span class="number">82</span><span class="punctuation">)</span>      <span class="comment"># 预期寿命高的国家</span></span><br></pre></td></tr></table></figure>
<p>比较运算符的标准集合可以在<code>filter()</code>函数中使用，如表所示：</p>
<table>
<thead>
<tr>
<th>Symbol</th>
<th>Name</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>==</code></td>
<td>Equal to</td>
</tr>
<tr>
<td><code>!=</code></td>
<td>Not equal to</td>
</tr>
<tr>
<td><code>&gt;</code>, <code>&lt;</code></td>
<td>Greater/Less than</td>
</tr>
<tr>
<td><code>&gt;=</code>, <code>&lt;=</code></td>
<td>Greater/Less than or equal</td>
</tr>
<tr>
<td><code>&amp;</code>,`</td>
<td><code>,</code>!`</td>
</tr>
</tbody>
</table>
<p>: Comparison operators that return Booleans (TRUE/FALSE).</p>
<h2 id="管道连接命令">管道连接命令</h2>
<p>使用<strong>dplyr</strong>函数的工作流的关键是<a href="http://r4ds.had.co.nz/pipes.html" title="'pipe'">’pipe’</a>操作符<code>%&gt;%</code>（或者自R <code>4.1.0</code>以来的内置管道<code>|&gt;</code>），名称取自Unix管道 <code>|</code>。管道启用表达式代码：前一个函数的输出成为下一个函数的第一个参数，从而启用<em>连接</em>。如下所示，其中只有来自亚洲的国家从<code>world</code>数据集中筛选，接下来对象是按列（<code>name_long</code>和<code>continent</code>）和前5行（结果未显示）分列的子集。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">world7 <span class="operator">=</span> world <span class="operator">|&gt;</span></span><br><span class="line">  filter<span class="punctuation">(</span>continent <span class="operator">==</span> <span class="string">&quot;Asia&quot;</span><span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">  select<span class="punctuation">(</span>name_long<span class="punctuation">,</span> continent<span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">  slice<span class="punctuation">(</span><span class="number">1</span><span class="operator">:</span><span class="number">5</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>上面的代码块显示了管道操作符如何允许以明确的顺序编写命令：从上到下（逐行）和从左到右运行。管道操作的另一种替代方法是嵌套函数调用，这种方法更难理解：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">world8 <span class="operator">=</span> slice<span class="punctuation">(</span></span><br><span class="line">  select<span class="punctuation">(</span></span><br><span class="line">    filter<span class="punctuation">(</span>world<span class="punctuation">,</span> continent <span class="operator">==</span> <span class="string">&quot;Asia&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">    name_long<span class="punctuation">,</span> continent<span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">  <span class="number">1</span><span class="operator">:</span><span class="number">5</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>另一种选择是将操作分为多个自包含行，特别是在开发新的 R 程序包时推荐使用此方法，这种方法的优点是可以通过具有不同名称的中间结果进行保存以便后续调试（但缺点是冗长，如果进行交互式分析时还会使全局环境凌乱）：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">world9_filtered <span class="operator">=</span> filter<span class="punctuation">(</span>world<span class="punctuation">,</span> continent <span class="operator">==</span> <span class="string">&quot;Asia&quot;</span><span class="punctuation">)</span></span><br><span class="line">world9_selected <span class="operator">=</span> select<span class="punctuation">(</span>world9_filtered<span class="punctuation">,</span> continent<span class="punctuation">)</span></span><br><span class="line">world9 <span class="operator">=</span> slice<span class="punctuation">(</span>world9_selected<span class="punctuation">,</span> <span class="number">1</span><span class="operator">:</span><span class="number">5</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>每种方法都有优缺点，其重要性取决于您的编程风格和应用程序。对于交互式数据分析（本章的重点），我们发现管道操作快速而直观，特别是与<a href="https://support.posit.co/hc/en-us/articles/200711853-Keyboard-Shortcuts-in-the-RStudio-IDE" title="RStudio">RStudio</a>/<a href="https://github.com/REditorSupport/vscode-R/wiki/Keyboard-shortcuts" title="VSCode">VSCode</a>快捷方式相结合时，可以创建管道并<a href="https://support.posit.co/hc/en-us/articles/205273297-Code-Completion-in-the-RStudio-IDE" title="自动完成">自动完成</a>变量名。</p>
<h2 id="矢量属性聚合">矢量属性聚合</h2>
<p>聚合涉及使用一个或多个&quot;分组变量&quot;对数据进行汇总，通常是从要进行聚合的数据框的列中选择的（地理聚合在下一章中介绍）。属性聚合的一个例子是根据以国家为单位的数据（每个国家一行）计算每个大洲的人口数量。<code>world</code>数据集包含了必要的要素：<code>pop</code>和<code>continent</code>列分别代表人口和分组变量。目的是找到每个大洲的国家人口总和（<code>sum()</code>），从而得到一个较小的数据框（聚合是一种数据缩减的形式，对于处理大型数据集时，聚合是有用的前期步骤）。可以使用基本R函数<code>aggregate()</code>来完成此操作，步骤如下所示：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">world_agg1 <span class="operator">=</span> aggregate<span class="punctuation">(</span>pop <span class="operator">~</span> continent<span class="punctuation">,</span> FUN <span class="operator">=</span> <span class="built_in">sum</span><span class="punctuation">,</span> data <span class="operator">=</span> world<span class="punctuation">,</span></span><br><span class="line">                       na.rm <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br><span class="line"><span class="built_in">class</span><span class="punctuation">(</span>world_agg1<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] &quot;data.frame&quot;</span></span><br></pre></td></tr></table></figure>
<p>结果是一个6行的非空间数据框，每一行代表一个大洲，两列分别报告了每个大洲的名称和人口（参见表)，显示前三个人口最多的大洲的结果）。</p>
<p><code>aggregate()</code>是一个<a href="https://adv-r.hadley.nz/s3.html" title="泛函数">泛函数</a>，这意味着它的行为取决于它的输入。<strong>sf</strong>提供了<code>aggregate.sf()</code>方法，当<code>x</code>是一个<code>sf</code>对象且提供了一个<code>by</code>参数时，它会自动激活：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">world_agg2 <span class="operator">=</span> aggregate<span class="punctuation">(</span>world<span class="punctuation">[</span><span class="string">&quot;pop&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="built_in">list</span><span class="punctuation">(</span>world<span class="operator">$</span>continent<span class="punctuation">)</span><span class="punctuation">,</span> FUN <span class="operator">=</span> <span class="built_in">sum</span><span class="punctuation">,</span> </span><br><span class="line">                       na.rm <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br><span class="line"><span class="built_in">class</span><span class="punctuation">(</span>world_agg2<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] &quot;sf&quot;         &quot;data.frame&quot;</span></span><br><span class="line">nrow<span class="punctuation">(</span>world_agg2<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] 8</span></span><br></pre></td></tr></table></figure>
<p>由此产生的<code>world_agg2</code>对象是一个包含8个特征的空间对象，这些特征代表世界的大陆(和开放的海洋)。</p>
<p><code>group_by() |&gt; summarize()</code>是 <strong>dplyr</strong> 中与<code>aggregate()</code>等效的函数，其中在<code>group_by()</code>函数中提供的变量名称指定了分组变量，而对要进行汇总的信息则是通过传递给 <code>summarize()</code>函数来指定的，如下所示：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">world_agg3 <span class="operator">=</span> world <span class="operator">|&gt;</span></span><br><span class="line">  group_by<span class="punctuation">(</span>continent<span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">  summarize<span class="punctuation">(</span>pop <span class="operator">=</span> <span class="built_in">sum</span><span class="punctuation">(</span>pop<span class="punctuation">,</span> na.rm <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>这种方法可能看起来更复杂，但它具有以下好处：灵活性、可读性以及对新列名称的控制。下面的命令示例展示了这种灵活性，它不仅计算了人口数量，还计算了每个大洲的面积和国家数量：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">world_agg4  <span class="operator">=</span> world <span class="operator">|&gt;</span> </span><br><span class="line">  group_by<span class="punctuation">(</span>continent<span class="punctuation">)</span> <span class="operator">|&gt;</span> </span><br><span class="line">  summarize<span class="punctuation">(</span>Pop <span class="operator">=</span> <span class="built_in">sum</span><span class="punctuation">(</span>pop<span class="punctuation">,</span> na.rm <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span><span class="punctuation">,</span> Area <span class="operator">=</span> <span class="built_in">sum</span><span class="punctuation">(</span>area_km2<span class="punctuation">)</span><span class="punctuation">,</span> N <span class="operator">=</span> n<span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>在前一个代码块中，<code>Pop</code>、<code>Area</code>和<code>N</code>是结果中的列名，<code>sum()</code>和<code>n()</code>是聚合函数。这些聚合函数返回的<code>sf</code>对象具有以大洲表示的行和包含每个陆地和相关岛屿的多个多边形的几何信息（这得益于几何操作<strong>union</strong>，如几何合并节所述）。</p>
<p>让我们结合目前已经学习到的<strong>dplyr</strong>函数知识，通过将多个命令链接起来以总结全球各大洲的属性数据。以下命令使用<code>mutate()</code>函数计算人口密度，使用<code>dplyr::arrange()</code>函数按国家数量排列大洲，使用<code>dplyr::slice_max()</code>函数保留人口最多的3个洲，并呈现结果简单表格：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">world_agg5 <span class="operator">=</span> world <span class="operator">|&gt;</span> </span><br><span class="line">  st_drop_geometry<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">|&gt;</span>                      <span class="comment"># 去掉几何</span></span><br><span class="line">  select<span class="punctuation">(</span>pop<span class="punctuation">,</span> continent<span class="punctuation">,</span> area_km2<span class="punctuation">)</span> <span class="operator">|&gt;</span>        <span class="comment"># 提取子集  </span></span><br><span class="line">  group_by<span class="punctuation">(</span>continent<span class="punctuation">)</span> <span class="operator">|&gt;</span>                     <span class="comment"># 分组、汇总</span></span><br><span class="line">  summarize<span class="punctuation">(</span>Pop <span class="operator">=</span> <span class="built_in">sum</span><span class="punctuation">(</span>pop<span class="punctuation">,</span> na.rm <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span><span class="punctuation">,</span> Area <span class="operator">=</span> <span class="built_in">sum</span><span class="punctuation">(</span>area_km2<span class="punctuation">)</span><span class="punctuation">,</span> N <span class="operator">=</span> n<span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">  mutate<span class="punctuation">(</span>Density <span class="operator">=</span> <span class="built_in">round</span><span class="punctuation">(</span>Pop <span class="operator">/</span> Area<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">|&gt;</span>     <span class="comment"># 计算人口密度</span></span><br><span class="line">  slice_max<span class="punctuation">(</span>Pop<span class="punctuation">,</span> n <span class="operator">=</span> <span class="number">3</span><span class="punctuation">)</span> <span class="operator">|&gt;</span>                   <span class="comment"># 保留最大的3行</span></span><br><span class="line">  arrange<span class="punctuation">(</span>desc<span class="punctuation">(</span>N<span class="punctuation">)</span><span class="punctuation">)</span>                           <span class="comment"># 国家数量降序</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>continent</th>
<th>Pop</th>
<th>Area</th>
<th>N</th>
<th>Density</th>
</tr>
</thead>
<tbody>
<tr>
<td>Africa</td>
<td>1154946633</td>
<td>29946198</td>
<td>51</td>
<td>39</td>
</tr>
<tr>
<td>Asia</td>
<td>4311408059</td>
<td>31252459</td>
<td>47</td>
<td>138</td>
</tr>
<tr>
<td>Europe</td>
<td>669036256</td>
<td>23065219</td>
<td>39</td>
<td>29</td>
</tr>
</tbody>
</table>
<p>: The top 3 most populous continents ordered by number of countries.</p>
<blockquote>
<p>更多细节可在帮助页面中查看（可通过<code>?summarize</code>和<code>vignette(package = &quot;dplyr&quot;)</code>访问）以及<a href="http://r4ds.had.co.nz/transform.html#grouped-summaries-with-summarize" title="R for Data Science">R for Data Science</a>第5章。</p>
</blockquote>
<h2 id="矢量属性连接">矢量属性连接</h2>
<p>在数据准备中，合并不同来源的数据是一种常见的任务。连接（<strong>Join</strong>）函数通过基于共享的&quot;key&quot;变量来合并表格。<strong>dplyr</strong>有多个连接函数，包括<code>left_join()</code>和<code>inner_join()</code>，详见<code>vignette(&quot;two-table&quot;)</code>以获取完整列表。这些函数名称遵循数据库语言<a href="http://r4ds.had.co.nz/relational-data.html" title="SQL">SQL</a>中使用的惯例。本部分重点讨论将非空间数据集与<code>sf</code>对象连接的过程。<strong>dplyr连接函数</strong>在数据框和<code>sf</code>对象上的操作相同，唯一重要的区别是<code>geometry</code>列表列。数据合并的结果可以是<code>sf</code>或<code>data.frame</code>对象。在空间数据中，最常见的属性合并类型是将<code>sf</code>对象作为第一个参数，并从作为第二个参数指定的<code>data.frame</code>中添加列。</p>
<p>为了展示连接，我们将把咖啡生产数据和<code>world</code>数据集合并。咖啡数据存储在一个名为<code>coffee_data</code>的数据框中，来自<strong>spData</strong>包（详情请参见<code>?coffee_data</code>）。它有3列：<code>name_long</code>列记录主要咖啡生产国家的名称，<code>coffee_production_2016</code>和<code>coffee_production_2017</code>列分别包含每年以60公斤袋为单位的咖啡生产估值。'left join’保留第一个数据集，将<code>world</code>与<code>coffee_data</code>合并：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">world_coffee <span class="operator">=</span> left_join<span class="punctuation">(</span>world<span class="punctuation">,</span> coffee_data<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; Joining with `by = join_by(name_long)`</span></span><br><span class="line"><span class="built_in">class</span><span class="punctuation">(</span>world_coffee<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] &quot;sf&quot;         &quot;tbl_df&quot;     &quot;tbl&quot;        &quot;data.frame&quot;</span></span><br></pre></td></tr></table></figure>
<p>由于输入数据集共享’key variable’（<code>name_long</code>），因此连接操作可以在不使用<code>by</code>参数的情况下完成（有关详细信息，请参见<code>?left_join</code>）。结果是一个与原始<code>world</code>对象相同的<code>sf</code>对象，但具有两个新变量（列索引为11和12）的咖啡产量。这可以绘制成地图，如下<a href="https://scy11.oss-cn-beijing.aliyuncs.com/img/202308230009131.png" title="🖼️ 图片">🖼️ 图片</a>的<code>plot()</code>函数所示：</p>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202308230009131.png" alt=""></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="built_in">names</span><span class="punctuation">(</span>world_coffee<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt;  [1] &quot;iso_a2&quot;                 &quot;name_long&quot;              &quot;continent&quot;             </span></span><br><span class="line"><span class="comment">#&gt;  [4] &quot;region_un&quot;              &quot;subregion&quot;              &quot;type&quot;                  </span></span><br><span class="line"><span class="comment">#&gt;  [7] &quot;area_km2&quot;               &quot;pop&quot;                    &quot;lifeExp&quot;               </span></span><br><span class="line"><span class="comment">#&gt; [10] &quot;gdpPercap&quot;              &quot;geom&quot;                   &quot;coffee_production_2016&quot;</span></span><br><span class="line"><span class="comment">#&gt; [13] &quot;coffee_production_2017&quot;</span></span><br><span class="line">plot<span class="punctuation">(</span>world_coffee<span class="punctuation">[</span><span class="string">&quot;coffee_production_2017&quot;</span><span class="punctuation">]</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>为了使连接生效，两个数据集都必须提供’key variable’ 。默认情况下，<strong>dplyr</strong>会使用所有名称匹配的变量。在这种情况下，<code>world_coffee</code>和<code>world</code>两个对象都包含一个名为<code>name_long</code>的变量，这解释了信息<code>Joining with</code> <code>by = join_by(name_long)</code>。在大多数名称不同的情况下，您有两个选项：</p>
<ol>
<li>重命名某个对象中的key variable，使其与其他对象匹配。</li>
<li>使用<code>by</code>参数指明连接变量。</li>
</ol>
<p>后一种方法在<code>coffee_data</code>的重命名版本中演示如下:</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">coffee_renamed <span class="operator">=</span> rename<span class="punctuation">(</span>coffee_data<span class="punctuation">,</span> nm <span class="operator">=</span> name_long<span class="punctuation">)</span></span><br><span class="line">world_coffee2 <span class="operator">=</span> left_join<span class="punctuation">(</span>world<span class="punctuation">,</span> coffee_renamed<span class="punctuation">,</span> by <span class="operator">=</span> join_by<span class="punctuation">(</span>name_long <span class="operator">==</span> nm<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">world_coffee100 <span class="operator">=</span> left_join<span class="punctuation">(</span>world<span class="punctuation">,</span> coffee_renamed<span class="punctuation">,</span> by <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;name_long&quot;</span> <span class="operator">=</span> <span class="string">&quot;nm&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>请注意，在原始对象中保留名称，意味着<code>world_coffee</code>和新对象<code>world_coffee2</code>是相同的。结果的另一个特点是具有与原始数据集相同的行数。尽管<code>coffee_data</code>中仅有47行数据，但<code>world_coffee</code>和<code>world_coffee2</code>中保留了所有177个国家记录：在原始数据集中没有匹配的行会被赋予新咖啡生产变量的<code>NA</code>值。如果我们只想保留具有键变量匹配的国家怎么办？在<br>
这种情况下，可以使用<strong>内连接</strong>：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">world_coffee_inner <span class="operator">=</span> inner_join<span class="punctuation">(</span>world<span class="punctuation">,</span> coffee_data<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; Joining with `by = join_by(name_long)`</span></span><br><span class="line">nrow<span class="punctuation">(</span>world_coffee_inner<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] 45</span></span><br></pre></td></tr></table></figure>
<p><code>inner_join()</code>的结果只有45行，而<code>coffee_data</code>中有47行。剩下的行发生了什么？我们可以使用<code>setdiff()</code>函数来<strong>识别未匹配行</strong>，如下所示：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">setdiff<span class="punctuation">(</span>coffee_data<span class="operator">$</span>name_long<span class="punctuation">,</span> world<span class="operator">$</span>name_long<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] &quot;Congo, Dem. Rep. of&quot; &quot;Others&quot;</span></span><br></pre></td></tr></table></figure>
<p>结果显示，<code>Others</code>占据了<code>world</code>数据集中不存在的一行，而<code>Democratic Republic of the Congo</code>的名称占据了另一行: 名称缩写，导致连接错误。下面的命令使用<strong>stringr</strong>包中的字符串匹配（<em>regex</em>）函数来确认<code>Congo, Dem. Rep. of</code>应为:</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">drc <span class="operator">=</span> stringr<span class="operator">::</span>str_subset<span class="punctuation">(</span>world<span class="operator">$</span>name_long<span class="punctuation">,</span> <span class="string">&quot;Dem*.+Congo&quot;</span><span class="punctuation">)</span></span><br><span class="line">drc</span><br><span class="line"><span class="comment">#&gt; [1] &quot;Democratic Republic of the Congo&quot;</span></span><br></pre></td></tr></table></figure>
<p>为了解决这个问题，我们将创建一个新版本的<code>coffee_data</code>并更新名称。<code>inner_join()</code>更新后的数据框返回一个包含所有46个咖啡生产国的结果:</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">coffee_data<span class="operator">$</span>name_long<span class="punctuation">[</span>grepl<span class="punctuation">(</span><span class="string">&quot;Congo,&quot;</span><span class="punctuation">,</span> coffee_data<span class="operator">$</span>name_long<span class="punctuation">)</span><span class="punctuation">]</span> <span class="operator">=</span> drc</span><br><span class="line">world_coffee_match <span class="operator">=</span> inner_join<span class="punctuation">(</span>world<span class="punctuation">,</span> coffee_data<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; Joining with `by = join_by(name_long)`</span></span><br><span class="line">nrow<span class="punctuation">(</span>world_coffee_match<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] 46</span></span><br></pre></td></tr></table></figure>
<p>也可以从另一个方向连接：从非空间数据集开始，并从简单要素对象中添加变量。下面演示了这一点，从<code>coffee_data</code>对象开始，并从原始<code>world</code>数据集中添加变量。与前面的连接相比，结果<strong>不是</strong>另一个简单要素对象，而是一个<strong>tidyverse</strong>数据框格式的tibble。连接的输出往往与其第一个参数相匹配：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">coffee_world <span class="operator">=</span> left_join<span class="punctuation">(</span>coffee_data<span class="punctuation">,</span> world<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; Joining with `by = join_by(name_long)`</span></span><br><span class="line"><span class="built_in">class</span><span class="punctuation">(</span>coffee_world<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] &quot;tbl_df&quot;     &quot;tbl&quot;        &quot;data.frame&quot;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>📌在大多数情况下，几何列只在<code>sf</code>对象中有用。<br>
只有当R&quot;知道&quot;它是由如<code>sf</code>等空间包定义的空间对象时，几何列才能用于创建地图和空间操作。<br>
幸运的是，具有几何列表列（如<code>coffee_world</code>）的非空间数据框可以如下方式强制转换为<code>sf</code>对象：<code>st_as_sf(coffee_world)</code>。</p>
</blockquote>
<p>本节涵盖了大部分的连接使用情况。如需更多信息，我们建议阅读<a href="https://r4ds.had.co.nz/relational-data.html?q=join#relational-data" title="Relational data">Relational data</a>章节，本书附带的<strong>geocompkg</strong>包中的<a href="https://geocompx.github.io/geocompkg/articles/join.html" title="join vignette">join vignette</a>，以及描述<strong>data.table</strong>和其他包中的连接方法的文档。<strong>空间连接</strong>将在下一章<em>空间连接</em>中讲述。</p>
<h2 id="创建属性移除空间信息">创建属性移除空间信息</h2>
<p>通常，我们想要根据已有的列创建新的列。例如，我们想要计算每个国家的人口密度。为此，我们需要将一个人口列（这里是<code>pop</code>）除以一个面积列（这里是<code>area_km2</code>），其中单位面积为平方千米。使用基础R，我们可以输入：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">world_new <span class="operator">=</span> world <span class="comment"># 不要覆盖原始数据</span></span><br><span class="line">world_new<span class="operator">$</span>pop_dens <span class="operator">=</span> world_new<span class="operator">$</span>pop <span class="operator">/</span> world_new<span class="operator">$</span>area_km2</span><br></pre></td></tr></table></figure>
<p>另外，我们还可以使用<strong>dplyr</strong>函数-<code>mutate()</code>或<code>transmute()</code>。<code>mutate()</code>在<code>sf</code>对象的倒数第二个位置添加新的列（最后一个位置是保留给几何图形的）：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">world_new2 <span class="operator">=</span> world <span class="operator">|&gt;</span> </span><br><span class="line">  mutate<span class="punctuation">(</span>pop_dens <span class="operator">=</span> pop <span class="operator">/</span> area_km2<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><code>mutate()</code>和<code>transmute()</code>的区别在于<code>transmute()</code>会删除所有其他已存在的列（除了<strong>sticky geometry</strong>列）。</p>
<p><code>unite()</code>函数来自<strong>tidyr</strong>包（该包提供了许多重塑数据集的有用函数，包括<code>pivot_longer()</code>），<code>unite()</code>函数将现有的列拼接在一起。例如我们想要将<code>continent</code>和<code>region_un</code>列合并成一个名为<code>con_reg</code>的新列。另外，我们可以定义一个分隔符（这里是冒号<code>:</code>），用于定义输入列的值应该如何拼接，并且确定是否删除原始列（这里是<code>TRUE</code>）。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">world_unite <span class="operator">=</span> world <span class="operator">|&gt;</span></span><br><span class="line">  tidyr<span class="operator">::</span>unite<span class="punctuation">(</span><span class="string">&quot;con_reg&quot;</span><span class="punctuation">,</span> continent<span class="operator">:</span>region_un<span class="punctuation">,</span> sep <span class="operator">=</span> <span class="string">&quot;:&quot;</span><span class="punctuation">,</span> remove <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>生成的<code>sf</code>对象有一个名为<code>con_reg</code>的新列，代表每个国家的大陆和地区，例如，<code>South America:Americas</code>代表阿根廷和其他南美洲国家。<strong>tidyr</strong> 的<code>separate()</code>函数的作用与<code>unite()</code>相反: 它使用正则表达式或字符位置将一列拆分为多列。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">world_separate <span class="operator">=</span> world_unite <span class="operator">|&gt;</span></span><br><span class="line">  tidyr<span class="operator">::</span>separate<span class="punctuation">(</span>con_reg<span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;continent&quot;</span><span class="punctuation">,</span> <span class="string">&quot;region_un&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> sep <span class="operator">=</span> <span class="string">&quot;:&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><strong>dplyr函数</strong><code>rename()</code>和基础 R 中的<code>setNames()</code>函数用于重命名列变量。<code>rename()</code>函数用新名称代替就名称。例如，下面的命令重命名<code>name_long</code>列为<code>name</code>：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">world <span class="operator">|&gt;</span> </span><br><span class="line">  rename<span class="punctuation">(</span>name <span class="operator">=</span> name_long<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><code>setNames()</code>函数一次性改变全部列名，并需要一个与各列匹配的字符向量。下面的示例说明了这一点，输出相同的<code>world</code>对象，但列名变得非常简单：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">new_names <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;i&quot;</span><span class="punctuation">,</span> <span class="string">&quot;n&quot;</span><span class="punctuation">,</span> <span class="string">&quot;c&quot;</span><span class="punctuation">,</span> <span class="string">&quot;r&quot;</span><span class="punctuation">,</span> <span class="string">&quot;s&quot;</span><span class="punctuation">,</span> <span class="string">&quot;t&quot;</span><span class="punctuation">,</span> <span class="string">&quot;a&quot;</span><span class="punctuation">,</span> <span class="string">&quot;p&quot;</span><span class="punctuation">,</span> <span class="string">&quot;l&quot;</span><span class="punctuation">,</span> <span class="string">&quot;gP&quot;</span><span class="punctuation">,</span> <span class="string">&quot;geom&quot;</span><span class="punctuation">)</span></span><br><span class="line">world_new_names <span class="operator">=</span> world <span class="operator">|&gt;</span></span><br><span class="line">  setNames<span class="punctuation">(</span>new_names<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>每个属性数据操作都保留简单要素的几何特征。有时候去除几何特征是有意义的。例如，为了加快聚合速度。请使用<code>st_drop_geometry()</code>进行操作，而不是手动使用诸如<code>select(world, -geom)</code>等命令，如下所示。</p>
<p><code>st_geometry(world_st) = NULL</code> 也可以用来从 <code>world</code> 中移除几何信息，但它会覆盖原始对象。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">world_data <span class="operator">=</span> world <span class="operator">|&gt;</span> st_drop_geometry<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line"><span class="built_in">class</span><span class="punctuation">(</span>world_data<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] &quot;tbl_df&quot;     &quot;tbl&quot;     &quot;data.frame&quot;</span></span><br></pre></td></tr></table></figure>
<h1>栅格数据操作</h1>
<p>与简单要素基础下的矢量数据模型相反（它将点、线和多边形表示为空间中的离散实体），栅格数据表示连续表面。本节将展示如何<em>从头</em>开始创建栅格对象，并基于<em>terra介绍</em>章节进行构建。由于它们独特的结构，对栅格数据集的子集提取和其他操作以不同的方式进行，在栅格数据提取子集章节中展示。</p>
<p>以下代码重新创建了在<em>栅格类</em>节使用的栅格数据集，其结果在<a href="https://scy11.oss-cn-beijing.aliyuncs.com/img/202308230031352.png" title="🖼️ 图片">🖼️ 图片</a>中展示。这<br>
展示了<code>rast()</code>函数如何工作来创建一个名为<code>elev</code>的示例栅格（表示高程）的示例。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">elev <span class="operator">=</span> rast<span class="punctuation">(</span>nrows <span class="operator">=</span> <span class="number">6</span><span class="punctuation">,</span> ncols <span class="operator">=</span> <span class="number">6</span><span class="punctuation">,</span></span><br><span class="line">            xmin <span class="operator">=</span> <span class="operator">-</span><span class="number">1.5</span><span class="punctuation">,</span> xmax <span class="operator">=</span> <span class="number">1.5</span><span class="punctuation">,</span> ymin <span class="operator">=</span> <span class="operator">-</span><span class="number">1.5</span><span class="punctuation">,</span> ymax <span class="operator">=</span> <span class="number">1.5</span><span class="punctuation">,</span></span><br><span class="line">            vals <span class="operator">=</span> <span class="number">1</span><span class="operator">:</span><span class="number">36</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202308230031352.png" alt=""></p>
<p>结果是一个具有6行和6列的栅格对象（由<code>nrow</code>和<code>ncol</code>参数指定），以及x和y方向上的最小和最大空间范围（<code>xmin</code>，<code>xmax</code>，<code>ymin</code>，<code>ymax</code>）。<code>vals</code>参数设置每个单元格包含的值：在这种情况下，是从1到36的数值数据。Raster对象还可以包含在R中<code>logical</code>或<code>factor</code>类变量形式表示的分类值。以下代码创建了图所示的栅格数据集：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">grain_order <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;clay&quot;</span><span class="punctuation">,</span> <span class="string">&quot;silt&quot;</span><span class="punctuation">,</span> <span class="string">&quot;sand&quot;</span><span class="punctuation">)</span></span><br><span class="line">grain_char <span class="operator">=</span> sample<span class="punctuation">(</span>grain_order<span class="punctuation">,</span> <span class="number">36</span><span class="punctuation">,</span> replace <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br><span class="line">grain_fact <span class="operator">=</span> factor<span class="punctuation">(</span>grain_char<span class="punctuation">,</span> levels <span class="operator">=</span> grain_order<span class="punctuation">)</span></span><br><span class="line">grain <span class="operator">=</span> rast<span class="punctuation">(</span>nrows <span class="operator">=</span> <span class="number">6</span><span class="punctuation">,</span> ncols <span class="operator">=</span> <span class="number">6</span><span class="punctuation">,</span> </span><br><span class="line">             xmin <span class="operator">=</span> <span class="operator">-</span><span class="number">1.5</span><span class="punctuation">,</span> xmax <span class="operator">=</span> <span class="number">1.5</span><span class="punctuation">,</span> ymin <span class="operator">=</span> <span class="operator">-</span><span class="number">1.5</span><span class="punctuation">,</span> ymax <span class="operator">=</span> <span class="number">1.5</span><span class="punctuation">,</span></span><br><span class="line">             vals <span class="operator">=</span> grain_fact<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>栅格对象将相应的查找表或&quot;栅格属性表&quot;（RAT）存储为数据框列表，可以使用<code>cats(grain)</code>查看（有关更多信息，请参见<code>?cats()</code>）。该列表的每个元素都是一个栅格层。还可以使用<code>levels()</code>函数检索和添加新的或替换现有的因子级别：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">levels<span class="punctuation">(</span>grain<span class="punctuation">)</span> <span class="operator">=</span> data.frame<span class="punctuation">(</span>value <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">)</span><span class="punctuation">,</span> wetness <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;wet&quot;</span><span class="punctuation">,</span> <span class="string">&quot;moist&quot;</span><span class="punctuation">,</span> <span class="string">&quot;dry&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">levels<span class="punctuation">(</span>grain<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [[1]]</span></span><br><span class="line"><span class="comment">#&gt;   value wetness</span></span><br><span class="line"><span class="comment">#&gt; 1     0     wet</span></span><br><span class="line"><span class="comment">#&gt; 2     1   moist</span></span><br><span class="line"><span class="comment">#&gt; 3     2     dry</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>📌分类栅格对象还可以使用颜色表存储与每个值相关联的颜色信息。<br>
颜色表是一个数据框，有三个（红色、绿色、蓝色）或四个（Alpha）列，其中每一行与一个值相关联。<br>
在<strong>terra</strong>中，可以使用<code>coltab()</code>函数查看或设置颜色表（请参阅 <code>?coltab</code>）。<br>
需要注意的是，将带有颜色表的栅格对象保存到文件（例如GeoTIFF）中也会保存颜色信息。</p>
</blockquote>
<h2 id="栅格数据提取子集">栅格数据提取子集</h2>
<p>用基础R中的<code>[</code>操作符提取栅格数据子集，改运算符接受多种输入：</p>
<ul>
<li>行-列索引</li>
<li>单元格 IDs</li>
<li>坐标系（见<em>空间栅格子集提取</em>节）</li>
<li>其他的空间对象（见<em>空间栅格子集提取</em>节）</li>
</ul>
<p>在这里，我们只展示前两个选项，因为它们可以被视为非空间操作。如果我们需要一个空间对象来对另一个对象进行子集提取，或者输出是一个空间对象，我们将其称为空间子集操作。因<br>
此，后两个选项将在下一章中进行展示（见<em>空间栅格子集提取</em>节）。</p>
<p>前两个子集操作选项在下面的命令中进行了演示------两者都返回栅格对象<code>elev</code>中左上角像素的值（结果未显示）：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># row 1, column 1</span></span><br><span class="line">elev<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">]</span></span><br><span class="line"><span class="comment"># cell ID 1</span></span><br><span class="line">elev<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<p>多层栅格对象的子集提取将返回每层的单元格值。例如，<code>two_layers = c(grain, elev)</code>；<code>two_layers[1]</code>返回一个包含一行两列的数据框架——每层一列。若<br>
要提取所有值或完整行，还可以使用<code>values()</code>。</p>
<p>可以通过与子集提取操作一起覆盖现有值来修改单元格值。例如，下面的代码块将<code>elev</code>的左上单元格设置为0（结果未显示）：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">elev<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">]</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">elev<span class="punctuation">[</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<p>留空方括号是使用<code>values()</code>检索栅格的所有值的快捷方式，通过此方式也可以修改多个单元格:</p>
<p>替换多层栅格的值可以使用矩阵，其列数与层数相同，行数与可替换单元格数相同（结果未显示）：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">two_layers <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span>grain<span class="punctuation">,</span> elev<span class="punctuation">)</span> </span><br><span class="line">two_layers<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="operator">=</span> cbind<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">4</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">two_layers<span class="punctuation">[</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<h2 id="栅格数据汇总">栅格数据汇总</h2>
<p>terra包含提取整个栅格数据描述性统计信息的功能。通过输入栅格对象的名称并将其打印到控制台，可以返回栅格的最小值和最大值。<code>summary()</code>提供了常见的描述性统计量——最小值、最大值、四分位数以及连续型栅格<code>NA</code>的数量，以及分类型栅格中每个类别的单元格数量。进一步的总结操作，例如标准偏差（见下文）或自定义总结统计量，可以通过<code>global()</code>计算得出。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">global<span class="punctuation">(</span>elev<span class="punctuation">,</span> sd<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果您向<code>summary()</code>和<code>global()</code>函数提供一个多层栅格对象，它们将分别总结每一个层次，可以通过运行以下命令进行演示：<code>summary(c(elev, grain))</code>。</p>
</blockquote>
<p>此外，<code>freq()</code>函数允许获取分类值的频率表。栅格值统计可以以多种方式进行可视化。特定的函数，如<code>boxplot()</code>、<code>density()</code>、<code>hist()</code>和<code>pairs()</code>也适用于栅格对象，如下方命令创建的直方图所示（未显示）：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">hist<span class="punctuation">(</span>elev<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>如果所需的可视化函数无法与栅格对象一起使用，可以使用<code>values()</code>函数提取要绘制的栅格数据（参见栅格数据提取子集节）。</p>
<p>描述性栅格统计属于所谓的<strong>全局</strong>栅格操作。这些以及其他典型的栅格处理操作是<strong>地图代数</strong>方案的一部分，将在下一章（<em>地图代数</em>节）中介绍。</p>
<blockquote>
<p>📌一些函数名在包之间发生了冲突（例如，<code>extract()</code>函数在<strong>terra</strong>和<strong>tidyr</strong>包中都有）。<br>
除了不通过引用函数来加载包（例如，<code>tidyr::extract()</code>），还有一种避免函数名冲突的方法是使用<code>detach()</code>取消加载引起问题的包。<br>
例如，下面的命令可以卸载<code>terra</code>包（这也可以在 RStudio的默认右下角窗格中的<em>package</em>选项卡中完成）：<code>detach(&quot;package:terra&quot;, unload = TRUE, force = TRUE)</code>。在<br>
使用<code>force</code>参数时，即使其他包依赖于该包，也可以确保分离该包。<br>
然而，这可能会导致依赖于已分离包的包受到限制的可用性，因此不建议使用该参数。</p>
</blockquote>
<h2 id="练习">练习</h2>
<p>对于这些练习，我们将使用<strong>spData</strong>包中的<code>us_states</code>和<code>us_states_df</code>数据集。你必须已经加载了包，以及在属性操作章节中使用的其他包（<strong>sf</strong>, <strong>dplyr</strong>, <strong>terra</strong>），通过如<code>library(spData)</code>这样的命令，在尝试这些练习之前：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>sf<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>dplyr<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>terra<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>spData<span class="punctuation">)</span></span><br><span class="line">data<span class="punctuation">(</span>us_states<span class="punctuation">)</span></span><br><span class="line">data<span class="punctuation">(</span>us_states_df<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><code>us_states</code>是一个空间对象（类为<code>sf</code>），包含了美国连续州的几何形状和一些属性（包括名字、区域、面积和人口）。<code>us_states_df</code>是一个数据框架（类为<code>data.frame</code>），包含了美国各州的名称和额外变量（包括 2010 年和 2015 年的中位数收入和贫困水平），包括阿拉斯加、夏威夷和波多黎各。数据来自美国人口普查局，并在<code>?us_states</code>和<code>?us_states_df</code>中有文档记录。</p>
<p>E1.<br>
创建一个叫做<code>us_states_name</code>的新对象，它只包含来自<code>us_states</code>对象的<code>NAME</code>列，使用基础 R (<code>[</code>) 或 tidyverse (<code>select()</code>) 语法。新对象的类是什么，是什么使它具有地理特征？</p>
<p>E2.<br>
从<code>us_states</code>对象中选择包含人口数据的列。使用不同的命令获得相同的结果（奖励：尝试找到三种获得相同结果的方法）。提示：尝试使用辅助函数，如<strong>dplyr</strong>中的<code>contains</code>或<code>matches</code>（参见<code>?contains</code>）。</p>
<p>E3.<br>
找到所有具有以下特征的州（找到<em>并</em>绘制它们）：</p>
<ul>
<li>属于中西部区域。</li>
<li>属于西部区域，面积低于 250,000 平方千米<em>并且</em>在 2015 年人口超过 5,000,000（提示：你可能需要使用<code>units::set_units()</code>或<code>as.numeric()</code>函数）。</li>
<li>属于南部区域，面积大于 150,000 平方千米或 2015 年总人口超过 7,000,000。</li>
</ul>
<p>E4.<br>
在<code>us_states</code>数据集中，2015 年的总人口是多少？2015 年的最小和最大总人口是多少？</p>
<p>E5.<br>
每个区域有多少个州？</p>
<p>E6.<br>
2015 年每个区域的最小和最大总人口是多少？2015 年每个区域的总人口是多少？</p>
<p>E7.<br>
从<code>us_states_df</code>添加变量到<code>us_states</code>，并创建一个叫做<code>us_states_stats</code>的新对象。你使用了什么函数，为什么？在这两个数据集中哪个变量是键？新对象的类是什么？</p>
<p>E8.<br>
<code>us_states_df</code>比<code>us_states</code>多两行。你怎么找到它们？（提示：尝试使用<code>dplyr::anti_join()</code>函数）</p>
<p>E9.<br>
2015 年每个州的人口密度是多少？2010 年每个州的人口密度是多少？</p>
<p>E10.<br>
2010 年和 2015 年每个州的人口密度变化了多少？计算百分比变化并将它们映射出来。</p>
<p>E11.<br>
将<code>us_states</code>中的列名更改为小写。（提示：辅助函数 - <code>tolower()</code>和<code>colnames()</code>可能会有帮助）</p>
<p>E12.<br>
使用<code>us_states</code>和<code>us_states_df</code>创建一个叫做<code>us_states_sel</code>的新对象。新对象应该只有两个变量 - <code>median_income_15</code>和<code>geometry</code>。将<code>median_income_15</code>列的名称更改为<code>Income</code>。</p>
<p>E13.<br>
计算 2010 年和 2015 年每个州贫困线以下居民数量的变化。（提示：参见<code>?us_states_df</code>了解贫困水平列的文档）奖励：计算每个州贫困线以下居民的百分比变化。</p>
<p>E14.<br>
2015 年每个区域的最小、平均和最大州贫困线以下人口数量是多少？奖励：哪个区域贫困线以下人口增加最多？</p>
<p>E15.<br>
从头开始创建一个具有九行和九列的栅格，分辨率为 0.5 十进制度（WGS84）。用随机数填充它。提取四个角单元格的值。</p>
<p>E16.<br>
我们示例栅格<code>grain</code>最常见的类是什么？</p>
<p>E17.<br>
绘制<strong>spDataLarge</strong>包中<code>dem.tif</code>文件的直方图和箱线图（<code>system.file(&quot;raster/dem.tif&quot;, package = &quot;spDataLarge&quot;)</code>）。</p>
]]></content>
      <categories>
        <category>R</category>
        <category>Geocomputaion</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>Geocomputaion</tag>
      </tags>
  </entry>
  <entry>
    <title>(5)几何操作</title>
    <url>/2023/08/14/2023-8-14-5%E5%87%A0%E4%BD%95%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<blockquote><p>本文由SCY翻译自《Geocomputation with R》<a href="https://r.geocompx.org/geometry-operations">第五章</a></p>
</blockquote>
<p>本章重点介绍如何操作地理对象的地理元素，例如通过简化和转换矢量几何图形、裁剪栅格数据集以及将矢量对象转换为栅格并从栅格转换为矢量。阅读本章并尝试章末的练习后，你应该能理解并控制<code>sf</code>对象中的几何列，以及与其他地理对象相关的栅格中所表示像素的范围和地理位置。</p>
<span id="more"></span>
<h1>前提条件</h1>
<ul>
<li>本章使用了与<em>R中的地理数据</em>章相同的包，但额外增加了<strong>spDataLarge</strong>，该包在<em>属性操作</em>章中已安装。</li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>sf<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>terra<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>dplyr<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>spData<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>spDataLarge<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<h1>引言</h1>
<p>迄今为止，本书已经解释了地理数据集的结构、如何基于它们的非地理属性和空间关系进行操作。本章重点介绍如何操作地理对象的地理元素，例如通过简化和转换矢量几何图形、裁剪栅格数据集以及将矢量对象转换为栅格并从栅格转换为矢量。阅读本章并尝试章末的练习后，你应该能理解并控制<code>sf</code>对象中的几何列，以及与其他地理对象相关的栅格中所表示像素的范围和地理位置。</p>
<p><em>矢量数据几何操作</em>节介绍了使用’一元’和’二元’操作转换矢量几何图形。一元操作在单个几何图形上独立工作，包括简化（线和多边形）、缓冲区和质心的创建，以及使用’仿射变换’移动/缩放/旋转单个几何图形。二元变换基于另一个形状修改一个几何图形，包括剪裁和几何联合节中介绍。类型转换（例如从多边形到线）。</p>
<p>节涵盖了栅格对象上的几何变换。这涉及改变底层像素的大小和数量，并赋予它们新的值。它教你如何更改分辨率（也称为栅格聚合和分解）、范围和栅格的原点。如果想要对齐来自不同来源的栅格数据集，这些操作特别有用。对齐的栅格对象在像素之间共享一对一对应关系，允许它们使用地图代数操作进行处理。栅格和矢量对象之间的交互在后面章节中介绍。它介绍了如何通过矢量几何图形“掩膜”和“提取”栅格值。重要的是，它还展示了如何将栅格“矢量化”和将矢量数据集“栅格化”，使两种数据模型更易于互换。</p>
<h2 id="矢量数据几何操作">矢量数据几何操作</h2>
<p>这一部分涉及以某种方式改变矢量（<code>sf</code>）对象几何形状的操作。与上一章节中介绍的空间数据操作相比，这里更为高级，因为我们深入到几何结构中：本节讨论的函数不仅作用于 <code>sf</code> 类对象，还作用于 <code>sfc</code> 类对象。</p>
<h3 id="简化">简化</h3>
<p>简化是一种矢量对象（线和多边形）的概括过程，通常用于较小比例的地图中。简化对象的另一个原因是减少它们消耗的内存、磁盘空间和网络带宽。在将复杂几何体发布为交互式地图之前，简化它们可能是明智的选择。<strong>sf</strong> 包提供了 <code>st_simplify()</code> 函数，使用 GEOS 实现的 Douglas-Peucker 算法来减少顶点数量。<code>st_simplify()</code> 使用 <code>dTolerance</code> 来以地图单位控制概括的级别 [具体细节请参见 @douglas_algorithms_1973]。下图展示了代表塞纳河及其支流的 <code>LINESTRING</code> 几何体的简化过程。以下命令创建了简化的几何体：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">seine_simp <span class="operator">=</span> st_simplify<span class="punctuation">(</span>seine<span class="punctuation">,</span> dTolerance <span class="operator">=</span> <span class="number">2000</span><span class="punctuation">)</span>  <span class="comment"># 2000 m</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309020108182.png" alt=""><br>
Comparison of the original and simplified geometry of the seine object.</p>
<p>生成的 <code>seine_simp</code> 对象是原始 <code>seine</code> 的副本，但顶点更少。这一点很明显，结果在视觉上更简单（上图，右侧），并且比原始对象占用的内存更少，如下所验证：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">object.size<span class="punctuation">(</span>seine<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; 18096 bytes</span></span><br><span class="line">object.size<span class="punctuation">(</span>seine_simp<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; 9112 bytes</span></span><br></pre></td></tr></table></figure>
<p>简化也适用于多边形。这通过表示美国本土的 <code>us_states</code> 来说明。正如我们在后面章节中所展示的，GEOS 假设数据在投影的坐标参考系统（CRS）中，而当使用地理 CRS 时，这可能会导致意外的结果。因此，第一步是将数据投影到某个适当的投影 CRS 中，例如美国国家地图等面积（EPSG = 2163）（如上图左上角所示）：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">us_states2163 <span class="operator">=</span> st_transform<span class="punctuation">(</span>us_states<span class="punctuation">,</span> <span class="string">&quot;EPSG:2163&quot;</span><span class="punctuation">)</span></span><br><span class="line">us_states2163 <span class="operator">=</span> us_states2163</span><br></pre></td></tr></table></figure>
<p><code>st_simplify()</code> 也同样很好的处理投影面要素。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">us_states_simp1 <span class="operator">=</span> st_simplify<span class="punctuation">(</span>us_states2163<span class="punctuation">,</span> dTolerance <span class="operator">=</span> <span class="number">100000</span><span class="punctuation">)</span>  <span class="comment"># 100 km</span></span><br></pre></td></tr></table></figure>
<p><code>st_simplify()</code>的一个限制是它基于每个几何体来简化对象。这意味着失去了“拓扑”，导致图@ref(fig:us-simp)（右上面板）中所示的重叠和“多洞”区域单位。 <strong>rmapshaper</strong> 的 <code>ms_simplify()</code> 提供了克服这个问题的替代方案。默认情况下，它使用 Visvalingam 算法，克服了 Douglas-Peucker算法的一些。 <!-- https://bost.ocks.org/mike/simplify/ --> 以下代码块使用此函数来简化<code>us_states2163</code>。结果只有输入顶点的1%（通过参数 <code>keep</code>设置），但其对象数量保持不变，因为我们设置了 <code>keep_shapes = TRUE</code>：[^1]</p>
<p>[^1]：即使将 <code>keep_shapes</code> 参数设置为<code>TRUE</code>，也可以通过简化多边形对象来删除小的内部多边形。要防止这种情况，您需要设置 <code>explode = TRUE</code>。此选项在简化之前将所有多边形转换为单独的多边形。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># proportion of points to retain (0-1; default 0.05)</span></span><br><span class="line">us_states_simp2 <span class="operator">=</span> rmapshaper<span class="operator">::</span>ms_simplify<span class="punctuation">(</span>us_states2163<span class="punctuation">,</span> keep <span class="operator">=</span> <span class="number">0.01</span><span class="punctuation">,</span></span><br><span class="line">                                          keep_shapes <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>对于简化的另一种选择是平滑多边形和线条几何图形的边界，这在 <strong>smoothr</strong> 包中实现。平滑插值几何图形的边缘，并不一定会导致较少的顶点，但在使用从空间向量化栅格产生的几何图形时尤为有用。</p>
<p><strong>smoothr</strong> 包实现了三种平滑技术：高斯核回归、Chaikin的角剪切算法和样条插值。这些都在<a href="https://strimas.com/smoothr/">website</a>.中进行了描述。请注意，与 <code>st_simplify()</code> 类似，平滑算法不保留“拓扑结构”。<strong>smoothr</strong> 的主要功能是 <code>smooth()</code>，其中 <code>method</code> 参数指定要使用的平滑技术。这些平滑技术可能在进行地理空间分析和图形表示时很有用，特别是在需要减少几何形状的锯齿状外观或复杂度时。通过合理选择平滑参数，可以在保留地理特征的同时，提高几何形状的视觉美感。以下是一个使用高斯核回归（Gaussian kernel regression）来通过<code>method=ksmooth</code>平滑美国各州边界的例子。<code>smoothness</code> 参数控制用于平滑几何形状的高斯带宽，其默认值为1。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">us_states_simp3 <span class="operator">=</span> smoothr<span class="operator">::</span>smooth<span class="punctuation">(</span>us_states2163<span class="punctuation">,</span> </span><br><span class="line">                                  method <span class="operator">=</span> <span class="string">&quot;ksmooth&quot;</span><span class="punctuation">,</span> smoothness <span class="operator">=</span> <span class="number">6</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>最后，原始数据集与简化版和平滑版的视觉比较显示在（下图）中。可以观察到Douglas-Peucker（<code>st_simplify</code>）、Visvalingam（<code>ms_simplify</code>）和高斯核回归（<code>smooth(method=ksmooth</code>)）算法的输出之间的差异。</p>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309020112005.png" alt=""><br>
Polygon simplification in action, comparing the original geometry of the contiguous United States with simplified versions, generated with functions from sf (top-right), rmapshaper (bottom-left), and smoothr (bottom-right) packages.</p>
<h3 id="质心">质心</h3>
<p>质心运算确定地理对象的中心。就像统计的集中趋势度量（包括平均数和中位数定义的“平均”）一样，有许多方法可以定义对象的地理中心。它们都为更复杂的矢量对象创建单一点表示。</p>
<p>最常用的质心运算是<em>地理质心</em>。这种类型的质心运算（通常称为“质心”）代表空间对象中的质量中心（想象一下用你的手指平衡一个盘子）。地理质心有许多用途，例如创建复杂几何图形的简单点表示，或估计多边形之间的距离。可以使用<strong>sf</strong>函数<code>st_centroid()</code>来计算，如下面的代码所示，该代码生成了新西兰地区和塞纳河支流的地理质心，以黑点在图中示出。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">nz_centroid <span class="operator">=</span> st_centroid<span class="punctuation">(</span>nz<span class="punctuation">)</span></span><br><span class="line">seine_centroid <span class="operator">=</span> st_centroid<span class="punctuation">(</span>seine<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>有时，地理质心会落在其父对象的边界之外（想象一个甜甜圈）。在这种情况下，可以使用<em>表面上的点</em>运算来确保点位于父对象内（例如，用于标记不规则的多边形对象，如岛屿状态），如图中的红点所示。请注意，这些红点总是位于其父对象上。它们是使用<code>st_point_on_surface()</code>创建的，如下所示：[^2]</p>
<p>[^2]: 网址 <a href="https://gis.stackexchange.com/a/76563/20955">https://gis.stackexchange.com/a/76563/20955</a>提供了<code>st_point_on_surface()</code>如何工作？</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">nz_pos <span class="operator">=</span> st_point_on_surface<span class="punctuation">(</span>nz<span class="punctuation">)</span></span><br><span class="line">seine_pos <span class="operator">=</span> st_point_on_surface<span class="punctuation">(</span>seine<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309022304851.png" alt=""><br>
Centroids (black points) and ‘points on surface’ (red points) of New Zealand’s regions (left) and the Seine (right) datasets.</p>
<p>其他类型的质心也存在，包括<em>切比雪夫中心</em>和<em>视觉中心</em>。我们不在此处探讨这些内容，但可以使用R来计算它们，我们将在<em>算法</em>章中看到。</p>
<h3 id="缓冲区">缓冲区</h3>
<p>缓冲区是代表距离几何特征一定距离内的区域的多边形：无论输入是点、线还是多边形，输出都是多边形。与简化（通常用于可视化和减小文件大小）不同，缓冲区倾向于用于地理数据分析。<br>
有多少个点在这条线的一定距离内？哪些人口群体在这个新商店的旅行距离内？通过围绕感兴趣的地理实体创建缓冲区，可以回答并可视化这些问题。</p>
<p>下图描述了围绕塞纳河及其支流的不同大小（5和50公里）的缓冲区。这些缓冲区是通过下面的命令创建的，这些命令显示 <code>st_buffer()</code> 命令至少需要两个参数：一个输入几何和一个距离，以CRS的单位提供（在本例中为米）：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">seine_buff_5km <span class="operator">=</span> st_buffer<span class="punctuation">(</span>seine<span class="punctuation">,</span> dist <span class="operator">=</span> <span class="number">5000</span><span class="punctuation">)</span></span><br><span class="line">seine_buff_50km <span class="operator">=</span> st_buffer<span class="punctuation">(</span>seine<span class="punctuation">,</span> dist <span class="operator">=</span> <span class="number">50000</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309022310986.png" alt=""><br>
Buffers around the Seine dataset of 5 km (left) and 50 km (right). Note the colors, which reflect the fact that one buffer is created per geometry feature.</p>
<blockquote>
<p>📌<code>st_buffer()</code> 的第三个也是最后一个参数是 <code>nQuadSegs</code>，表示“每个象限的线段数”，默认设置为30（意味着缓冲区创建的圆由 $4 \times 30 = 120$ 条线组成）。<br>
这个参数很少需要设置。当缓冲操作的输出占用的内存成为主要问题（在这种情况下应该减少）或者需要非常高的精度（在这种情况下应该增加）时，它可能会有用。</p>
</blockquote>
<h3 id="仿射变换">仿射变换</h3>
<p>仿射变换是保留线条和平行性的任何变换。然而，角度或长度并不一定会保留。仿射变换包括平移（移位）、缩放和旋转等。此外，可以使用这些操作的任何组合。仿射变换是地理计算的重要组成部分。例如，标签放置需要移位，非连续区域制图用到缩放，而在重新投影或改进基于失真或错误投影的地图创建的几何图形时，会应用许多仿射变换。<strong>sf</strong> 包为 <code>sfg</code> 和 <code>sfc</code> 类的对象实现了仿射变换。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">nz_sfc <span class="operator">=</span> st_geometry<span class="punctuation">(</span>nz<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>平移是将每个点以地图单位的相同距离移动。它可以通过将数值向量添加到矢量对象来完成。例如，下面的代码将所有y坐标向北移动100,000米，但不改变x坐标。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">nz_shift <span class="operator">=</span> nz_sfc <span class="operator">+</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span> <span class="number">100000</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>缩放通过一个因子放大或缩小对象。它可以全局或局部应用。全局缩放增加或减小与原点坐标有关的所有坐标值，同时保持所有几何图形的拓扑关系不变。它可以通过减法或乘法对<code>sfg</code>或<code>sfc</code>对象进行操作。</p>
<p>局部缩放独立处理几何体，并需要确定几何体将围绕哪些点进行缩放，例如，质心。在下面的示例中，每个几何体都围绕质心缩小了一半。为实现这一目的，首先要以一种方式移动每个对象，使其中心的坐标为 <code>0,0</code>（<code>(nz_sfc - nz_centroid_sfc)</code>）。接下来，减小几何体的尺寸一半（<code>* 0.5</code>）。最后，将每个对象的质心移回到输入数据的坐标（<code>+ nz_centroid_sfc</code>）。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">nz_centroid_sfc <span class="operator">=</span> st_centroid<span class="punctuation">(</span>nz_sfc<span class="punctuation">)</span></span><br><span class="line">nz_scale <span class="operator">=</span> <span class="punctuation">(</span>nz_sfc <span class="operator">-</span> nz_centroid_sfc<span class="punctuation">)</span> <span class="operator">*</span> <span class="number">0.5</span> <span class="operator">+</span> nz_centroid_sfc</span><br></pre></td></tr></table></figure>
<p>对二维坐标的旋转需要一个旋转矩阵：</p>
<p>$$<br>
R =<br>
\begin{bmatrix}<br>
\cos \theta &amp; -\sin \theta \<br>
\sin \theta &amp; \cos \theta \<br>
\end{bmatrix}<br>
$$<br>
它以顺时针方向旋转点。旋转矩阵可以在R中实现如下：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">rotation <span class="operator">=</span> <span class="keyword">function</span><span class="punctuation">(</span>a<span class="punctuation">)</span><span class="punctuation">&#123;</span></span><br><span class="line">  r <span class="operator">=</span> a <span class="operator">*</span> <span class="built_in">pi</span> <span class="operator">/</span> <span class="number">180</span> <span class="comment">#degrees to radians</span></span><br><span class="line">  matrix<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="built_in">cos</span><span class="punctuation">(</span>r<span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">sin</span><span class="punctuation">(</span>r<span class="punctuation">)</span><span class="punctuation">,</span> <span class="operator">-</span><span class="built_in">sin</span><span class="punctuation">(</span>r<span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">cos</span><span class="punctuation">(</span>r<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span> nrow <span class="operator">=</span> <span class="number">2</span><span class="punctuation">,</span> ncol <span class="operator">=</span> <span class="number">2</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">&#125;</span> </span><br></pre></td></tr></table></figure>
<p><code>rotation</code>函数接受一个参数<code>a</code> - 以度为单位的旋转角度。旋转可以围绕选定的点（例如质心）进行。有关更多示例，请参见<code>vignette(&quot;sf3&quot;)</code>。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">nz_rotate <span class="operator">=</span> <span class="punctuation">(</span>nz_sfc <span class="operator">-</span> nz_centroid_sfc<span class="punctuation">)</span> <span class="operator">*</span> rotation<span class="punctuation">(</span><span class="number">30</span><span class="punctuation">)</span> <span class="operator">+</span> nz_centroid_sfc</span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309022312133.png" alt=""><br>
Illustrations of affine transformations: shift, scale and rotate.</p>
<p>最后，可以使用<code>st_set_geometry()</code>函数将新创建的几何图形替换旧的几何图形。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">nz_scale_sf <span class="operator">=</span> st_set_geometry<span class="punctuation">(</span>nz<span class="punctuation">,</span> nz_scale<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<h3 id="裁剪">裁剪</h3>
<p>空间裁剪是一种空间子集处理方式，至少涉及一些受影响特征的 <code>geometry</code> 列的更改。</p>
<p>裁剪只能应用于比点更复杂的特征：线、多边形及其“多”的要素。为了说明这个概念，我们将从一个简单的例子开始：两个重叠的圆，中心点彼此相距一单位，半径为一。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">b <span class="operator">=</span> st_sfc<span class="punctuation">(</span>st_point<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span> st_point<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="comment"># create 2 points</span></span><br><span class="line">b <span class="operator">=</span> st_buffer<span class="punctuation">(</span>b<span class="punctuation">,</span> dist <span class="operator">=</span> <span class="number">1</span><span class="punctuation">)</span> <span class="comment"># convert points to circles</span></span><br><span class="line">plot<span class="punctuation">(</span>b<span class="punctuation">,</span> border <span class="operator">=</span> <span class="string">&quot;grey&quot;</span><span class="punctuation">)</span></span><br><span class="line">text<span class="punctuation">(</span>x <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="operator">-</span><span class="number">0.5</span><span class="punctuation">,</span> <span class="number">1.5</span><span class="punctuation">)</span><span class="punctuation">,</span> y <span class="operator">=</span> <span class="number">1</span><span class="punctuation">,</span> labels <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;x&quot;</span><span class="punctuation">,</span> <span class="string">&quot;y&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> cex <span class="operator">=</span> <span class="number">3</span><span class="punctuation">)</span> <span class="comment"># add text</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309022315781.png" alt=""><br>
Overlapping circles.</p>
<p>假设你想选择的不是一个圆或另一个圆，而是由<code>x</code><em>和</em><code>y</code>都覆盖的空间。这可以使用函数<code>st_intersection()</code>来实现，使用名为<code>x</code>和<code>y</code>的对象来表示左侧和右侧的圆。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">x <span class="operator">=</span> b<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span></span><br><span class="line">y <span class="operator">=</span> b<span class="punctuation">[</span><span class="number">2</span><span class="punctuation">]</span></span><br><span class="line">x_and_y <span class="operator">=</span> st_intersection<span class="punctuation">(</span>x<span class="punctuation">,</span> y<span class="punctuation">)</span></span><br><span class="line">plot<span class="punctuation">(</span>b<span class="punctuation">,</span> border <span class="operator">=</span> <span class="string">&quot;grey&quot;</span><span class="punctuation">)</span></span><br><span class="line">plot<span class="punctuation">(</span>x_and_y<span class="punctuation">,</span> col <span class="operator">=</span> <span class="string">&quot;lightgrey&quot;</span><span class="punctuation">,</span> border <span class="operator">=</span> <span class="string">&quot;grey&quot;</span><span class="punctuation">,</span> add <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span> <span class="comment"># intersecting area</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309022316777.png" alt=""><br>
Overlapping circles with a gray color indicating intersection between them.</p>
<p>以下代码块演示了这如何适用于代表<code>x</code>和<code>y</code>的“Venn”图的所有组合，灵感来自*《R for Data Science》*一书的<a href="http://r4ds.had.co.nz/transform.html#logical-operators">Figure 5.1</a>。</p>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309022317722.png" alt=""><br>
Spatial equivalents of logical operators.</p>
<h3 id="子集提取和裁剪">子集提取和裁剪</h3>
<p>裁剪对象可以改变其几何形状，但也可以对对象进行子集提取，只返回与裁剪/子集对象相交（或部分相交）的特征。为了说明这一点，我们将对覆盖图中的圆圈<code>x</code>和<code>y</code>的边界框的点进行子集提取。</p>
<p>有些点将仅在一个圆圈内，有些将在两者内，有些则在两者之外。下面使用<code>st_sample()</code>在圆圈<code>x</code>和<code>y</code>的范围内生成<em>简单随机</em>分布的点，得到图中所示的输出，提出了这样的问题：如何对点进行子集提取，以便仅返回与<em>两者</em><code>x</code>和<code>y</code>相交的点？</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">bb <span class="operator">=</span> st_bbox<span class="punctuation">(</span>st_union<span class="punctuation">(</span>x<span class="punctuation">,</span> y<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">box <span class="operator">=</span> st_as_sfc<span class="punctuation">(</span>bb<span class="punctuation">)</span></span><br><span class="line">set.seed<span class="punctuation">(</span><span class="number">2017</span><span class="punctuation">)</span></span><br><span class="line">p <span class="operator">=</span> st_sample<span class="punctuation">(</span>x <span class="operator">=</span> box<span class="punctuation">,</span> size <span class="operator">=</span> <span class="number">10</span><span class="punctuation">)</span></span><br><span class="line">p_xy1 <span class="operator">=</span> p<span class="punctuation">[</span>x_and_y<span class="punctuation">]</span></span><br><span class="line">plot<span class="punctuation">(</span>box<span class="punctuation">,</span> border <span class="operator">=</span> <span class="string">&quot;grey&quot;</span><span class="punctuation">,</span> lty <span class="operator">=</span> <span class="number">2</span><span class="punctuation">)</span></span><br><span class="line">plot<span class="punctuation">(</span>x<span class="punctuation">,</span> add <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> border <span class="operator">=</span> <span class="string">&quot;grey&quot;</span><span class="punctuation">)</span></span><br><span class="line">plot<span class="punctuation">(</span>y<span class="punctuation">,</span> add <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> border <span class="operator">=</span> <span class="string">&quot;grey&quot;</span><span class="punctuation">)</span></span><br><span class="line">plot<span class="punctuation">(</span>p<span class="punctuation">,</span> add <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br><span class="line">plot<span class="punctuation">(</span>p_xy1<span class="punctuation">,</span> cex <span class="operator">=</span> <span class="number">3</span><span class="punctuation">,</span> col <span class="operator">=</span> <span class="string">&quot;red&quot;</span><span class="punctuation">,</span> add <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br><span class="line">text<span class="punctuation">(</span>x <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="operator">-</span><span class="number">0.5</span><span class="punctuation">,</span> <span class="number">1.5</span><span class="punctuation">)</span><span class="punctuation">,</span> y <span class="operator">=</span> <span class="number">1</span><span class="punctuation">,</span> labels <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;x&quot;</span><span class="punctuation">,</span> <span class="string">&quot;y&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> cex <span class="operator">=</span> <span class="number">2</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309022318921.png" alt=""><br>
Randomly distributed points within the bounding box enclosing circles x and y. The point that intersects with both objects x and y is highlighted.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">bb <span class="operator">=</span> st_bbox<span class="punctuation">(</span>st_union<span class="punctuation">(</span>x<span class="punctuation">,</span> y<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">box <span class="operator">=</span> st_as_sfc<span class="punctuation">(</span>bb<span class="punctuation">)</span></span><br><span class="line">set.seed<span class="punctuation">(</span><span class="number">2017</span><span class="punctuation">)</span></span><br><span class="line">p <span class="operator">=</span> st_sample<span class="punctuation">(</span>x <span class="operator">=</span> box<span class="punctuation">,</span> size <span class="operator">=</span> <span class="number">10</span><span class="punctuation">)</span></span><br><span class="line">x_and_y <span class="operator">=</span> st_intersection<span class="punctuation">(</span>x<span class="punctuation">,</span> y<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>下面的代码块演示了实现相同结果的三种方法。我们可以直接使用<code>x</code>和<code>y</code>的交集（由上一个代码块中的<code>x_and_y</code>表示）作为子集对象，如下面代码块的第一行所示。我们还可以找到输入点（由<code>p</code>表示）与子集/裁剪对象<code>x_and_y</code>之间的<em>交集</em>，如下面代码块的第二行所示。这第二种方法将返回部分与<code>x_and_y</code>相交的特征，但是对于跨越子集对象边界的空间广泛特征，几何形状将被修改。第三种方法是使用二元空间谓词<code>st_intersects()</code>创建子集对象，该谓词在前一章中介绍。</p>
<p>结果是相同的（除了属性名称的表面差异），但实现差异很大：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">p_xy1 <span class="operator">=</span> p<span class="punctuation">[</span>x_and_y<span class="punctuation">]</span> <span class="comment"># way #1</span></span><br><span class="line">p_xy2 <span class="operator">=</span> st_intersection<span class="punctuation">(</span>p<span class="punctuation">,</span> x_and_y<span class="punctuation">)</span> <span class="comment"># way #2</span></span><br><span class="line">sel_p_xy <span class="operator">=</span> st_intersects<span class="punctuation">(</span>p<span class="punctuation">,</span> x<span class="punctuation">,</span> sparse <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">)</span><span class="punctuation">[</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">]</span> <span class="operator">&amp;</span> </span><br><span class="line">  st_intersects<span class="punctuation">(</span>p<span class="punctuation">,</span> y<span class="punctuation">,</span> sparse <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">)</span><span class="punctuation">[</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">]</span> <span class="comment"># way #3</span></span><br><span class="line">p_xy3 <span class="operator">=</span> p<span class="punctuation">[</span>sel_p_xy<span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<p>尽管上面的示例相当做作，主要用于教育目的而不是应用目的，我们鼓励读者复现结果以加深您对在R中处理地理矢量对象的理解，但它提出了一个重要问题：应该使用哪种实现？通常，应优先选择更简洁的实现，即上述的第一种方法。我们将在<em>算法</em>章中回到选择相同技术或算法的不同实现之间的问题。</p>
<h3 id="合并">合并</h3>
<p>正如我们在节中所看到的，空间聚合可以无声无息地溶解同一组中相接触的多边形的几何形状。下面的代码块演示了使用基础和<strong>dplyr</strong>函数将49个<code>us_states</code>聚合成四个区域的过程（见图中的结果）：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">regions <span class="operator">=</span> aggregate<span class="punctuation">(</span>x <span class="operator">=</span> us_states<span class="punctuation">[</span><span class="punctuation">,</span> <span class="string">&quot;total_pop_15&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span> by <span class="operator">=</span> <span class="built_in">list</span><span class="punctuation">(</span>us_states<span class="operator">$</span>REGION<span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">                    FUN <span class="operator">=</span> <span class="built_in">sum</span><span class="punctuation">,</span> na.rm <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br><span class="line">regions2 <span class="operator">=</span> us_states <span class="operator">|&gt;</span> </span><br><span class="line">  group_by<span class="punctuation">(</span>REGION<span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">  summarize<span class="punctuation">(</span>pop <span class="operator">=</span> <span class="built_in">sum</span><span class="punctuation">(</span>total_pop_15<span class="punctuation">,</span> na.rm <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309022322706.png" alt=""><br>
Spatial aggregation on contiguous polygons, illustrated by aggregating the population of US states into regions, with population represented by color. Note the operation automatically dissolves boundaries between states.</p>
<p>在几何方面发生了什么情况呢？在幕后，<code>aggregate()</code>和<code>summarize()</code>都使用<code>st_union()</code>组合几何体并溶解它们之间的边界。下面的代码块展示了如何创建一个统一的美国西部：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">us_west <span class="operator">=</span> us_states<span class="punctuation">[</span>us_states<span class="operator">$</span>REGION <span class="operator">==</span> <span class="string">&quot;West&quot;</span><span class="punctuation">,</span> <span class="punctuation">]</span></span><br><span class="line">us_west_union <span class="operator">=</span> st_union<span class="punctuation">(</span>us_west<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>该函数可以接受两个几何体并将它们联合起来，如下面的代码块所示，其中创建了一个包括德克萨斯州的统一的西部区块（挑战：重现并绘制结果）：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">texas <span class="operator">=</span> us_states<span class="punctuation">[</span>us_states<span class="operator">$</span>NAME <span class="operator">==</span> <span class="string">&quot;Texas&quot;</span><span class="punctuation">,</span> <span class="punctuation">]</span></span><br><span class="line">texas_union <span class="operator">=</span> st_union<span class="punctuation">(</span>us_west_union<span class="punctuation">,</span> texas<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<h3 id="类型转化">类型转化</h3>
<p>几何类型转换是一项强大的操作，可实现几何类型的转换。它在 <strong>sf</strong> 包的 <code>st_cast()</code> 函数中实现。重要的是，<code>st_cast()</code> 在单一简单要素几何（<code>sfg</code>）对象、简单要素几何列（<code>sfc</code>）和简单要素对象上的行为不同。</p>
<p>让我们创建一个多点对象来说明几何类型转换如何在简单要素几何（<code>sfg</code>）对象上工作：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">multipoint <span class="operator">=</span> st_multipoint<span class="punctuation">(</span>matrix<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">,</span> <span class="number">5</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">)</span><span class="punctuation">,</span> ncol <span class="operator">=</span> <span class="number">2</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>在这种情况下，<code>st_cast()</code>可以用于将新对象转换为线或多边形。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">linestring <span class="operator">=</span> st_cast<span class="punctuation">(</span>multipoint<span class="punctuation">,</span> <span class="string">&quot;LINESTRING&quot;</span><span class="punctuation">)</span></span><br><span class="line">polyg <span class="operator">=</span> st_cast<span class="punctuation">(</span>multipoint<span class="punctuation">,</span> <span class="string">&quot;POLYGON&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309022324831.png" alt=""><br>
Examples of a linestring and a polygon casted from a multipoint geometry.</p>
<p>从多点到线串的转换是一种常见的操作，它通过有序的点观测（例如 GPS 测量或地理标签媒体）创建线对象。反过来，这允许执行空间操作，例如计算所走路径的长度。从多点或线串到多边形的转换通常用于计算面积，例如从围绕湖泊的 GPS 测量集或从建筑用地的角落。</p>
<p>使用 <code>st_cast()</code> 还可以反转转换过程。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">multipoint_2 <span class="operator">=</span> st_cast<span class="punctuation">(</span>linestring<span class="punctuation">,</span> <span class="string">&quot;MULTIPOINT&quot;</span><span class="punctuation">)</span></span><br><span class="line">multipoint_3 <span class="operator">=</span> st_cast<span class="punctuation">(</span>polyg<span class="punctuation">,</span> <span class="string">&quot;MULTIPOINT&quot;</span><span class="punctuation">)</span></span><br><span class="line">all.equal<span class="punctuation">(</span>multipoint<span class="punctuation">,</span> multipoint_2<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] TRUE</span></span><br><span class="line">all.equal<span class="punctuation">(</span>multipoint<span class="punctuation">,</span> multipoint_3<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] TRUE</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>📌对于单个简单要素几何体（<code>sfg</code>），<code>st_cast()</code>还提供了从非多重类型到多重类型（例如，从<code>POINT</code>到<code>MULTIPOINT</code>）以及从多重类型到非多重类型的几何转换。然而，当从多重类型转换到非多重类型时，旧对象中的第一个元素将保留在输出对象中。</p>
</blockquote>
<p>几何转换对于简单特征几何列（<code>sfc</code>）和简单特征对象在大多数情况下与<code>sfg</code>的工作方式相同。其中一个重要的区别是多重类型与非多重类型之间的转换。因此，<code>sfc</code>或<code>sf</code>的多重对象被拆分成许多非多重对象。</p>
<p>下表显示了对简单特征对象的可能几何类型转换。单个简单特征几何（由表格的第一列表示）可以转换为多个几何类型，由下表的列表示。有些转换是不可能的：例如，您不能将单个点转换为多段线或多边形，这就解释了表格中的单元格<code>[1，4:5]</code>包含NA的原因。有些转换将单个要素输入拆分为多个子要素，对<code>sf</code>对象进行“扩展”（添加具有重复属性值的新行）。例如，当由五对坐标组成的多点几何体转换为’POINT’几何体时，输出将包含五个特征。</p>
<table>
<caption>Geometry casting on simple feature geometries (see Section 2.1) with input type by row and output type by column</caption>
 <thead>
  <tr>
   <th style="text-align:left;">  </th>
   <th style="text-align:right;"> POI </th>
   <th style="text-align:right;"> MPOI </th>
   <th style="text-align:right;"> LIN </th>
   <th style="text-align:right;"> MLIN </th>
   <th style="text-align:right;"> POL </th>
   <th style="text-align:right;"> MPOL </th>
   <th style="text-align:right;"> GC </th>
  </tr>
 </thead>
<tbody>
  <tr>
   <td style="text-align:left;"> POI(1) </td>
   <td style="text-align:right;"> 1 </td>
   <td style="text-align:right;"> 1 </td>
   <td style="text-align:right;"> 1 </td>
   <td style="text-align:right;"> NA </td>
   <td style="text-align:right;"> NA </td>
   <td style="text-align:right;"> NA </td>
   <td style="text-align:right;"> NA </td>
  </tr>
  <tr>
   <td style="text-align:left;"> MPOI(1) </td>
   <td style="text-align:right;"> 4 </td>
   <td style="text-align:right;"> 1 </td>
   <td style="text-align:right;"> 1 </td>
   <td style="text-align:right;"> 1 </td>
   <td style="text-align:right;"> 1 </td>
   <td style="text-align:right;"> NA </td>
   <td style="text-align:right;"> NA </td>
  </tr>
  <tr>
   <td style="text-align:left;"> LIN(1) </td>
   <td style="text-align:right;"> 5 </td>
   <td style="text-align:right;"> 1 </td>
   <td style="text-align:right;"> 1 </td>
   <td style="text-align:right;"> 1 </td>
   <td style="text-align:right;"> 1 </td>
   <td style="text-align:right;"> NA </td>
   <td style="text-align:right;"> NA </td>
  </tr>
  <tr>
   <td style="text-align:left;"> MLIN(1) </td>
   <td style="text-align:right;"> 7 </td>
   <td style="text-align:right;"> 2 </td>
   <td style="text-align:right;"> 2 </td>
   <td style="text-align:right;"> 1 </td>
   <td style="text-align:right;"> NA </td>
   <td style="text-align:right;"> NA </td>
   <td style="text-align:right;"> NA </td>
  </tr>
  <tr>
   <td style="text-align:left;"> POL(1) </td>
   <td style="text-align:right;"> 5 </td>
   <td style="text-align:right;"> 1 </td>
   <td style="text-align:right;"> 1 </td>
   <td style="text-align:right;"> 1 </td>
   <td style="text-align:right;"> 1 </td>
   <td style="text-align:right;"> 1 </td>
   <td style="text-align:right;"> NA </td>
  </tr>
  <tr>
   <td style="text-align:left;"> MPOL(1) </td>
   <td style="text-align:right;"> 10 </td>
   <td style="text-align:right;"> 1 </td>
   <td style="text-align:right;"> NA </td>
   <td style="text-align:right;"> 1 </td>
   <td style="text-align:right;"> 2 </td>
   <td style="text-align:right;"> 1 </td>
   <td style="text-align:right;"> 1 </td>
  </tr>
  <tr>
   <td style="text-align:left;"> GC(1) </td>
   <td style="text-align:right;"> 9 </td>
   <td style="text-align:right;"> 1 </td>
   <td style="text-align:right;"> NA </td>
   <td style="text-align:right;"> NA </td>
   <td style="text-align:right;"> NA </td>
   <td style="text-align:right;"> NA </td>
   <td style="text-align:right;"> 1 </td>
  </tr>
</tbody>
<tfoot>
<tr>
<td style = 'padding: 0; border:0;' colspan='100%'><sup></sup> 注意：像（1）这样的数值代表特征的数量；NA意味着该操作不可能。缩写：POI、LIN、POL 和 GC 分别指 POINT、LINESTRING、POLYGON 和 GEOMETRYCOLLECTION。这些几何类型的 MULTI 版本由一个前置的 M 表示，例如，MPOI 是 MULTIPOINT 的缩写。</td>
</tr>
</tfoot>
</table>
<p>让我们尝试在新对象<code>multilinestring_sf</code>上应用几何类型转换作为示例：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">multilinestring_list <span class="operator">=</span> <span class="built_in">list</span><span class="punctuation">(</span>matrix<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">4</span><span class="punctuation">,</span> <span class="number">5</span><span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">)</span><span class="punctuation">,</span> ncol <span class="operator">=</span> <span class="number">2</span><span class="punctuation">)</span><span class="punctuation">,</span> </span><br><span class="line">                            matrix<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">4</span><span class="punctuation">,</span> <span class="number">4</span><span class="punctuation">,</span> <span class="number">4</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">)</span><span class="punctuation">,</span> ncol <span class="operator">=</span> <span class="number">2</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">                            matrix<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">2</span><span class="punctuation">,</span> <span class="number">4</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">)</span><span class="punctuation">,</span> ncol <span class="operator">=</span> <span class="number">2</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">multilinestring <span class="operator">=</span> st_multilinestring<span class="punctuation">(</span>multilinestring_list<span class="punctuation">)</span></span><br><span class="line">multilinestring_sf <span class="operator">=</span> st_sf<span class="punctuation">(</span>geom <span class="operator">=</span> st_sfc<span class="punctuation">(</span>multilinestring<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">multilinestring_sf</span><br><span class="line"><span class="comment">#&gt; Simple feature collection with 1 feature and 0 fields</span></span><br><span class="line"><span class="comment">#&gt; Geometry type: MULTILINESTRING</span></span><br><span class="line"><span class="comment">#&gt; Dimension:     XY</span></span><br><span class="line"><span class="comment">#&gt; Bounding box:  xmin: 1 ymin: 1 xmax: 4 ymax: 5</span></span><br><span class="line"><span class="comment">#&gt; CRS:           NA</span></span><br><span class="line"><span class="comment">#&gt;                             geom</span></span><br><span class="line"><span class="comment">#&gt; 1 MULTILINESTRING ((1 5, 4 3)...</span></span><br></pre></td></tr></table></figure>
<p>你可以将其想象成一条道路或河流网络。新对象只有一行，定义了所有线条。这限制了可以执行的操作数量，例如阻止为每个线段添加名称或计算单条线的长度。在这种情况下，可以使用<code>st_cast()</code>函数，因为它将一条多段线分成三条线：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">linestring_sf2 <span class="operator">=</span> st_cast<span class="punctuation">(</span>multilinestring_sf<span class="punctuation">,</span> <span class="string">&quot;LINESTRING&quot;</span><span class="punctuation">)</span></span><br><span class="line">linestring_sf2</span><br><span class="line"><span class="comment">#&gt; Simple feature collection with 3 features and 0 fields</span></span><br><span class="line"><span class="comment">#&gt; Geometry type: LINESTRING</span></span><br><span class="line"><span class="comment">#&gt; Dimension:     XY</span></span><br><span class="line"><span class="comment">#&gt; Bounding box:  xmin: 1 ymin: 1 xmax: 4 ymax: 5</span></span><br><span class="line"><span class="comment">#&gt; CRS:           NA</span></span><br><span class="line"><span class="comment">#&gt;                    geom</span></span><br><span class="line"><span class="comment">#&gt; 1 LINESTRING (1 5, 4 3)</span></span><br><span class="line"><span class="comment">#&gt; 2 LINESTRING (4 4, 4 1)</span></span><br><span class="line"><span class="comment">#&gt; 3 LINESTRING (2 2, 4 2)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309022327383.png" alt=""><br>
Examples of type casting between MULTILINESTRING (left) and LINESTRING (right).</p>
<p>新创建的对象允许创建属性和测量长度：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">linestring_sf2<span class="operator">$</span>name <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;Riddle Rd&quot;</span><span class="punctuation">,</span> <span class="string">&quot;Marshall Ave&quot;</span><span class="punctuation">,</span> <span class="string">&quot;Foulke St&quot;</span><span class="punctuation">)</span></span><br><span class="line">linestring_sf2<span class="operator">$</span><span class="built_in">length</span> <span class="operator">=</span> st_length<span class="punctuation">(</span>linestring_sf2<span class="punctuation">)</span></span><br><span class="line">linestring_sf2</span><br><span class="line"><span class="comment">#&gt; Simple feature collection with 3 features and 2 fields</span></span><br><span class="line"><span class="comment">#&gt; Geometry type: LINESTRING</span></span><br><span class="line"><span class="comment">#&gt; Dimension:     XY</span></span><br><span class="line"><span class="comment">#&gt; Bounding box:  xmin: 1 ymin: 1 xmax: 4 ymax: 5</span></span><br><span class="line"><span class="comment">#&gt; CRS:           NA</span></span><br><span class="line"><span class="comment">#&gt;                    geom         name length</span></span><br><span class="line"><span class="comment">#&gt; 1 LINESTRING (1 5, 4 3)    Riddle Rd   3.61</span></span><br><span class="line"><span class="comment">#&gt; 2 LINESTRING (4 4, 4 1) Marshall Ave   3.00</span></span><br><span class="line"><span class="comment">#&gt; 3 LINESTRING (2 2, 4 2)    Foulke St   2.00</span></span><br></pre></td></tr></table></figure>
<h2 id="栅格数据几何操作">栅格数据几何操作</h2>
<p>几何栅格操作包括图像的平移、翻转、镜像、缩放、旋转或扭曲。这些操作在许多应用中是必要的，包括地理参考，用于让图像能够叠加在具有已知坐标参考系统（CRS）的准确地图上。存在多种地理参考技术，包括：</p>
<ul>
<li>基于已知 <a href="https://www.qgistutorials.com/en/docs/3/georeferencing_basics.html">ground control points</a>的地理校正</li>
<li>正射校正，还考虑了局部地形</li>
<li>图像<a href="https://en.wikipedia.org/wiki/Image_registration">registration</a> 用于通过使一幅图像与另一幅图像对齐（在坐标系统和分辨率方面）来组合拍摄同一物体但使用不同传感器拍摄的图像</li>
</ul>
<p>对于前两点，R 语言相当不适合，因为这些操作通常需要手动干预，这就是它们通常是在专用 GIS 软件的帮助下完成的原因。另一方面，在R中对几幅图像进行<em>对齐</em>是可能的，本节将展示如何执行此操作。这通常包括更改图像的<em>范围</em>、<em>分辨率</em>和<em>原点</em>。当然，也需要匹配的投影。</p>
<p>无论如何，有其他原因需要对单个栅格图像执行几何操作。例如，我们将德国的都市区定义为面积超过 20 平方千米、人口超过500,000的像素。然而，原始居民栅格的分辨率为1平方千米，这就是我们将分辨率降低（聚合）20倍的原因。聚合栅格的另一个原因就是简单地减少运行时间或节省磁盘空间。当然，只有当手头的任务允许栅格数据的粗分辨率时，才推荐使用此方法。</p>
<h3 id="几何相交">几何相交</h3>
<p>我们展示了如何从由其他空间对象覆盖的栅格中提取值。为了检索空间输出，我们可以使用几乎相同的子集提取语法。唯一的区别是必须明确表示我们希望把 <code>drop</code> 参数设置为 <code>FALSE</code> 来保持矩阵结构。这将返回一个包含与<code>clip</code>重叠中点的单元格的栅格对象。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">elev <span class="operator">=</span> rast<span class="punctuation">(</span>system.file<span class="punctuation">(</span><span class="string">&quot;raster/elev.tif&quot;</span><span class="punctuation">,</span> package <span class="operator">=</span> <span class="string">&quot;spData&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">clip <span class="operator">=</span> rast<span class="punctuation">(</span>xmin <span class="operator">=</span> <span class="number">0.9</span><span class="punctuation">,</span> xmax <span class="operator">=</span> <span class="number">1.8</span><span class="punctuation">,</span> ymin <span class="operator">=</span> <span class="operator">-</span><span class="number">0.45</span><span class="punctuation">,</span> ymax <span class="operator">=</span> <span class="number">0.45</span><span class="punctuation">,</span></span><br><span class="line">            resolution <span class="operator">=</span> <span class="number">0.3</span><span class="punctuation">,</span> vals <span class="operator">=</span> <span class="built_in">rep</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">9</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">elev<span class="punctuation">[</span>clip<span class="punctuation">,</span> drop <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">]</span></span><br><span class="line"><span class="comment">#&gt; class       : SpatRaster </span></span><br><span class="line"><span class="comment">#&gt; dimensions  : 2, 1, 1  (nrow, ncol, nlyr)</span></span><br><span class="line"><span class="comment">#&gt; resolution  : 0.5, 0.5  (x, y)</span></span><br><span class="line"><span class="comment">#&gt; extent      : 1, 1.5, -0.5, 0.5  (xmin, xmax, ymin, ymax)</span></span><br><span class="line"><span class="comment">#&gt; coord. ref. : lon/lat WGS 84 (EPSG:4326) </span></span><br><span class="line"><span class="comment">#&gt; source(s)   : memory</span></span><br><span class="line"><span class="comment">#&gt; name        : elev </span></span><br><span class="line"><span class="comment">#&gt; min value   :   18 </span></span><br><span class="line"><span class="comment">#&gt; max value   :   24</span></span><br></pre></td></tr></table></figure>
<p>对于相同的操作，我们还可以使用<code>intersect()</code>和<code>crop()</code>命令。</p>
<h3 id="范围和原点">范围和原点</h3>
<p>当合并栅格或在栅格上执行地图代数时，它们的分辨率、投影、原点和/或范围必须匹配。否则，我们如何将一个分辨率为0.2（十进制）度的栅格的值与分辨率为1（十进制）度的第二个栅格的值相加呢？当我们想要合并来自具有不同投影和分辨率的不同传感器的卫星图像时，会出现相同的问题。我们可以通过<em>对齐栅格</em>来处理不匹配的数据。</p>
<p>在最简单的情况下，两个图像只在其范围上有所不同。下面的代码在栅格的每一侧添加一行和两列，同时将所有新值设置为<code>NA</code>。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">elev <span class="operator">=</span> rast<span class="punctuation">(</span>system.file<span class="punctuation">(</span><span class="string">&quot;raster/elev.tif&quot;</span><span class="punctuation">,</span> package <span class="operator">=</span> <span class="string">&quot;spData&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">elev_2 <span class="operator">=</span> extend<span class="punctuation">(</span>elev<span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309022331979.png" alt=""><br>
Original raster (left) and the same raster (right) extended by one row on the top and bottom and two columns on the left and right.</p>
<p>在R中对具有不同范围的两个对象执行代数运算时，<strong>terra</strong>包会返回一个错误。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">elev_3 <span class="operator">=</span> elev <span class="operator">+</span> elev_2</span><br><span class="line"><span class="comment">#&gt; Error: [+] extents do not match</span></span><br></pre></td></tr></table></figure>
<p>当然，我们可以利用<code>extend()</code>来使两个栅格的范围相匹配。我们不是告诉函数要添加多少行或列，而是通过使用另一个栅格对象让它自行判断。在这里，我们将 <code>elev</code> 对象扩展到与 <code>elev_2</code> 的范围相同。新添加的行和列的值会被设置为 <code>NA</code>。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">elev_4 <span class="operator">=</span> extend<span class="punctuation">(</span>elev<span class="punctuation">,</span> elev_2<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>栅格的起始点是离坐标（0,0）最近的单元格角。<code>origin()</code> 函数返回起始点的坐标。在下面的例子中，存在一个坐标为（0,0）的单元格角，但这并不一定是起始点。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">origin<span class="punctuation">(</span>elev_4<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] 0 0</span></span><br></pre></td></tr></table></figure>
<p>如果两个栅格具有不同的起始点，它们的单元格将不会完全重叠，从而使地图代数运算变得不可能。要更改起始点，请使用 <code>origin()</code>。[^3]图揭示了以这种方式更改起始点的效果。</p>
<p>[^3]: 如果两个栅格数据集的起始点仅略有不同，有时简单地增加 <code>terra::terraOptions()</code> 的 <code>tolerance</code> 参数就足够了。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># change the origin</span></span><br><span class="line">origin<span class="punctuation">(</span>elev_4<span class="punctuation">)</span> <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0.25</span><span class="punctuation">,</span> <span class="number">0.25</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309022334940.png" alt=""><br>
Rasters with identical values but different origins.</p>
<p>注意，频繁改变分辨率，（下一节）也会改变原点。</p>
<h3 id="聚合和离散">聚合和离散</h3>
<p>栅格数据集在分辨率方面也可能有所不同。为了匹配分辨率，可以减小（使用<code>aggregate()</code>）或增加（使用<code>disagg()</code>）其中一个栅格的分辨率。<a href="%E8%AF%B7%E6%B3%A8%E6%84%8F%EF%BC%8C%E5%87%8F%E5%B0%8F%E5%88%86%E8%BE%A8%E7%8E%87%E4%BC%9A%E5%AF%BC%E8%87%B4%E6%95%B0%E6%8D%AE%E6%8D%9F%E5%A4%B1%EF%BC%8C%E8%80%8C%E5%A2%9E%E5%8A%A0%E5%88%86%E8%BE%A8%E7%8E%87%E4%B8%8D%E4%BC%9A%E6%8F%90%E4%BE%9B%E6%9B%B4%E7%B2%BE%E7%A1%AE%E7%9A%84%E6%95%B0%E6%8D%AE%E3%80%82">^4</a> 作为示例，我们在此通过一个因子5改变<code>dem</code>（在<strong>spDataLarge</strong> 包中找到）的空间分辨率。此外，输出单元格值应与输入单元格的平均值相对应（注意也可以使用其他函数，例如 <code>median()</code>、<code>sum()</code> 等）。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">dem <span class="operator">=</span> rast<span class="punctuation">(</span>system.file<span class="punctuation">(</span><span class="string">&quot;raster/dem.tif&quot;</span><span class="punctuation">,</span> package <span class="operator">=</span> <span class="string">&quot;spDataLarge&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">dem_agg <span class="operator">=</span> aggregate<span class="punctuation">(</span>dem<span class="punctuation">,</span> fact <span class="operator">=</span> <span class="number">5</span><span class="punctuation">,</span> fun <span class="operator">=</span> mean<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309022338901.png" alt=""><br>
Original raster (left). Aggregated raster (right).</p>
<p><code>disagg()</code> 函数用于增加栅格对象的分辨率。它提供了两种计算新创建单元格值的方法：默认方法（<code>method = &quot;near&quot;</code>）仅将输入单元格的值赋给所有输出单元格，从而复制值，导致输出呈“块状”。<code>bilinear</code> 方法使用输入图像的四个最近像素中心（图中的鲑鱼色点）来按距离计算加权平均值（图中的箭头）。输出单元格的值由图左上角的方块表示。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">dem_disagg <span class="operator">=</span> disagg<span class="punctuation">(</span>dem_agg<span class="punctuation">,</span> fact <span class="operator">=</span> <span class="number">5</span><span class="punctuation">,</span> method <span class="operator">=</span> <span class="string">&quot;bilinear&quot;</span><span class="punctuation">)</span></span><br><span class="line">identical<span class="punctuation">(</span>dem<span class="punctuation">,</span> dem_disagg<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] FALSE</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309022339937.png" alt=""><br>
The distance-weighted average of the four closest input cells determine the output when using the bilinear method for disaggregation.</p>
<p>比较<code>dem</code>和<code>dem_disagg</code>的值，我们可以发现它们并不相同（您也可以使用<code>compareGeom()</code> 或<code>all.equal()</code>）。然而，这几乎是意料之中的，因为细分是一种简单的插值技术。重要的是要记住，细分会导致更精细的分辨率；然而，相应的值只能与其较低分辨率的源数据一样准确。</p>
<h3 id="重采样">重采样</h3>
<p>上述聚合和细分的方法仅适用于我们想要通过聚合/细分因子来改变栅格的分辨率的情况。然而，当我们有两个或更多具有不同分辨率和原点的栅格时该怎么办呢？这就是重采样的作用 – 一个计算新像素位置值的过程。简而言之，这个过程采取我们原始栅格的值，并为具有自定义分辨率和原点的目标栅格重新计算新值。</p>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309030006472.png" alt=""><br>
Resampling of an original (input) raster into a target raster with custom resolution and origin.</p>
<p>有几种方法可以用来估计具有不同分辨率/原点的栅格的值。主要的重采样方法包括：</p>
<ul>
<li>最近邻：将原始栅格的最近单元格的值分配给目标栅格的单元格。这是一种快速简单的技术，通常适用于对<em>分类栅格</em>进行重采样。</li>
<li>双线性插值：将原始栅格的四个最近单元格的加权平均值分配给目标栅格的单元格（见图@ref(fig:bilinear)）。这是适用于<em>连续栅格</em>的最快方法。</li>
<li>三次插值：使用原始栅格的16个最近单元格的值来确定输出单元格的值，应用三次多项式函数。用于<em>连续栅格</em>，并且与双线性插值相比，结果表面更平滑，但计算上更耗费资源。</li>
<li>三次样条插值：也使用原始栅格的16个最近单元格的值来确定输出单元格的值，但应用三次样条（分段三次多项式函数）。用于<em>连续栅格</em>。</li>
<li>Lanczos窗口化sinc重采样：使用原始栅格的36个最近单元格的值来确定输出单元格的值。用于连续栅格。[^5]</li>
</ul>
<p>[^5]: 关于这种方法的更详细解释可以在 <a href="https://gis.stackexchange.com/a/14361/20955">https://gis.stackexchange.com/a/14361/20955</a> 找到。</p>
<p>上述解释强调，只有<em>最近邻</em>重采样适用于分类栅格，而所有方法都可以用于连续栅格（结果不同）。还请注意，这些方法从上到下在复杂性和处理时间上都有所增加。</p>
<p>要应用重采样，<strong>terra</strong> 包提供了一个 <code>resample()</code> 函数。它接受一个输入栅格（<code>x</code>），一个具有目标空间属性的栅格（<code>y</code>），以及一个重采样方法（<code>method</code>）。</p>
<p>我们需要一个具有目标空间属性的栅格来了解 <code>resample()</code> 函数是如何工作的。在这个例子中，我们创建了<code>target_rast</code>，但通常你会使用一个已经存在的栅格对象。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">target_rast <span class="operator">=</span> rast<span class="punctuation">(</span>xmin <span class="operator">=</span> <span class="number">794650</span><span class="punctuation">,</span> xmax <span class="operator">=</span> <span class="number">798250</span><span class="punctuation">,</span> </span><br><span class="line">                   ymin <span class="operator">=</span> <span class="number">8931750</span><span class="punctuation">,</span> ymax <span class="operator">=</span> <span class="number">8935350</span><span class="punctuation">,</span></span><br><span class="line">                   resolution <span class="operator">=</span> <span class="number">300</span><span class="punctuation">,</span> crs <span class="operator">=</span> <span class="string">&quot;EPSG:32717&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>接下来，我们需要提供两个栅格对象作为前两个参数，并选择上述重采样方法中的一个。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">dem_resampl <span class="operator">=</span> resample<span class="punctuation">(</span>dem<span class="punctuation">,</span> y <span class="operator">=</span> target_rast<span class="punctuation">,</span> method <span class="operator">=</span> <span class="string">&quot;bilinear&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>下图展示了对<code>dem</code>对象应用不同重采样方法的比较。</p>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309030008634.png" alt=""><br>
Visual comparison of the original raster and five different resampling methods.</p>
<p><code>resample()</code> 函数还有一些额外的重采样方法，包括<code>sum</code>、<code>min</code>、<code>q1</code>、<code>med</code>、<code>q3</code>、<code>max</code>、<code>average</code>、<code>mode</code>和<code>rms</code>。所有这些方法都基于所有非NA贡献网格单元的值计算给定的统计量。例如，当每个栅格单元代表一个空间广泛的变量（例如，人数）时，<code>sum</code>是有用的。使用<code>sum</code>的效果是，重采样后的栅格应与原始栅格具有相同的人口总数。</p>
<p>当我们的目标栅格与原始栅格具有不同的坐标参照系统（CRS）时，栅格重投影是重采样的特殊情况。</p>
<blockquote>
<p>📌<strong>terra</strong>中的大多数几何操作都是用户友好的，相当快速，并可用于大型栅格对象。然而，可能存在一些情况，当涉及到广泛的栅格或许多栅格文件时，<strong>terra</strong>可能不是最高效的，应该考虑一些替代方案。</p>
</blockquote>
<p>最成熟的替代方案来自GDAL库。它包括几个实用功能，包括：</p>
<ul>
<li><code>gdalinfo</code> - 列出有关栅格文件的各种信息，包括其分辨率、CRS、边界框等。</li>
<li><code>gdal_translate</code> - 在不同的文件格式之间转换栅格数据。</li>
<li><code>gdal_rasterize</code> - 将矢量数据转换为栅格文件。</li>
<li><code>gdalwarp</code> - 允许栅格镶嵌、重采样、裁剪和重投影。</li>
</ul>
<p>以上所有函数都是用C++编写的，但可以使用<code>sf::gdal_utils()</code>、<strong>gdalUtilities</strong>包或通过系统命令在R中调用。重要的是，所有这些函数都期望栅格文件路径作为输入，并经常将其输出作为栅格文件返回（例如，<code>gdalUtilities::gdal_translate(&quot;my_file.tif&quot;, &quot;new_file.tif&quot;, t_srs = &quot;EPSG:4326&quot;)</code>）。这与通常的<strong>terra</strong>方法非常不同，后者期望<code>SpatRaster</code>对象作为输入。</p>
<h2 id="练习">练习</h2>
<p>E1. 生成并绘制 <code>nz</code> 数据集的简化版本。使用 <code>ms_simplify()</code> 的不同 <code>keep</code> 值（范围从0.5到0.00005）和 <code>st_simplify()</code> 的不同 <code>dTolerance</code> 值（从100到100,000）进行实验。</p>
<ul>
<li>对于每种方法，从什么值开始，结果的形态开始崩溃，使新西兰变得不可识别？</li>
<li>高级: <code>st_simplify()</code> 的结果几何类型与 <code>ms_simplify()</code> 的几何类型有什么不同？这会造成什么问题，如何解决？</li>
</ul>
<p>E2. 在空间数据操作章节的第一个练习中，已经确定坎特伯雷地区拥有新西兰101个最高点中的70个。使用 <code>st_buffer()</code>，<code>nz_height</code> 中有多少点在坎特伯雷的100 km内？</p>
<p>E3. 找到新西兰的地理中心。它距离坎特伯雷的地理中心有多远？</p>
<p>E4. 大多数世界地图都是朝北的。通过反射 <code>world</code> 对象的几何体（本章未提及的仿射变换之一），可以创建一个朝南的世界地图。编写代码来实现这一点。提示: 你需要使用一个两元素向量来进行此转换。加分题: 创建一个倒立的国家地图。</p>
<p>E5. 运行<a href="https://r.geocompx.org/geometry-operations.html#subsetting-and-clipping">5.2.6</a>章节中的代码。参考该章节中创建的对象，找出包含在 <code>x</code> <em>和</em> <code>y</code> 中的 <code>p</code> 中的点。</p>
<ul>
<li>使用基本子集运算符。</li>
<li>使用 <code>st_intersection()</code> 创建的中间对象。</li>
</ul>
<p>E6. 以米为单位计算美国各州的边界线长度。哪个州的边界最长，哪个州的边界最短？提示: <code>st_length</code> 函数计算 <code>LINESTRING</code> 或 <code>MULTILINESTRING</code> 几何的长度。</p>
<p>E7. 将 srtm.tif 文件读入 R (<code>srtm = rast(system.file(&quot;raster/srtm.tif&quot;, package = &quot;spDataLarge&quot;))</code>)。此栅格的分辨率为0.00083乘以0.00083度。使用 <strong>terra</strong> 包中提供的所有方法，将其分辨率更改为0.01乘以0.01度。可视化结果。你能注意到这些重采样方法的结果之间有任何区别吗？</p>
]]></content>
      <categories>
        <category>R</category>
        <category>Geocomputaion</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>Geocomputaion</tag>
      </tags>
  </entry>
  <entry>
    <title>(6)栅格矢量交叉</title>
    <url>/2023/08/15/2023-8-15-6%E6%A0%85%E6%A0%BC%E7%9F%A2%E9%87%8F%E4%BA%A4%E5%8F%89/</url>
    <content><![CDATA[<blockquote><p>本文由SCY翻译自《Geocomputation with R》<a href="https://r.geocompx.org/raster-vector">第六章</a></p>
</blockquote>
<p>本章专注于栅格和矢量地理数据模型之间的相互作用。包括四个主要技术：使用矢量对象进行栅格裁剪和遮罩；使用不同类型的矢量数据提取栅格值；以及栅格与矢量之间的转换。以上概念使用前几章中使用的数据进行演示，以了解其潜在的现实应用。</p>
<span id="more"></span>
<h1>前提条件</h1>
<ul>
<li>本章要求下列包：</li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>sf<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>terra<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>dplyr<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<h1>引言</h1>
<p>本章专注于栅格和矢量地理数据模型之间的相互作用。包括四个主要技术：使用矢量对象进行栅格裁剪和遮罩；使用不同类型的矢量数据提取栅格值；以及栅格与矢量之间的转换。以上概念使用前几章中使用的数据进行演示，以了解其潜在的现实应用。</p>
<h1>栅格裁剪</h1>
<p>许多地理数据项目涉及从许多不同来源整合数据，例如遥感图像（栅格）和行政边界（矢量）。通常，输入栅格数据集的范围大于感兴趣的区域。在这种情况下，栅格<strong>裁剪</strong>和<strong>掩膜</strong>对于统一输入数据的空间范围非常有用。这两个操作减少了对象的内存使用和后续分析步骤的相关计算资源，而且是创建涉及栅格数据地图之前必要的预处理步骤。</p>
<p>我们将使用两个对象来说明栅格裁剪：</p>
<ul>
<li>一个代表犹他州西南部海拔高度（海平面以上米数）的<code>SpatRaster</code>对象<code>srtm</code></li>
<li>一个代表锡安国家公园的矢量（<code>sf</code>）对象 <code>zion</code></li>
</ul>
<p>目标对象和裁剪对象必须具有相同的投影。因此，下面的代码块不仅从<strong>spDataLarge</strong>包中读取了章节@ref(spatial-class) 中安装的数据集，还对<code>zion</code>进行了“重投影”。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">srtm <span class="operator">=</span> rast<span class="punctuation">(</span>system.file<span class="punctuation">(</span><span class="string">&quot;raster/srtm.tif&quot;</span><span class="punctuation">,</span> package <span class="operator">=</span> <span class="string">&quot;spDataLarge&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">zion <span class="operator">=</span> read_sf<span class="punctuation">(</span>system.file<span class="punctuation">(</span><span class="string">&quot;vector/zion.gpkg&quot;</span><span class="punctuation">,</span> package <span class="operator">=</span> <span class="string">&quot;spDataLarge&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">zion <span class="operator">=</span> st_transform<span class="punctuation">(</span>zion<span class="punctuation">,</span> crs<span class="punctuation">(</span>srtm<span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>我们使用<strong>terra</strong>包的<code>crop()</code>函数来裁剪<code>srtm</code>栅格。该函数根据传递给其第二个参数的对象的范围减小传递给其第一个参数的对象的矩形范围。下面的命令演示了这个功能，生成了图：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">srtm_cropped <span class="operator">=</span> crop<span class="punctuation">(</span>srtm<span class="punctuation">,</span> zion<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>与<code>crop()</code>相关的是<strong>terra</strong>函数<code>mask()</code>，它将传递给第二个参数的对象范围之外的值设置为<code>NA</code>。因此，以下命令会掩膜锡安国家公园边界以外的每一个单元格：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">srtm_masked <span class="operator">=</span> mask<span class="punctuation">(</span>srtm<span class="punctuation">,</span> zion<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>重要的是，在大多数情况下，我们想要同时使用<code>crop()</code>和<code>mask()</code> 这两个函数。这组函数的组合将(a)将栅格的范围限制在我们感兴趣的区域内，然后 (b) 将该区域外的所有值替换为NA。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">srtm_cropped <span class="operator">=</span> crop<span class="punctuation">(</span>srtm<span class="punctuation">,</span> zion<span class="punctuation">)</span></span><br><span class="line">srtm_final <span class="operator">=</span> mask<span class="punctuation">(</span>srtm_cropped<span class="punctuation">,</span> zion<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>更改<code>mask()</code>的设置会产生不同的结果。设置<code>inverse = TRUE</code>将会屏蔽公园范围<em>内</em>的所有内容（详见<code>?mask</code>），而设置 <code>updatevalue = 0</code> 将会将国家公园外的所有像素设置为0。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">srtm_inv_masked <span class="operator">=</span> mask<span class="punctuation">(</span>srtm<span class="punctuation">,</span> zion<span class="punctuation">,</span> inverse <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#&gt; The legacy packages maptools, rgdal, and rgeos, underpinning the sp package,</span><br><span class="line">#&gt; which was just loaded, will retire in October 2023.</span><br><span class="line">#&gt; Please refer to R-spatial evolution reports for details, especially</span><br><span class="line">#&gt; https://r-spatial.org/r/2023/05/15/evolution4.html.</span><br><span class="line">#&gt; It may be desirable to make the sf package available;</span><br><span class="line">#&gt; package maintainers should consider adding sf to Suggests:.</span><br><span class="line">#&gt; The sp package is now running under evolution status 2</span><br><span class="line">#&gt;      (status 2 uses the sf package in place of rgdal)</span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309030016800.png" alt=""><br>
Illustration of raster cropping and raster masking.</p>
<h2 id="栅格提取">栅格提取</h2>
<p>栅格提取是识别并返回基于（通常是矢量）地理“选择器”对象在特定位置的“目标”栅格关联的值的过程。结果取决于所使用的选择器的类型（点、线或多边形）以及传递给<code>terra::extract()</code>函数的参数。栅格提取的反向过程 — 基于矢量对象分配栅格单元格值 — 是<em>栅格化</em>，详见 @ref(rasterization) 部分。</p>
<p>基本示例是在特定<strong>点</strong>处提取栅格单元格的值。为此，我们将使用 <code>zion_points</code>，其中包含锡安国家公园内的30个位置样本（见图 @ref(fig:pointextr)）。以下命令从<code>srtm</code>中提取高程值，并创建一个包含点的ID（每个矢量的一行一个值）和每个点的相关<code>srtm</code>值的数据框。现在，我们可以使用<code>cbind()</code>函数将结果对象添加到我们的<code>zion_points</code>数据集中：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">data<span class="punctuation">(</span><span class="string">&quot;zion_points&quot;</span><span class="punctuation">,</span> package <span class="operator">=</span> <span class="string">&quot;spDataLarge&quot;</span><span class="punctuation">)</span></span><br><span class="line">elevation <span class="operator">=</span> terra<span class="operator">::</span>extract<span class="punctuation">(</span>srtm<span class="punctuation">,</span> zion_points<span class="punctuation">)</span></span><br><span class="line">zion_points <span class="operator">=</span> cbind<span class="punctuation">(</span>zion_points<span class="punctuation">,</span> elevation<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<div class="figure" style="text-align: center">
<img data-src="06-raster-vector_files/figure-html/pointextr-1.png" alt="Locations of points used for raster extraction." width="100%" />
<p class="caption">(\#fig:pointextr)Locations of points used for raster extraction.</p>
</div>
<p>栅格提取也适用于<strong>线</strong>选择器。提取线所接触的每个栅格单元格的一个值。然而，线提取方法不推荐用于沿截面获取值，因为很难获得每一对提取的栅格值之间的正确距离。</p>
<p>在这种情况下，更好的方法是将线分割成许多点，然后为这些点提取值。为了演示这一点，下面的代码创建了 <code>zion_transect</code>，一条从锡安国家公园的西北部到东南部的直线，如图 @ref(fig:lineextr)(A)所示（有关矢量数据模型的回顾，请参见 @ref(vector-data) 部分）：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">zion_transect <span class="operator">=</span> cbind<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="operator">-</span><span class="number">113.2</span><span class="punctuation">,</span> <span class="operator">-</span><span class="number">112.9</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">37.45</span><span class="punctuation">,</span> <span class="number">37.2</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">  st_linestring<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">|&gt;</span> </span><br><span class="line">  st_sfc<span class="punctuation">(</span>crs <span class="operator">=</span> crs<span class="punctuation">(</span>srtm<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">  st_sf<span class="punctuation">(</span>geometry <span class="operator">=</span> _<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>规划徒步旅行时，从线性选择器中提取高度的实用性可见一斑。下面演示的方法提供了路线的“海拔剖面图”（线不需要是直的），这对于估计由于长时间攀爬而需要的时间非常有用。</p>
<p>第一步是为每个截面添加唯一的 <code>id</code>。接下来，我们可以使用 <code>st_segmentize()</code>函数在我们的线（或线）上用提供的密度（<code>dfMaxLength</code>）添加点，并使用 <code>st_cast()</code> 将它们转换为点。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">zion_transect<span class="operator">$</span>id <span class="operator">=</span> <span class="number">1</span><span class="operator">:</span>nrow<span class="punctuation">(</span>zion_transect<span class="punctuation">)</span></span><br><span class="line">zion_transect <span class="operator">=</span> st_segmentize<span class="punctuation">(</span>zion_transect<span class="punctuation">,</span> dfMaxLength <span class="operator">=</span> <span class="number">250</span><span class="punctuation">)</span></span><br><span class="line">zion_transect <span class="operator">=</span> st_cast<span class="punctuation">(</span>zion_transect<span class="punctuation">,</span> <span class="string">&quot;POINT&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>现在，我们有了一大组点，我们想要推导出我们的截面中第一个点与后续各点之间的距离。在这种情况下，我们只有一个截面，但原则上，代码应该适用于任何数量的截面：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">zion_transect <span class="operator">=</span> zion_transect <span class="operator">|&gt;</span> </span><br><span class="line">  group_by<span class="punctuation">(</span>id<span class="punctuation">)</span> <span class="operator">|&gt;</span> </span><br><span class="line">  mutate<span class="punctuation">(</span>dist <span class="operator">=</span> st_distance<span class="punctuation">(</span>geometry<span class="punctuation">)</span><span class="punctuation">[</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">]</span><span class="punctuation">)</span> </span><br></pre></td></tr></table></figure>
<p>最后，我们可以提取截面中每个点的高程值，并将此信息与我们的主要对象结合起来。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">zion_elev <span class="operator">=</span> terra<span class="operator">::</span>extract<span class="punctuation">(</span>srtm<span class="punctuation">,</span> zion_transect<span class="punctuation">)</span></span><br><span class="line">zion_transect <span class="operator">=</span> cbind<span class="punctuation">(</span>zion_transect<span class="punctuation">,</span> zion_elev<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>所得到的<code>zion_transect</code>可以用来创建高程剖面图，如图所示。</p>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309031415868.png" alt=""><br>
Location of a line used for raster extraction (left) and the elevation along this line (right).</p>
<p>栅格提取的最后一种地理矢量对象是<strong>多边形</strong>。与线条一样，多边形每个多边形倾向于返回许多栅格值。以下命令演示了这一点，其结果是一个数据框，列名为<code>ID</code>（多边形的行号）和<code>srtm</code>（相关的海拔值）：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">zion_srtm_values <span class="operator">=</span> terra<span class="operator">::</span>extract<span class="punctuation">(</span>x <span class="operator">=</span> srtm<span class="punctuation">,</span> y <span class="operator">=</span> zion<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>这样的结果可以用来生成每个多边形的栅格值的汇总统计信息，例如用来描述单个区域或比较多个区域。下面的代码展示了这一点，它创建了对象<code>zion_srtm_df</code>，包含锡安国家公园内的海拔值的汇总统计信息：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">group_by<span class="punctuation">(</span>zion_srtm_values<span class="punctuation">,</span> ID<span class="punctuation">)</span> <span class="operator">|&gt;</span> </span><br><span class="line">  summarize<span class="punctuation">(</span>across<span class="punctuation">(</span>srtm<span class="punctuation">,</span> <span class="built_in">list</span><span class="punctuation">(</span><span class="built_in">min</span> <span class="operator">=</span> <span class="built_in">min</span><span class="punctuation">,</span> mean <span class="operator">=</span> mean<span class="punctuation">,</span> <span class="built_in">max</span> <span class="operator">=</span> <span class="built_in">max</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; # A tibble: 1 × 4</span></span><br><span class="line"><span class="comment">#&gt;      ID srtm_min srtm_mean srtm_max</span></span><br><span class="line"><span class="comment">#&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;</span></span><br><span class="line"><span class="comment">#&gt; 1     1     1122     1818.     2661</span></span><br></pre></td></tr></table></figure>
<p>前述代码段使用了<strong>dplyr</strong>来提供每个多边形ID的单元格值的汇总统计信息。结果提供了有用的总结，例如公园内的最大高度约为海拔2661米（也可以用这种方式计算其他汇总统计信息，如标准差）。因为示例中只有一个多边形，所以返回了一个单行的数据框；然而，当使用多个选择多边形时，该方法同样适用。</p>
<p>相似的方法适用于在多边形内计数分类栅格值的出现次数。这通过一个土地覆盖数据集（<code>nlcd</code>）在上图中进行说明，并在下面的代码中演示：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">nlcd <span class="operator">=</span> rast<span class="punctuation">(</span>system.file<span class="punctuation">(</span><span class="string">&quot;raster/nlcd.tif&quot;</span><span class="punctuation">,</span> package <span class="operator">=</span> <span class="string">&quot;spDataLarge&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">zion2 <span class="operator">=</span> st_transform<span class="punctuation">(</span>zion<span class="punctuation">,</span> st_crs<span class="punctuation">(</span>nlcd<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">zion_nlcd <span class="operator">=</span> terra<span class="operator">::</span>extract<span class="punctuation">(</span>nlcd<span class="punctuation">,</span> zion2<span class="punctuation">)</span></span><br><span class="line">zion_nlcd <span class="operator">|&gt;</span> </span><br><span class="line">  group_by<span class="punctuation">(</span>ID<span class="punctuation">,</span> levels<span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">  count<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; # A tibble: 7 × 3</span></span><br><span class="line"><span class="comment">#&gt; # Groups:   ID, levels [7]</span></span><br><span class="line"><span class="comment">#&gt;      ID levels         n</span></span><br><span class="line"><span class="comment">#&gt;   &lt;dbl&gt; &lt;fct&gt;      &lt;int&gt;</span></span><br><span class="line"><span class="comment">#&gt; 1     1 Developed   4205</span></span><br><span class="line"><span class="comment">#&gt; 2     1 Barren     98285</span></span><br><span class="line"><span class="comment">#&gt; 3     1 Forest    298299</span></span><br><span class="line"><span class="comment">#&gt; 4     1 Shrubland 203701</span></span><br><span class="line"><span class="comment">#&gt; # ℹ 3 more rows</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309031417001.png" alt=""><br>
Area used for continuous (left) and categorical (right) raster extraction.</p>
<p>尽管<strong>terra</strong>包提供了在多边形内快速提取栅格值的功能，<code>extract()</code>在处理大型多边形数据集时仍可能成为瓶颈。<strong>exactextractr</strong>包通过<code>exact_extract()</code>函数提供了一个<a href="https://github.com/geocompx/geocompr/issues/813">明显更快的替代方案</a>用于提取像素值。<code>exact_extract()</code>函数还默认计算了每个栅格单元被多边形重叠的部分，这更为精确（有关详细信息，请参见下面的注释）。</p>
<blockquote>
<p>📌多边形通常具有不规则的形状，因此，多边形可能只与栅格的某些部分重叠。<br>
为了获得更详细的结果，<code>terra::extract()</code> 函数有一个叫做 <code>exact</code> 的参数。<br>
通过设置 <code>exact = TRUE</code>，我们在输出的数据框中多得到一列<code>fraction</code>，代表每个单元格被多边形覆盖的部分。<br>
这可以用于计算例如连续栅格的加权平均值或者分类栅格的更精确覆盖率。<br>
默认情况下，它的值为 <code>FALSE</code>，因为这个操作需要更多的计算。<br>
<code>exactextractr::exact_extract()</code> 函数始终计算多边形在每个单元格中的覆盖部分。</p>
</blockquote>
<h2 id="栅格化">栅格化</h2>
<p>栅格化是将矢量对象转换为栅格对象表示的过程。通常，输出栅格随后用于定量分析（例如，地形分析）或建模。栅格数据模型具有一些特性，使其有助于某些方法。此外，栅格化过程可以帮助简化数据集，因为所得的值都具有相同的空间分辨率：栅格化可以看作是地理数据聚合的一种特殊类型。</p>
<p><strong>terra</strong> 包中包含了用于执行此工作的 <code>rasterize()</code> 函数。其前两个参数是 <code>x</code>（要栅格化的矢量对象）和<code>y</code>（定义输出范围、分辨率和坐标参考系统的“模板栅格”对象）。输入栅格的地理分辨率对结果有重大影响：如果分辨率过低（单元格大小过大），结果可能会错过矢量数据的全部地理变化；如果分辨率过高，则计算时间可能过长。在决定适当的地理分辨率时没有简单的规则可遵循，这在很大程度上取决于结果的预期用途。例如，当栅格化的输出需要与某些其他现有栅格对齐时，目标分辨率通常由用户决定。</p>
<p>为了演示栅格化的实际效果，我们将使用一个模板栅格，其范围和坐标参考系统与输入矢量数据<code>cycle_hire_osm_projected</code>相同，并且空间分辨率为1000米：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">cycle_hire_osm <span class="operator">=</span> spData<span class="operator">::</span>cycle_hire_osm</span><br><span class="line">cycle_hire_osm_projected <span class="operator">=</span> st_transform<span class="punctuation">(</span>cycle_hire_osm<span class="punctuation">,</span> <span class="string">&quot;EPSG:27700&quot;</span><span class="punctuation">)</span></span><br><span class="line">raster_template <span class="operator">=</span> rast<span class="punctuation">(</span>ext<span class="punctuation">(</span>cycle_hire_osm_projected<span class="punctuation">)</span><span class="punctuation">,</span> resolution <span class="operator">=</span> <span class="number">1000</span><span class="punctuation">,</span></span><br><span class="line">                       crs <span class="operator">=</span> st_crs<span class="punctuation">(</span>cycle_hire_osm_projected<span class="punctuation">)</span><span class="operator">$</span>wkt<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>栅格化是一项非常灵活的操作：结果不仅取决于模板栅格的性质，还取决于输入矢量的类型（例如，点、多边形）以及 <code>rasterize()</code> 函数所采用的各种参数。</p>
<p>为了说明这种灵活性，我们将尝试三种不同的栅格化方法。首先，我们创建一个表示自行车租赁点存在或不存在的栅格（称为存在/不存在栅格）。在这种情况下，<code>rasterize()</code> 除了上述的矢量和栅格对象 <code>x</code> 和 <code>y</code> 之外，不需要任何参数。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ch_raster1 <span class="operator">=</span> rasterize<span class="punctuation">(</span>cycle_hire_osm_projected<span class="punctuation">,</span> raster_template<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><code>fun</code>参数用于指定将紧密相邻的多个观测值转换为栅格对象中的关联单元格所使用的汇总统计信息。默认情况下使用 <code>fun = &quot;last&quot;</code>，但也可以使用其他选项，例如 <code>fun = &quot;length&quot;</code>，在这种情况下，用于计算每个网格单元格中自行车租赁点的数量。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ch_raster2 <span class="operator">=</span> rasterize<span class="punctuation">(</span>cycle_hire_osm_projected<span class="punctuation">,</span> raster_template<span class="punctuation">,</span> </span><br><span class="line">                       fun <span class="operator">=</span> <span class="string">&quot;length&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>新的输出结果，<code>ch_raster2</code>，展示了每个网格单元中的自行车租赁点数量。自行车租赁地点拥有不同数量的自行车，由<code>capacity</code>变量描述，这引发了一个问题：每个网格单元的容量是多少？为了计算这个值，我们必须对字段（<code>&quot;capacity&quot;</code>）进行求和，从而得到图所示的输出结果（也可以使用其他汇总函数，例如 <code>mean</code>）。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ch_raster3 <span class="operator">=</span> rasterize<span class="punctuation">(</span>cycle_hire_osm_projected<span class="punctuation">,</span> raster_template<span class="punctuation">,</span> </span><br><span class="line">                       field <span class="operator">=</span> <span class="string">&quot;capacity&quot;</span><span class="punctuation">,</span> fun <span class="operator">=</span> <span class="built_in">sum</span><span class="punctuation">,</span> na.rm <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309031421627.png" alt=""><br>
Examples of point rasterization.</p>
<p>另一个基于加利福尼亚州的多边形和边界的数据集（如下所示）用于说明线的栅格化。在将多边形对象转换为多段线后，创建了一个具有0.5度分辨率的模板栅格。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">california <span class="operator">=</span> dplyr<span class="operator">::</span>filter<span class="punctuation">(</span>us_states<span class="punctuation">,</span> NAME <span class="operator">==</span> <span class="string">&quot;California&quot;</span><span class="punctuation">)</span></span><br><span class="line">california_borders <span class="operator">=</span> st_cast<span class="punctuation">(</span>california<span class="punctuation">,</span> <span class="string">&quot;MULTILINESTRING&quot;</span><span class="punctuation">)</span></span><br><span class="line">raster_template2 <span class="operator">=</span> rast<span class="punctuation">(</span>ext<span class="punctuation">(</span>california<span class="punctuation">)</span><span class="punctuation">,</span> resolution <span class="operator">=</span> <span class="number">0.5</span><span class="punctuation">,</span></span><br><span class="line">                        crs <span class="operator">=</span> st_crs<span class="punctuation">(</span>california<span class="punctuation">)</span><span class="operator">$</span>wkt<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>在考虑线或多边形栅格化时，一个有用的附加参数是<code>touches</code>。默认情况下，它为<code>FALSE</code>，但当更改为<code>TRUE</code>时，所有被线或多边形边界触及的单元格都会得到一个值。下面的代码展示了使用<code>touches = TRUE</code>的线栅格化。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">california_raster1 <span class="operator">=</span> rasterize<span class="punctuation">(</span>california_borders<span class="punctuation">,</span> raster_template2<span class="punctuation">,</span></span><br><span class="line">                               touches <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>与多边形栅格化相比，默认情况下<code>touches = FALSE</code>，只选择其质心在选择多边形内的栅格单元格，如图所示。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">california_raster2 <span class="operator">=</span> rasterize<span class="punctuation">(</span>california<span class="punctuation">,</span> raster_template2<span class="punctuation">)</span> </span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309031422308.png" alt=""><br>
Examples of line and polygon rasterizations.</p>
<h2 id="空间矢量化">空间矢量化</h2>
<p>空间矢量化是栅格化的对应部分，但方向相反。它涉及将空间连续的栅格数据转换为空间离散的矢量数据，例如点、线或多边形。</p>
<blockquote>
<p>📌确实，我们应当小心措辞以避免混淆！<br>
在R语言中，矢量化通常指的是通过类似<code>1:10/2</code>这样的操作来替代<code>for</code>循环等结构的可能性（详见@wickham_advanced_2019）。所以，当谈到将栅格数据转换为矢量数据时，我们应避免使用“矢量化”一词，以免与R中的这一特定概念混淆。</p>
</blockquote>
<p>矢量化的最简单形式是将栅格单元格的中心点转换为点。<code>as.points()</code>正是针对所有非<code>NA</code>的栅格网格单元格进行此操作。注意，这里我们还使用了<code>st_as_sf()</code>来将结果对象转换为<code>sf</code>类。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">elev <span class="operator">=</span> rast<span class="punctuation">(</span>system.file<span class="punctuation">(</span><span class="string">&quot;raster/elev.tif&quot;</span><span class="punctuation">,</span> package <span class="operator">=</span> <span class="string">&quot;spData&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">elev_point <span class="operator">=</span> as.points<span class="punctuation">(</span>elev<span class="punctuation">)</span> <span class="operator">|&gt;</span> </span><br><span class="line">  st_as_sf<span class="punctuation">(</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309031426621.png" alt=""><br>
Raster and point representation of the elev object.</p>
<p>另一种常见的空间矢量化类型是创建代表连续高度或温度（例如等温线）的等高线。我们将使用现实世界的数字高程模型（DEM），因为人造栅格<code>elev</code>会产生平行线（读者的任务：验证并解释为什么会发生这种情况）。可以使用 <strong>terra</strong> 函数 <code>as.contour()</code>创建等高线，该函数本身是R内置函数<code>filled.contour()</code>的封装，如下所示（未显示）：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">dem <span class="operator">=</span> rast<span class="punctuation">(</span>system.file<span class="punctuation">(</span><span class="string">&quot;raster/dem.tif&quot;</span><span class="punctuation">,</span> package <span class="operator">=</span> <span class="string">&quot;spDataLarge&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">cl <span class="operator">=</span> as.contour<span class="punctuation">(</span>dem<span class="punctuation">)</span> <span class="operator">|&gt;</span> </span><br><span class="line">  st_as_sf<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line">plot<span class="punctuation">(</span>dem<span class="punctuation">,</span> axes <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">)</span></span><br><span class="line">plot<span class="punctuation">(</span>cl<span class="punctuation">,</span> add <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>等高线也可以通过诸如<code>contour()</code>、<code>rasterVis::contourplot()</code>或<code>tmap::tm_iso()</code>等函数添加到现有的绘图中。如图所示，等值线可以加标签。</p>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309031428007.png" alt=""><br>
DEM with hillshading, showing the southern flank of Mt. Mongón overlaid with contour lines.</p>
<p>最后一种矢量化涉及将栅格转换为多边形。这可以通过 <code>terra::as.polygons()</code>来完成，该函数将每个栅格单元格转换为由五个坐标组成的多边形，所有这些都存储在内存中（这解释了为什么与矢量相比，栅格通常更快！）。</p>
<p>下面通过将<code>grain</code>对象转换为多边形，并随后消除具有相同属性值的多边形之间的边界（还可以参见<code>as.polygons()</code>中的<code>dissolve</code>参数）来进行说明。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">grain <span class="operator">=</span> rast<span class="punctuation">(</span>system.file<span class="punctuation">(</span><span class="string">&quot;raster/grain.tif&quot;</span><span class="punctuation">,</span> package <span class="operator">=</span> <span class="string">&quot;spData&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">grain_poly <span class="operator">=</span> as.polygons<span class="punctuation">(</span>grain<span class="punctuation">)</span> <span class="operator">|&gt;</span> </span><br><span class="line">  st_as_sf<span class="punctuation">(</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309031429271.png" alt=""><br>
Illustration of vectorization of raster (left) into polygons (dissolve = FALSE; center) and aggregated polygons (dissolve = TRUE; right).</p>
<p><code>grain</code>数据集的聚合多边形具有直线边界，这是由于通过连接矩形像素来定义所产生的。<strong>smoothr</strong>包可用于平滑多边形的边缘。由于平滑会消除多边形边界中的锐角，平滑后的多边形将不具有与原始像素完全相同的空间覆盖（有关示例，请参见 <strong>smoothr</strong><a href="https://strimas.com/smoothr/">website</a> ）。因此，在使用平滑后的多边形进行进一步分析时应谨慎。</p>
<h2 id="练习">练习</h2>
<p>以下部分练习使用来自 <strong>spDataLarge</strong> 包的矢量（<code>zion_points</code>）和栅格数据集（<code>srtm</code>）。它们还使用从矢量数据集（<code>ch</code>）派生的多边形 ‘凸包’ 来表示感兴趣的区域:</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>sf<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>terra<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>spData<span class="punctuation">)</span></span><br><span class="line">zion_points_path <span class="operator">=</span> system.file<span class="punctuation">(</span><span class="string">&quot;vector/zion_points.gpkg&quot;</span><span class="punctuation">,</span> package <span class="operator">=</span> <span class="string">&quot;spDataLarge&quot;</span><span class="punctuation">)</span></span><br><span class="line">zion_points <span class="operator">=</span> read_sf<span class="punctuation">(</span>zion_points_path<span class="punctuation">)</span></span><br><span class="line">srtm <span class="operator">=</span> rast<span class="punctuation">(</span>system.file<span class="punctuation">(</span><span class="string">&quot;raster/srtm.tif&quot;</span><span class="punctuation">,</span> package <span class="operator">=</span> <span class="string">&quot;spDataLarge&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">ch <span class="operator">=</span> st_combine<span class="punctuation">(</span>zion_points<span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">  st_convex_hull<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">|&gt;</span> </span><br><span class="line">  st_as_sf<span class="punctuation">(</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>E1. 根据（1）<code>zion_points</code>数据集和（2）<code>ch</code>数据集裁剪<code>srtm</code>栅格。输出地图之间有任何区别吗？接下来，使用这两个数据集对<code>srtm</code>进行遮罩处理。现在能看到任何区别吗？你如何解释这种情况？</p>
<ul>
<li>对<code>srtm</code>栅格进行裁剪和遮罩处理可能会产生不同的结果，因为<code>zion_points</code>和<code>ch</code>表示的区域可能有所不同。裁剪操作基于数据集的边界，而遮罩操作则基于数据集的几何形状。如果两个数据集的几何形状不同，结果也会不同。</li>
</ul>
<p>E2. 首先，从<code>srtm</code>中提取<code>zion_points</code>中表示的点的值。接下来，使用<code>zion_points</code>中每个点周围的90缓冲区提取<code>srtm</code>的平均值，并比较这两组值。什么时候通过缓冲区提取值比仅通过点提取值更合适？</p>
<ul>
<li>当需要考虑点周围的区域或当点可能不准确表示感兴趣的区域时，使用缓冲区提取值可能更合适。例如，在考虑地形或其他空间变量时，使用缓冲区可能会提供更多的上下文信息。</li>
</ul>
<p>E3. 提取新西兰（<code>nz_height</code>对象）海拔高度超过3100米的点，并为新点数据集的范围创建一个分辨率为3 km的模板栅格。使用这两个新对象：</p>
<ul>
<li>计算每个网格单元中最高点的数量。</li>
<li>找到每个网格单元中的最大海拔。</li>
</ul>
<p>E4. 聚合统计新西兰高点的栅格（在前一个练习中创建），将其地理分辨率减半（因此单元格为6 x 6 km），并绘制结果。</p>
<ul>
<li>将低分辨率的栅格重新采样回原始的3 km分辨率。结果有何变化？</li>
<li>降低栅格分辨率的两个优点和两个缺点是什么？</li>
</ul>
<p>E5. 将<code>grain</code>数据集多边形化，并过滤所有代表粘土的方块。</p>
<ul>
<li>
<p>列举矢量数据相对于栅格数据的两个优点和两个缺点。</p>
</li>
<li>
<p>在你的工作中，什么时候将栅格转换为矢量会很有用？</p>
</li>
<li>
<p>矢量数据通常提供更高的精度和更清晰的边界表示，同时允许复杂的几何和拓扑关系。但它们可能需要更多的存储空间和计算时间，特别是对于大型或复杂的数据集。</p>
</li>
<li>
<p>将栅格转换为矢量可能在需要精确边界、复杂的空间分析或与其他矢量数据集交互时有用。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>R</category>
        <category>Geocomputaion</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>Geocomputaion</tag>
      </tags>
  </entry>
  <entry>
    <title>(7)地理数据重投影</title>
    <url>/2023/08/16/2023-8-16-7%E5%9C%B0%E7%90%86%E6%95%B0%E6%8D%AE%E9%87%8D%E6%8A%95%E5%BD%B1/</url>
    <content><![CDATA[<blockquote><p>本文由SCY翻译自《Geocomputation with R》<a href="https://r.geocompx.org/reproj-geo-data">第七章</a></p>
</blockquote>
<p>本章演示了如何设置并将地理数据从一个CRS<em>转换</em>到另一个CRS，并进一步突出了由于忽略CRS而可能出现的特定问题，当您的数据以经纬度坐标存储时，应该特别注意。</p>
<span id="more"></span>
<h1>前提条件</h1>
<ul>
<li>本章要求下列包：</li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>sf<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>terra<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>dplyr<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>spData<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>spDataLarge<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<h1>引言</h1>
<p>前面章节介绍了坐标参照系统（CRSs），主要集中在两个主要类型：<em>地理</em>（‘lon/lat’，其单位为经度和纬度的度数）和<em>投影</em>（通常以米为单位，从基准点开始）坐标系统。本章在此基础上进一步拓展。它演示了如何设置并将地理数据从一个CRS<em>转换</em>到另一个CRS，并进一步突出了由于忽略CRS而可能出现的特定问题，您应该特别注意，特别是当您的数据以经纬度坐标存储时。</p>
<p>在许多项目中，不需要担心不同的CRS，更不用说在不同的CRS之间转换了。了解您的数据是在投影坐标系统还是地理坐标系统中，以及这对几何操作的影响非常重要。然而，如果您知道您的数据的CRS以及几何操作的影响（在下一节中介绍），CRS应该在幕后<em>正常工作</em>，人们通常在事情出错时突然需要了解CRS。拥有明确定义的CRS，并且所有项目数据都在其中，再加上理解如何以及为什么使用不同的CRS，可以确保事情不会出错。此外，学习坐标系统将加深您对地理数据集及其有效使用方法的了解。</p>
<p>本章教授CRS的基础知识，展示了使用不同CRS的后果（包括可能出错的情况），以及如何将数据集从一个坐标系统“重新投影”到另一个坐标系统。在下一节中，我们将介绍R中的CRS，展示如何获取和设置与空间对象关联的CRS。通过创建缓冲区的实际示例演示了了解数据所在CRS的重要性。本章解决了何时重新投影以及使用哪个CRS的问题。本章介绍了重新投影矢量和栅格对象，并在章节中修改了地图投影。</p>
<h1>坐标参考系统</h1>
<p>大多数现代地理工具都需要CRS转换，包括核心R空间包和桌面GIS软件如QGIS，它们与 <a href="https://proj.org">PROJ</a> 接口，这是一个开源C++库，用于“将坐标从一个坐标参考系统（CRS）转换到另一个”。CRS可以用多种方式描述，包括以下几种。</p>
<ol>
<li>简单但可能含糊不清的陈述，如“它在经/纬坐标中”</li>
<li>正式化但现已过时的“proj4字符串”（也称为“proj-string”），如 <code>+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs</code></li>
<li>使用标识的’authority:code’文本字符串，如 <code>EPSG:4326</code></li>
</ol>
<p>每个都指的是同一件事：构成全球定位系统（GPS）坐标和许多其他数据集基础的“WGS84”坐标系统。但哪一个才是正确的？</p>
<p>简短的回答是，识别CRSs的第三种方式是首选：<code>EPSG:4326</code> 由本书涵盖的 <strong>sf</strong>（以及扩展的 <strong>stars</strong>）和 <strong>terra</strong> 包以及许多其他用于处理地理数据的软件项目所理解，包括 <a href="https://docs.qgis.org/3.16/en/docs/user_manual/working_with_projections/working_with_projections.html">QGIS</a> 和 <a href="https://proj.org/development/quickstart.html">PROJ</a>。<code>EPSG:4326</code> 在未来可靠的。此外，尽管它是机器可读的，但与proj-string表示法不同，“EPSG:4326” 简短、易记且在网上非常容易找到（例如，搜索EPSG:4326会在网站 <a href="https://epsg.io/4326">epsg.io</a> 上找到专 dedicated 页）。更简洁的标识符<code>4326</code>由<strong>sf</strong>理解，但<strong>我们建议使用更明确的 <code>AUTHORITY:CODE</code> 表示法来消除歧义并提供上下文</strong>。</p>
<p>较长的回答是，这三个描述都不够，并且需要更多的细节来进行明确的CRS处理和转换：由于CRS的复杂性，不可能在如此短的文本字符串中捕获有关它们的所有相关信息。出于这个原因，开放地理空间联盟（OGC，还开发了<strong>sf</strong> 包实现的简单要素规范）开发了一种用于描述CRS的开放标准格式，称为WKT（众所周知的文本）。这在<a href="https://portal.opengeospatial.org/files/18-010r7">100多页的文档</a>中详细介绍了“定义了坐标参考系统的抽象模型的文本字符串实现的结构和内容，该抽象模型描述在ISO 19111:2019”中。WGS84 CRS的WKT表示法具有<strong>标识符</strong><code>EPSG:4326</code>，如下所示：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">st_crs<span class="punctuation">(</span><span class="string">&quot;EPSG:4326&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; Coordinate Reference System:</span></span><br><span class="line"><span class="comment">#&gt;   User input: EPSG:4326 </span></span><br><span class="line"><span class="comment">#&gt;   wkt:</span></span><br><span class="line"><span class="comment">#&gt; GEOGCRS[&quot;WGS 84&quot;,</span></span><br><span class="line"><span class="comment">#&gt;     ENSEMBLE[&quot;World Geodetic System 1984 ensemble&quot;,</span></span><br><span class="line"><span class="comment">#&gt;         MEMBER[&quot;World Geodetic System 1984 (Transit)&quot;],</span></span><br><span class="line"><span class="comment">#&gt;         MEMBER[&quot;World Geodetic System 1984 (G730)&quot;],</span></span><br><span class="line"><span class="comment">#&gt;         MEMBER[&quot;World Geodetic System 1984 (G873)&quot;],</span></span><br><span class="line"><span class="comment">#&gt;         MEMBER[&quot;World Geodetic System 1984 (G1150)&quot;],</span></span><br><span class="line"><span class="comment">#&gt;         MEMBER[&quot;World Geodetic System 1984 (G1674)&quot;],</span></span><br><span class="line"><span class="comment">#&gt;         MEMBER[&quot;World Geodetic System 1984 (G1762)&quot;],</span></span><br><span class="line"><span class="comment">#&gt;         MEMBER[&quot;World Geodetic System 1984 (G2139)&quot;],</span></span><br><span class="line"><span class="comment">#&gt;         ELLIPSOID[&quot;WGS 84&quot;,6378137,298.257223563,</span></span><br><span class="line"><span class="comment">#&gt;             LENGTHUNIT[&quot;metre&quot;,1]],</span></span><br><span class="line"><span class="comment">#&gt;         ENSEMBLEACCURACY[2.0]],</span></span><br><span class="line"><span class="comment">#&gt;     PRIMEM[&quot;Greenwich&quot;,0,</span></span><br><span class="line"><span class="comment">#&gt;         ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]],</span></span><br><span class="line"><span class="comment">#&gt;     CS[ellipsoidal,2],</span></span><br><span class="line"><span class="comment">#&gt;         AXIS[&quot;geodetic latitude (Lat)&quot;,north,</span></span><br><span class="line"><span class="comment">#&gt;             ORDER[1],</span></span><br><span class="line"><span class="comment">#&gt;             ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]],</span></span><br><span class="line"><span class="comment">#&gt;         AXIS[&quot;geodetic longitude (Lon)&quot;,east,</span></span><br><span class="line"><span class="comment">#&gt;             ORDER[2],</span></span><br><span class="line"><span class="comment">#&gt;             ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]],</span></span><br><span class="line"><span class="comment">#&gt;     USAGE[</span></span><br><span class="line"><span class="comment">#&gt;         SCOPE[&quot;Horizontal component of 3D system.&quot;],</span></span><br><span class="line"><span class="comment">#&gt;         AREA[&quot;World.&quot;],</span></span><br><span class="line"><span class="comment">#&gt;         BBOX[-90,-180,90,180]],</span></span><br><span class="line"><span class="comment">#&gt;     ID[&quot;EPSG&quot;,4326]]</span></span><br></pre></td></tr></table></figure>
<p>命令的输出显示了CRS标识符（也称为空间参考标识符或<a href="https://postgis.net/workshops/postgis-intro/projection.html">SRID</a>）的工作方式：它只是一个查找，提供与CRS的更完整WKT表示形式关联的唯一标识符。这提出了一个问题：如果标识符和CRS的较长WKT表示之间存在不匹配怎么办？关于这一点，@opengeospatialconsortium_wellknown_2019很明确，详细的WKT表示优先于<a href="https://docs.opengeospatial.org/is/18-010r7/18-010r7.html#37">identifier</a>：</p>
<blockquote>
<p>📌如果引用的标识符中给出的任何属性或值与WKT描述中明确给出的属性或值冲突，则WKT值应优先。</p>
</blockquote>
<p>以<code>AUTHORITY:CODE</code>形式引用CRS标识符的惯例，也被用于其他<a href="https://jorisvandenbossche.github.io/blog/2020/02/11/geopandas-pyproj-crs/">languages</a>编写的地理软件，允许广泛引用正式定义的坐标系统。^[可以使用几种其他方法来引用唯一的CRS，<a href="https://docs.qgis.org/3.16/en/docs/pyqgis_developer_cookbook/crs.html?highlight=srid">QGIS</a>和其他标识符类型（例如<code>EPSG:4326</code>标识符的更详细变体，<code>urn:ogc:def:crs:EPSG::4326</code>）接受五种标识符类型（EPSG代码，PostGIS SRID，INTERNAL SRID，proj-string和WKT字符串）。]CRS标识符中最常用的权威机构是<em>EPSG</em>，这是欧洲石油调查小组的首字母缩写，该小组发布了CRS的标准化列表（EPSG由油气机构<a href="https://www.iogp.org/our-committees/geomatics/">Geomatics Committee of the International Association of Oil &amp; Gas Producers</a>在2005年<a href="http://wiki.gis.com/wiki/index.php/European_Petroleum_Survey_Group">taken over</a>）。CRS标识符中可以使用其他权威机构。<br>
例如，<code>ESRI:54030</code>指的是ESRI对罗宾逊投影的实现，其具有以下WKT字符串（仅显示前8行）：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">st_crs<span class="punctuation">(</span><span class="string">&quot;ESRI:54030&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; Coordinate Reference System:</span></span><br><span class="line"><span class="comment">#&gt;   User input: ESRI:54030 </span></span><br><span class="line"><span class="comment">#&gt;   wkt:</span></span><br><span class="line"><span class="comment">#&gt; PROJCRS[&quot;World_Robinson&quot;,</span></span><br><span class="line"><span class="comment">#&gt;     BASEGEOGCRS[&quot;WGS 84&quot;,</span></span><br><span class="line"><span class="comment">#&gt;         DATUM[&quot;World Geodetic System 1984&quot;,</span></span><br><span class="line"><span class="comment">#&gt;             ELLIPSOID[&quot;WGS 84&quot;,6378137,298.257223563,</span></span><br><span class="line"><span class="comment">#&gt;                 LENGTHUNIT[&quot;metre&quot;,1]]],</span></span><br><span class="line"><span class="comment">#&gt; ...</span></span><br></pre></td></tr></table></figure>
<p>WKT字符串详尽、精确且准确，允许无歧义地存储和转换CRS。它们包含了任何给定CRS的所有相关信息，包括其基准面和椭球体、本初子午线、投影和单位。^[在WKTCRS定义出现之前，proj-string是指定坐标操作和存储CRS的标准方式。这些基于键=值形式（例如，<code>+proj=longlat +datum=WGS84+no_defs</code>）构建的字符串表示，在大多数情况下已经被或者将来应该被WKT表示所取代。]</p>
<p>最近的PROJ版本（6+）仍允许使用proj-string来定义坐标操作，但一些proj-string键（如<code>+nadgrids</code>、<code>+towgs84</code>、<code>+k</code>、<code>+init=epsg:</code>）要么不再受支持，要么不鼓励使用。<br>
此外，只有三个基准面（即WGS84、NAD83和NAD27）可以在proj-string中直接设置。关于CRS定义和PROJ库演变的更长解释可以在@bivand_progress_2021，@pebesma_spatial_2022的第2章，以及<a href="https://inbo.github.io/tutorials/tutorials/spatial_crs_coding/">Floris Vanderhaeghe的博客文章</a>中找到。此外，如<a href="https://proj.org/development/reference/cpp/cpp_general.html">PROJ文档</a>所概述的，WKT CRS格式有不同的版本，包括WKT1和WKT2的两个变体，其中后者（WKT2，2018规范）对应于ISO 19111:2019。</p>
<h1>查询和设置坐标系</h1>
<p>让我们看看CRS是如何存储在R的空间对象中的，以及如何查询和设置它们。首先，我们将研究如何在<strong>矢量</strong>地理数据对象中获取和设置CRS，从以下示例开始：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">vector_filepath <span class="operator">=</span> system.file<span class="punctuation">(</span><span class="string">&quot;shapes/world.gpkg&quot;</span><span class="punctuation">,</span> package <span class="operator">=</span> <span class="string">&quot;spData&quot;</span><span class="punctuation">)</span></span><br><span class="line">new_vector <span class="operator">=</span> read_sf<span class="punctuation">(</span>vector_filepath<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>我们的新对象<code>new_vector</code>是一个<code>sf</code>类的数据框，代表了全球各个国家（有关详细信息，请参阅帮助页面<code>?spData::world</code>）。可以使用<strong>sf</strong>函数<code>st_crs()</code>来检索CRS。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">st_crs<span class="punctuation">(</span>new_vector<span class="punctuation">)</span> <span class="comment"># get CRS</span></span><br><span class="line"><span class="comment">#&gt; Coordinate Reference System:</span></span><br><span class="line"><span class="comment">#&gt;   User input: WGS 84 </span></span><br><span class="line"><span class="comment">#&gt;   wkt:</span></span><br><span class="line"><span class="comment">#&gt;   ...</span></span><br></pre></td></tr></table></figure>
<p>输出是一个包含两个主要组件的列表：</p>
<ol>
<li><code>User input</code>（在此情况下为<code>WGS 84</code>，即<code>EPSG:4326</code>的同义词，它在这种情况下是从输入文件中获取的），对应于上述的CRS标识符</li>
<li><code>wkt</code>，包含有关CRS的所有相关信息的完整WKT字符串</li>
</ol>
<p><code>input</code>元素是灵活的，根据输入文件或用户输入，可以包含<code>AUTHORITY:CODE</code>表示（例如<code>EPSG:4326</code>）、CRS的名称（例如<code>WGS 84</code>）或甚至proj-string定义。<code>wkt</code>元素存储WKT表示，用于保存对象到文件或进行任何坐标操作。以上，我们可以看到<code>new_vector</code>对象具有WGS84椭球体，使用格林威治基准经线，以及纬度和经度轴的顺序。在这种情况下，我们还有一些附加元素，如<code>USAGE</code>解释了使用该CRS的适合区域，以及<code>ID</code>指向CRS的标识符：<code>EPSG:4326</code>。</p>
<p><code>st_crs</code>函数还具有一个有用的功能——我们可以检索有关所用CRS的一些附加信息。例如，尝试运行：</p>
<ul>
<li><code>st_crs(new_vector)$IsGeographic</code>来检查CRS是否是地理的</li>
<li><code>st_crs(new_vector)$units_gdal</code>找出CRS的单位</li>
<li><code>st_crs(new_vector)$srid</code>提取其’SRID’标识符（如果可用）</li>
<li><code>st_crs(new_vector)$proj4string</code>提取proj-string表示</li>
</ul>
<p>在坐标参考系统（CRS）缺失或设置错误的CRS的情况下，可以使用<code>st_set_crs()</code>函数（在这种情况下，由于文件在读入时已经正确设置了CRS，WKT字符串保持不变）：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">new_vector <span class="operator">=</span> st_set_crs<span class="punctuation">(</span>new_vector<span class="punctuation">,</span> <span class="string">&quot;EPSG:4326&quot;</span><span class="punctuation">)</span> <span class="comment"># set CRS</span></span><br></pre></td></tr></table></figure>
<p>在栅格地理数据对象中获取和设置坐标参考系统（CRS）的工作方式与矢量数据对象类似。<code>terra</code>包中的<code>crs()</code>函数从<code>SpatRaster</code>对象访问CRS信息（注意使用<code>cat()</code>函数以便漂亮地打印）：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">raster_filepath <span class="operator">=</span> system.file<span class="punctuation">(</span><span class="string">&quot;raster/srtm.tif&quot;</span><span class="punctuation">,</span> package <span class="operator">=</span> <span class="string">&quot;spDataLarge&quot;</span><span class="punctuation">)</span></span><br><span class="line">my_rast <span class="operator">=</span> rast<span class="punctuation">(</span>raster_filepath<span class="punctuation">)</span></span><br><span class="line">cat<span class="punctuation">(</span>crs<span class="punctuation">(</span>my_rast<span class="punctuation">)</span><span class="punctuation">)</span> <span class="comment"># get CRS</span></span><br><span class="line"><span class="comment">#&gt; GEOGCRS[&quot;WGS 84&quot;,</span></span><br><span class="line"><span class="comment">#&gt;     ENSEMBLE[&quot;World Geodetic System 1984 ensemble&quot;,</span></span><br><span class="line"><span class="comment">#&gt;         MEMBER[&quot;World Geodetic System 1984 (Transit)&quot;],</span></span><br><span class="line"><span class="comment">#&gt;         MEMBER[&quot;World Geodetic System 1984 (G730)&quot;],</span></span><br><span class="line"><span class="comment">#&gt;         MEMBER[&quot;World Geodetic System 1984 (G873)&quot;],</span></span><br><span class="line"><span class="comment">#&gt;         MEMBER[&quot;World Geodetic System 1984 (G1150)&quot;],</span></span><br><span class="line"><span class="comment">#&gt;         MEMBER[&quot;World Geodetic System 1984 (G1674)&quot;],</span></span><br><span class="line"><span class="comment">#&gt;         MEMBER[&quot;World Geodetic System 1984 (G1762)&quot;],</span></span><br><span class="line"><span class="comment">#&gt;         MEMBER[&quot;World Geodetic System 1984 (G2139)&quot;],</span></span><br><span class="line"><span class="comment">#&gt;         ELLIPSOID[&quot;WGS 84&quot;,6378137,298.257223563,</span></span><br><span class="line"><span class="comment">#&gt;             LENGTHUNIT[&quot;metre&quot;,1]],</span></span><br><span class="line"><span class="comment">#&gt;         ENSEMBLEACCURACY[2.0]],</span></span><br><span class="line"><span class="comment">#&gt;     PRIMEM[&quot;Greenwich&quot;,0,</span></span><br><span class="line"><span class="comment">#&gt;         ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]],</span></span><br><span class="line"><span class="comment">#&gt;     CS[ellipsoidal,2],</span></span><br><span class="line"><span class="comment">#&gt;         AXIS[&quot;geodetic latitude (Lat)&quot;,north,</span></span><br><span class="line"><span class="comment">#&gt;             ORDER[1],</span></span><br><span class="line"><span class="comment">#&gt;             ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]],</span></span><br><span class="line"><span class="comment">#&gt;         AXIS[&quot;geodetic longitude (Lon)&quot;,east,</span></span><br><span class="line"><span class="comment">#&gt;             ORDER[2],</span></span><br><span class="line"><span class="comment">#&gt;             ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]],</span></span><br><span class="line"><span class="comment">#&gt;     USAGE[</span></span><br><span class="line"><span class="comment">#&gt;         SCOPE[&quot;Horizontal component of 3D system.&quot;],</span></span><br><span class="line"><span class="comment">#&gt;         AREA[&quot;World.&quot;],</span></span><br><span class="line"><span class="comment">#&gt;         BBOX[-90,-180,90,180]],</span></span><br><span class="line"><span class="comment">#&gt;     ID[&quot;EPSG&quot;,4326]]</span></span><br></pre></td></tr></table></figure>
<p>输出结果为代表CRS的WKT字符串。相同的函数<code>crs()</code>也可以用来给栅格对象设置CRS。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">crs<span class="punctuation">(</span>my_rast<span class="punctuation">)</span> <span class="operator">=</span> <span class="string">&quot;EPSG:26912&quot;</span> <span class="comment"># set CRS</span></span><br></pre></td></tr></table></figure>
<p>在这里，我们可以使用标识符（在大多数情况下推荐）或完整的WKT字符串表示。设置<code>crs</code>的替代方法包括proj-string字符串或从其他现有对象中提取的CRS，尽管这些方法可能在将来的适用性上较差。</p>
<p>重要的是，<code>st_crs()</code>和<code>crs()</code>函数不会改变坐标的值或几何图形。它们的作用仅仅是设置关于对象CRS的元数据信息。</p>
<p>在某些情况下，地理对象的CRS是未知的，就像下面的代码块中创建的<code>london</code>数据集一样，引入的伦敦示例中就有这样的情况：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">london <span class="operator">=</span> data.frame<span class="punctuation">(</span>lon <span class="operator">=</span> <span class="operator">-</span><span class="number">0.1</span><span class="punctuation">,</span> lat <span class="operator">=</span> <span class="number">51.5</span><span class="punctuation">)</span> <span class="operator">|&gt;</span> </span><br><span class="line">  st_as_sf<span class="punctuation">(</span>coords <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;lon&quot;</span><span class="punctuation">,</span> <span class="string">&quot;lat&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">st_is_longlat<span class="punctuation">(</span>london<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] NA</span></span><br></pre></td></tr></table></figure>
<p>输出的<code>NA</code>显示<strong>sf</strong>不知道CRS是什么，并且不愿意猜测（<code>NA</code>字面意思是’不可用’）。除非人为指定了CRS或者从具有CRS元数据的源中加载，否则<strong>sf</strong>不会对坐标系统做出任何明确的假设，除了说“我不知道”。鉴于可用CRS的多样性，这种行为是有道理的，但与一些方法不同，例如GeoJSON文件格式规范，它简化地假设所有坐标都具有经纬度坐标系：<code>EPSG:4326</code>。没有指定CRS的数据集可能会引起问题：所有地理坐标都有坐标系统，只有知道它正在处理的CRS类型，软件才能在绘图和几何操作方面做出正确的决策。因此，再次强调，始终检查数据集的CRS并设置它（如果它丢失）是非常重要的。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">london_geo <span class="operator">=</span> st_set_crs<span class="punctuation">(</span>london<span class="punctuation">,</span> <span class="string">&quot;EPSG:4326&quot;</span><span class="punctuation">)</span></span><br><span class="line">st_is_longlat<span class="punctuation">(</span>london_geo<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] TRUE</span></span><br></pre></td></tr></table></figure>
<h1>投影和未投影数据上的几何操作</h1>
<p>自 <strong>sf</strong> 版本 1.0.0 以来，得益于引入的S2 <em>球面几何引擎</em>，R处理具有经纬度CRS的地理矢量数据集的能力有了很大的提高。如图所示，<strong>sf</strong>根据CRS的类型和S2是否被禁用（默认启用）来选择使用 GEOS 或 S2。对于投影数据和没有 CRS 的数据，总是使用GEOS；对于地理数据，S2 默认启用，但可以通过 <code>sf::sf_use_s2(FALSE)</code> 禁用。</p>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309031515946.png" alt=""><br>
The behavior of the geometry operations in the sf package depending on the input data’s CRS.</p>
<p>为了展示 CRS 的重要性，我们将在前一节中的<code>london</code>对象周围创建 100 公里的缓冲区。我们还将故意创建一个“距离”为1度的有错误的缓冲区，这大约相当于100公里（赤道上1度大约为111公里）。在深入代码之前，值得简短地跳到下图来直观了解您应该能够通过下面的代码块重现的输出。</p>
<p>第一阶段是围绕上面创建的 <code>london</code> 和 <code>london_geo</code> 对象创建三个缓冲区，边界距离分别为 1 度和 100 公里（或 100,000 米，可以用科学记数法表示为 <code>1e5</code>）距离伦敦市中心。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">london_buff_no_crs <span class="operator">=</span> st_buffer<span class="punctuation">(</span>london<span class="punctuation">,</span> dist <span class="operator">=</span> <span class="number">1</span><span class="punctuation">)</span>   <span class="comment"># incorrect: no CRS</span></span><br><span class="line">london_buff_s2 <span class="operator">=</span> st_buffer<span class="punctuation">(</span>london_geo<span class="punctuation">,</span> dist <span class="operator">=</span> <span class="number">100000</span><span class="punctuation">)</span> <span class="comment"># silent use of s2</span></span><br><span class="line">london_buff_s2_100_cells <span class="operator">=</span> st_buffer<span class="punctuation">(</span>london_geo<span class="punctuation">,</span> dist <span class="operator">=</span> <span class="number">100000</span><span class="punctuation">,</span> max_cells <span class="operator">=</span> <span class="number">100</span><span class="punctuation">)</span> </span><br></pre></td></tr></table></figure>
<p>在上述的第一行中，<strong>sf</strong>假设输入是投影的，并生成了以度为单位的缓冲区的结果，这是有问题的，我们将看到。在第二行中，<strong>sf</strong>使用球面几何引擎S2（在章节@ref(spatial-class) 中引入）默默地计算缓冲区的范围，使用 <code>max_cells = 1000</code> 的默认值——在第三行中设置为 <code>100</code>——这些后果将很快显现（详见 <code>?s2::s2_buffer_cells</code>）。为了强调 <strong>sf</strong> 对未投影（地理）坐标系统的S2几何引擎的影响，我们将在下面的代码块中暂时禁用它，使用命令<code>sf_use_s2()</code>（默认为 <code>TRUE</code>）。与 <code>london_buff_no_crs</code>一样，新的<code>london_geo</code>对象是一个地理怪物：它的单位是度，这在绝大多数情况下都没有意义：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">sf<span class="operator">::</span>sf_use_s2<span class="punctuation">(</span><span class="literal">FALSE</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; Spherical geometry (s2) switched off</span></span><br><span class="line">london_buff_lonlat <span class="operator">=</span> st_buffer<span class="punctuation">(</span>london_geo<span class="punctuation">,</span> dist <span class="operator">=</span> <span class="number">1</span><span class="punctuation">)</span> <span class="comment"># incorrect result</span></span><br><span class="line"><span class="comment">#&gt; Warning in st_buffer.sfc(st_geometry(x), dist, nQuadSegs, endCapStyle =</span></span><br><span class="line"><span class="comment">#&gt; endCapStyle, : st_buffer does not correctly buffer longitude/latitude data</span></span><br><span class="line"><span class="comment">#&gt; dist is assumed to be in decimal degrees (arc_degrees).</span></span><br><span class="line">sf<span class="operator">::</span>sf_use_s2<span class="punctuation">(</span><span class="literal">TRUE</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; Spherical geometry (s2) switched on</span></span><br></pre></td></tr></table></figure>
<p>上述的警告信息暗示了在经纬度数据上执行平面几何操作的问题。当通过命令 <code>sf::sf_use_s2(FALSE)</code>关闭球面几何操作时，缓冲区（以及其他几何操作）可能会产生无价值的输出，因为它们使用的是纬度和经度的单位，这与以米为单位的适当距离单位相比是一个糟糕的替代品。</p>
<blockquote>
<p>📌两条经线（称为子午线）之间的距离在赤道处约为111公里（执行<code>geosphere::distGeo(c(0,0),c(1,0))</code>找到精确距离）。这在极地缩小为零。例如，在伦敦的纬度上，子午线之间的距离不到70公里（挑战：执行验证此事的代码）。</p>
</blockquote>
<!-- `geosphere::distGeo(c(0, 51.5), c(1, 51.5))` -->
<p>相比之下，纬线彼此之间的距离不受纬度的影响：它们总是相距约111公里，包括在赤道和靠近极地的地方。</p>
<p>不要将关于地理（<code>经度/纬度</code>）坐标参照系的警告解释为“坐标参照系不应该被设置”：它几乎总是应该被设置的！更好的理解是建议将数据<em>重新投影</em>到投影坐标参照系上。此建议并不总是需要遵循：在某些情况下，执行空间和几何操作几乎没有差别（例如，空间子集）。但是对于涉及距离的操作，例如缓冲区，确保良好结果的唯一方法（不使用球形几何引擎）是创建数据的投影副本，并在其上运行操作。在下面的代码块中完成了这一操作：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">london_proj <span class="operator">=</span> data.frame<span class="punctuation">(</span>x <span class="operator">=</span> <span class="number">530000</span><span class="punctuation">,</span> y <span class="operator">=</span> <span class="number">180000</span><span class="punctuation">)</span> <span class="operator">|&gt;</span> </span><br><span class="line">  st_as_sf<span class="punctuation">(</span>coords <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;x&quot;</span><span class="punctuation">,</span> <span class="string">&quot;y&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> crs <span class="operator">=</span> <span class="string">&quot;EPSG:27700&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>结果是一个与<code>london</code>相同但重新投影到合适坐标参照系（在这种情况下为英国国家网格，其EPSG代码为27700）的新对象，该坐标参照系的单位为米。我们可以使用<code>st_crs()</code>来验证CRS已更改，如下所示（部分输出已被替换为<code>...</code>）：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">st_crs<span class="punctuation">(</span>london_proj<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; Coordinate Reference System:</span></span><br><span class="line"><span class="comment">#&gt;   User input: EPSG:27700 </span></span><br><span class="line"><span class="comment">#&gt;   wkt:</span></span><br><span class="line"><span class="comment">#&gt; PROJCRS[&quot;OSGB36 / British National Grid&quot;,</span></span><br><span class="line"><span class="comment">#&gt;     BASEGEOGCRS[&quot;OSGB36&quot;,</span></span><br><span class="line"><span class="comment">#&gt;         DATUM[&quot;Ordnance Survey of Great Britain 1936&quot;,</span></span><br><span class="line"><span class="comment">#&gt;             ELLIPSOID[&quot;Airy 1830&quot;,6377563.396,299.3249646,</span></span><br><span class="line"><span class="comment">#&gt;                 LENGTHUNIT[&quot;metre&quot;,1]]],</span></span><br><span class="line"><span class="comment">#&gt; ...</span></span><br></pre></td></tr></table></figure>
<p>此CRS描述的显著组成部分包括EPSG代码（<code>EPSG:27700</code>）和详细的<code>wkt</code>字符串（仅显示前5行）。^[有关最相关投影参数和相关概念的简短描述，请参阅Jochen Albrecht在<a href="http://www.geography.hunter.cuny.edu/~jochen/GTECH361/lectures/">http://www.geography.hunter.cuny.edu/~jochen/GTECH361/lectures/</a> 主持的第四讲，并在<a href="https://proj.org/usage/projections.html">https://proj.org/usage/projections.html</a> 查看信息。<a href="http://xn--spatialreference-tk1zb1b39arz3a3b7330cldpmmue21cmh4b3is228j.xn--orgprogonos-904s.com/furuti/MapProj%E3%80%82">关于投影的其他优秀资源是spatialreference.org和progonos.com/furuti/MapProj。</a>]CRS的单位描述在LENGTHUNIT字段中，单位是米（而不是度），这告诉我们这是一个投影的CRS：<code>st_is_longlat(london_proj)</code>现在返回<code>FALSE</code>，并且对<code>london_proj</code>的几何操作将无需警告即可工作。对<code>london_proj</code>的缓冲区操作将使用GEOS，结果将以适当的距离单位返回。以下代码行在<em>投影</em>数据周围创建了恰好100公里的缓冲区：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">london_buff_projected <span class="operator">=</span> st_buffer<span class="punctuation">(</span>london_proj<span class="punctuation">,</span> <span class="number">100000</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>上述三个<em>具有</em>指定CRS的<code>london_buff*</code>对象（<code>london_buff_s2</code>，<code>london_buff_lonlat</code>和<code>london_buff_projected</code>）在前面的代码块中创建的几何图形在下图中有所展示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#&gt; Warning: The `returnclass` argument of `ne_download()` sp as of rnaturalearth 1.0.0.</span><br><span class="line">#&gt; ℹ Please use `sf` objects with &#123;rnaturalearth&#125;, support for Spatial objects</span><br><span class="line">#&gt;   (sp) will be removed in a future release of the package.</span><br><span class="line">#&gt; This warning is displayed once every 8 hours.</span><br><span class="line">#&gt; Call `lifecycle::last_lifecycle_warnings()` to see where this warning was</span><br><span class="line">#&gt; generated.</span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309031548552.png" alt=""><br>
Buffers around London showing results created with the S2 spherical geometry engine on lon/lat data (left), projected data (middle) and lon/lat data without using spherical geometry (right). The left plot illustrates the result of buffering unprojected data with sf, which calls Google’s S2 spherical geometry engine by default with max cells set to 1000 (thin line). The thick ‘blocky’ line illustrates the result of the same operation with max cells set to 100.</p>
<p>从上图中可以清楚地看到，基于<code>s2</code>和适当投影的CRS的缓冲区并没有被“压扁”，意味着缓冲区边界的每一部分都与伦敦等距离。当<code>s2</code>未被使用时，从经纬度CRS生成的结果，无论是因为输入缺少CRS还是因为<code>sf_use_s2()</code>被关闭，都会严重失真，结果在南北轴向延伸，突出了在经纬度输入上使用假设投影数据的算法（如GEOS所做）的危险性。然而，使用S2生成的结果也同样失真，尽管不太显著。图中（左）的两个缓冲区边界都是锯齿状的，尽管这可能只在用<code>s2</code>参数<code>max_cells</code>设置为100创建的粗边界表示的缓冲区时才显现或相关。</p>
<!--toDo:rl-->
<!--jn: maybe it is worth to emphasize that the differences are due to the use of S2 vs GEOS-->
<!--jn: you mention S2 a lot in this section, but not GEOS...-->
<p>教训是，通过S2从经纬度数据获得的结果将与使用投影数据获得的结果不同。随着<code>max_cells</code>值的增加，S2派生的缓冲区和GEOS派生的投影数据上的缓冲区之间的差异减小，此参数的“正确”值可能取决于许多因素，缺省值1000是合理的。在选择<code>max_cells</code>值时，应在计算速度和结果分辨率之间取得平衡。在曲线边界有优势的情况下，在缓冲（或执行其他几何操作）之前转换到投影CRS可能是合适的。</p>
<p>从上述示例中可以清楚地看到CRS的重要性（主要是它们是投影的还是地理的）以及<strong>sf</strong>默认使用S2在经纬度数据上进行缓冲的影响。后续章节将更深入地探讨何时需要投影CRS以及重投影矢量和栅格对象的细节。</p>
<h1>何时重投影？</h1>
<p>上一节展示了如何手动设置坐标参考系统（CRS），通过<code>st_set_crs(london, &quot;EPSG:4326&quot;)</code>。然而，在现实世界的应用中，CRS通常在数据读入时自动设置。在许多项目中，主要与CRS有关的任务是将对象从一个CRS<em>转换</em>为另一个CRS。但是，何时应该转换数据？转换为哪个CRS？这些问题没有明确的答案，CRS的选择总是涉及权衡。然而，本节提供了一些一般性原则，可以帮助您做决策。</p>
<p>首先值得考虑的是<em>何时进行转换</em>。在某些情况下，转换为地理CRS是至关重要的，例如使用<strong>leaflet</strong>包在线发布数据时。另一个情况是当必须比较或组合两个具有不同CRS的对象时，例如当我们试图找到具有不同CRS的两个对象之间的距离时：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">st_distance<span class="punctuation">(</span>london_geo<span class="punctuation">,</span> london_proj<span class="punctuation">)</span></span><br><span class="line"><span class="comment"># &gt; Error: st_crs(x) == st_crs(y) is not TRUE</span></span><br></pre></td></tr></table></figure>
<p>要使<code>london</code>和<code>london_proj</code>对象在地理上可比较，必须将其中一个转换为另一个的CRS。但是应该使用哪个CRS呢？答案取决于具体情况：许多项目，特别是涉及网络映射的项目，需要以EPSG:4326的输出，此时最好转换投影对象。然而，如果项目需要平面几何操作而不是球面几何操作引擎（例如，为了创建具有平滑边缘的缓冲区），那么将具有地理CRS的数据转换为具有投影CRS的等效对象可能是值得的，例如英国国家网格（EPSG:27700）。</p>
<h1>选择哪个CRS使用?</h1>
<p><em>选择哪个CRS</em>的问题很棘手，很少有“正确”的答案：“不存在全能的投影，当远离指定框架的中心时，所有投影都会发生失真”。此外，你不应该只依附于一个投影来完成每项任务。有可能在分析的某些部分使用一种投影，在另一部分使用另一种投影，甚至在可视化中使用其他投影。始终尝试选择最能实现你目标的CRS！在选择**地理坐标参照系（CRS）**时，答案通常是<a href="https://en.wikipedia.org/wiki/World_Geodetic_System#A_new_World_Geodetic_System:_WGS_84">WGS84</a>。它不仅用于网络地图绘制，而且由于GPS数据集以及数以千计的栅格和矢量数据集默认都提供在这个CRS下。WGS84是世界上最常用的CRS，因此值得记住其EPSG代码：4326。这个“神奇的数字”可以用来将具有不寻常的投影CRS的对象转换成广泛理解的形式。</p>
<p>那么在需要**投影坐标参照系（CRS）**时怎么办呢？在某些情况下，这不是我们可以自由决定的问题：“通常投影的选择是由公共测绘机构做出的”这意味着当使用本地数据源时，最好使用数据提供的CRS来工作，以确保兼容性，即使官方的CRS不是最精确的。伦敦的例子很容易回答，因为（a）英国国家网格（及其相关的EPSG代码27700）众所周知，（b）原始数据集（<code>london</code>）已经有了该CRS。</p>
<p>常用的默认值是通用横轴墨卡托（<a href="https://en.wikipedia.org/wiki/Universal_Transverse_Mercator_coordinate_system">UTM</a>），一组将地球划分为60个经度楔形和20个纬度段的CRS。UTM CRS所使用的横轴墨卡托投影是共形的，但随着距离UTM区域中心的距离增加，面积和距离的失真程度逐渐加剧。因此，GIS软件Manifold的文档建议将使用UTM区域的项目的经度范围限制在中央子午线的6度之内（来源：<a href="http://www.manifold.net/doc/mfd9/universal_transverse_mercator_projection.htm">manifold.net</a>）。所以，我们建议仅在您关注保持相对较小区域的角度时使用UTM！</p>
<p>地球上几乎每个地方都有一个UTM代码，例如“60H”，指的是新西兰北部R语言发明的地方。UTM的EPSG代码对于北半球的位置依次从32601到32660，对于南半球的位置则从32701到32760。</p>
<p>要展示该系统是如何工作的，让我们创建一个函数<code>lonlat2UTM()</code>，用来计算地球上任何点所对应的EPSG代码，如下所示<a href="https://stackoverflow.com/a/9188972/"></a>：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">lonlat2UTM <span class="operator">=</span> <span class="keyword">function</span><span class="punctuation">(</span>lonlat<span class="punctuation">)</span> <span class="punctuation">&#123;</span></span><br><span class="line">  utm <span class="operator">=</span> <span class="punctuation">(</span><span class="built_in">floor</span><span class="punctuation">(</span><span class="punctuation">(</span>lonlat<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="operator">+</span> <span class="number">180</span><span class="punctuation">)</span> <span class="operator">/</span> <span class="number">6</span><span class="punctuation">)</span> <span class="operator">%%</span> <span class="number">60</span><span class="punctuation">)</span> <span class="operator">+</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">if</span> <span class="punctuation">(</span>lonlat<span class="punctuation">[</span><span class="number">2</span><span class="punctuation">]</span> <span class="operator">&gt;</span> <span class="number">0</span><span class="punctuation">)</span> <span class="punctuation">&#123;</span></span><br><span class="line">    utm <span class="operator">+</span> <span class="number">32600</span></span><br><span class="line">  <span class="punctuation">&#125;</span> <span class="keyword">else</span><span class="punctuation">&#123;</span></span><br><span class="line">    utm <span class="operator">+</span> <span class="number">32700</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>以下命令使用这个函数来识别奥克兰和伦敦的UTM区域和相应的EPSG代码。这些代码对于进一步的地理空间数据分析和操作非常重要。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">lonlat2UTM<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">174.7</span><span class="punctuation">,</span> <span class="operator">-</span><span class="number">36.9</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] 32760</span></span><br><span class="line">lonlat2UTM<span class="punctuation">(</span>st_coordinates<span class="punctuation">(</span>london<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] 32630</span></span><br></pre></td></tr></table></figure>
<p>目前，我们也有一些工具可以帮助我们选择合适的CRS（坐标参考系统），其中包括<strong>crssuggest</strong>包。<!--add ref or docs-->该包的主要函数 <code>suggest_crs()</code>接受一个带有地理CRS的空间对象，并返回可能用于给定区域的投影CRS列表。^[该包还允许在没有任何CRS信息附加的情况下找出数据的真实CRS。]另一个有用的工具是一个网页<a href="https://jjimenezshaw.github.io/crs-explorer/%EF%BC%8C%E5%AE%83%E6%A0%B9%E6%8D%AE%E6%89%80%E9%80%89%E7%9A%84%E4%BD%8D%E7%BD%AE%E5%92%8C%E7%B1%BB%E5%9E%8B%E5%88%97%E5%87%BACRS%E3%80%82">https://jjimenezshaw.github.io/crs-explorer/，它根据所选的位置和类型列出CRS。</a></p>
<p>重要提示：虽然这些工具在许多情况下都很有帮助，但在应用推荐的CRS之前，你需要了解其属性。</p>
<p>当不立即清楚合适的CRS时，CRS的选择应取决于后续地图和分析中最重要的要保留的属性。所有的CRS要么是等面积的，要么是等距的，要么是保形的（形状保持不变），要么是这些特性的某种折中组合。可以为感兴趣的区域创建带有本地参数的自定义CRS，并且当单个CRS不适用于所有任务时，项目中可以使用多个CRS。如果没有合适的CRS，'测地计算’可以提供一个备选方案（参见<a href="https://proj.org/geodesic.html">proj.org/geodesic.html</a>）。无论使用哪个投影CRS，对于覆盖数百公里的几何体，结果可能不准确。</p>
<p>在决定定制CRS时，我们建议如下：^[非常感谢一位匿名审稿人的评论，他们构成了这些建议的基础。]</p>
<ul>
<li>对于定制的本地投影（将原点的纬度和经度设置为研究区域的中心），可以使用Lambert方位等面积（<a href="https://en.wikipedia.org/wiki/Lambert_azimuthal_equal-area_projection">LAEA</a>）投影，这是一种在所有位置的等面积投影，但在数千公里以外会扭曲形状。</li>
<li>对于特定准确的直线距离，可以使用方位等距（<a href="https://en.wikipedia.org/wiki/Azimuthal_equidistant_projection">AEQD</a>）投影，该投影的起点与本地投影的中心点之间的距离。</li>
<li>对于覆盖数千公里的区域，可以使用Lambert保角圆锥（<a href="https://en.wikipedia.org/wiki/Lambert_conformal_conic_projection">LCC</a>）投影，其锥体设置可在割线之间保持距离和面积属性合理。</li>
<li>对于极地区域，可以使用立体（<a href="https://en.wikipedia.org/wiki/Stereographic_projection">STERE</a>）投影，但要注意不要依赖于离中心数千公里的面积和距离计算。</li>
</ul>
<p>一种可能的方法是为研究区域的中心点创建方位等距（<a href="https://en.wikipedia.org/wiki/Azimuthal_equidistant_projection">AEQD</a>）投影，以自动选择特定于本地数据集的投影坐标参考系统（CRS）。这涉及基于数据集的中心点，使用米为单位创建自定义CRS（没有EPSG代码）。请注意，应谨慎使用此方法：没有其他数据集与创建的自定义CRS兼容，当用于覆盖数百公里的广泛数据集时，结果可能不准确。</p>
<p>本节概述的原则同样适用于矢量和栅格数据集。然而，CRS转换的某些特点是每个地理数据模型所独有的。我们将介绍矢量数据转换的特殊性和栅格转换的特殊性。接下来，最后一节将展示如何创建自定义地图投影。</p>
<h1>矢量几何重投影</h1>
<!--jn: idea adding info about custom piplines?-->
<p><em>空间类</em>章演示了矢量几何是如何由点组成的，以及点如何形成更复杂的对象，如线和多边形。因此，重新投影矢量包括转换这些点的坐标，它们构成了线和多边形的顶点。</p>
<p><em>何时重投影</em>节包含了一个示例，其中至少一个<code>sf</code>对象必须转换为具有不同CRS的等效对象，以计算两个对象之间的距离。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">london2 <span class="operator">=</span> st_transform<span class="punctuation">(</span>london_geo<span class="punctuation">,</span> <span class="string">&quot;EPSG:27700&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>现在已经使用 <strong>sf</strong> 函数 <code>st_transform()</code> 创建了 <code>london</code> 的转换版本，就可以找到两个伦敦表示之间的距离了。^[替代 <code>st_transform()</code>的是<strong>lwgeom</strong>中的<code>st_transform_proj()</code>，它可以进行绕过GDAL的转换，并可以支持GDAL不支持的投影。在撰写本文时（2022年），我们没有找到任何仅由<code>st_transform_proj()</code> 支持而不由 <code>st_transform()</code> 支持的投影。]令人惊讶的是，<code>london</code> 和 <code>london2</code> 相距超过2公里！^[两点之间的位置差异并不是由于转换操作的不完美（实际上非常精确），而是由于手动创建的<code>london</code>和<code>london_proj</code>的坐标精度低所造成的。同样令人惊讶的是，结果以米为单位的矩阵形式提供。这是因为 <code>st_distance()</code>可以提供许多特征之间的距离，而且CRS的单位是米。使用 <code>as.numeric()</code> 将结果强制转换为常规数字。]</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">st_distance<span class="punctuation">(</span>london2<span class="punctuation">,</span> london_proj<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; Units: [m]</span></span><br><span class="line"><span class="comment">#&gt;      [,1]</span></span><br><span class="line"><span class="comment">#&gt; [1,] 2018</span></span><br></pre></td></tr></table></figure>
<p>下面展示了使用 <code>cycle_hire_osm</code>（来自 <strong>spData</strong> 的一个 <code>sf</code> 对象，代表伦敦可以租借自行车的“停靠站”）查询和重新投影CRS的函数。可以用函数 <code>st_crs()</code> 查询<code>sf</code>对象的CRS。输出以包含坐标系统信息的多行文本打印：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">st_crs<span class="punctuation">(</span>cycle_hire_osm<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; Coordinate Reference System:</span></span><br><span class="line"><span class="comment">#&gt;   User input: EPSG:4326 </span></span><br><span class="line"><span class="comment">#&gt;   wkt:</span></span><br><span class="line"><span class="comment">#&gt; GEOGCS[&quot;WGS 84&quot;,</span></span><br><span class="line"><span class="comment">#&gt;     DATUM[&quot;WGS_1984&quot;,</span></span><br><span class="line"><span class="comment">#&gt;         SPHEROID[&quot;WGS 84&quot;,6378137,298.257223563,</span></span><br><span class="line"><span class="comment">#&gt;             AUTHORITY[&quot;EPSG&quot;,&quot;7030&quot;]],</span></span><br><span class="line"><span class="comment">#&gt;         AUTHORITY[&quot;EPSG&quot;,&quot;6326&quot;]],</span></span><br><span class="line"><span class="comment">#&gt;     PRIMEM[&quot;Greenwich&quot;,0,</span></span><br><span class="line"><span class="comment">#&gt;         AUTHORITY[&quot;EPSG&quot;,&quot;8901&quot;]],</span></span><br><span class="line"><span class="comment">#&gt;     UNIT[&quot;degree&quot;,0.0174532925199433,</span></span><br><span class="line"><span class="comment">#&gt;         AUTHORITY[&quot;EPSG&quot;,&quot;9122&quot;]],</span></span><br><span class="line"><span class="comment">#&gt;     AUTHORITY[&quot;EPSG&quot;,&quot;4326&quot;]]</span></span><br></pre></td></tr></table></figure>
<p>主要的CRS组件 <code>User input</code> 和 <code>wkt</code>被打印为单一实体，<code>st_crs()</code>的输出实际上是一个名为<code>crs</code>的类的命名列表，具有两个元素，分别命名为 <code>input</code> 和 <code>wkt</code>，如以下代码块的输出所示：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">crs_lnd <span class="operator">=</span> st_crs<span class="punctuation">(</span>london_geo<span class="punctuation">)</span></span><br><span class="line"><span class="built_in">class</span><span class="punctuation">(</span>crs_lnd<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] &quot;crs&quot;</span></span><br><span class="line"><span class="built_in">names</span><span class="punctuation">(</span>crs_lnd<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] &quot;input&quot; &quot;wkt&quot;</span></span><br></pre></td></tr></table></figure>
<p>可以使用 <code>$</code> 运算符检索附加元素，包括 <code>Name</code>、<code>proj4string</code> 和 <code>epsg</code>（有关详细信息，请参阅<a href="https://r-spatial.github.io/sf/reference/st_crs.html"><code>?st_crs</code></a>和GDAL<a href="https://gdal.org/tutorials/osr_api_tut.html#querying-coordinate-reference-system">网站</a> 上的 CRS 和转换教程）：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">crs_lnd<span class="operator">$</span>Name</span><br><span class="line"><span class="comment">#&gt; [1] &quot;WGS 84&quot;</span></span><br><span class="line">crs_lnd<span class="operator">$</span>proj4string</span><br><span class="line"><span class="comment">#&gt; [1] &quot;+proj=longlat +datum=WGS84 +no_defs&quot;</span></span><br><span class="line">crs_lnd<span class="operator">$</span>epsg</span><br><span class="line"><span class="comment">#&gt; [1] 4326</span></span><br></pre></td></tr></table></figure>
<p>WKT 表示形式存储在 <code>crs_lnd</code> 对象的 <code>$wkt</code> 元素中，是最终的真实来源。这意味着前面代码块的输出是来自 PROJ 提供的 <code>wkt</code> 表示的查询，而不是对象及其 CRS 的固有属性。</p>
<p>当对象的CRS被转换时，CRS的<code>wkt</code>和<code>User Input</code>元素都会发生改变。在下面的代码块中，我们用投影 CRS 创建了一个新版本的 <code>cycle_hire_osm</code>（为了简洁，仅显示 CRS 输出的前4行）：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">cycle_hire_osm_projected <span class="operator">=</span> st_transform<span class="punctuation">(</span>cycle_hire_osm<span class="punctuation">,</span> <span class="string">&quot;EPSG:27700&quot;</span><span class="punctuation">)</span></span><br><span class="line">st_crs<span class="punctuation">(</span>cycle_hire_osm_projected<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; Coordinate Reference System:</span></span><br><span class="line"><span class="comment">#&gt;   User input: EPSG:27700 </span></span><br><span class="line"><span class="comment">#&gt;   wkt:</span></span><br><span class="line"><span class="comment">#&gt; PROJCRS[&quot;OSGB36 / British National Grid&quot;,</span></span><br><span class="line"><span class="comment">#&gt; ...</span></span><br></pre></td></tr></table></figure>
<p>生成的对象具有新的CRS，其EPSG代码为27700。但是如何了解有关此EPSG代码或任何代码的更多详细信息呢？一个选项是在线搜索，</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">crs_lnd_new <span class="operator">=</span> st_crs<span class="punctuation">(</span><span class="string">&quot;EPSG:27700&quot;</span><span class="punctuation">)</span></span><br><span class="line">crs_lnd_new<span class="operator">$</span>Name</span><br><span class="line"><span class="comment">#&gt; [1] &quot;OSGB36 / British National Grid&quot;</span></span><br><span class="line">crs_lnd_new<span class="operator">$</span>proj4string</span><br><span class="line"><span class="comment">#&gt; [1] &quot;+proj=tmerc +lat_0=49 +lon_0=-2 +k=0.9996012717 +x_0=400000 +y_0=-100000 +ellps=airy +units=m +no_defs&quot;</span></span><br><span class="line">crs_lnd_new<span class="operator">$</span>epsg</span><br><span class="line"><span class="comment">#&gt; [1] 27700</span></span><br></pre></td></tr></table></figure>
<p>结果显示，EPSG代码27700代表了英国国家网格，这个结果可以通过在线搜索“<a href="https://www.google.com/search?q=CRS+27700">EPSG 27700</a>”找到。</p>
<blockquote>
<p>📌在控制台中打印一个空间对象会自动返回其坐标参考系统。要显式地访问和修改它，可以使用<code>st_crs</code>函数，例如<code>st_crs(cycle_hire_osm)</code>。</p>
</blockquote>
<h1>栅格几何重投影</h1>
<p>在前一部分描述的投影概念同样适用于栅格数据。然而，矢量和栅格的重新投影之间存在重要差异：转换矢量对象涉及更改每个顶点的坐标，但这不适用于栅格数据。栅格由相同大小的矩形单元格组成（以地图单位表示，如度或米），因此单独转换像素的坐标通常是不切实际的。栅格重新投影涉及创建一个新的栅格对象，与原始对象相比，通常具有不同数量的列和行。随后必须重新估计属性，从而允许用适当的值“填充”新的像素。换句话说，栅格重新投影可以看作是两个单独的空间操作：栅格范围到另一个CRS的矢量重新投影，以及通过重新采样计算新的像素值。因此，在大多数情况下，当使用栅格和矢量数据时，最好避免重新投影栅格，而是重新投影向量。</p>
<blockquote>
<p>📌常规栅格的重新投影也被称为扭曲。<br>
此外，还有一种称为“变换”的类似操作。与重新采样所有值不同，它保留所有值不变，但重新计算每个栅格单元格的新坐标，改变网格几何形状。例如，它可以将输入栅格（一个常规网格）转换为曲线网格。在R中，可以使用<a href="https://r-spatial.github.io/stars/articles/stars5.html"><strong>stars</strong>包</a>执行变换操作。</p>
</blockquote>
<p>栅格重新投影过程是使用<strong>terra</strong>包中的<code>project()</code>函数完成的。与前一节中演示的<code>st_transform()</code>函数类似，<code>project()</code>采用地理对象（在本例中为栅格数据集）和第二个参数中的某些CRS表示。顺便说一下–第二个参数也可以是具有不同CRS的现有栅格对象。</p>
<p>让我们看两个光栅转换的例子：使用分类和连续数据。土地覆盖数据通常由分类地图表示。<code>nlcd.tif</code>文件为美国犹他州的一个小区域提供了信息，该信息来自<a href="https://www.mrlc.gov/data/nlcd-2011-land-cover-conus">National Land Cover Database 2011</a>，在NAD83/UTM zone 12 N CRS中，如下面的代码块输出所示（仅显示输出的第一行）：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">cat_raster <span class="operator">=</span> rast<span class="punctuation">(</span>system.file<span class="punctuation">(</span><span class="string">&quot;raster/nlcd.tif&quot;</span><span class="punctuation">,</span> package <span class="operator">=</span> <span class="string">&quot;spDataLarge&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">crs<span class="punctuation">(</span>cat_raster<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; PROJCRS[&quot;NAD83 / UTM zone 12N&quot;,</span></span><br><span class="line"><span class="comment">#&gt; ...</span></span><br></pre></td></tr></table></figure>
<p>在这个区域内，区分了8个土地覆盖类型（NLCD2011土地覆盖类型的完整列表可以在<a href="https://www.mrlc.gov/data/legends/national-land-cover-database-2011-nlcd2011-legend">mrlc.gov</a>上找到）：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">unique<span class="punctuation">(</span>cat_raster<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt;       levels</span></span><br><span class="line"><span class="comment">#&gt; 1      Water</span></span><br><span class="line"><span class="comment">#&gt; 2  Developed</span></span><br><span class="line"><span class="comment">#&gt; 3     Barren</span></span><br><span class="line"><span class="comment">#&gt; 4     Forest</span></span><br><span class="line"><span class="comment">#&gt; 5  Shrubland</span></span><br><span class="line"><span class="comment">#&gt; 6 Herbaceous</span></span><br><span class="line"><span class="comment">#&gt; 7 Cultivated</span></span><br><span class="line"><span class="comment">#&gt; 8   Wetlands</span></span><br></pre></td></tr></table></figure>
<p>在重新投影分类光栅时，估计值必须与原始值相同。这可以使用最近邻方法（<code>near</code>）完成，该方法将每个新单元格的值设置为输入光栅的最近单元格（中心）的值。一个例子是将<code>cat_raster</code>重新投影到WGS84，这是一种非常适合网络映射的地理坐标参照系。第一步是获得该CRS的PROJ定义，例如可以使用<a href="http://spatialreference.org/ref/epsg/wgs-84/">http://spatialreference.org</a>网页来完成。最后一步是使用<code>project()</code>函数重新投影光栅，在分类数据的情况下，它使用最近邻方法（<code>near</code>）。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">cat_raster_wgs84 <span class="operator">=</span> project<span class="punctuation">(</span>cat_raster<span class="punctuation">,</span> <span class="string">&quot;EPSG:4326&quot;</span><span class="punctuation">,</span> method <span class="operator">=</span> <span class="string">&quot;near&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>重新投影后的光栅与原始光栅在许多属性上有所不同，包括列数和行数（因此单元格数）、分辨率（从米转换为度）和范围，如表@ref(tab:catraster)所示（请注意，类别数量从8增加到9，这是由于增加了<code>NA</code>值，而不是因为创建了新类别 —— 土地覆盖类别得以保留）。</p>
<p>Table: Key attributes in the original (‘cat_raster’) and projected (‘cat_raster_wgs84’) categorical raster datasets.</p>
<table>
<thead>
<tr>
<th style="text-align:left">CRS</th>
<th style="text-align:right">nrow</th>
<th style="text-align:right">ncol</th>
<th style="text-align:right">ncell</th>
<th style="text-align:right">resolution</th>
<th style="text-align:right">unique_categories</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">NAD83</td>
<td style="text-align:right">1359</td>
<td style="text-align:right">1073</td>
<td style="text-align:right">1458207</td>
<td style="text-align:right">31.5275</td>
<td style="text-align:right">8</td>
</tr>
<tr>
<td style="text-align:left">WGS84</td>
<td style="text-align:right">1246</td>
<td style="text-align:right">1244</td>
<td style="text-align:right">1550024</td>
<td style="text-align:right">0.0003</td>
<td style="text-align:right">9</td>
</tr>
</tbody>
</table>
<p>对数值光栅（具有 <code>numeric</code> 或在此例中的 <code>integer</code> 值）的重新投影过程几乎相同。下面使用 <strong>spDataLarge</strong> 中的 <code>srtm.tif</code> 文件展示这一过程，该文件来自 <a href="https://www2.jpl.nasa.gov/srtm/">Shuttle Radar Topography Mission（SRTM）</a>，以WGS84坐标参考系表示海平面以上的米高（海拔）：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">con_raster <span class="operator">=</span> rast<span class="punctuation">(</span>system.file<span class="punctuation">(</span><span class="string">&quot;raster/srtm.tif&quot;</span><span class="punctuation">,</span> package <span class="operator">=</span> <span class="string">&quot;spDataLarge&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">crs<span class="punctuation">(</span>con_raster<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] &quot;GEOGCRS[\&quot;WGS 84\&quot;,\n    ENSEMBLE[\&quot;World Geodetic System 1984 ensemble\&quot;,\n        MEMBER[\&quot;World Geodetic System 1984 (Transit)\&quot;],\n        MEMBER[\&quot;World Geodetic System 1984 (G730)\&quot;],\n        MEMBER[\&quot;World Geodetic System 1984 (G873)\&quot;],\n        MEMBER[\&quot;World Geodetic System 1984 (G1150)\&quot;],\n        MEMBER[\&quot;World Geodetic System 1984 (G1674)\&quot;],\n        MEMBER[\&quot;World Geodetic System 1984 (G1762)\&quot;],\n        MEMBER[\&quot;World Geodetic System 1984 (G2139)\&quot;],\n        ELLIPSOID[\&quot;WGS 84\&quot;,6378137,298.257223563,\n            LENGTHUNIT[\&quot;metre\&quot;,1]],\n        ENSEMBLEACCURACY[2.0]],\n    PRIMEM[\&quot;Greenwich\&quot;,0,\n        ANGLEUNIT[\&quot;degree\&quot;,0.0174532925199433]],\n    CS[ellipsoidal,2],\n        AXIS[\&quot;geodetic latitude (Lat)\&quot;,north,\n            ORDER[1],\n            ANGLEUNIT[\&quot;degree\&quot;,0.0174532925199433]],\n        AXIS[\&quot;geodetic longitude (Lon)\&quot;,east,\n            ORDER[2],\n            ANGLEUNIT[\&quot;degree\&quot;,0.0174532925199433]],\n    USAGE[\n        SCOPE[\&quot;Horizontal component of 3D system.\&quot;],\n        AREA[\&quot;World.\&quot;],\n        BBOX[-90,-180,90,180]],\n    ID[\&quot;EPSG\&quot;,4326]]&quot;</span></span><br></pre></td></tr></table></figure>
<p>我们将重新投影这个数据集到一个投影的坐标参考系中，但不是用适用于分类数据的最近邻方法。相反，我们将使用双线性方法，该方法基于原始栅格中的四个最近单元格计算输出单元格的值。^[<br>
还可以在<em>重采样</em>节中提到的其他方法。]投影数据集中的值是这四个单元格的值的距离加权平均值：输入单元格距离输出单元格的中心越近，其权重就越大。以下命令创建代表WGS 84 / UTM zone 12N的文本字符串，并使用<code>bilinear</code>方法将栅格重新投影到此CRS中。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">con_raster_ea <span class="operator">=</span> project<span class="punctuation">(</span>con_raster<span class="punctuation">,</span> <span class="string">&quot;EPSG:32612&quot;</span><span class="punctuation">,</span> method <span class="operator">=</span> <span class="string">&quot;bilinear&quot;</span><span class="punctuation">)</span></span><br><span class="line">crs<span class="punctuation">(</span>con_raster_ea<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] &quot;PROJCRS[\&quot;WGS 84 / UTM zone 12N\&quot;,\n    BASEGEOGCRS[\&quot;WGS 84\&quot;,\n        ENSEMBLE[\&quot;World Geodetic System 1984 ensemble\&quot;,\n            MEMBER[\&quot;World Geodetic System 1984 (Transit)\&quot;],\n            MEMBER[\&quot;World Geodetic System 1984 (G730)\&quot;],\n            MEMBER[\&quot;World Geodetic System 1984 (G873)\&quot;],\n            MEMBER[\&quot;World Geodetic System 1984 (G1150)\&quot;],\n            MEMBER[\&quot;World Geodetic System 1984 (G1674)\&quot;],\n            MEMBER[\&quot;World Geodetic System 1984 (G1762)\&quot;],\n            MEMBER[\&quot;World Geodetic System 1984 (G2139)\&quot;],\n            ELLIPSOID[\&quot;WGS 84\&quot;,6378137,298.257223563,\n                LENGTHUNIT[\&quot;metre\&quot;,1]],\n            ENSEMBLEACCURACY[2.0]],\n        PRIMEM[\&quot;Greenwich\&quot;,0,\n            ANGLEUNIT[\&quot;degree\&quot;,0.0174532925199433]],\n        ID[\&quot;EPSG\&quot;,4326]],\n    CONVERSION[\&quot;UTM zone 12N\&quot;,\n        METHOD[\&quot;Transverse Mercator\&quot;,\n            ID[\&quot;EPSG\&quot;,9807]],\n        PARAMETER[\&quot;Latitude of natural origin\&quot;,0,\n            ANGLEUNIT[\&quot;degree\&quot;,0.0174532925199433],\n            ID[\&quot;EPSG\&quot;,8801]],\n        PARAMETER[\&quot;Longitude of natural origin\&quot;,-111,\n            ANGLEUNIT[\&quot;degree\&quot;,0.0174532925199433],\n            ID[\&quot;EPSG\&quot;,8802]],\n        PARAMETER[\&quot;Scale factor at natural origin\&quot;,0.9996,\n            SCALEUNIT[\&quot;unity\&quot;,1],\n            ID[\&quot;EPSG\&quot;,8805]],\n        PARAMETER[\&quot;False easting\&quot;,500000,\n            LENGTHUNIT[\&quot;metre\&quot;,1],\n            ID[\&quot;EPSG\&quot;,8806]],\n        PARAMETER[\&quot;False northing\&quot;,0,\n            LENGTHUNIT[\&quot;metre\&quot;,1],\n            ID[\&quot;EPSG\&quot;,8807]]],\n    CS[Cartesian,2],\n        AXIS[\&quot;(E)\&quot;,east,\n            ORDER[1],\n            LENGTHUNIT[\&quot;metre\&quot;,1]],\n        AXIS[\&quot;(N)\&quot;,north,\n            ORDER[2],\n            LENGTHUNIT[\&quot;metre\&quot;,1]],\n    USAGE[\n        SCOPE[\&quot;Engineering survey, topographic mapping.\&quot;],\n        AREA[\&quot;Between 114°W and 108°W, northern hemisphere between equator and 84°N, onshore and offshore. Canada - Alberta; Northwest Territories (NWT); Nunavut; Saskatchewan. Mexico. United States (USA).\&quot;],\n        BBOX[0,-114,84,-108]],\n    ID[\&quot;EPSG\&quot;,32612]]&quot;</span></span><br></pre></td></tr></table></figure>
<p>数值变量的栅格重新投影也会导致数值和空间属性的微小变化，例如单元格数量、分辨率和范围。这些变化在表 @ref(tab:rastercrs) 中得到展示。^[另一个未在表中表示的细微变化是新投影栅格数据集中值的类别是 <code>numeric</code>。这是因为<code>bilinear</code>方法适用于连续数据，结果很少强制转换为整数值。这可能会在保存栅格数据集时影响文件大小。]</p>
<p>Table: (#tab:rastercrs)Key attributes in the original (‘con_raster’) and projected (‘con_raster_ea’) continuous raster datasets.</p>
<table>
<thead>
<tr>
<th style="text-align:left">CRS</th>
<th style="text-align:right">nrow</th>
<th style="text-align:right">ncol</th>
<th style="text-align:right">ncell</th>
<th style="text-align:right">resolution</th>
<th style="text-align:right">mean</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">WGS84</td>
<td style="text-align:right">457</td>
<td style="text-align:right">465</td>
<td style="text-align:right">212505</td>
<td style="text-align:right">0.0008</td>
<td style="text-align:right">1843</td>
</tr>
<tr>
<td style="text-align:left">UTM zone 12N</td>
<td style="text-align:right">515</td>
<td style="text-align:right">422</td>
<td style="text-align:right">217330</td>
<td style="text-align:right">83.5334</td>
<td style="text-align:right">1842</td>
</tr>
</tbody>
</table>
<blockquote>
<p>📌当然，2D地球投影的局限性同样适用于矢量数据和栅格数据。我们最多只能遵循三个空间属性（距离、面积、方向）中的两个。因此，手头的任务决定了选择哪个投影。例如，如果我们对密度感兴趣（每个网格单元的点数或每个网格单元的居民数），我们应该使用等面积投影。</p>
</blockquote>
<h1>自定义坐标系</h1>
<p>使用<code>AUTHORITY:CODE</code>标识符（例如<code>EPSG:4326</code>）捕获的现有CRS非常适合许多应用。然而，在某些情况下，可能希望使用替代投影或创建自定义CRS。*选择哪个CRS使用?*节提到了使用自定义CRS的原因，并提供了几种可能的方法。在这里，我们展示如何在R中应用这些想法。</p>
<p>其中一种方法是采用现有的CRS的WKT定义，修改其中的一些元素，然后使用新定义进行重新投影。对于空间向量，可以使用<code>st_crs()$wkt</code>和<code>st_transform()</code>，对于空间栅格，可以使用<code>crs()</code>和<code>project()</code>，如下面的示例所示，该示例将<code>zion</code>对象转换为自定义的方位等距（AEQD）CRS。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">zion <span class="operator">=</span> read_sf<span class="punctuation">(</span>system.file<span class="punctuation">(</span><span class="string">&quot;vector/zion.gpkg&quot;</span><span class="punctuation">,</span> package <span class="operator">=</span> <span class="string">&quot;spDataLarge&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>使用自定义AEQD CRS需要知道数据集中心点的坐标（以度为单位，地理CRS）。在我们的情况下，可以通过计算<code>zion</code>区域的质心并将其转换为WGS84来提取这些信息。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">zion_centr <span class="operator">=</span> st_centroid<span class="punctuation">(</span>zion<span class="punctuation">)</span></span><br><span class="line">zion_centr_wgs84 <span class="operator">=</span> st_transform<span class="punctuation">(</span>zion_centr<span class="punctuation">,</span> <span class="string">&quot;EPSG:4326&quot;</span><span class="punctuation">)</span></span><br><span class="line">st_as_text<span class="punctuation">(</span>st_geometry<span class="punctuation">(</span>zion_centr_wgs84<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] &quot;POINT (-113 37.3)&quot;</span></span><br></pre></td></tr></table></figure>
<p>接下来，我们可以使用新获得的值来更新下面所示的方位等距（AEQD）CRS的WKT定义。注意，我们只修改了下面的两个值 —— 将“Central_Meridian”改为我们的质心的经度，并将“Latitude_Of_Origin”改为质心的纬度。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">my_wkt <span class="operator">=</span> <span class="string">&#x27;PROJCS[&quot;Custom_AEQD&quot;,</span></span><br><span class="line"><span class="string"> GEOGCS[&quot;GCS_WGS_1984&quot;,</span></span><br><span class="line"><span class="string">  DATUM[&quot;WGS_1984&quot;,</span></span><br><span class="line"><span class="string">   SPHEROID[&quot;WGS_1984&quot;,6378137.0,298.257223563]],</span></span><br><span class="line"><span class="string">  PRIMEM[&quot;Greenwich&quot;,0.0],</span></span><br><span class="line"><span class="string">  UNIT[&quot;Degree&quot;,0.0174532925199433]],</span></span><br><span class="line"><span class="string"> PROJECTION[&quot;Azimuthal_Equidistant&quot;],</span></span><br><span class="line"><span class="string"> PARAMETER[&quot;Central_Meridian&quot;,-113.0263],</span></span><br><span class="line"><span class="string"> PARAMETER[&quot;Latitude_Of_Origin&quot;,37.29818],</span></span><br><span class="line"><span class="string"> UNIT[&quot;Meter&quot;,1.0]]&#x27;</span></span><br></pre></td></tr></table></figure>
<p>这种方法的最后一步是将我们的原始对象（<code>zion</code>）转换为我们的新自定义CRS（<code>zion_aeqd</code>）。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">zion_aeqd <span class="operator">=</span> st_transform<span class="punctuation">(</span>zion<span class="punctuation">,</span> my_wkt<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>自定义投影也可以交互式地制作，例如，使用<a href="https://projectionwizard.org/#">Projection Wizard</a>网页应用程序。这个网站允许您选择数据的空间范围和失真属性，并返回可能的投影列表。该列表还包含您可以复制和用于重新投影的投影的WKT定义。有关使用WKT字符串创建自定义CRS定义的详细信息，请参阅@opengeospatialconsortium_wellknown_2019。</p>
<p>PROJ字符串也可以用来创建自定义投影，接受投影本身固有的限制，特别是在涵盖大地理区域的几何体上。已经开发了许多投影，并可以通过PROJ字符串的<code>+proj=</code>元素进行设置，仅在<a href="https://proj.org/operations/projections/index.html">PROJ网站</a>上就详细描述了几十个项目。</p>
<p>当绘制世界地图并保持面积关系时，Mollweide投影是一种流行且通常合理的选择，如下图所示。要使用此投影，我们需要在<code>st_transform</code>函数中使用proj-string元素<code>&quot;+proj=moll&quot;</code>来指定它。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">world_mollweide <span class="operator">=</span> st_transform<span class="punctuation">(</span>world<span class="punctuation">,</span> crs <span class="operator">=</span> <span class="string">&quot;+proj=moll&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>&lt;<img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309031641668.png" alt=""><br>
Mollweide projection of the world.</p>
<p>当绘制世界地图时，人们通常希望最小化所有空间属性（面积、方向、距离）的失真。实现这一目标的最受欢迎的投影之一是<a href="http://www.winkel.org/other/Winkel%20Tripel%20Projections.htm">Winkel tripel</a>，如下图所示。^[该投影被国家地理学会等机构使用。]这个结果是通过以下命令创建的：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">world_wintri <span class="operator">=</span> st_transform<span class="punctuation">(</span>world<span class="punctuation">,</span> crs <span class="operator">=</span> <span class="string">&quot;+proj=wintri&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309031643063.png" alt=""><br>
Winkel tripel projection of the world.</p>
<p>此外，在大多数CRS定义中可以修改proj-string参数，例如可以使用<code>+lon_0</code>和<code>+lat_0</code>参数调整投影的中心点。下面的代码将坐标转换为以纽约市的经度和纬度为中心的兰伯特等面积投影。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">world_laea2 <span class="operator">=</span> st_transform<span class="punctuation">(</span>world<span class="punctuation">,</span></span><br><span class="line">                           crs <span class="operator">=</span> <span class="string">&quot;+proj=laea +x_0=0 +y_0=0 +lon_0=-74 +lat_0=40&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309031648355.png" alt=""><br>
Lambert azimuthal equal-area projection of the world centered on New York City.</p>
<p>关于CRS修改的更多信息可以在<a href="https://proj.org/usage/index.html">使用PROJ</a>文档中找到。</p>
<h1>练习</h1>
<p>E1. 通过将 <code>nz</code> 对象转换为 WGS84 坐标参考系统（CRS）来创建一个名为 <code>nz_wgs</code> 的新对象。</p>
<ul>
<li>为两者创建一个 <code>crs</code> 类的对象，并用它来查询它们的CRS。</li>
<li>根据每个对象的边界框，每个CRS使用什么单位？</li>
<li>从 <code>nz_wgs</code> 中移除CRS并绘制结果：这张新西兰的地图有什么问题，为什么？</li>
</ul>
<p>E2. 将 <code>world</code> 数据集转换为横向墨卡托投影（<code>&quot;+proj=tmerc&quot;</code>）并绘制结果。发生了什么变化，为什么？尝试将其转换回 WGS 84 并绘制新对象。为什么新对象与原对象不同？</p>
<p>E3. 使用最近邻插值方法将连续栅格（<code>con_raster</code>）转换为 NAD83 / UTM区域12N。发生了什么变化？它如何影响结果？</p>
<p>E4. 使用双线性插值方法将分类栅格（<code>cat_raster</code>）转换为 WGS 84。发生了什么变化？它如何影响结果？</p>
<!--toDo:jn-->
<!--improve/replace/modify the following q-->
<!-- E5. Create your own proj-string.  -->
<!-- It should have the Lambert Azimuthal Equal Area (`laea`) projection, the WGS84 ellipsoid, the longitude of projection center of 95 degrees west, the latitude of projection center of 60 degrees north, and its units should be in meters. -->
<!-- Next, subset Canada from the `world` object and transform it into the new projection.  -->
<!-- Plot and compare a map before and after the transformation. -->
<!-- ```{r 06-reproj-40} -->
<!-- new_p4s = "+proj=laea +ellps=WGS84 +lon_0=-95 +lat_0=60 +units=m" -->
<!-- canada = dplyr::filter(world, name_long == "Canada") -->
<!-- new_canada = st_transform(canada, new_p4s) -->
<!-- par(mfrow = c(1, 2)) -->
<!-- plot(st_geometry(canada), graticule = TRUE, axes = TRUE) -->
<!-- plot(st_geometry(new_canada), graticule = TRUE, axes = TRUE) -->
<!-- ``` -->
]]></content>
      <categories>
        <category>R</category>
        <category>Geocomputaion</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>Geocomputaion</tag>
      </tags>
  </entry>
  <entry>
    <title>(8)地理数据 I/O</title>
    <url>/2023/08/17/2023-8-17-8%E5%9C%B0%E7%90%86%E6%95%B0%E6%8D%AEIO/</url>
    <content><![CDATA[<blockquote><p>本文由SCY翻译自《Geocomputation with R》<a href="https://r.geocompx.org/read-write">第八章</a></p>
</blockquote>
<p>本章关于读取和写入地理数据。地理数据<em>输入</em>对地理计算至关重要，没有数据就不可能有真实世界的应用。数据<em>输出</em>也非常关键,它能够让其他人使用由你的工作产生的有价值的新数据集或改进后的数据集。总而言之,输入/输出这些进程可以称为数据I/O。</p>
<span id="more"></span>
<h1>前提条件</h1>
<p>本章要求下面的包</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>sf<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>terra<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>dplyr<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>spData<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<h1>引言</h1>
<!--toDo:RL-->
<!--revise and update the following section-->
<p>本章关于读取和写入地理数据。地理数据<em>输入</em>对地理计算至关重要，没有数据就不可能有真实世界的应用。数据<em>输出</em>也非常关键，它能够让其他人使用由你的工作产生的有价值的新数据集或改进后的数据集。总而言之,输入/输出这些进程可以称为数据I/O。</p>
<p>地理数据I/O通常只需要在项目开始和结束时编写几行代码。它经常被简单地视为一个步骤的过程而被忽略。然而,在项目开始时(例如使用过时或有缺陷的数据集)的错误会在稍后导致大问题,因此值得在确定哪些数据集是<em>可用的</em>、它们可以在<em>哪里找到</em>以及如何<em>检索</em>它们上投入相当多的时间。后面章节描述了各种<em>地理门户网站</em>，这些网站共同包含了数十TB的数据,以及如何使用它们。为了进一步简化数据访问,已经开发了许多用于下载地理数据的软件包。存在许多地理文件格式,各有其优缺点。关于实际高效读取和写入这些文件格式的过程直到第<em>数据输入</em>节和<em>数据输出</em>节才涵盖。最后一节<em>输出可视化</em>演示了保存可视化输出(地图)的方法，为<em>高级制图</em>章节关于可视化做准备。</p>
<h1>获取开放数据</h1>
<!--toDo:RL-->
<!--revise and update the following section-->
<p>在互联网上可以获取到大量且不断增加的地理数据，其中许多数据是免费提供并可供访问和使用的（需适当给予提供者适当的署名）。[^08-read-write-plot-1]从某种程度上说，现在存在着<em>过多</em>的数据，意味着通常有多个地方可以获取相同的数据集。有些数据集的质量较差。在这种情况下，了解从何处获取数据变得至关重要，因此第一部分介绍了一些最重要的数据来源。各种“地理门户”（提供地理空间数据的网络服务，如<a href="https://catalog.data.gov/dataset?metadata_type=geospatial">Data.gov</a>）是一个很好的起点，提供了广泛的数据，但通常仅适用于特定位置（如在更新的<a href="https://en.wikipedia.org/wiki/Geoportal">维基百科页面</a>上所示）。</p>
<p>[^08-read-write-plot-1]：例如，访问<a href="https://freegisdata.rtwilson.com/">https://freegisdata.rtwilson.com/</a>获取免费可用的地理数据网站列表。</p>
<p>一些全球性的地理门户解决了这个问题。例如，<a href="http://www.geoportal.org/">GEOSS门户</a>和<a href="https://scihub.copernicus.eu/">科普尼库斯开放获取中心</a>包含许多具有全球覆盖范围的栅格数据集。从由美国国家航空航天局（NASA）运营的<a href="http://sedac.ciesin.columbia.edu/">SEDAC</a>门户和欧洲联盟的<a href="http://inspire-geoportal.ec.europa.eu/">INSPIRE地理门户</a>可以访问到丰富的矢量数据集，涵盖全球和区域。</p>
<p>大多数地理门户提供图形界面，允许基于空间和时间范围等特征查询数据集，美国地质调查局的<a href="https://earthexplorer.usgs.gov/">EarthExplorer</a>就是一个典型的例子。通过浏览器<em>交互式地探索</em>数据集是了解可用图层的有效方式。然而，从可重现性和效率的角度来看，<em>下载</em>数据最好使用代码进行。可以通过多种技术从命令行启动下载，主要是通过URL和API（例如查看<a href="https://scihub.copernicus.eu/twiki/do/view/SciHubWebPortal/APIHubDescription">哨兵API</a>）。托管在静态URL上的文件可以使用<code>download.file()</code>进行下载，正如下面的代码块所示，该代码块访问了来自<a href="https://doi.pangaea.de/10.1594/PANGAEA.868349">doi.pangaea.de</a>的PeRL：多年冻土区域池塘和湖泊数据库：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">download.file<span class="punctuation">(</span>url <span class="operator">=</span> <span class="string">&quot;https://hs.pangaea.de/Maps/PeRL/PeRL_permafrost_landscapes.zip&quot;</span><span class="punctuation">,</span></span><br><span class="line">              destfile <span class="operator">=</span> <span class="string">&quot;PeRL_permafrost_landscapes.zip&quot;</span><span class="punctuation">,</span> </span><br><span class="line">              mode <span class="operator">=</span> <span class="string">&quot;wb&quot;</span><span class="punctuation">)</span></span><br><span class="line">unzip<span class="punctuation">(</span><span class="string">&quot;PeRL_permafrost_landscapes.zip&quot;</span><span class="punctuation">)</span></span><br><span class="line">canada_perma_land <span class="operator">=</span> read_sf<span class="punctuation">(</span><span class="string">&quot;PeRL_permafrost_landscapes/canada_perma_land.shp&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<h1>地理数据包</h1>
<!--toDo:RL-->
<!--revise and update the following section-->
<!-- JN: btw -- should we add references to these packages? -->
<p>已经开发了许多用于访问地理数据的R包，其中一些在表中呈现出来。这些包提供了一个或多个空间库或地理门户的接口，旨在使命令行中的数据访问更加快速。</p>
<table class="table" style="margin-left: auto; margin-right: auto;">
<caption>(\#tab:datapackages)Selected R packages for geographic data retrieval.</caption>
 <thead>
  <tr>
   <th style="text-align:left;"> Package </th>
   <th style="text-align:left;"> Description </th>
  </tr>
 </thead>
<tbody>
  <tr>
   <td style="text-align:left;"> FedData </td>
   <td style="text-align:left;"> Datasets maintained by the US Federal government, including elevation and land cover. </td>
  </tr>
  <tr>
   <td style="text-align:left;"> geodata </td>
   <td style="text-align:left;"> Download and import imports administrative, elevation, WorldClim data. </td>
  </tr>
  <tr>
   <td style="text-align:left;"> osmdata </td>
   <td style="text-align:left;"> Download and import small OpenStreetMap datasets. </td>
  </tr>
  <tr>
   <td style="text-align:left;"> osmextract </td>
   <td style="text-align:left;"> Download and import large OpenStreetMap datasets. </td>
  </tr>
  <tr>
   <td style="text-align:left;"> rnaturalearth </td>
   <td style="text-align:left;"> Access to Natural Earth vector and raster data. </td>
  </tr>
  <tr>
   <td style="text-align:left;"> rnoaa </td>
   <td style="text-align:left;"> Imports National Oceanic and Atmospheric Administration (NOAA) climate data. </td>
  </tr>
</tbody>
</table>
<!--toDo:JN-->
<!-- add to the table: -->
<!-- https://github.com/jhollist/elevatr/issues/64 -->
<!-- https://github.com/mikejohnson51/climateR/issues/44 -->
<!-- maybe: -->
<!-- https://github.com/ErikKusch/KrigR -->
<!-- https://github.com/VeruGHub/easyclimate -->
<!-- mention: -->
<!-- https://github.com/ropensci/MODIStsp -->
<!-- https://github.com/ropensci/rsat -->
<!--https://onlinelibrary.wiley.com/doi/10.1111/ecog.06768-->
<p>需要强调的是，表中仅代表了少量可用的地理数据包。例如，存在大量的R包用于获取各种社会人口数据，如<strong>tidycensus</strong>和<strong>tigris</strong>（美国），<strong>cancensus</strong>（加拿大），<strong>eurostat</strong>和<strong>giscoR</strong>（欧盟），或者<strong>idbr</strong>（国际数据库）–阅读<a href="https://walker-data.com/census-r">分析美国人口普查数据</a>以找到如何分析此类数据的一些示例。同样，还有一些R包可供访问各个地区和国家的空间数据，如<strong>bcdata</strong>（不列颠哥伦比亚省），<strong>geobr</strong>（巴西），<strong>RCzechia</strong>（捷克）或<strong>rgugik</strong>（波兰）。另一个值得注意的包是<strong>GSODR</strong>，它在R中提供全球每日天气摘要数据（请参阅该包的<a href="https://github.com/ropensci/GSODR">README</a>以获取天气数据源的概述）。</p>
<p>每个数据包都有自己的访问数据的语法。这种多样性在随后的代码块中得到了展示，这些代码块展示了如何使用表@ref(tab:datapackages)中的三个包获取数据。<a href="%E5%8F%AF%E4%BB%A5%E5%9C%A8%3Chttps://rspatialdata.github.io/%3E%E6%89%BE%E5%88%B0%E4%BD%BF%E7%94%A8%E4%B8%93%E7%94%A8R%E5%8C%85%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E4%B8%8B%E8%BD%BD%E7%9A%84%E6%9B%B4%E5%A4%9A%E7%A4%BA%E4%BE%8B%E3%80%82">^08-read-write-plot-2</a> 国家边界通常很有用，可以使用<strong>rnaturalearth</strong>包中的<code>ne_countries()</code>函数来访问这些边界，如下所示：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>rnaturalearth<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; Support for Spatial objects (`sp`) will be deprecated in &#123;rnaturalearth&#125; and will be removed in a future release of the package. Please use `sf` objects with &#123;rnaturalearth&#125;. For example: `ne_download(returnclass = &#x27;sf&#x27;)`</span></span><br><span class="line">usa <span class="operator">=</span> ne_countries<span class="punctuation">(</span>country <span class="operator">=</span> <span class="string">&quot;United States of America&quot;</span><span class="punctuation">)</span> <span class="comment"># United States borders</span></span><br><span class="line"><span class="comment">#&gt; Warning: The `returnclass` argument of `ne_download()` sp as of rnaturalearth 1.0.0.</span></span><br><span class="line"><span class="comment">#&gt; ℹ Please use `sf` objects with &#123;rnaturalearth&#125;, support for Spatial objects</span></span><br><span class="line"><span class="comment">#&gt;   (sp) will be removed in a future release of the package.</span></span><br><span class="line"><span class="comment">#&gt; This warning is displayed once every 8 hours.</span></span><br><span class="line"><span class="comment">#&gt; Call `lifecycle::last_lifecycle_warnings()` to see where this warning was</span></span><br><span class="line"><span class="comment">#&gt; generated.</span></span><br><span class="line"><span class="built_in">class</span><span class="punctuation">(</span>usa<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] &quot;SpatialPolygonsDataFrame&quot;</span></span><br><span class="line"><span class="comment">#&gt; attr(,&quot;package&quot;)</span></span><br><span class="line"><span class="comment">#&gt; [1] &quot;sp&quot;</span></span><br><span class="line"><span class="comment"># alternative way of accessing the data, with geodata</span></span><br><span class="line"><span class="comment"># geodata::gadm(&quot;USA&quot;, level = 0, path = tempdir())</span></span><br></pre></td></tr></table></figure>
<p>默认情况下，<strong>rnaturalearth</strong>返回<code>Spatial*</code>类的对象。可以使用<code>st_as_sf()</code>将结果转换为<code>sf</code>对象，如下所示：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">usa_sf <span class="operator">=</span> st_as_sf<span class="punctuation">(</span>usa<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<!--toDo:JN-->
<!-- add info about other world-data packages, when rgeoboundaries on CRAN -->
<!-- https://github.com/wmgeolab/rgeoboundaries/issues/11 -->
<!-- https://github.com/wmgeolab/rgeoboundaries -->
<!-- https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0231866 -->
<!-- https://www.geoboundaries.org/ -->
<p>第二个示例使用<strong>geodata</strong>包下载了一系列具有十分钟空间分辨率（在赤道处约为18.5公里）的全球月降水总和栅格数据。结果是一个<code>SpatRaster</code>类的多层对象。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>geodata<span class="punctuation">)</span></span><br><span class="line">worldclim_prec <span class="operator">=</span> worldclim_global<span class="punctuation">(</span><span class="string">&quot;prec&quot;</span><span class="punctuation">,</span> res <span class="operator">=</span> <span class="number">10</span><span class="punctuation">,</span> path <span class="operator">=</span> tempdir<span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="built_in">class</span><span class="punctuation">(</span>worldclim_prec<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>第三个示例使用<strong>osmdata</strong>包从OpenStreetMap（OSM）数据库中查找公园。如下面的代码块所示，查询从函数<code>opq()</code>（OpenStreetMap查询的缩写）开始，其第一个参数是边界框或表示边界框的文本字符串（在此示例中为利兹市）。结果传递给一个函数，用于选择我们感兴趣的OSM元素（在本例中为公园），表示为<em>键-值对</em>。接下来，它们被传递给<code>osmdata_sf()</code>函数，该函数完成了下载数据并将其转换为<code>sf</code>对象列表的工作（有关详细信息，请参阅<code>vignette('osmdata')</code>）：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>osmdata<span class="punctuation">)</span></span><br><span class="line">parks <span class="operator">=</span> opq<span class="punctuation">(</span>bbox <span class="operator">=</span> <span class="string">&quot;leeds uk&quot;</span><span class="punctuation">)</span> <span class="operator">|&gt;</span> </span><br><span class="line">  add_osm_feature<span class="punctuation">(</span>key <span class="operator">=</span> <span class="string">&quot;leisure&quot;</span><span class="punctuation">,</span> value <span class="operator">=</span> <span class="string">&quot;park&quot;</span><span class="punctuation">)</span> <span class="operator">|&gt;</span> </span><br><span class="line">  osmdata_sf<span class="punctuation">(</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><strong>osmdata</strong>包的一个限制是它受到<em>速率限制</em>，这意味着它无法下载大型的OSM数据集（例如一个大城市的所有OSM数据）。为了克服这个限制，开发了<strong>osmextract</strong>包，它可以用来下载和导入包含预定义区域压缩版本的二进制<code>.pbf</code>文件，其中包含了OSM数据库的数据。<!--todo: 添加正确的引用--></p>
<p>OpenStreetMap是一个庞大的全球众包数据数据库，每天都在不断增长，并且有一个更广泛的工具生态系统，可以轻松访问数据，从用于快速开发和测试OSM查询的<a href="https://overpass-turbo.eu/">Overpass turbo</a>网络服务，到将数据导入PostGIS数据库的<a href="https://osm2pgsql.org/">osm2pgsql</a>。尽管从OSM派生的数据集的质量各不相同，但数据源和更广泛的OSM生态系统具有许多优势：它们提供全球范围内的免费数据集，并且得益于众多志愿者的帮助不断改进。使用OSM鼓励“公民科学”和对数字公共领域的贡献（您可以从<a href="https://www.openstreetmap.org">www.openstreetmap.org</a>开始编辑代表您熟悉的世界某个部分的数据）。</p>
<p>有时，软件包附带了内置数据集。可以通过四种方式访问这些数据集：通过附加软件包（如果软件包使用<strong>spData</strong>的“惰性加载”），使用<code>data(dataset, package = mypackage)</code>，通过<code>mypackage::dataset</code>引用数据集，或者使用<code>system.file(filepath, package = mypackage)</code>来访问原始数据文件。以下代码块使用<code>world</code>数据集（通过附加其父包<code>library(spData)</code>已加载）说明了后两种选项：[^08-read-write-plot-3]</p>
<p>[^08-read-write-plot-3]：有关使用R软件包进行数据导入的更多信息，请参见@gillespie_efficient_2016的第5.5和第5.6节。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">world2 <span class="operator">=</span> spData<span class="operator">::</span>world</span><br><span class="line">world3 <span class="operator">=</span> read_sf<span class="punctuation">(</span>system.file<span class="punctuation">(</span><span class="string">&quot;shapes/world.gpkg&quot;</span><span class="punctuation">,</span> package <span class="operator">=</span> <span class="string">&quot;spData&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>最后一个示例<code>system.file(&quot;shapes/world.gpkg&quot;, package = &quot;spData&quot;)</code>返回了一个路径，该路径指向<strong>spData</strong>软件包中的<code>&quot;shapes/&quot;</code>文件夹内的<code>world.gpkg</code>文件。</p>
<p>获取空间信息的另一种方法是进行地理编码——将位置描述（通常是地址）转换为其坐标。这通常通过向在线服务发送查询并获得位置作为结果来完成。存在许多此类服务，它们在地理编码方法、使用限制、成本或API密钥要求方面存在差异。R有几个用于地理编码的包；然而，<strong>tidygeocoder</strong>似乎允许使用一致的接口连接到<a href="https://jessecambon.github.io/tidygeocoder/articles/geocoder_services.html">最多数量的地理编码服务</a>。<strong>tidygeocoder</strong>的主要函数是<code>geocode</code>，它接受一个包含地址的数据框，并将坐标添加为<code>&quot;lat&quot;</code>和<code>&quot;long&quot;</code>。该函数还允许使用<code>method</code>参数选择地理编码服务，并具有许多其他参数。</p>
<p>下面的示例搜索位于伦敦苏豪区一幢建筑上的约翰·斯诺蓝色牌匾的坐标。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>tidygeocoder<span class="punctuation">)</span></span><br><span class="line">geo_df <span class="operator">=</span> data.frame<span class="punctuation">(</span>address <span class="operator">=</span> <span class="string">&quot;54 Frith St, London W1D 4SJ, UK&quot;</span><span class="punctuation">)</span></span><br><span class="line">geo_df <span class="operator">=</span> geocode<span class="punctuation">(</span>geo_df<span class="punctuation">,</span> address<span class="punctuation">,</span> method <span class="operator">=</span> <span class="string">&quot;osm&quot;</span><span class="punctuation">)</span></span><br><span class="line">geo_df</span><br></pre></td></tr></table></figure>
<p>得到的数据框可以使用<code>st_as_sf()</code>转换为<code>sf</code>对象。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">geo_sf <span class="operator">=</span> st_as_sf<span class="punctuation">(</span>geo_df<span class="punctuation">,</span> coords <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;long&quot;</span><span class="punctuation">,</span> <span class="string">&quot;lat&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> crs <span class="operator">=</span> <span class="string">&quot;EPSG:4326&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>这个包还允许执行相反的过程，称为反向地理编码，用于基于一对坐标获取一组信息（名称、地址等）。</p>
<!--toDo:jn-->
<!-- we should add a rgee section in the bridges chapter and add a reference here -->
<!-- consider data from rgee -->
<!-- rgee - see https://github.com/loreabad6/30DayMapChallenge/blob/main/scripts/day08_blue.R -->
<!-- Finally, there are some packages that allows to download spatial data among many other functions.  -->
<!-- Prominent example here is the **rgee** package  -->
<!-- ee_imagecollection_to_local -->
<h1>地理网络服务</h1>
<!--toDo:RL-->
<!--revise and update the following section-->
<!--jn: Robin, I am leaving this section entirely to you -- I have zero knowledge about OWS-->
<!-- potentially useful package - https://github.com/eblondel/geosapi -->
<!-- rstac - https://gist.github.com/h-a-graham/420434c158c139180f5eb82859099082, -->
<p>为了标准化访问空间数据的Web API，开放地理信息联盟（OGC）制定了一系列Web服务规范（统称为OGC Web Services，简称OWS）。这些规范包括Web要素服务（Web Feature Service，WFS）、Web地图服务（Web Map Service，WMS）、Web地图切片服务（Web Map Tile Service，WMTS）、Web覆盖服务（Web Coverage Service，WCS），甚至还有Web处理服务（Web Processing Service，WPS）。像PostGIS等地图服务器已经采用了这些协议，从而实现了查询的标准化。与其他Web API一样，OWS API使用“base URL”、“endpoint”和在<code>?</code>后的“UURL query arguments”来请求数据（请参阅<strong>httr</strong>软件包中的<a href="https://httr.r-lib.org/articles/api-packages.html"><code>best-practices-api-packages</code></a>文章）。</p>
<p>有许多请求可以发送到OWS服务。其中一个最基本的请求是<code>getCapabilities</code>，下面使用<strong>httr</strong>函数<code>GET()</code>和<code>modify_url()</code>演示了这个请求。下面的代码块演示了如何构建和发送查询，本例中是为了发现由联合国粮食及农业组织（FAO）运行的服务的功能：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>httr<span class="punctuation">)</span></span><br><span class="line">base_url <span class="operator">=</span> <span class="string">&quot;http://www.fao.org&quot;</span></span><br><span class="line">endpoint <span class="operator">=</span> <span class="string">&quot;/figis/geoserver/wfs&quot;</span></span><br><span class="line">q <span class="operator">=</span> <span class="built_in">list</span><span class="punctuation">(</span>request <span class="operator">=</span> <span class="string">&quot;GetCapabilities&quot;</span><span class="punctuation">)</span></span><br><span class="line">res <span class="operator">=</span> GET<span class="punctuation">(</span>url <span class="operator">=</span> modify_url<span class="punctuation">(</span>base_url<span class="punctuation">,</span> path <span class="operator">=</span> endpoint<span class="punctuation">)</span><span class="punctuation">,</span> query <span class="operator">=</span> q<span class="punctuation">)</span></span><br><span class="line">res<span class="operator">$</span>url</span><br><span class="line"><span class="comment">#&gt; [1] &quot;https://www.fao.org/figis/geoserver/wfs?request=GetCapabilities&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面的代码块演示了如何使用<code>GET()</code>函数以编程方式构建API请求，该函数接受基本URL和查询参数列表，可以轻松扩展。请求的结果保存在<code>res</code>中，它是<strong>httr</strong>包中定义的<code>response</code>类的对象，是一个包含请求信息的列表，包括URL。通过执行<code>browseURL(res$url)</code>可以看到，结果也可以直接在浏览器中查看。提取请求内容的一种方式如下：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">txt <span class="operator">=</span> content<span class="punctuation">(</span>res<span class="punctuation">,</span> <span class="string">&quot;text&quot;</span><span class="punctuation">)</span></span><br><span class="line">xml <span class="operator">=</span> xml2<span class="operator">::</span>read_xml<span class="punctuation">(</span>txt<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">xml</span><br><span class="line"><span class="comment">#&gt; &#123;xml_document&#125; ...</span></span><br><span class="line"><span class="comment">#&gt; [1] &lt;ows:ServiceIdentification&gt;\n  &lt;ows:Title&gt;GeoServer WFS...</span></span><br><span class="line"><span class="comment">#&gt; [2] &lt;ows:ServiceProvider&gt;\n  &lt;ows:ProviderName&gt;UN-FAO Fishe...</span></span><br><span class="line"><span class="comment">#&gt; ...</span></span><br></pre></td></tr></table></figure>
<p>可以使用<code>GetFeature</code>请求和特定的<code>typeName</code>从WFS服务中下载数据（如下面的代码块所示）。</p>
<p>可用的名称取决于所访问的Web要素服务。可以使用Web技术以编程方式提取它们，也可以在浏览器中手动滚动浏览<code>GetCapabilities</code>输出的内容。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">qf <span class="operator">=</span> <span class="built_in">list</span><span class="punctuation">(</span>request <span class="operator">=</span> <span class="string">&quot;GetFeature&quot;</span><span class="punctuation">,</span> typeName <span class="operator">=</span> <span class="string">&quot;area:FAO_AREAS&quot;</span><span class="punctuation">)</span></span><br><span class="line">file <span class="operator">=</span> tempfile<span class="punctuation">(</span>fileext <span class="operator">=</span> <span class="string">&quot;.gml&quot;</span><span class="punctuation">)</span></span><br><span class="line">GET<span class="punctuation">(</span>url <span class="operator">=</span> base_url<span class="punctuation">,</span> path <span class="operator">=</span> endpoint<span class="punctuation">,</span> query <span class="operator">=</span> qf<span class="punctuation">,</span> write_disk<span class="punctuation">(</span>file<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">fao_areas <span class="operator">=</span> read_sf<span class="punctuation">(</span>file<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>请注意使用<code>write_disk()</code>来确保结果被写入磁盘而不是加载到内存中，从而可以使用<strong>sf</strong>导入这些数据。这个示例展示了如何使用<strong>httr</strong>获得对Web服务的底层访问权限，这对于理解Web服务的工作原理可能很有用。然而，对于许多日常任务来说，更高级的接口可能更合适，为此目的已经开发了许多R包和教程。<strong>ows4R</strong>包就是专门用于处理OWS服务的。</p>
<h1>文件形式</h1>
<p>地理数据集通常存储为文件或空间数据库中。文件格式可以存储矢量数据或栅格数据，而空间数据库如<a href="https://postgis.net/">PostGIS</a>可以同时存储两种类型的数据。如今，各种文件格式可能令人困惑，但自从20世纪60年代开始使用GIS软件（当时第一个广泛分发的空间分析程序<a href="https://news.harvard.edu/gazette/story/2011/10/the-invention-of-gis/">SYMAP</a>在哈佛大学创建）以来，已经进行了许多整合和标准化。</p>
<p>GDAL（应该发音为“goo-dal”，其中双“o”是对面向对象的引用），即地理数据抽象库，自2000年发布以来已经解决了许多与地理文件格式不兼容相关的问题。GDAL提供了一个统一且高性能的接口，用于读取和写入许多栅格和矢量数据格式。[^08-read-write-plot-4] 许多开放和专有的GIS程序，包括GRASS、ArcGIS和QGIS，在其图形用户界面后面使用GDAL来进行摄取和输出地理数据的相关格式。</p>
<p>[^08-read-write-plot-4]：正如我们在<em>几何操作</em>章中提到的，GDAL还包含一组实用函数，可以进行栅格镶嵌、重采样、裁剪、重投影等操作。</p>
<p>GDAL提供对200多种矢量和栅格数据格式的访问。下表呈现了一些常用的空间文件格式的基本信息。</p>
<table>
<caption>(\#tab:formats)Selected spatial file formats.</caption>
 <thead>
  <tr>
   <th style="text-align:left;"> Name </th>
   <th style="text-align:left;"> Extension </th>
   <th style="text-align:left;"> Info </th>
   <th style="text-align:left;"> Type </th>
   <th style="text-align:left;"> Model </th>
  </tr>
 </thead>
<tbody>
  <tr>
   <td style="text-align:left;"> ESRI Shapefile </td>
   <td style="text-align:left;width: 7em; "> .shp (the main file) </td>
   <td style="text-align:left;width: 14em; "> Popular format consisting of at least three files. No support for: files &gt; 2GB;  mixed types; names &gt; 10 chars; cols &gt; 255. </td>
   <td style="text-align:left;"> Vector </td>
   <td style="text-align:left;width: 7em; "> Partially open </td>
  </tr>
  <tr>
   <td style="text-align:left;"> GeoJSON </td>
   <td style="text-align:left;width: 7em; "> .geojson </td>
   <td style="text-align:left;width: 14em; "> Extends the JSON exchange format by including a subset of the simple feature representation; mostly used for storing coordinates in longitude and latitude; it is extended by the TopoJSON format </td>
   <td style="text-align:left;"> Vector </td>
   <td style="text-align:left;width: 7em; "> Open </td>
  </tr>
  <tr>
   <td style="text-align:left;"> KML </td>
   <td style="text-align:left;width: 7em; "> .kml </td>
   <td style="text-align:left;width: 14em; "> XML-based format for spatial visualization, developed for use with Google Earth. Zipped KML file forms the KMZ format. </td>
   <td style="text-align:left;"> Vector </td>
   <td style="text-align:left;width: 7em; "> Open </td>
  </tr>
  <tr>
   <td style="text-align:left;"> GPX </td>
   <td style="text-align:left;width: 7em; "> .gpx </td>
   <td style="text-align:left;width: 14em; "> XML schema created for exchange of GPS data. </td>
   <td style="text-align:left;"> Vector </td>
   <td style="text-align:left;width: 7em; "> Open </td>
  </tr>
  <tr>
   <td style="text-align:left;"> FlatGeobuf </td>
   <td style="text-align:left;width: 7em; "> .fgb </td>
   <td style="text-align:left;width: 14em; "> Single file format allowing for quick reading and writing of vector data. Has streaming capabilities. </td>
   <td style="text-align:left;"> Vector </td>
   <td style="text-align:left;width: 7em; "> Open </td>
  </tr>
  <tr>
   <td style="text-align:left;"> GeoTIFF </td>
   <td style="text-align:left;width: 7em; "> .tif/.tiff </td>
   <td style="text-align:left;width: 14em; "> Popular raster format. A TIFF file containing additional spatial metadata. </td>
   <td style="text-align:left;"> Raster </td>
   <td style="text-align:left;width: 7em; "> Open </td>
  </tr>
  <tr>
   <td style="text-align:left;"> Arc ASCII </td>
   <td style="text-align:left;width: 7em; "> .asc </td>
   <td style="text-align:left;width: 14em; "> Text format where the first six lines represent the raster header, followed by the raster cell values arranged in rows and columns. </td>
   <td style="text-align:left;"> Raster </td>
   <td style="text-align:left;width: 7em; "> Open </td>
  </tr>
  <tr>
   <td style="text-align:left;"> SQLite/SpatiaLite </td>
   <td style="text-align:left;width: 7em; "> .sqlite </td>
   <td style="text-align:left;width: 14em; "> Standalone  relational database, SpatiaLite is the spatial extension of SQLite. </td>
   <td style="text-align:left;"> Vector and raster </td>
   <td style="text-align:left;width: 7em; "> Open </td>
  </tr>
  <tr>
   <td style="text-align:left;"> ESRI FileGDB </td>
   <td style="text-align:left;width: 7em; "> .gdb </td>
   <td style="text-align:left;width: 14em; "> Spatial and nonspatial objects created by ArcGIS. Allows: multiple feature classes; topology. Limited support from GDAL. </td>
   <td style="text-align:left;"> Vector and raster </td>
   <td style="text-align:left;width: 7em; "> Proprietary </td>
  </tr>
  <tr>
   <td style="text-align:left;"> GeoPackage </td>
   <td style="text-align:left;width: 7em; "> .gpkg </td>
   <td style="text-align:left;width: 14em; "> Lightweight database container based on SQLite allowing an easy and platform-independent exchange of geodata </td>
   <td style="text-align:left;"> Vector and (very limited) raster </td>
   <td style="text-align:left;width: 7em; "> Open </td>
  </tr>
</tbody>
</table>
<p>一个重要的发展是为了标准化和开源文件格式，即1994年成立了开放地理空间联盟（<a href="http://www.opengeospatial.org/">OGC</a>）。除了定义简单要素数据模型，OGC还协调开发开放标准，例如在文件格式中使用的KML和GeoPackage。OGC认可的开放文件格式相对于专有格式具有几个优势：标准是公开的，确保透明性，并为用户提供了进一步开发和调整文件格式以适应其特定需求的可能性。</p>
<p>ESRI Shapefile是最流行的矢量数据交换格式；然而，它不是开放格式（尽管其规范是公开的）。它在1990年代初开发，并具有许多限制。首先，它是一个多文件格式，至少由三个文件组成。它只支持255列，列名限制为十个字符，文件大小限制为 2 GB。此外，ESRI Shapefile不支持所有可能的几何类型，例如，它无法区分多边形和多部分多边形。[^08-read-write-plot-5] 尽管存在这些限制，长时间以来都缺乏一个可行的替代方案。与此同时，<a href="https://www.geopackage.org/">GeoPackage</a>出现了，似乎是ESRI Shapefile的一个更适合的替代候选。GeoPackage是一种用于交换地理空间信息的格式，也是OGC的标准。GeoPackage标准描述了如何在一个小型SQLite容器中存储地理空间信息的规则。因此，GeoPackage是一个轻量级的空间数据库容器，允许存储矢量和栅格数据，还可以存储非空间数据和扩展。除了GeoPackage，还有其他值得查看的地理空间数据交换格式。</p>
<p>GeoTIFF格式似乎是最显著的栅格数据格式。它允许将空间信息（如CRS）嵌入到TIFF文件中。与ESRI Shapefile类似，这个格式最早于1990年代开发，但作为开放格式。此外，GeoTIFF仍在不断扩展和改进。最近对GeoTIFF格式的最重要的一个新增是其称为<a href="https://www.cogeo.org/">COG</a>（<em>云优化的GeoTIFF</em>）的变体。以COG形式保存的栅格对象可以托管在HTTP服务器上，因此其他人可以仅读取文件的部分内容，而无需下载整个文件。</p>
<p>还有许多其他的空间数据格式，由于书的篇幅限制，我们没有详细解释或在表@ref(tab:formats)中提及。此外，新的空间数据格式正在开发中（例如，<a href="https://geoparquet.org/">GeoParquet</a>和<a href="https://zarr.dev/">Zarr</a>），并且现有的格式也在不断改进。如果您想了解更多关于其他格式的信息，我们建议您阅读GDAL关于<a href="https://gdal.org/drivers/vector/index.html">矢量</a>和<a href="https://gdal.org/drivers/raster/index.html">栅格</a>驱动程序的文档。此外，一些空间数据格式可以存储除矢量或栅格外的其他数据模型（类型）。这包括用于存储激光雷达点云的LAS和LAZ格式，以及用于存储多维数组的NetCDF和HDF格式。</p>
<p>空间数据通常也可以使用表格（非空间）文本格式进行存储，包括CSV文件或Excel电子表格。例如，这可以方便地与不使用GIS工具的人共享空间样本，或者与不接受空间数据格式的其他软件交换数据。然而，这种方法可能存在几个问题——对于存储比点更复杂的几何形状来说相当具有挑战性，并且不直接存储有关CRS的信息。</p>
<h1>数据输入 (I)</h1>
<p>执行诸如<code>sf::read_sf()</code>（我们用于加载矢量数据的主要函数）或<code>terra::rast()</code>（用于加载栅格数据的主要函数）等命令会悄无声息地触发一系列事件，从文件中读取数据。此外，有许多R包包含着各种各样的地理数据，或者提供了对不同数据源的简单访问。它们都会将数据加载到R中，更准确地说，将对象分配给存储在RAM中、从R会话的<a href="http://adv-r.had.co.nz/Environments.html"><code>.GlobalEnv</code></a>中访问的工作空间中。</p>
<h2 id="矢量数据">矢量数据</h2>
<p>空间矢量数据有多种文件格式。最常见的表示形式，如<code>.geojson</code>和<code>.gpkg</code>文件，可以直接使用<strong>sf</strong>函数<code>read_sf()</code>（或等效的<code>st_read()</code>）导入到R中，它在幕后使用了<a href="https://gdal.org/drivers/vector/index.html">GDAL的矢量驱动程序</a>。<code>st_drivers()</code>函数返回一个数据框，其中包含前两列的<code>name</code>和<code>long_name</code>，以及每个驱动程序的特性，这些特性对于GDAL（因此也对于<strong>sf</strong>）可用，包括写入数据的能力和在随后的列中存储栅格数据的能力，正如表@ref(tab:drivers)中对关键文件格式所示。以下命令显示了计算机GDAL安装中报告的前三个驱动程序（结果可能因安装的GDAL版本而异）以及它们特性的摘要。请注意，大多数驱动程序都可以写入数据（87个驱动程序中的51个），而仅有16种格式可以有效地表示栅格数据以及矢量数据（详细信息请参见<code>?st_drivers()</code>）：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">sf_drivers <span class="operator">=</span> st_drivers<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line">head<span class="punctuation">(</span>sf_drivers<span class="punctuation">,</span> n <span class="operator">=</span> <span class="number">3</span><span class="punctuation">)</span></span><br><span class="line">summary<span class="punctuation">(</span>sf_drivers<span class="punctuation">[</span><span class="operator">-</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="operator">:</span><span class="number">2</span><span class="punctuation">)</span><span class="punctuation">]</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<table>
<caption>(\#tab:drivers)Popular drivers/formats for reading/writing vector data.</caption>
 <thead>
  <tr>
   <th style="text-align:left;"> name </th>
   <th style="text-align:left;"> long_name </th>
   <th style="text-align:left;"> write </th>
   <th style="text-align:left;"> copy </th>
   <th style="text-align:left;"> is_raster </th>
   <th style="text-align:left;"> is_vector </th>
   <th style="text-align:left;"> vsi </th>
  </tr>
 </thead>
<tbody>
  <tr>
   <td style="text-align:left;"> ESRI Shapefile </td>
   <td style="text-align:left;width: 7em; "> ESRI Shapefile </td>
   <td style="text-align:left;"> TRUE </td>
   <td style="text-align:left;"> FALSE </td>
   <td style="text-align:left;"> FALSE </td>
   <td style="text-align:left;"> TRUE </td>
   <td style="text-align:left;"> TRUE </td>
  </tr>
  <tr>
   <td style="text-align:left;"> GPX </td>
   <td style="text-align:left;width: 7em; "> GPX </td>
   <td style="text-align:left;"> TRUE </td>
   <td style="text-align:left;"> FALSE </td>
   <td style="text-align:left;"> FALSE </td>
   <td style="text-align:left;"> TRUE </td>
   <td style="text-align:left;"> TRUE </td>
  </tr>
  <tr>
   <td style="text-align:left;"> KML </td>
   <td style="text-align:left;width: 7em; "> Keyhole Markup Language (KML) </td>
   <td style="text-align:left;"> TRUE </td>
   <td style="text-align:left;"> FALSE </td>
   <td style="text-align:left;"> FALSE </td>
   <td style="text-align:left;"> TRUE </td>
   <td style="text-align:left;"> TRUE </td>
  </tr>
  <tr>
   <td style="text-align:left;"> GeoJSON </td>
   <td style="text-align:left;width: 7em; "> GeoJSON </td>
   <td style="text-align:left;"> TRUE </td>
   <td style="text-align:left;"> FALSE </td>
   <td style="text-align:left;"> FALSE </td>
   <td style="text-align:left;"> TRUE </td>
   <td style="text-align:left;"> TRUE </td>
  </tr>
  <tr>
   <td style="text-align:left;"> GPKG </td>
   <td style="text-align:left;width: 7em; "> GeoPackage </td>
   <td style="text-align:left;"> TRUE </td>
   <td style="text-align:left;"> TRUE </td>
   <td style="text-align:left;"> TRUE </td>
   <td style="text-align:left;"> TRUE </td>
   <td style="text-align:left;"> TRUE </td>
  </tr>
  <tr>
   <td style="text-align:left;"> FlatGeobuf </td>
   <td style="text-align:left;width: 7em; "> FlatGeobuf </td>
   <td style="text-align:left;"> TRUE </td>
   <td style="text-align:left;"> FALSE </td>
   <td style="text-align:left;"> FALSE </td>
   <td style="text-align:left;"> TRUE </td>
   <td style="text-align:left;"> TRUE </td>
  </tr>
</tbody>
</table>
<p><code>read_sf()</code>的第一个参数是<code>dsn</code>，它应该是一个文本字符串或一个包含单个文本字符串的对象。文本字符串的内容在不同的驱动程序之间可能会有所不同。在大多数情况下，例如ESRI Shapefile（<code>.shp</code>）或<code>GeoPackage</code>格式（<code>.gpkg</code>），<code>dsn</code>将是一个文件名。<code>read_sf()</code>会根据文件扩展名猜测驱动程序，正如下面的示例中展示的针对<code>.gpkg</code>文件：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">f <span class="operator">=</span> system.file<span class="punctuation">(</span><span class="string">&quot;shapes/world.gpkg&quot;</span><span class="punctuation">,</span> package <span class="operator">=</span> <span class="string">&quot;spData&quot;</span><span class="punctuation">)</span></span><br><span class="line">world <span class="operator">=</span> read_sf<span class="punctuation">(</span>f<span class="punctuation">,</span> quiet <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>对于某些驱动程序，<code>dsn</code>可以提供为文件夹名称、数据库的访问凭据或GeoJSON字符串表示形式（有关更多详细信息，请参见<code>read_sf()</code>帮助页面的示例）。</p>
<p>一些矢量驱动程序格式可以存储多个数据图层。默认情况下，<code>read_sf()</code>会自动读取在<code>dsn</code>中指定的文件的第一个图层；但是，您可以使用<code>layer</code>参数来指定任何其他图层。</p>
<p><code>read_sf()</code>函数还允许使用两种可能的机制将文件的部分内容读入RAM。第一个与<code>query</code>参数相关，它允许使用<a href="https://gdal.org/user/ogr_sql_dialect.html">OGR SQL查询文本</a>指定要读取的数据部分。下面的示例从中提取了仅有坦桑尼亚的数据（图@ref(fig:readsfquery)：A）。通过指定我们要从<code>&quot;world&quot;</code>图层中选择所有列（<code>SELECT *</code>），其中<code>name_long</code>等于<code>&quot;Tanzania&quot;</code>：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">tanzania <span class="operator">=</span> read_sf<span class="punctuation">(</span>f<span class="punctuation">,</span> query <span class="operator">=</span> <span class="string">&#x27;SELECT * FROM world WHERE name_long = &quot;Tanzania&quot;&#x27;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>如果您不知道可用列的名称，一个好的方法是仅读取数据的一行，可以使用<code>'SELECT * FROM world WHERE FID = 1'</code>。<code>FID</code>代表<em>要素ID</em> - 大多数情况下，它是行号；但是，其值取决于使用的文件格式。例如，在ESRI Shapefile中，<code>FID</code>从0开始，在其他一些文件格式中从1开始，甚至可以是任意值。</p>
<p>第二种机制使用<code>wkt_filter</code>参数。此参数需要一个表示我们要提取数据的研究区域的well-known text。让我们尝试一个小例子 - 我们希望从文件中读取与坦桑尼亚边界50,000米缓冲区相交的多边形。为了实现这一点，我们需要通过（a）创建缓冲区，（b）使用<code>st_geometry()</code>将<code>sf</code>缓冲区对象转换为<code>sfc</code>几何对象，以及（c）使用<code>st_as_text()</code>将几何对象转化为其well-known text表示形式来准备我们的&quot;过滤器&quot;：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">tanzania_buf <span class="operator">=</span> st_buffer<span class="punctuation">(</span>tanzania<span class="punctuation">,</span> <span class="number">50000</span><span class="punctuation">)</span></span><br><span class="line">tanzania_buf_geom <span class="operator">=</span> st_geometry<span class="punctuation">(</span>tanzania_buf<span class="punctuation">)</span></span><br><span class="line">tanzania_buf_wkt <span class="operator">=</span> st_as_text<span class="punctuation">(</span>tanzania_buf_geom<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>现在，我们可以使用<code>wkt_filter</code>参数应用这个&quot;过滤器&quot;：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">tanzania_neigh <span class="operator">=</span> read_sf<span class="punctuation">(</span>f<span class="punctuation">,</span> wkt_filter <span class="operator">=</span> tanzania_buf_wkt<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>我们的结果如图：B所示，包含了坦桑尼亚以及其50公里缓冲区内的每个国家。</p>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309031723273.png" alt=""><br>
Reading a subset of the vector data using a query (A) and a wkt filter (B).</p>
<p>当然，某些选项是特定于某些驱动程序的<a href="%E6%9C%89%E5%85%B3%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF%EF%BC%8C%E8%AF%B7%E5%8F%82%E9%98%85%E6%BA%90%E6%96%87%E7%8C%AE%E4%B8%AD%E7%9A%84%E7%AC%AC8%E7%AB%A0%E3%80%82">^08-read-write-plot-6</a>。例如，考虑坐标存储在电子表格格式（<code>.csv</code>）中的情况。要将此类文件读取为空间对象，我们自然必须指定表示坐标的列名（在下面的示例中为<code>X</code>和<code>Y</code>）。我们可以使用<code>options</code>参数来实现这一点。要了解可能的选项，请参阅相应的GDAL驱动程序描述的’Open Options’部分。对于逗号分隔值（csv）格式，请访问<a href="http://www.gdal.org/drv_csv.html">http://www.gdal.org/drv_csv.html</a>。</p>
<p><a href="%E6%9C%89%E5%85%B3%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF%EF%BC%8C%E8%AF%B7%E5%8F%82%E9%98%85%E6%BA%90%E6%96%87%E7%8C%AE%E4%B8%AD%E7%9A%84%E7%AC%AC8%E7%AB%A0%E3%80%82">^08-read-write-plot-6</a>:可以在以下链接找到支持的矢量格式和选项列表： <a href="http://gdal.org/ogr_formats.html">http://gdal.org/ogr_formats.html</a>.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">cycle_hire_txt <span class="operator">=</span> system.file<span class="punctuation">(</span><span class="string">&quot;misc/cycle_hire_xy.csv&quot;</span><span class="punctuation">,</span> package <span class="operator">=</span> <span class="string">&quot;spData&quot;</span><span class="punctuation">)</span></span><br><span class="line">cycle_hire_xy <span class="operator">=</span> read_sf<span class="punctuation">(</span>cycle_hire_txt<span class="punctuation">,</span></span><br><span class="line">  options <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;X_POSSIBLE_NAMES=X&quot;</span><span class="punctuation">,</span> <span class="string">&quot;Y_POSSIBLE_NAMES=Y&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>除了描述’XY’坐标的列外，单个列还可以包含几何信息。Well-known text (WKT)、well-known binary (WKB)和GeoJSON格式就是这种情况的示例。例如，<code>world_wkt.csv</code>文件有一个名为<code>WKT</code>的列，表示世界各国的多边形。我们将再次使用<code>options</code>参数来指示这一点。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">world_txt <span class="operator">=</span> system.file<span class="punctuation">(</span><span class="string">&quot;misc/world_wkt.csv&quot;</span><span class="punctuation">,</span> package <span class="operator">=</span> <span class="string">&quot;spData&quot;</span><span class="punctuation">)</span></span><br><span class="line">world_wkt <span class="operator">=</span> read_sf<span class="punctuation">(</span>world_txt<span class="punctuation">,</span> options <span class="operator">=</span> <span class="string">&quot;GEOM_POSSIBLE_NAMES=WKT&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># the same as</span></span><br><span class="line">world_wkt2 <span class="operator">=</span> st_read<span class="punctuation">(</span>world_txt<span class="punctuation">,</span> options <span class="operator">=</span> <span class="string">&quot;GEOM_POSSIBLE_NAMES=WKT&quot;</span><span class="punctuation">,</span> </span><br><span class="line">                    quiet <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> stringsAsFactors <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">,</span> as_tibble <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>📌并非所有支持的矢量文件格式都存储有关其坐标参考系统的信息。在这些情况下，可以使用<code>st_set_crs()</code>函数添加缺失的信息。</p>
</blockquote>
<p>作为最后一个示例，我们将展示<code>read_sf()</code>如何读取 KML 文件。KML 文件以 XML 格式存储地理信息——这是一种用于创建网页和以应用程序无关的方式传输数据的数据格式。在这里，我们访问来自网络的KML文件。该文件包含多个图层。<code>st_layers()</code>列出了所有可用的图层。我们选择第一个图层<code>Placemarks</code>，并通过<code>read_sf()</code>中的<code>layer</code>参数来指定：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">u <span class="operator">=</span> <span class="string">&quot;https://developers.google.com/kml/documentation/KML_Samples.kml&quot;</span></span><br><span class="line">download.file<span class="punctuation">(</span>u<span class="punctuation">,</span> <span class="string">&quot;KML_Samples.kml&quot;</span><span class="punctuation">)</span></span><br><span class="line">st_layers<span class="punctuation">(</span><span class="string">&quot;KML_Samples.kml&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; Driver: KML </span></span><br><span class="line"><span class="comment">#&gt; Available layers:</span></span><br><span class="line"><span class="comment">#&gt;              layer_name  geometry_type features fields crs_name</span></span><br><span class="line"><span class="comment">#&gt; 1            Placemarks       3D Point        3      2   WGS 84</span></span><br><span class="line"><span class="comment">#&gt; 2      Highlighted Icon       3D Point        1      2   WGS 84</span></span><br><span class="line"><span class="comment">#&gt; 3                 Paths 3D Line String        6      2   WGS 84</span></span><br><span class="line"><span class="comment">#&gt; 4         Google Campus     3D Polygon        4      2   WGS 84</span></span><br><span class="line"><span class="comment">#&gt; 5      Extruded Polygon     3D Polygon        1      2   WGS 84</span></span><br><span class="line"><span class="comment">#&gt; 6 Absolute and Relative     3D Polygon        4      2   WGS 84</span></span><br><span class="line">kml <span class="operator">=</span> read_sf<span class="punctuation">(</span><span class="string">&quot;KML_Samples.kml&quot;</span><span class="punctuation">,</span> layer <span class="operator">=</span> <span class="string">&quot;Placemarks&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>到目前为止，本节中所示的所有示例都使用了<strong>sf</strong>包进行地理数据导入。它快速且灵活，但值得看看其他特定文件格式的包。一个例子是<strong>geojsonsf</strong>包。一个<a href="https://github.com/ATFutures/geobench">基准测试</a>表明，相对于读取<code>.geojson</code>文件，它的速度约快于<strong>sf</strong>包的10倍。</p>
<h2 id="栅格数据">栅格数据</h2>
<p>与矢量数据类似，栅格数据也有许多文件格式，其中一些支持多层文件。<strong>terra</strong>的<code>rast()</code>命令在提供仅有一层的文件时读取单个图层。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">raster_filepath <span class="operator">=</span> system.file<span class="punctuation">(</span><span class="string">&quot;raster/srtm.tif&quot;</span><span class="punctuation">,</span> package <span class="operator">=</span> <span class="string">&quot;spDataLarge&quot;</span><span class="punctuation">)</span></span><br><span class="line">single_layer <span class="operator">=</span> rast<span class="punctuation">(</span>raster_filepath<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>它也适用于您想读取多层文件的情况。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">multilayer_filepath <span class="operator">=</span> system.file<span class="punctuation">(</span><span class="string">&quot;raster/landsat.tif&quot;</span><span class="punctuation">,</span> package <span class="operator">=</span> <span class="string">&quot;spDataLarge&quot;</span><span class="punctuation">)</span></span><br><span class="line">multilayer_rast <span class="operator">=</span> rast<span class="punctuation">(</span>multilayer_filepath<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>之前的所有示例都是从存储在硬盘上的文件中读取空间信息。然而，GDAL 还允许直接从在线资源读取数据，如HTTP/HTTPS/FTP网络资源。我们需要做的唯一的事情就是在文件路径之前添加<code>/vsicurl/</code>前缀。让我们尝试连接到全球2000-2012年间500米分辨率的每月降雪概率数据。12月份的降雪概率以Cloud Optimized GeoTIFF (COG)文件的形式存储在以下网址中：\url{<a href="https://zenodo.org/record/5774954/files/clm_snow.prob_esacci.dec_p.90_500m_s0..0cm_2000..2012_v2.0.tif">https://zenodo.org/record/5774954/files/clm_snow.prob_esacci.dec_p.90_500m_s0..0cm_2000..2012_v2.0.tif</a>}。要读取在线文件，我们只需提供其URL，同时加上<code>/vsicurl/</code>前缀。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">myurl <span class="operator">=</span> <span class="string">&quot;/vsicurl/https://zenodo.org/record/5774954/files/clm_snow.prob_esacci.dec_p.90_500m_s0..0cm_2000..2012_v2.0.tif&quot;</span></span><br><span class="line">snow <span class="operator">=</span> rast<span class="punctuation">(</span>myurl<span class="punctuation">)</span></span><br><span class="line">snow</span><br><span class="line"><span class="comment">#&gt; class       : SpatRaster </span></span><br><span class="line"><span class="comment">#&gt; dimensions  : 35849, 86400, 1  (nrow, ncol, nlyr)</span></span><br><span class="line"><span class="comment">#&gt; resolution  : 0.00417, 0.00417  (x, y)</span></span><br><span class="line"><span class="comment">#&gt; extent      : -180, 180, -62, 87.4  (xmin, xmax, ymin, ymax)</span></span><br><span class="line"><span class="comment">#&gt; coord. ref. : lon/lat WGS 84 (EPSG:4326) </span></span><br><span class="line"><span class="comment">#&gt; source      : clm_snow.prob_esacci.dec_p.90_500m_s0..0cm_2000..2012_v2.0.tif </span></span><br><span class="line"><span class="comment">#&gt; name        : clm_snow.prob_esacci.dec_p.90_500m_s0..0cm_2000..2012_v2.0</span></span><br></pre></td></tr></table></figure>
<p>由于输入数据是COG，实际上我们并没有将这个文件读入到我们的内存中，而是创建了一个连接，没有获取任何值。只有在应用任何基于值的操作（如<code>crop()</code>或<code>extract()</code>）时才会读取其值。这也使我们能够只读取数据的一小部分，而无需下载整个文件。例如，我们可以通过指定其坐标并应用<code>extract()</code>函数来获取雷克雅未克（Reykjavik）12月份的降雪概率（70%）：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">rey <span class="operator">=</span> data.frame<span class="punctuation">(</span>lon <span class="operator">=</span> <span class="operator">-</span><span class="number">21.94</span><span class="punctuation">,</span> lat <span class="operator">=</span> <span class="number">64.15</span><span class="punctuation">)</span></span><br><span class="line">snow_rey <span class="operator">=</span> extract<span class="punctuation">(</span>snow<span class="punctuation">,</span> rey<span class="punctuation">)</span></span><br><span class="line">snow_rey</span><br><span class="line"><span class="comment">#&gt;   ID clm_snow.prob_esacci.dec_p.90_500m_s0..0cm_2000..2012_v2.0</span></span><br><span class="line"><span class="comment">#&gt; 1  1                                                         70</span></span><br></pre></td></tr></table></figure>
<p>通过这种方式，我们只下载了一个值，而不是整个庞大的GeoTIFF文件。</p>
<p>上面的例子只展示了一个简单（但有用）的情况，但还有更多可以探索的内容。<code>/vsicurl/</code>前缀不仅适用于栅格数据，还适用于矢量文件格式。只需在矢量文件的URL前添加该前缀，就可以直接从在线存储中使用<code>read_sf()</code>函数读取矢量。</p>
<p>值得注意的是，<code>/vsicurl/</code>并不是GDAL提供的唯一前缀，还有许多其他前缀，例如<code>/vsizip/</code>用于在不预先解压缩的情况下从ZIP归档中读取空间文件，或者<code>/vsis3/</code>用于即时读取在AWS S3存储桶中可用的文件。您可以在<a href="https://gdal.org/user/virtual_file_systems.html">https://gdal.org/user/virtual_file_systems.html</a>上了解更多信息。</p>
<!-- ### Databases -->
<!-- jn:toDo-->
<!-- postgis input example -->
<h1>数据输出 (O)</h1>
<p>写入地理数据可以将数据从一种格式转换为另一种格式，并保存新创建的对象。根据数据类型（矢量或栅格）、对象类别（例如<code>sf</code>或<code>SpatRaster</code>）以及存储信息的类型和数量（例如对象大小、值范围），了解如何以最高效的方式存储空间文件非常重要。接下来的两个章节将演示如何实现这一点。</p>
<h2 id="矢量数据-2">矢量数据</h2>
<p><code>write_sf()</code>是<code>read_sf()</code>的对应函数。它允许你将<strong>sf</strong>对象写入各种地理矢量文件格式，包括最常见的格式，如<code>.geojson</code>、<code>.shp</code> 和 <code>.gpkg</code>。根据文件名，<code>write_sf()</code>会自动决定使用哪个驱动程序。写入过程的速度也取决于驱动程序的性能。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">write_sf<span class="punctuation">(</span>obj <span class="operator">=</span> world<span class="punctuation">,</span> dsn <span class="operator">=</span> <span class="string">&quot;world.gpkg&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：如果你尝试再次写入相同的数据源，该函数会覆盖文件：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">write_sf<span class="punctuation">(</span>obj <span class="operator">=</span> world<span class="punctuation">,</span> dsn <span class="operator">=</span> <span class="string">&quot;world.gpkg&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>与覆盖文件不同，我们可以使用<code>append = TRUE</code>将新图层添加到文件中，这在几种空间格式中都受到支持，包括GeoPackage。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">write_sf<span class="punctuation">(</span>obj <span class="operator">=</span> world<span class="punctuation">,</span> dsn <span class="operator">=</span> <span class="string">&quot;world_many_layers.gpkg&quot;</span><span class="punctuation">,</span> append <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>另一种选择是使用<code>st_write()</code>，因为它与<code>write_sf()</code>等效。然而，它有不同的默认设置——它不会覆盖文件（在尝试这样做时会返回错误），并显示所写文件格式和对象的简要摘要。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">st_write<span class="punctuation">(</span>obj <span class="operator">=</span> world<span class="punctuation">,</span> dsn <span class="operator">=</span> <span class="string">&quot;world2.gpkg&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; Writing layer `world2&#x27; to data source `world2.gpkg&#x27; using driver `GPKG&#x27;</span></span><br><span class="line"><span class="comment">#&gt; Writing 177 features with 10 fields and geometry type Multi Polygon.</span></span><br></pre></td></tr></table></figure>
<p><code>layer_options</code>参数可以用于许多不同的目的。其中之一是将空间数据写入文本文件。这可以通过在<code>layer_options</code>中指定<code>GEOMETRY</code>来实现。对于简单的点数据集，可以使用<code>AS_XY</code>（它会创建两列新列来存储坐标），或者对于更复杂的空间数据，可以使用<code>AS_WKT</code>（它会创建一个新列，其中包含空间对象的Well-Known Text表示）。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">write_sf<span class="punctuation">(</span>cycle_hire_xy<span class="punctuation">,</span> <span class="string">&quot;cycle_hire_xy.csv&quot;</span><span class="punctuation">,</span> layer_options <span class="operator">=</span> <span class="string">&quot;GEOMETRY=AS_XY&quot;</span><span class="punctuation">)</span></span><br><span class="line">write_sf<span class="punctuation">(</span>world_wkt<span class="punctuation">,</span> <span class="string">&quot;world_wkt.csv&quot;</span><span class="punctuation">,</span> layer_options <span class="operator">=</span> <span class="string">&quot;GEOMETRY=AS_WKT&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<h2 id="栅格数据-2">栅格数据</h2>
<p><code>writeRaster()</code>函数用于将<code>SpatRaster</code> 对象保存到磁盘文件中。该函数需要输入有关输出数据类型和文件格式的信息，同时还接受特定于所选文件格式的GDAL选项（请参阅 <code>?writeRaster</code> 获取更多详细信息）。</p>
<p><strong>terra</strong>包在保存栅格数据时提供了七种数据类型：INT1U、INT2S、INT2U、INT4S、INT4U、FLT4S 和 FLT8S。[^08-read-write-plot-7] 数据类型决定了写入磁盘的栅格对象的位表示。要选择使用哪种数据类型取决于栅格对象的值范围。数据类型能够表示的值越多，文件在磁盘上占用的空间就越大。无符号整数（INT1U、INT2U、INT4U）适用于分类数据，而浮点数（FLT4S 和 FLT8S）通常用于表示连续数据。<code>writeRaster()</code> 默认使用 FLT4S。虽然这在大多数情况下是有效的，但如果要保存二进制或分类数据，输出文件的大小将变得不必要地大。因此，我们建议选择占用存储空间最少的数据类型，但仍能表示所有值（请使用 <code>summary()</code> 函数检查值范围）。</p>
<p>[^08-read-write-plot-7]:  不推荐使用 INT4U，因为 R 不支持32位无符号整数。</p>
<table>
<caption>(\#tab:datatypes)Data types supported by the terra package.</caption>
 <thead>
  <tr>
   <th style="text-align:left;"> Data type </th>
   <th style="text-align:left;"> Minimum value </th>
   <th style="text-align:left;"> Maximum value </th>
  </tr>
 </thead>
<tbody>
  <tr>
   <td style="text-align:left;"> INT1U </td>
   <td style="text-align:left;"> 0 </td>
   <td style="text-align:left;"> 255 </td>
  </tr>
  <tr>
   <td style="text-align:left;"> INT2S </td>
   <td style="text-align:left;"> -32,767 </td>
   <td style="text-align:left;"> 32,767 </td>
  </tr>
  <tr>
   <td style="text-align:left;"> INT2U </td>
   <td style="text-align:left;"> 0 </td>
   <td style="text-align:left;"> 65,534 </td>
  </tr>
  <tr>
   <td style="text-align:left;"> INT4S </td>
   <td style="text-align:left;"> -2,147,483,647 </td>
   <td style="text-align:left;"> 2,147,483,647 </td>
  </tr>
  <tr>
   <td style="text-align:left;"> INT4U </td>
   <td style="text-align:left;"> 0 </td>
   <td style="text-align:left;"> 4,294,967,296 </td>
  </tr>
  <tr>
   <td style="text-align:left;"> FLT4S </td>
   <td style="text-align:left;"> -3.4e+38 </td>
   <td style="text-align:left;"> 3.4e+38 </td>
  </tr>
  <tr>
   <td style="text-align:left;"> FLT8S </td>
   <td style="text-align:left;"> -1.7e+308 </td>
   <td style="text-align:left;"> 1.7e+308 </td>
  </tr>
</tbody>
</table>
<p>默认情况下，输出文件的格式由文件名决定。将文件命名为 <code>*.tif</code> 将创建一个 GeoTIFF 文件，如下所示：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">writeRaster<span class="punctuation">(</span>single_layer<span class="punctuation">,</span> filename <span class="operator">=</span> <span class="string">&quot;my_raster.tif&quot;</span><span class="punctuation">,</span> datatype <span class="operator">=</span> <span class="string">&quot;INT2U&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>一些栅格文件格式具有额外的选项，可以通过将<a href="http://www.gdal.org/formats_list.html">GDAL参数</a>提供给<code>writeRaster()</code> 函数的 <code>options</code> 参数来设置。在 <strong>terra</strong> 中，默认情况下，GeoTIFF 文件以 LZW 压缩方式写入，参数设置为 <code>gdal = c(&quot;COMPRESS=LZW&quot;)</code>。要更改或禁用压缩，我们需要修改这个参数。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">writeRaster<span class="punctuation">(</span>x <span class="operator">=</span> single_layer<span class="punctuation">,</span> filename <span class="operator">=</span> <span class="string">&quot;my_raster.tif&quot;</span><span class="punctuation">,</span></span><br><span class="line">            gdal <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;COMPRESS=NONE&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> overwrite <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>此外，我们还可以使用<code>filetype=&quot;COG&quot;</code>选项将我们的栅格对象保存为 COG（<em>Cloud Optimized GeoTIFF</em>，详见第@ref(file-formats) 节）。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">writeRaster<span class="punctuation">(</span>x <span class="operator">=</span> single_layer<span class="punctuation">,</span> filename <span class="operator">=</span> <span class="string">&quot;my_raster.tif&quot;</span><span class="punctuation">,</span></span><br><span class="line">            filetype <span class="operator">=</span> <span class="string">&quot;COG&quot;</span><span class="punctuation">,</span> overwrite <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<h1>输出可视化</h1>
<p>R支持许多不同的静态和交互式图形格式。保存静态绘图的最通用方法是打开一个图形设备，创建绘图，然后关闭它，例如：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">png<span class="punctuation">(</span>filename <span class="operator">=</span> <span class="string">&quot;lifeExp.png&quot;</span><span class="punctuation">,</span> width <span class="operator">=</span> <span class="number">500</span><span class="punctuation">,</span> height <span class="operator">=</span> <span class="number">350</span><span class="punctuation">)</span></span><br><span class="line">plot<span class="punctuation">(</span>world<span class="punctuation">[</span><span class="string">&quot;lifeExp&quot;</span><span class="punctuation">]</span><span class="punctuation">)</span></span><br><span class="line">dev.off<span class="punctuation">(</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>其他可用的图形设备包括 <code>pdf()</code>、<code>bmp()</code>、<code>jpeg()</code> 和 <code>tiff()</code>。您可以指定输出图的多个属性，包括宽度、高度和分辨率。</p>
<p>另外，一些图形包提供了自己的函数来保存图形输出。例如，<strong>tmap</strong> 包提供了<code>tmap_save()</code>函数。您可以通过指定对象名称和新文件的文件路径，将 <code>tmap</code> 对象保存为不同的图形格式或 HTML 文件。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>tmap<span class="punctuation">)</span></span><br><span class="line">tmap_obj <span class="operator">=</span> tm_shape<span class="punctuation">(</span>world<span class="punctuation">)</span> <span class="operator">+</span> tm_polygons<span class="punctuation">(</span>col <span class="operator">=</span> <span class="string">&quot;lifeExp&quot;</span><span class="punctuation">)</span></span><br><span class="line">tmap_save<span class="punctuation">(</span>tmap_obj<span class="punctuation">,</span> filename <span class="operator">=</span> <span class="string">&quot;lifeExp_tmap.png&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>另一方面，您可以使用<strong>mapview</strong>包中的<code>mapshot()</code>函数将创建的交互式地图保存为 HTML 文件或图像：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>mapview<span class="punctuation">)</span></span><br><span class="line">mapview_obj <span class="operator">=</span> mapview<span class="punctuation">(</span>world<span class="punctuation">,</span> zcol <span class="operator">=</span> <span class="string">&quot;lifeExp&quot;</span><span class="punctuation">,</span> legend <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br><span class="line">mapshot<span class="punctuation">(</span>mapview_obj<span class="punctuation">,</span> file <span class="operator">=</span> <span class="string">&quot;my_interactive_map.html&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<h1>练习</h1>
<p>E1. 列举并描述三种矢量、栅格和地理数据库格式的类型。</p>
<p>E2. 至少命名 <strong>sf</strong> 函数 <code>read_sf()</code> 和 <code>st_read()</code> 之间的两个区别。</p>
<ul>
<li><code>read_sf()</code> 是一个更简单、更直接的函数，用于快速读取矢量数据，而 <code>st_read()</code> 提供了更多的选项和控制，包括对图层、驱动程序和其他参数的选择。</li>
<li><code>read_sf()</code> 返回一个简化的数据框（<code>sf</code>对象），而 <code>st_read()</code> 返回一个标准的数据框，并提供了一种选择性地读取几何数据的方法。</li>
</ul>
<p>E3. 从 <strong>spData</strong> 包中读取 <code>cycle_hire_xy.csv</code> 文件作为一个空间对象（提示：它位于 <code>misc</code> 文件夹中）。加载对象的几何类型是什么？</p>
<p>E4. 使用 <strong>rnaturalearth</strong> 下载德国的边界，并创建一个名为 <code>germany_borders</code> 的新对象。将这个新对象写入GeoPackage格式的文件。</p>
<p>E5. 使用 <strong>geodata</strong> 包下载全球每月最低温度，空间分辨率为五分钟。提取六月的值，并将它们保存到名为 <code>tmin_june.tif</code> 的文件中（提示：使用 <code>terra::subset()</code>）。</p>
<p>E6. 创建德国边界的静态地图，并将其保存为PNG文件。</p>
<p>E7. 使用 <code>cycle_hire_xy.csv</code> 文件中的数据创建一个交互式地图。将此地图导出到名为 <code>cycle_hire.html</code> 的文件。</p>
]]></content>
      <categories>
        <category>R</category>
        <category>Geocomputaion</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>Geocomputaion</tag>
      </tags>
  </entry>
  <entry>
    <title>(4)空间操作</title>
    <url>/2023/08/13/2023-8-13-4%E7%A9%BA%E9%97%B4%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<blockquote><p>本文由SCY翻译自《Geocomputation with R》<a href="https://r.geocompx.org/spatial-operations">第四章</a></p>
</blockquote>
<p>空间操作，包括矢量数据集之间的空间连接以及栅格数据集上的局部和焦点操作，是地理计算的重要部分。本章展示了如何基于空间对象的位置和形状以多种方式进行修改。许多空间操作有与之对应的非空间（属性）操作，因此上一章中演示的如子集提取和数据集连接等概念在此也适用。</p>
<span id="more"></span>
<h1>前提条件</h1>
<ul>
<li>此章节需要使用和之前章节相同的包。</li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>sf<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>terra<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>dplyr<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>spData<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<h1>引言</h1>
<p>空间操作，包括矢量数据集之间的空间连接以及栅格数据集上的局部和焦点操作，是地理计算的重要部分。本章展示了如何基于空间对象的位置和形状以多种方式进行修改。许多空间操作有与之对应的非空间（属性）操作，因此上一章中演示的如子集提取和数据集连接等概念在此也适用。对于矢量操作来说，这一点尤为适用：矢量属性操作为理解空间对应关系——即空间子集（在空间矢量提取部分中介绍）提供了基础。空间连接和空间聚合也具有非空间相似操作，已在上一章中介绍。</p>
<p>空间操作与非空间操作在许多方面有所不同，例如：空间连接可以通过多种方式进行，包括匹配与目标数据集相交或位于目标数据集一定距离范围内的实体，而上一章节矢量属性连接中讨论的属性连接只能通过一种方式进行（除非使用模糊连接，如 <a href="https://cran.r-project.org/package=fuzzyjoin" title="fuzzyjoin"><strong>fuzzyjoin</strong></a> 包的文档所述）。对象之间不同类型的空间关系，包括相交和分离，均在章节拓扑关系中描述。空间对象的另一个独特之处在于距离，所有的空间对象都通过空间相关联，距离计算可用于探索这种关联的强度，正如在距离关系节中描述的矢量数据的情况一样。</p>
<p>栅格对象上的空间操作包括子集提取——在空间栅格子集提取节中进行了介绍-以及将多个栅格&quot;瓦片&quot;合并成一个对象，在合并栅格节中演示。地图代数涵盖了一系列修改栅格单元值的操作，可以参考周围单元值，也可以不参考周围单元值。地图代数的概念对许多应用至关重要，本节介绍了地图代数，并分别在地图代数节介绍了局部、焦点和分区地图代数操作。全局地图代数操作会生成代表整个栅格数据集的汇总统计数据，与栅格数据的距离计算在全局操作和距离章节中进行了讨论。在章节中，讨论了合并两个栅格数据集的过程，并结合一个可重现的示例进行演示。</p>
<blockquote>
<p>📌需要注意的是，使用两个空间对象进行空间操作需要这两个对象具有相同的坐标参考系统。这个话题在<em>crs介绍</em>中引入，并在<em>地理数据重投影</em>中进行了更详细的讨论。</p>
</blockquote>
<h1>矢量数据空间操作</h1>
<p>本节概述了在<strong>sf</strong>包中表示为简单要素的矢量地理数据上的空间操作。<em>栅格数据空间操作</em>节使用 terra 包中的类和函数对栅格数据集进行空间操作。</p>
<h2 id="空间矢量提取">空间矢量提取</h2>
<p>空间子集提取是将空间对象进行处理并返回一个包含与另一个对象空间相关特征的新对象的过程。类似于属性子集提取（在矢量属性提取子集）节中介绍），可使用方括号（<code>[</code>）运算符来创建 sf 数据框的子集，其语法为<code>x[y, , op = st_intersects]</code>，其中<code>x</code>是 sf 对象的一个子集，<code>y</code>是&quot;子集对象&quot;，<code>op = st_intersects</code>是一个可选参数，用于指定进行子集提取处理的拓扑关系（也称为二元谓词）。当未提供<code>op</code>参数时，<code>st_intersects()</code>是默认的拓扑关系。命令<code>x[y, ]</code>与上述<code>x[y, , op = st_intersects]</code>完全相同，但不同于<code>x[y, , op = st_disjoint]</code>（这些以及其他拓扑关系的含义在下一节中描述）。tidyverse中的<code>filter()</code>函数也可以使用，但这种方法更冗长，如下例所示。</p>
<p>为了演示空间子集提取，我们将使用 spData 包中的<code>nz</code>和<code>nz_height</code>数据集，它们分别包含新西兰16个主要地区和101个最高点的地理数据，以投影坐标系为基础。以下代码块创建的对象表示Canterbury，然后使用<strong>空间子集提取</strong>返回该区域内所有的高点：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">canterbury <span class="operator">=</span> nz <span class="operator">|&gt;</span> filter<span class="punctuation">(</span>Name <span class="operator">==</span> <span class="string">&quot;Canterbury&quot;</span><span class="punctuation">)</span></span><br><span class="line">canterbury_height <span class="operator">=</span> nz_height<span class="punctuation">[</span>canterbury<span class="punctuation">,</span> <span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202308232057538.png" alt="Illustration of spatial subsetting with red triangles representing 101 high points in New Zealand, clustered near the central Canterbuy region (left). The points in Canterbury were created with the  subsetting operator (highlighted in gray, right)." title="Illustration of spatial subsetting with red triangles representing 101 high points in New Zealand, clustered near the central Canterbuy region (left). The points in Canterbury were created with the `[` subsetting operator (highlighted in gray, right)."></p>
<p>就像属性子集提取一样，命令<code>x[y, ]</code>（相当于<code>nz_height[canterbury, ]</code>）使用源对象<code>y</code>的内容对目标<code>x</code>进行特征子集提取。然而，与<code>y</code>是逻辑或整数类的向量不同的是，对于空间子集提取，<code>x</code>和<code>y</code>都必须是地理对象。具体而言，以这种方式用于空间子集提取的对象必须具有类<code>sf</code>或<code>sfc</code>。<code>nz</code>和<code>nz_height</code>都是地理向量数据框，具有类<code>sf</code>，操作的结果将返回另一个<code>sf</code>对象，表示目标<code>nz_height</code>对象中与（在本例中位于）canterbury地区相交的特征（即位于高处的点）。</p>
<p>用于空间子集提取的<strong>各种拓扑关系</strong>决定了目标对象中的特征，必须与要选择的子集对象具有的空间关系类型。这些关系包括<em>接触</em>、<em>交叉</em>或<em>包含</em>，在拓扑关系部分中我们将很快看到。默认设置<code>st_intersects</code>是一个&quot;全包括&quot;的拓扑关系，它将返回与源&quot;子集&quot;对象<em>接触</em>、<em>交叉</em>或<em>包含</em>的目标中的特征。如上所示，可以用<code>op=</code>参数指定其他空间运算符，如下面的命令所示，该命令返回<code>st_intersects()</code>的相反内容，即与坎特伯雷不相交的点（请参阅部分）：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">nz_height<span class="punctuation">[</span>canterbury<span class="punctuation">,</span> <span class="punctuation">,</span> op <span class="operator">=</span> st_disjoint<span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>📌请注意前面代码块中的空参数用 <code>, ,</code> 表示是为了突出 <code>op</code>，即 <code>sf</code> 对象 <code>[</code> 的第三个参数。<br>
可以使用这个参数以多种方式改变子集操作。<br>
例如，<code>nz_height[canterbury, 2, op = st_disjoint]</code> 返回相同的行，但仅包括第二个属性列（详见 <code>sf:::`[.sf`</code> 和 <code>?sf</code>）。</p>
</blockquote>
<p>对于许多应用而言，关于矢量数据的空间子集提取的知识就是你需要了解的全部内容：它只会按预期工作。如果你急于了解更多拓扑关系，超出了 <code>st_intersects()</code>和<code>st_disjoint()</code>的范围，请跳到下一节拓扑关系。如果你对细节感兴趣，包括其他子集方式，请继续阅读。</p>
<p>另一种进行空间子集提取的方法是使用拓扑操作返回的对象。这些对象本身就很有用，例如在探索相邻区域之间的关系图网络时，但它们也可以用于子集操作，如下方的代码块中所演示的：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">sel_sgbp <span class="operator">=</span> st_intersects<span class="punctuation">(</span>x <span class="operator">=</span> nz_height<span class="punctuation">,</span> y <span class="operator">=</span> canterbury<span class="punctuation">)</span></span><br><span class="line"><span class="built_in">class</span><span class="punctuation">(</span>sel_sgbp<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] &quot;sgbp&quot; &quot;list&quot;</span></span><br><span class="line">sel_sgbp</span><br><span class="line"><span class="comment">#&gt; Sparse geometry binary predicate list of length 101, where the</span></span><br><span class="line"><span class="comment">#&gt; predicate was `intersects&#x27;</span></span><br><span class="line"><span class="comment">#&gt; first 10 elements:</span></span><br><span class="line"><span class="comment">#&gt;  1: (empty)</span></span><br><span class="line"><span class="comment">#&gt;  2: (empty)</span></span><br><span class="line"><span class="comment">#&gt;  3: (empty)</span></span><br><span class="line"><span class="comment">#&gt;  4: (empty)</span></span><br><span class="line"><span class="comment">#&gt;  5: 1</span></span><br><span class="line"><span class="comment">#&gt;  6: 1</span></span><br><span class="line"><span class="comment">#&gt;  7: 1</span></span><br><span class="line"><span class="comment">#&gt;  8: 1</span></span><br><span class="line"><span class="comment">#&gt;  9: 1</span></span><br><span class="line"><span class="comment">#&gt;  10: 1</span></span><br><span class="line">sel_logical <span class="operator">=</span> lengths<span class="punctuation">(</span>sel_sgbp<span class="punctuation">)</span> <span class="operator">&gt;</span> <span class="number">0</span></span><br><span class="line">canterbury_height2 <span class="operator">=</span> nz_height<span class="punctuation">[</span>sel_logical<span class="punctuation">,</span> <span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<p>以上代码块创建一个 <code>sgbp</code> 类的对象 (一个稀疏几何二元谓词，一个在空间操作中长度为 <code>x</code> 的列表)，然后将其转换为逻辑向量 <code>sel_logical</code>（包含仅为 <code>TRUE</code> 和 <code>FALSE</code> 的值，这也可以由 dplyr 的 filter 函数使用）。<code>lengths()</code>识别<code>nz_height</code>中的哪些要素与 <code>y</code> 中的任何对象相交。在这种情况下，1 是最大可能值，但对于更复杂的操作，可以使用该方法仅对与源对象中的 2 个或更多个要素相交的要素进行子集操作。</p>
<blockquote>
<p>📌注意：通过在<code>st_intersects()</code>等运算符中设置<code>sparse = FALSE</code>（意思是“返回密集矩阵而不是稀疏矩阵”）也可以返回逻辑输出。例如，命令<code>st_intersects(x = nz_height, y = canterbury, sparse = FALSE)[, 1]</code>将返回与<code>sel_logical</code>相同的输出。<br>
注意：涉及<code>sgbp</code>对象的解决方案更具普遍性，因为它适用于多对多的操作并且对内存要求较低。</p>
</blockquote>
<p>使用 sf 函数<code>st_filter()</code>可以实现相同的结果，该函数是为了增加<code>sf</code>对象与dplyr数据操作代码之间的兼容性而创建的：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">canterbury_height3 <span class="operator">=</span> nz_height <span class="operator">|&gt;</span></span><br><span class="line">  st_filter<span class="punctuation">(</span>y <span class="operator">=</span> canterbury<span class="punctuation">,</span> .predicate <span class="operator">=</span> st_intersects<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>到目前为止，有三个完全相同（除了行名）的<code>canterbury_height</code>版本，一个使用<code>[</code>操作符创建，一个通过中间选择对象创建，另一个使用sf的便捷函数<code>st_filter()</code>创建。</p>
<p>下一节探讨了不同类型的空间关系，也称为<strong>二元谓词</strong>，可以用来确定两个特征是否存在空间关系。</p>
<h2 id="拓扑关系">拓扑关系</h2>
<p>拓扑关系描述了对象之间的空间关系。完整称呼为&quot;二元拓扑关系&quot;，是关于由有序点集（通常形成点、线和多边形）在两个或多个维度中定义的两个对象之间的空间关系的逻辑陈述（答案只能是<code>TRUE</code>或<code>FALSE</code>）。这听起来可能相当抽象，实际上，拓扑关系的定义和分类是基于1966年首次以书籍形式出版的数学基础，代数拓扑领域一直延续到21世纪。</p>
<p>尽管拓扑关系起源于数学，但通过参考常用函数的可视化，可以直观地理解用于测试常见空间关系类型的拓扑关系。显示了各种几何对及其关联关系。图中的第三和第四对（从左到右然后向下）表明，对于某些关系，顺序很重要：虽然等于、相交、交叉、接触和重叠的关系是对称的，意味着如果<code>function(x, y)</code>为真，则<code>function(y, x)</code>也为真，但包含和内部等顺序重要的几何关系则不是。注意，每一对几何图形都有一个&quot;DE-9IM&quot;字符串，例如FF2F11212，将在下一节中描述。</p>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202308232211273.png" alt="Topological relations between vector geometries, inspired by Figures 1 and 2 in Egenhofer and Herring (1990). The relations for which the function(x, y) is true are printed for each geometry pair, with x represented in pink and y represented in blue. The nature of the spatial relationship for each pair is described by the Dimensionally Extended 9-Intersection Model string." title="Topological relations between vector geometries, inspired by Figures 1 and 2 in Egenhofer and Herring (1990). The relations for which the function(x, y) is true are printed for each geometry pair, with x represented in pink and y represented in blue. The nature of the spatial relationship for each pair is described by the Dimensionally Extended 9-Intersection Model string."></p>
<p>在<code>sf</code>中，测试不同拓扑关系的函数被称为&quot;二元谓词&quot;，如在操作简单要素几何的文献 Manipulating Simple Feature Geometries 中所述，可以使用命令 <a href="https://r-spatial.github.io/sf/articles/sf3.html" title="vignette(&quot;sf3&quot;)">vignette(“sf3”)</a>查看，也可以在帮助页面中查看<a href="https://r-spatial.github.io/sf/reference/geos_binary_ops.html" title="?geos_binary_pred">?geos_binary_pred</a>。为了更好地理解拓扑关系的实用性，我们将建立一个简单可重现的例子，基于上图中所述的关系，巩固了前一章节<em>几何</em>所介绍的矢量几何图形表示的知识。请注意，为了创建代表多边形顶点坐标（x 和 y）的表格数据，我们使用基本 R 函数 <code>cbind()</code> 创建表示坐标点的矩阵，一个<code>POLYGON</code>，最后是 <code>sfc</code> 对象，如<em>空间类</em>所述：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">polygon_matrix <span class="operator">=</span> cbind<span class="punctuation">(</span></span><br><span class="line">  x <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span> <span class="number">0</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span>   <span class="number">0</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">  y <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">0.5</span><span class="punctuation">,</span> <span class="number">0</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">)</span></span><br><span class="line">polygon_sfc <span class="operator">=</span> st_sfc<span class="punctuation">(</span>st_polygon<span class="punctuation">(</span><span class="built_in">list</span><span class="punctuation">(</span>polygon_matrix<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>请注意在上面创建的多边形之上，我们将创建额外的几何体来展示它们在空间中的关系。所示的命令在绘制时与该多边形相关联。请注意在转换数据框时使用了函数<code>st_as_sf()</code>和参数<code>coords</code>，以高效地将包含坐标列的数据框转换为包含点的<code>sf</code>对象：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">line_sfc <span class="operator">=</span> st_sfc<span class="punctuation">(</span>st_linestring<span class="punctuation">(</span>cbind<span class="punctuation">(</span></span><br><span class="line">  x <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0.4</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">  y <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0.2</span><span class="punctuation">,</span> <span class="number">0.5</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 创建点</span></span><br><span class="line">point_df <span class="operator">=</span> data.frame<span class="punctuation">(</span></span><br><span class="line">  x <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0.2</span><span class="punctuation">,</span> <span class="number">0.7</span><span class="punctuation">,</span> <span class="number">0.4</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">  y <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0.1</span><span class="punctuation">,</span> <span class="number">0.2</span><span class="punctuation">,</span> <span class="number">0.8</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">)</span></span><br><span class="line">point_sf <span class="operator">=</span> st_as_sf<span class="punctuation">(</span>point_df<span class="punctuation">,</span> coords <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;x&quot;</span><span class="punctuation">,</span> <span class="string">&quot;y&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202308232229968.png" alt="Points, line and polygon objects arranged to illustrate topological relations." title="Points, line and polygon objects arranged to illustrate topological relations."></p>
<p>一个简单查询是：<code>point_sf</code> 中的哪些点与多边形 <code>polygon_sfc</code> 以某种方式相交？此问题通过检查可得到答案（点1和点3分别与多边形相切和在多边形内）。可以使用空间谓词 <code>st_intersects()</code>，如下所示：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">st_intersects<span class="punctuation">(</span>point_sf<span class="punctuation">,</span> polygon_sfc<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; Sparse geometry binary predicate... `intersects&#x27;</span></span><br><span class="line"><span class="comment">#&gt;  1: 1</span></span><br><span class="line"><span class="comment">#&gt;  2: (empty)</span></span><br><span class="line"><span class="comment">#&gt;  3: 1</span></span><br></pre></td></tr></table></figure>
<p>结果应该符合你的直觉：第一个和第三个点返回正（<code>1</code>）的结果，第二个点在多边形的边界之外返回负结果（用一个空向量表示）。而令人意想不到的是，结果以向量列表的形式呈现。这个<em>稀疏矩阵</em>输出只记录存在关系的部分，减少了对多要素对象进行拓扑操作时的内存需求。正如我们在前面的部分中所看到的，当<code>sparse = FALSE</code>时，返回的是一个由<code>TRUE</code>或<code>FALSE</code>值组成的<em>稠密矩阵</em>：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">st_intersects<span class="punctuation">(</span>point_sf<span class="punctuation">,</span> polygon_sfc<span class="punctuation">,</span> sparse <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt;       [,1]</span></span><br><span class="line"><span class="comment">#&gt; [1,]  TRUE</span></span><br><span class="line"><span class="comment">#&gt; [2,] FALSE</span></span><br><span class="line"><span class="comment">#&gt; [3,]  TRUE</span></span><br></pre></td></tr></table></figure>
<p>在上述输出中，每一行代表目标（参数<code>x</code>）对象中的一个特征，每一列代表选择对象（<code>y</code>）中的一个特征。在这个情况下，<code>y</code>对象<code>polygon_sfc</code>中只有一个特征，所以结果只有一列，这个结果可以用于我们在<em>空间子集提取</em>部分所看到的子集提取。</p>
<p><code>st_intersects()</code>即使在特征只是相切的情况下也返回<code>TRUE</code>，<code>intersects</code>是一种&quot;全能&quot;的拓扑操作，它识别许多类型的空间关系，如下图所示。更有限制的问题包括哪些点位于多边形内，以及哪些特征在<code>y</code>上或包含与<code>y</code>共享的边界？这些问题可以如下回答（结果未显示）：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">st_within<span class="punctuation">(</span>point_sf<span class="punctuation">,</span> polygon_sfc<span class="punctuation">)</span>    <span class="comment"># 在范围内</span></span><br><span class="line">st_touches<span class="punctuation">(</span>point_sf<span class="punctuation">,</span> polygon_sfc<span class="punctuation">)</span>   <span class="comment"># 相切</span></span><br></pre></td></tr></table></figure>
<p>请注意，尽管第一个点<em>接触</em>多边形的边界，但它并不在其中；第三个点在多边形内部，但不接触其边界的任何部分。<code>st_intersects()</code>的反义词是<code>st_disjoint()</code>，它只返回与选择对象在空间上完全不相关的对象（注意<code>[,  1]</code>将结果转换为向量）：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">st_disjoint<span class="punctuation">(</span>point_sf<span class="punctuation">,</span> polygon_sfc<span class="punctuation">,</span> sparse <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">)</span><span class="punctuation">[</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">]</span></span><br><span class="line"><span class="comment">#&gt; [1] FALSE  TRUE FALSE</span></span><br></pre></td></tr></table></figure>
<p>函数<code>st_is_within_distance()</code>检测到那些<em>几乎接触</em>选择对象的特征，它有一个额外的<code>dist</code>参数。它可以用来设置目标对象需要多近才能被选择。请注意，尽管点2距离<code>polygon_sfc</code>的最近顶点的距离超过0.2个单位，但当距离设置为0.2时，它仍然被选择。这是因为距离是测量到最近的边缘，在这种情况下是多边形直接在点2上方的部分，如下图所示。（你可以用命令<code>st_distance(point_sf, polygon_sfc)</code>来验证点2和多边形之间的实际距离是0.13。）下面的代码块演示了’is within distance’二元空间谓词，其结果显示每个点都在多边形的0.2个单位内：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">st_is_within_distance<span class="punctuation">(</span>point_sf<span class="punctuation">,</span> polygon_sfc<span class="punctuation">,</span> dist <span class="operator">=</span> <span class="number">0.2</span><span class="punctuation">,</span> sparse <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">)</span><span class="punctuation">[</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">]</span></span><br><span class="line"><span class="comment">#&gt; [1] TRUE TRUE TRUE</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>📌算拓扑关系的函数使用空间索引来大大提高空间查询性能。<br>
它们使用Sort-Tile-Recursive（STR）算法来实现。<br>
下一节中提到的<code>st_join</code>函数也使用空间索引。<br>
您可以在<a href="https://www.r-spatial.org/r/2017/06/22/spatial-index.html">https://www.r-spatial.org/r/2017/06/22/spatial-index.html</a>中了解更多信息。</p>
</blockquote>
<h2 id="DE-9IM-strings">DE-9IM strings</h2>
<p>在前一节所示的二元谓词之下，隐含的是Dimensionally Extended 9-Intersection Model (DE-9IM)。正如这个神秘的名字所暗示的那样，这并不是一个容易的话题。不过，学习它有可能更好地理解空间关系。此外，DE-9IM的高级用途还包括创建自定义空间谓词。该模型最初被其发明者标记为&quot;DE + 9IM&quot;，指的是&quot;两个要素的边界、内部和外部的交界面的维度&quot; ，但现在被称为DE-9IM 。</p>
<p>为了演示DE-9IM strings的工作原理，让我们看看中第一个几何对之间的各种关系。下图展示了9 intersection model (9IM)，显示了每个对象的内部、边界和外部之间的交点，当第一个对象<code>x</code>的每个组件被排列为列，而<code>y</code>的每个组件被排列为行时，会创建出一个带有每个元素交点突出显示的分面图形。</p>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202308232332970.png" alt="Illustration of how the Dimensionally Extended 9 Intersection Model (DE-9IM) works. Colors not in the legend represent the overlap between different components. The thick lines highlight 2 dimensional intesections, e.g. between the boundary of object x and the interior of object y, shown in the middle top facet." title="Illustration of how the Dimensionally Extended 9 Intersection Model (DE-9IM) works. Colors not in the legend represent the overlap between different components. The thick lines highlight 2 dimensional intesections, e.g. between the boundary of object x and the interior of object y, shown in the middle top facet."></p>
<p>DE-9IM strings是基于每种关系的不同维度而产生的。在这种情况下，图中的红色交点分别有着0（点）、1（线）和2（多边形）不同的维度，如简单表格所示。</p>
<table>
<thead>
<tr>
<th></th>
<th>Interior (x)</th>
<th>Boundary (x)</th>
<th>Exterior (x)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Interior (y)</td>
<td>2</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>Boundary (y)</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>Exterior (y)</td>
<td>2</td>
<td>1</td>
<td>2</td>
</tr>
</tbody>
</table>
<p>按行展开这个矩阵（即按顺序连接第一行、第二行、第三行）得到字符串<code>212111212</code>。另一个例子可以用来说明该系统：下图中展示的关系（第三列和第一行中的第三个多边形对）可以用DE-9IM系统定义如下：</p>
<ul>
<li>较大对象<code>x</code>的<em>内部</em>与<code>y</code>的内部、边界和外部之间的交集分别有维数2、1和2</li>
<li>较大对象<code>x</code>的<em>边界</em>与<code>y</code>的内部、边界和外部之间的交叉点分别有F，F 和1的维度，其中<code>F</code>表示<code>false</code>，物体是不相交的</li>
<li><code>x</code>的<em>外部</em>与<code>y</code>的内部、边界和外部之间的交集分别具有F、F和2的维度，更大对象的外部不接触<code>y</code>的内部或边界，但更小和更大对象的外部覆盖相同的区域</li>
</ul>
<p>当这三个组件连接在一起时，创建字符串<code>212</code>、<code>FF1</code>和<code>FF2</code>。这与从函数<code>st_relations()</code>获得的结果相同(参见本章的源代码，查看图) 中的其他几何图形是如何创建的) :</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">xy2sfc <span class="operator">=</span> <span class="keyword">function</span><span class="punctuation">(</span>x<span class="punctuation">,</span> y<span class="punctuation">)</span> st_sfc<span class="punctuation">(</span>st_polygon<span class="punctuation">(</span><span class="built_in">list</span><span class="punctuation">(</span>cbind<span class="punctuation">(</span>x<span class="punctuation">,</span> y<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">x <span class="operator">=</span> xy2sfc<span class="punctuation">(</span>x <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span> <span class="number">0</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">0</span><span class="punctuation">)</span><span class="punctuation">,</span> y <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">0.5</span><span class="punctuation">,</span> <span class="number">0</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">y <span class="operator">=</span> xy2sfc<span class="punctuation">(</span>x <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0.7</span><span class="punctuation">,</span> <span class="number">0.7</span><span class="punctuation">,</span> <span class="number">0.9</span><span class="punctuation">,</span> <span class="number">0.7</span><span class="punctuation">)</span><span class="punctuation">,</span> y <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0.8</span><span class="punctuation">,</span> <span class="number">0.5</span><span class="punctuation">,</span> <span class="number">0.5</span><span class="punctuation">,</span> <span class="number">0.8</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">st_relate<span class="punctuation">(</span>x<span class="punctuation">,</span> y<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt;      [,1]       </span></span><br><span class="line"><span class="comment">#&gt; [1,] &quot;212FF1FF2&quot;</span></span><br></pre></td></tr></table></figure>
<p>理解DE-9IM strings可以推出新的二元空间谓词。<code>?st_relate</code> 帮助页面包含’Queen’关系和’rook’关系的函数定义，其中多边形共享边界或仅共享一个点。'Queen’关系意味着&quot;边界-边界&quot;关系(简单表格中第二列和第二行的单元格或 DE-9IM string的第五个元素)不能是空的，它相当于模式 <code>F***T****</code>，而对于’rook’关系，则相同的元素必须是1（表示线性相交）。这些措施的执行情况如下:</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">st_queen <span class="operator">=</span> <span class="keyword">function</span><span class="punctuation">(</span>x<span class="punctuation">,</span> y<span class="punctuation">)</span> st_relate<span class="punctuation">(</span>x<span class="punctuation">,</span> y<span class="punctuation">,</span> pattern <span class="operator">=</span> <span class="string">&quot;F***T****&quot;</span><span class="punctuation">)</span></span><br><span class="line">st_rook <span class="operator">=</span> <span class="keyword">function</span><span class="punctuation">(</span>x<span class="punctuation">,</span> y<span class="punctuation">)</span> st_relate<span class="punctuation">(</span>x<span class="punctuation">,</span> y<span class="punctuation">,</span> pattern <span class="operator">=</span> <span class="string">&quot;F***1****&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>在先前创建的对象<code>x</code>的基础上，我们可以使用新创建的函数来找出网格中哪些元素是’queen’和’rook’相对于网格中间的正方形，如下所示:</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">grid <span class="operator">=</span> st_make_grid<span class="punctuation">(</span>x<span class="punctuation">,</span> n <span class="operator">=</span> <span class="number">3</span><span class="punctuation">)</span></span><br><span class="line">grid_sf <span class="operator">=</span> st_sf<span class="punctuation">(</span>grid<span class="punctuation">)</span></span><br><span class="line">grid_sf<span class="operator">$</span>queens <span class="operator">=</span> lengths<span class="punctuation">(</span>st_queen<span class="punctuation">(</span>grid<span class="punctuation">,</span> grid<span class="punctuation">[</span><span class="number">5</span><span class="punctuation">]</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">&gt;</span> <span class="number">0</span></span><br><span class="line">plot<span class="punctuation">(</span>grid<span class="punctuation">,</span> col <span class="operator">=</span> grid_sf<span class="operator">$</span>queens<span class="punctuation">)</span></span><br><span class="line">grid_sf<span class="operator">$</span>rooks <span class="operator">=</span> lengths<span class="punctuation">(</span>st_rook<span class="punctuation">(</span>grid<span class="punctuation">,</span> grid<span class="punctuation">[</span><span class="number">5</span><span class="punctuation">]</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">&gt;</span> <span class="number">0</span></span><br><span class="line">plot<span class="punctuation">(</span>grid<span class="punctuation">,</span> col <span class="operator">=</span> grid_sf<span class="operator">$</span>rooks<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202308240039875.png" alt="Demonstration of custom binary spatial predicates for finding ‘queen’ (left) and ‘rook’ (right) relations to the central square in a grid with 9 geometries." title="Demonstration of custom binary spatial predicates for finding ‘queen’ (left) and ‘rook’ (right) relations to the central square in a grid with 9 geometries."></p>
<h2 id="空间连接">空间连接</h2>
<p>连接两个非空间数据集依赖于一个共享的’key’变量，如矢量属性连接节中所述。空间数据连接应用了相同的概念，但是依赖于前面部分描述的空间关系。与属性数据一样，连接从源对象(<code>y</code>)向目标对象(参数<code>x</code>在联接函数中)添加新的列。</p>
<p>这个过程可以通过以下例子来说明：假设你在地球表面随机分布了十个点，问这些点中哪些在陆地上，属于哪些国家。在<a href="https://github.com/geocompx/geocompr/blob/main/code/04-spatial-join.R" title="reproducible example">reproducible example</a>中实现这个想法将会提高你的地理数据处理技能，并演示空间连接的运作方式。首先，需要创建随机分布在地球表面的点：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">set.seed<span class="punctuation">(</span><span class="number">2018</span><span class="punctuation">)</span> <span class="comment"># set seed for reproducibility</span></span><br><span class="line"><span class="punctuation">(</span>bb <span class="operator">=</span> st_bbox<span class="punctuation">(</span>world<span class="punctuation">)</span><span class="punctuation">)</span> <span class="comment"># the world&#x27;s bounds</span></span><br><span class="line"><span class="comment">#&gt;   xmin   ymin   xmax   ymax </span></span><br><span class="line"><span class="comment">#&gt; -180.0  -89.9  180.0   83.6</span></span><br><span class="line">random_df <span class="operator">=</span> data.frame<span class="punctuation">(</span></span><br><span class="line">  x <span class="operator">=</span> runif<span class="punctuation">(</span>n <span class="operator">=</span> <span class="number">10</span><span class="punctuation">,</span> <span class="built_in">min</span> <span class="operator">=</span> bb<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="built_in">max</span> <span class="operator">=</span> bb<span class="punctuation">[</span><span class="number">3</span><span class="punctuation">]</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">  y <span class="operator">=</span> runif<span class="punctuation">(</span>n <span class="operator">=</span> <span class="number">10</span><span class="punctuation">,</span> <span class="built_in">min</span> <span class="operator">=</span> bb<span class="punctuation">[</span><span class="number">2</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="built_in">max</span> <span class="operator">=</span> bb<span class="punctuation">[</span><span class="number">4</span><span class="punctuation">]</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">)</span></span><br><span class="line">random_points <span class="operator">=</span> random_df <span class="operator">|&gt;</span> </span><br><span class="line">  st_as_sf<span class="punctuation">(</span>coords <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;x&quot;</span><span class="punctuation">,</span> <span class="string">&quot;y&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> crs <span class="operator">=</span> <span class="string">&quot;EPSG:4326&quot;</span><span class="punctuation">)</span> <span class="comment"># set coordinates and CRS</span></span><br></pre></td></tr></table></figure>
<p>下图中的场景显示，<code>Random_points</code>对象(左上)缺乏属性数据，而<code>world</code>(右上)具有属性，包括图例中显示的国家样本的国家名称。空间连接使用<code>st_join()</code>实现，如下面的代码块所示。输出是<code>Random_join</code>对象，如图(左下)。在创建连接的数据集之前，我们使用空间子集提取来创建<code>world_random</code>，其中只包含含有随机点的国家，以验证在连接的数据集中返回的国家名称数量应该是4(参见下图的右上面板)。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">world_random <span class="operator">=</span> world<span class="punctuation">[</span>random_points<span class="punctuation">,</span> <span class="punctuation">]</span></span><br><span class="line">nrow<span class="punctuation">(</span>world_random<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] 4</span></span><br><span class="line">random_joined <span class="operator">=</span> st_join<span class="punctuation">(</span>random_points<span class="punctuation">,</span> world<span class="punctuation">[</span><span class="string">&quot;name_long&quot;</span><span class="punctuation">]</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202308271029710.png" alt="Illustration of a spatial join. A new attribute variable is added to random points (top left) from source world object (top right) resulting in the data represented in the final panel." title="Illustration of a spatial join. A new attribute variable is added to random points (top left) from source world object (top right) resulting in the data represented in the final panel."></p>
<p>默认情况下，<code>st_join()</code>执行<em>左连接</em>，这意味着结果是一个包含来自 <code>x</code> 的所有行的对象，其中包括没有匹配 <code>y</code> 的行（请参见矢量属性连接），但是也可以通过设置参数 <code>left = FALSE</code> 进行内连接。与空间子集提取相似，<code>st_join()</code> 默认使用的拓扑运算符是 <code>st_intersects()</code>，可以通过设置 <code>join</code> 参数来更改（详见 <code>?st_join</code>）。上面的示例演示了将多边形图层的一列添加到点图层的方法，但是该方法适用于任何几何类型。在这种情况下，例如当<code>x</code>包含多边形，每个多边形都与<code>y</code>中多个对象匹配时，空间连接将通过为每个<code>y</code>的匹配创建新行而导致重复的要素。</p>
<h2 id="非重叠连接">非重叠连接</h2>
<p>有时候，两个地理数据集虽然没有触碰，但仍然存在着强烈的地理关系。<code>cycle_hire</code>和<code>cycle_hire_osm</code>这两个数据集已经被附加在<strong>spData</strong>包中，它们提供了很好的例子。将它们绘制出来可以发现它们经常密切相关，但并不触碰，如下图所示。以下代码创建了基础图：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">plot<span class="punctuation">(</span>st_geometry<span class="punctuation">(</span>cycle_hire<span class="punctuation">)</span><span class="punctuation">,</span> col <span class="operator">=</span> <span class="string">&quot;blue&quot;</span><span class="punctuation">)</span></span><br><span class="line">plot<span class="punctuation">(</span>st_geometry<span class="punctuation">(</span>cycle_hire_osm<span class="punctuation">)</span><span class="punctuation">,</span> add <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> pch <span class="operator">=</span> <span class="number">3</span><span class="punctuation">,</span> col <span class="operator">=</span> <span class="string">&quot;red&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>我们可以检查是否有任何点与下面所示的<code>st_intersect()</code>相同:</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="built_in">any</span><span class="punctuation">(</span>st_touches<span class="punctuation">(</span>cycle_hire<span class="punctuation">,</span> cycle_hire_osm<span class="punctuation">,</span> sparse <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] FALSE</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202308241315813.png" alt="The spatial distribution of cycle hire points in London based on official data (blue) and OpenStreetMap data (red)." title="The spatial distribution of cycle hire points in London based on official data (blue) and OpenStreetMap data (red)."></p>
<p>想象一下，我们需要将<code>cycle_hire_osm</code>中的<code>capacity</code>变量与官方&quot;目标&quot;数据中的 <code>cycle_hire</code>进行连接，此时需要使用<em>非重叠连接</em>。最简单的方法是使用二元谓词 <code>st_is_within_distance()</code>，如下所示，使用20米的阈值距离。如果启用了球面几何引擎（s2），则可以将度量单位的阈值距离设置为<em>未投影数据</em>（例如 lon/lat CRSs，如 WGS84），因为它在<strong>sf</strong>中默认启用（请参见<em>s2</em>节）。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">sel <span class="operator">=</span> st_is_within_distance<span class="punctuation">(</span>cycle_hire<span class="punctuation">,</span> cycle_hire_osm<span class="punctuation">,</span> </span><br><span class="line">                            dist <span class="operator">=</span> units<span class="operator">::</span>set_units<span class="punctuation">(</span><span class="number">20</span><span class="punctuation">,</span> <span class="string">&quot;m&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">summary<span class="punctuation">(</span>lengths<span class="punctuation">(</span>sel<span class="punctuation">)</span> <span class="operator">&gt;</span> <span class="number">0</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt;    Mode   FALSE    TRUE </span></span><br><span class="line"><span class="comment">#&gt; logical     304     438</span></span><br></pre></td></tr></table></figure>
<p>这表明，目标对象<code>cycle_hire</code>内有438个点位于与<code>cycle_hire_osm</code>的阈值距离内。如何检索与各个<code>cycle_hire_osm</code>点相关联的<em>值</em>？解决方案即为使用<code>st_join()</code>，但添加了一个<code>dist</code>参数（设为20 m）：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">z <span class="operator">=</span> st_join<span class="punctuation">(</span>cycle_hire<span class="punctuation">,</span> cycle_hire_osm<span class="punctuation">,</span> st_is_within_distance<span class="punctuation">,</span> </span><br><span class="line">            dist <span class="operator">=</span> units<span class="operator">::</span>set_units<span class="punctuation">(</span><span class="number">20</span><span class="punctuation">,</span> <span class="string">&quot;m&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">nrow<span class="punctuation">(</span>cycle_hire<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] 742</span></span><br><span class="line">nrow<span class="punctuation">(</span>z<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] 762</span></span><br></pre></td></tr></table></figure>
<p>请注意，连接结果中的行数大于目标行数。这是因为在<code>cycle_hire</code>中的某些自行车租赁站在<code>cycle_hire_osm</code>中有多个匹配项。为了聚合重叠点的值并返回平均值，我们可以使用属性章节学习到的<em>聚合</em>方法，得到行数与目标相同的对象：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">z <span class="operator">=</span> z <span class="operator">|&gt;</span> </span><br><span class="line">  group_by<span class="punctuation">(</span>id<span class="punctuation">)</span> <span class="operator">|&gt;</span> </span><br><span class="line">  summarize<span class="punctuation">(</span>capacity <span class="operator">=</span> mean<span class="punctuation">(</span>capacity<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">nrow<span class="punctuation">(</span>z<span class="punctuation">)</span> <span class="operator">==</span> nrow<span class="punctuation">(</span>cycle_hire<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] TRUE</span></span><br></pre></td></tr></table></figure>
<p>附近站点的容量可以通过比较源数据<code>cycle_hire_osm</code>的容量绘图和这个新对象的结果来进行验证(图表未显示)。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">plot<span class="punctuation">(</span>cycle_hire_osm<span class="punctuation">[</span><span class="string">&quot;capacity&quot;</span><span class="punctuation">]</span><span class="punctuation">)</span></span><br><span class="line">plot<span class="punctuation">(</span>z<span class="punctuation">[</span><span class="string">&quot;capacity&quot;</span><span class="punctuation">]</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>这种连接的结果使用了空间操作，以改变与简单要素相关的属性数据；而与每个要素相关的几何体保持不变。</p>
<h2 id="空间聚合">空间聚合</h2>
<p>与属性数据聚合相同，空间数据聚合也可以<em>压缩</em>数据：聚合结果的行数比非聚合输入要少。统计学的<em>聚合函数</em>（如平均数或总和）可以总结变量的多个数值，并返回每个<em>分组变量</em>的单个值。在矢量属性聚合节中，我们演示了如何使用<code>aggregate()</code>和<code>group_by() |&gt; summarize()</code>根据属性变量压缩数据，本节介绍了相同的函数如何与空间对象一起工作。</p>
<p>回到新西兰的例子中，假设您想要查找每个地区高峰的平均高度，源对象（在这种情况下是 <code>y</code> 或 <code>nz</code>）定义了如何将目标对象（<code>x</code> 或 <code>nz_height</code>）中的价值分组。使用基础 R 的 <code>aggregate()</code> 方法可以在一行代码中完成此操作：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">nz_agg <span class="operator">=</span> aggregate<span class="punctuation">(</span>x <span class="operator">=</span> nz_height<span class="punctuation">,</span> by <span class="operator">=</span> nz<span class="punctuation">,</span> FUN <span class="operator">=</span> mean<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>前一条命令的结果是一个具有与（空间）聚合对象（<code>nz</code>）相同几何形状的<code>sf</code>对象，您可以使用命令<code>identical(st_geometry(nz),st_geometry(nz_agg))</code>来验证。前一操作的结果如下图所示，该图显示了在新西兰的16个地区中，<code>nz_height</code>每个要素的平均值。同样的结果也可以通过将<code>st_join()</code>的输出导入到&quot;tidy&quot;函数<code>group_by()</code>和<code>summarize()</code>中来生成，具体如下：</p>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202308241401703.png" alt="Average height of the top 101 high points across the regions of New Zealand." title="Average height of the top 101 high points across the regions of New Zealand."></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">nz_agg2 <span class="operator">=</span> st_join<span class="punctuation">(</span>x <span class="operator">=</span> nz<span class="punctuation">,</span> y <span class="operator">=</span> nz_height<span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">  group_by<span class="punctuation">(</span>Name<span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">  summarize<span class="punctuation">(</span>elevation <span class="operator">=</span> mean<span class="punctuation">(</span>elevation<span class="punctuation">,</span> na.rm <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>通过使用函数<code>mean()</code>，<code>nz_agg</code>对象与分组对象<code>nz</code>具有相同的几何形状，但增加了一个新列，该列汇总每个地区中<code>x</code>的值。其他函数也可以用于此处，包括<code>median()</code>、<code>sd()</code>和其他每个组返回单个值的函数。需要注意的是，<code>aggregate()</code>与<code>group_by() |&gt; summarize()</code>方法之间的一个区别是前者在不匹配的区域名称上显示<code>NA</code>值，而后者保留区域名称。因此，&quot;tidy&quot;方法在聚合功能和结果列名称方面更具灵活性。同时，也在合并节涵盖了创建新几何体的聚合操作。</p>
<h2 id="连接不一致图层">连接不一致图层</h2>
<p>空间一致性是与空间聚合相关的重要概念。<em>聚合对象</em>（我们将其称为<code>y</code>）与目标对象（<code>x</code>）是<em>一致的</em>，如果这两个对象有共享的边界。通常情况下，行政边界数据满足此条件，其中大单位——例如英国的中层超输出区（<a href="https://www.ons.gov.uk/methodology/geography/ukgeographies/censusgeography" title="MSOAs">MSOAs</a>）或许多其他欧洲国家的区域——由许多较小单位组成。</p>
<p>相比之下，<em>不一致</em>聚合对象与目标对象没有共同的边界。这对于空间聚合(和其他空间操作)是有问题的，如下图所示。聚合每个子区域的质心将不会返回准确的结果。面积插值通过将值从一组面积单位转移到另一组面积单位来克服这个问题，使用一系列算法，包括简单的面积加权方法和更复杂的方法，如&quot;pycnophylactic&quot;方法。</p>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202308251643479.png" alt="Illustration of congruent (left) and incongruent (right) areal units with respect to larger aggregating zones (translucent ted borders)." title="Illustration of congruent (left) and incongruent (right) areal units with respect to larger aggregating zones (translucent ted borders)."></p>
<p><strong>spData</strong>包有一个名为<code>incongruent</code>的数据集（在上图的右面板中带有黑色边框的彩色多边形），以及一个名为<code>aggregating_zones</code>的数据集（在的右面板中带有半透明蓝色边框的两个多边形）。假设<code>incongruent</code>的<code>value</code>列指的是以百万欧元为单位的总区域收入。我们如何将九个基础空间多边形的值转换为<code>aggregating_zones</code>中的两个多边形？</p>
<p>这个最简单、有用的方法是<em>面积加权</em>空间插值方法，它按照重叠面积的比例，将值从<em>不相容</em>对象传递到<em>聚合区域</em>中的一个新列中：输入和输出要素之间的空间交叉越大，相应的值也越大。这在下面的代码片段中通过<code>st_interpolate_aw()</code>实现。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">iv <span class="operator">=</span> incongruent<span class="punctuation">[</span><span class="string">&quot;value&quot;</span><span class="punctuation">]</span> <span class="comment"># keep only the values to be transferred</span></span><br><span class="line">agg_aw <span class="operator">=</span> st_interpolate_aw<span class="punctuation">(</span>iv<span class="punctuation">,</span> aggregating_zones<span class="punctuation">,</span> extensive <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; Warning in st_interpolate_aw.sf(iv, aggregating_zones, extensive = TRUE):</span></span><br><span class="line"><span class="comment">#&gt; st_interpolate_aw assumes attributes are constant or uniform over areas of x</span></span><br><span class="line">agg_aw<span class="operator">$</span>value</span><br><span class="line"><span class="comment">#&gt; [1] 19.6 25.7</span></span><br></pre></td></tr></table></figure>
<p>案例中，由于总收入是一种所谓的空间广泛变量（随着地区增大而增加），所以将落入聚合区域的交叉值进行总结是有意义的。这里假设收入在较小的区域内均匀分布（所以有上面的警告信息）。但对于空间密集变量<a href="https://geodacenter.github.io/workbook/3b_rates/lab3b.html#spatially-extensive-and-spatially-intensive-variables" title="intensive">intensive</a>（如<em>平均</em>收入或百分比），情况会有所不同，它们不会随着区域的增加而增加。<code>st_interpolate_aw()</code>在处理空间密集变量时同样有效：将<code>extensive</code>参数设置为<code>FALSE</code>，它将在执行聚合时使用平均函数而非求和函数。</p>
<h2 id="距离关系">距离关系</h2>
<p>拓扑关系是二元的──一个要素要么相交，要么不相交──而距离关系是连续的。两个对象之间的距离是用<code>st_distance()</code>函数计算的。下面的代码块说明了这一点，找到了新西兰最高点与坎特伯雷地区地理重心之间的距离，该地理重心是在<em>空间子集提取</em>中创建的：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">nz_highest <span class="operator">=</span> nz_height <span class="operator">|&gt;</span> slice_max<span class="punctuation">(</span>n <span class="operator">=</span> <span class="number">1</span><span class="punctuation">,</span> order_by <span class="operator">=</span> elevation<span class="punctuation">)</span></span><br><span class="line">canterbury_centroid <span class="operator">=</span> st_centroid<span class="punctuation">(</span>canterbury<span class="punctuation">)</span></span><br><span class="line">st_distance<span class="punctuation">(</span>nz_highest<span class="punctuation">,</span> canterbury_centroid<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; Units: [m]</span></span><br><span class="line"><span class="comment">#&gt;        [,1]</span></span><br><span class="line"><span class="comment">#&gt; [1,] 115540</span></span><br></pre></td></tr></table></figure>
<p>这个结果有两个令人惊讶之处:</p>
<ul>
<li>它具有<code>units</code>，告诉我们距离是100,000米，而不是100,000英寸或任何其他距离的度量。</li>
<li>即使结果只包含一个单一值，它仍以矩阵形式返回</li>
</ul>
<p>第二个特性暗示了<code>st_length()</code>的另一个有用的特性，它能够在对象<code>x</code>和<code>y</code>中的所有特征组合之间返回<em>距离矩阵</em>。下面的命令说明了这一点，它找出了<code>nz_height</code>中前三个特征与<code>co</code>所代表的奥塔戈和坎特伯雷地区之间的距离。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">co <span class="operator">=</span> filter<span class="punctuation">(</span>nz<span class="punctuation">,</span> grepl<span class="punctuation">(</span><span class="string">&quot;Canter|Otag&quot;</span><span class="punctuation">,</span> Name<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">st_distance<span class="punctuation">(</span>nz_height<span class="punctuation">[</span><span class="number">1</span><span class="operator">:</span><span class="number">3</span><span class="punctuation">,</span> <span class="punctuation">]</span><span class="punctuation">,</span> co<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; Units: [m]</span></span><br><span class="line"><span class="comment">#&gt;        [,1]  [,2]</span></span><br><span class="line"><span class="comment">#&gt; [1,] 123537 15498</span></span><br><span class="line"><span class="comment">#&gt; [2,]  94283     0</span></span><br><span class="line"><span class="comment">#&gt; [3,]  93019     0</span></span><br></pre></td></tr></table></figure>
<p>请注意，<code>nz_height</code>中第二和第三个要素以及<code>co</code>中第二个要素之间的距离为零。这证明了点与多边形之间的距离是指到<em>多边形的任何部分</em>的距离。<code>nz_height</code>中第二个和第三个点位于奥塔哥地区，这可以通过绘制它们来验证（结果未显示）：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">plot<span class="punctuation">(</span>st_geometry<span class="punctuation">(</span>co<span class="punctuation">)</span><span class="punctuation">[</span><span class="number">2</span><span class="punctuation">]</span><span class="punctuation">)</span></span><br><span class="line">plot<span class="punctuation">(</span>st_geometry<span class="punctuation">(</span>nz_height<span class="punctuation">)</span><span class="punctuation">[</span><span class="number">2</span><span class="operator">:</span><span class="number">3</span><span class="punctuation">]</span><span class="punctuation">,</span> add <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<h1>栅格数据空间操作</h1>
<p>本节建立在栅格数据操作基础上，该节重点介绍了处理栅格数据的各种基本方法，以便展示更高级和明确的空间栅格操作，并使用在本节中手动创建的<code>elev</code>和<code>grain</code>对象。为了方便读者，这些数据集也可以在<strong>spData</strong>包中找到。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">elev <span class="operator">=</span> rast<span class="punctuation">(</span>system.file<span class="punctuation">(</span><span class="string">&quot;raster/elev.tif&quot;</span><span class="punctuation">,</span> package <span class="operator">=</span> <span class="string">&quot;spData&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">grain <span class="operator">=</span> rast<span class="punctuation">(</span>system.file<span class="punctuation">(</span><span class="string">&quot;raster/grain.tif&quot;</span><span class="punctuation">,</span> package <span class="operator">=</span> <span class="string">&quot;spData&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<h2 id="空间栅格提取">空间栅格提取</h2>
<p>前一章栅格数据操作展示了如何检索与特定单元格ID或行列组合相关联的值。栅格对象也可以通过位置（坐标）和其他空间对象进行提取。要使用坐标进行子集提取，可以使用<strong>terra</strong>函数<code>cellFromXY()</code>将坐标’translate’为单元格ID。另一种方法是使用<code>terra::extract()</code>（请注意，在<strong>tidyverse</strong>中还有一个名为<code>extract()</code>的函数）来提取值。下面展示了两种方法来找到覆盖在坐标为0.1，0.1的点上的单元格的值。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">id <span class="operator">=</span> cellFromXY<span class="punctuation">(</span>elev<span class="punctuation">,</span> xy <span class="operator">=</span> matrix<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">0.1</span><span class="punctuation">,</span> <span class="number">0.1</span><span class="punctuation">)</span><span class="punctuation">,</span> ncol <span class="operator">=</span> <span class="number">2</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">elev<span class="punctuation">[</span>id<span class="punctuation">]</span></span><br><span class="line"><span class="comment"># the same as</span></span><br><span class="line">terra<span class="operator">::</span>extract<span class="punctuation">(</span>elev<span class="punctuation">,</span> matrix<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">0.1</span><span class="punctuation">,</span> <span class="number">0.1</span><span class="punctuation">)</span><span class="punctuation">,</span> ncol <span class="operator">=</span> <span class="number">2</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>栅格对象可以与另一个栅格对象进行子集提取，示例如下：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">clip <span class="operator">=</span> rast<span class="punctuation">(</span>xmin <span class="operator">=</span> <span class="number">0.9</span><span class="punctuation">,</span> xmax <span class="operator">=</span> <span class="number">1.8</span><span class="punctuation">,</span> ymin <span class="operator">=</span> <span class="operator">-</span><span class="number">0.45</span><span class="punctuation">,</span> ymax <span class="operator">=</span> <span class="number">0.45</span><span class="punctuation">,</span></span><br><span class="line">            resolution <span class="operator">=</span> <span class="number">0.3</span><span class="punctuation">,</span> vals <span class="operator">=</span> <span class="built_in">rep</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">9</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">elev<span class="punctuation">[</span>clip<span class="punctuation">]</span></span><br><span class="line"><span class="comment"># we can also use extract</span></span><br><span class="line">terra<span class="operator">::</span>extract<span class="punctuation">(</span>elev<span class="punctuation">,</span> ext<span class="punctuation">(</span>clip<span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>这等于获取第一个栅格对象（在本例中为<code>elev</code>）的值，这些值落在第二个栅格（即<code>clip</code>）的范围内，如下图所示。</p>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202308251958656.png" alt="Original raster (left). Raster mask (middle). Output of masking a raster (right)." title="Original raster (left). Raster mask (middle). Output of masking a raster (right)."></p>
<p>上述示例返回了特定单元格的值，但在许多情况下，需要对栅格数据集进行子集提取得到空间输出。这可以通过将<code>[</code>运算符的<code>drop</code>参数设置为<code>FALSE</code>来实现。下面的代码返回<code>elev</code>的前两个单元（即顶部行的前两个单元格），并作为栅格对象返回（仅显示输出的前两行）：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">elev<span class="punctuation">[</span><span class="number">1</span><span class="operator">:</span><span class="number">2</span><span class="punctuation">,</span> drop <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">]</span>    <span class="comment"># spatial subsetting with cell IDs</span></span><br><span class="line"><span class="comment">#&gt; class       : SpatRaster </span></span><br><span class="line"><span class="comment">#&gt; dimensions  : 1, 2, 1  (nrow, ncol, nlyr)</span></span><br><span class="line"><span class="comment">#&gt; ...</span></span><br></pre></td></tr></table></figure>
<p>另一个常见的空间子集提取例子是当一个具有<code>logical</code>（或<code>NA</code>）值的栅格用于掩膜具有相同范围和分辨率的另一个栅格，如上图所示。在这种情况下，可以使用<code>[</code>和 <code>mask()</code>函数（结果未显示）:</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># create raster mask</span></span><br><span class="line">rmask <span class="operator">=</span> elev</span><br><span class="line">values<span class="punctuation">(</span>rmask<span class="punctuation">)</span> <span class="operator">=</span> sample<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="literal">NA</span><span class="punctuation">,</span> <span class="literal">TRUE</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="number">36</span><span class="punctuation">,</span> replace <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>在上面的代码块中，我们创建了一个名为<code>rmask</code>的掩膜对象，其值被随机分配为<code>NA</code>和<code>TRUE</code>。接下来，我们想要保留那些在<code>rmask</code>中为<code>TRUE</code>的<code>elev</code>值。换句话说，我们想要使用<code>rmask</code>屏蔽<code>elev</code>。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># spatial subsetting</span></span><br><span class="line">elev<span class="punctuation">[</span>rmask<span class="punctuation">,</span> drop <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">]</span>           <span class="comment"># with [ operator</span></span><br><span class="line">mask<span class="punctuation">(</span>elev<span class="punctuation">,</span> rmask<span class="punctuation">)</span>                   <span class="comment"># with mask()</span></span><br></pre></td></tr></table></figure>
<p>以上方法还可用于使用<code>NA</code>替换某些值（例如，预计出现错误）。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">elev<span class="punctuation">[</span>elev <span class="operator">&lt;</span> <span class="number">20</span><span class="punctuation">]</span> <span class="operator">=</span> <span class="literal">NA</span></span><br></pre></td></tr></table></figure>
<p>这些操作实际上是布尔局部操作，因为我们逐单元格比较了两个栅格。下一小节将更详细地探讨这些和相关的操作。</p>
<h2 id="地图代数">地图代数</h2>
<p>“地图代数&quot;是在上世纪70年代末提出的，用于描述地理栅格数据和（虽然不那么突出）矢量数据的分析的&quot;一套约定、功能和技术”。在这个背景下，我们更加明确地定义地图代数，作为一种修改或汇总栅格单元值的操作，涉及周围单元、区域或应用于每个单元的统计函数。</p>
<p>地图代数操作往往是快速的，因为栅格数据集只隐式地存储坐标，因此有一句<a href="https://geozoneblog.wordpress.com/2013/04/19/raster-vs-vector/" title="古老格言">古老格言</a> “栅格更快，但矢量更正确”。栅格数据集中单元的位置可以通过使用其矩阵位置和数据集的分辨率和原点（存储在标头中）来计算。然而，就处理而言，只要我们确保处理后单元格位置不变，单元格的地理位置就几乎不相关。此外，如果两个或多个栅格数据集具有相同的范围、投影和分辨率，可以将它们视为矩阵进行处理。</p>
<p>这是使用<strong>terra</strong>包进行地图代数的方法。首先，会查询栅格数据集的标头，并（在需要处理多个数据集的地图代数运算中）检查数据集是否兼容。其次，地图代数保留所谓的一对一定位对应关系，这意味着单元格不能移动。这与矩阵代数不同，矩阵代数中，例如在矩阵乘法或除法时，值会改变位置。</p>
<p>地图代数（或栅格数据的制图建模）将栅格操作分为四个子类，每个子类同时在一个或多个栅格上进行操作：</p>
<ol>
<li><em>局部</em>或逐单元格操作</li>
<li><em>焦点</em>或邻域操作。最常见的输出单元格值是3x3输入单元格块的结果</li>
<li><em>区域</em>操作与焦点操作相似，但计算新值的周围像素网格可能具有不规则的大小和形状</li>
<li><em>全局</em>或逐栅格操作。这意味着输出单元格可能从一个或多个整个栅格派生其值</li>
</ol>
<p>这种分类按照用于每个像素处理步骤的<strong>单元格数量</strong>和<strong>输出类型</strong>对地图代数操作进行分类。为了完整起见，我们应该提到栅格操作还可以按学科分类，例如地形、水文分析或图像分类。以下部分解释了每种类型的地图代数操作如何使用，参考了实际示例。</p>
<h2 id="局部操作">局部操作</h2>
<p><strong>局部</strong>操作包括在一个或多个层上的所有逐单元格操作。栅格代数是局部操作的典型用例——这包括从栅格中添加或减去值，平方和乘以栅格。栅格代数还允许逻辑操作，例如查找大于特定值的所有栅格单元格（在我们下面的示例中为5）。<strong>terra</strong>包支持所有这些操作及更多，如下图所示：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">elev <span class="operator">+</span> elev</span><br><span class="line">elev<span class="operator">^</span><span class="number">2</span></span><br><span class="line"><span class="built_in">log</span><span class="punctuation">(</span>elev<span class="punctuation">)</span></span><br><span class="line">elev <span class="operator">&gt;</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202308262241490.png" alt="Examples of different local operations of the elev raster object: adding two rasters, squaring, applying logarithmic transformation, and performing a logical operation." title="Examples of different local operations of the elev raster object: adding two rasters, squaring, applying logarithmic transformation, and performing a logical operation."></p>
<p><em>局部操作</em>的另一个很好的例子是将数字值的区间分为诸如将数字高程模型分为低（类别1）、中（类别2）和高（类别3）海拔的组。使用<code>classify()</code>命令，我们首先需要构建一个重分类矩阵，其中第一列对应于类别的下限，第二列对应于上限。第三列代表第一和第二列中指定范围的新值。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">rcl <span class="operator">=</span> matrix<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span> <span class="number">12</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">12</span><span class="punctuation">,</span> <span class="number">24</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">,</span> <span class="number">24</span><span class="punctuation">,</span> <span class="number">36</span><span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">)</span><span class="punctuation">,</span> ncol <span class="operator">=</span> <span class="number">3</span><span class="punctuation">,</span> byrow <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br><span class="line">rcl</span><br><span class="line"><span class="comment">#&gt;      [,1] [,2] [,3]</span></span><br><span class="line"><span class="comment">#&gt; [1,]    0   12    1</span></span><br><span class="line"><span class="comment">#&gt; [2,]   12   24    2</span></span><br><span class="line"><span class="comment">#&gt; [3,]   24   36    3</span></span><br></pre></td></tr></table></figure>
<p>在这里，我们将范围为0-12、12-24和24-36的栅格值进行了<em>重分类</em>，分别赋值为1、2和3。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">recl <span class="operator">=</span> classify<span class="punctuation">(</span>elev<span class="punctuation">,</span> rcl <span class="operator">=</span> rcl<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><code>classify()</code>函数也可以用于我们想要减少分类栅格中类别数量的情况。我们将在<em>地理营销</em>中执行几个附加的重分类操作。</p>
<p>除了算术运算符外，还可以使用<code>app()</code>、<code>tapp()</code>和<code>lapp()</code>函数。它们更有效率，因此，在大型栅格数据集存在的情况下，它们是首选。此外，它们允许你直接保存输出文件。<code>app()</code>函数将一个函数应用到栅格的每个单元格，并用于将多个图层的值汇总（例如，计算总和）到一个图层。<code>tapp()</code>是<code>app()</code>的扩展，允许我们选择要执行某个操作的图层子集（参见<code>index</code>参数）。最后，<code>lapp()</code>函数允许使用图层作为参数将一个函数应用到每个单元格——下面将介绍<code>lapp()</code>的一个应用。</p>
<p>归一化植被指数（NDVI）的计算是一种众所周知的局部（逐像素）栅格操作。它返回一个值介于-1和1之间的栅格；正值表示存在活植物（通常 &gt; 0.2）。NDVI是从遥感影像的红色和近红外（NIR）波段计算的，通常来自Landsat或Sentinel等卫星系统。植被在可见光光谱中大量吸收光线，特别是在红色通道中，同时反射NIR光线，从而解释了NVDI公式：</p>
<p>$$<br>
\begin{split}<br>
NDVI&amp;= \frac{\text{NIR} - \text{Red}}{\text{NIR} + \text{Red}}\<br>
\end{split}<br>
$$</p>
<p>让我们计算锡安国家公园的多光谱卫星影像的NDVI。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">multi_raster_file <span class="operator">=</span> system.file<span class="punctuation">(</span><span class="string">&quot;raster/landsat.tif&quot;</span><span class="punctuation">,</span> package <span class="operator">=</span> <span class="string">&quot;spDataLarge&quot;</span><span class="punctuation">)</span></span><br><span class="line">multi_rast <span class="operator">=</span> rast<span class="punctuation">(</span>multi_raster_file<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>栅格对象具有四个卫星波段：蓝、绿、红和近红外（NIR）。我们下一步应该在 R 函数中使用NDVI公式：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ndvi_fun <span class="operator">=</span> <span class="keyword">function</span><span class="punctuation">(</span>nir<span class="punctuation">,</span> red<span class="punctuation">)</span><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="punctuation">(</span>nir <span class="operator">-</span> red<span class="punctuation">)</span> <span class="operator">/</span> <span class="punctuation">(</span>nir <span class="operator">+</span> red<span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>这个函数接受两个数值参数，<code>nir</code>和<code>red</code>，并返回一个带有NDVI值的数值向量。它可以用作<code>lapp()</code>的<code>fun</code>参数。我们只需记住，我们的函数只需要两个波段（不是原始栅格的四个），并且它们需要按<code>NIR</code>、<code>red</code>的顺序排列。这就是为什么我们在进行任何计算之前，使用<code>multi_rast[[c(4, 3)]]</code>来提取输入栅格的子集。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ndvi_rast <span class="operator">=</span> lapp<span class="punctuation">(</span>multi_rast<span class="punctuation">[[</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">4</span><span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">)</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">,</span> fun <span class="operator">=</span> ndvi_fun<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>结果显示在下图的右侧面板上，可以与同一区域的RGB图像（同一图的左侧面板）进行比较。这让我们看到最大的NDVI值与该区域北部的密集森林区域相连，而最低的值则与北部的湖泊和积雪覆盖的山脊有关。</p>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202308262308411.png" alt="RGB image (left) and NDVI values (right) calculated for the example satellite file of the Zion National Park" title="RGB image (left) and NDVI values (right) calculated for the example satellite file of the Zion National Park"></p>
<p>预测映射是局部栅格操作的另一个有趣应用。响应变量对应于空间中测量或观察到的点，例如物种丰富度、滑坡的存在、树木疾病或农作物产量。因此，我们可以轻松从各种栅格（例如海拔、pH值、降水量、温度、土地覆盖、土壤类型等）检索空间或预测变量。随后，我们使用<code>lm()</code>、<code>glm()</code>、<code>gam()</code>或机器学习技术将响应建模为预测因子的函数。因此，将估计系数应用于预测栅格值，并对输出栅格值求和（参见 <em>生态</em>章节），可以对栅格对象进行空间预测。</p>
<h2 id="焦点操作">焦点操作</h2>
<p>虽然<em>局部</em>函数可能在多个层上操作一个单元格，但<em>焦点</em>操作会考虑中心（焦点）单元格及其邻居。通常考虑的邻域（也称为内核、滤波器或移动窗口）大小为3x3个单元格（即中心单元格及其周围的八个邻居），但可以根据用户的定义采用任何其他（不一定是矩形的）形状。焦点操作将一个聚合函数应用于指定邻域内的所有单元格，将相应的输出用作中心单元格的新值，然后移至下一个中心单元格，如下图所示。此操作的其他名称是空间滤波和卷积。</p>
<p>在R中，我们可以使用<code>focal()</code>函数来执行空间滤波。我们通过一个<code>matrix</code>定义移动窗口的形状，其值对应于权重（参见下面代码块中的<code>w</code>参数）。其次，<code>fun</code>参数让我们指定我们希望应用于这个邻域的函数。这里，我们选择最小值，但可以使用任何其他汇总函数，包括<code>sum()</code>、<code>mean()</code>或<code>var()</code>。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">r_focal <span class="operator">=</span> focal<span class="punctuation">(</span>elev<span class="punctuation">,</span> w <span class="operator">=</span> matrix<span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span> nrow <span class="operator">=</span> <span class="number">3</span><span class="punctuation">,</span> ncol <span class="operator">=</span> <span class="number">3</span><span class="punctuation">)</span><span class="punctuation">,</span> fun <span class="operator">=</span> <span class="built_in">min</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>这个函数还接受其他参数，例如，在过程中是否应删除<code>NA</code>值（<code>na.rm = TRUE</code>）或不删除（<code>na.rm = FALSE</code>）。</p>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202308262319552.png" alt="Input raster (left) and resulting output raster (right) due to a focal operation - finding the minimum value in 3-by-3 moving windows." title="Input raster (left) and resulting output raster (right) due to a focal operation - finding the minimum value in 3-by-3 moving windows."></p>
<p>我们可以快速检查输出是否符合我们的预期。在我们的示例中，最小值必须始终位于移动窗口的左上角（请记住，我们通过从左上角开始逐行增加单元格值来创建输入栅格）。在此示例中，权重矩阵只包括1，这意味着每个单元格对输出具有相同的权重，但这可以更改。</p>
<p><em>焦点</em>函数或滤波器在图像处理中起着主导作用。低通或平滑滤波使用平均函数来消除极值。在分类数据的情况下，我们可以用众数（最常见的值）替换平均数。相反，高通滤波强调特征。此处，线检测的拉普拉斯和索贝尔滤波可以作为例子。你可以查看<code>focal()</code>的帮助页面了解如何在 R 中使用它们（这也将在本章节结束时的练习中使用）。</p>
<p>地形处理，计算地形特性如坡度、方向和流向，依赖于<em>焦点</em>函数。虽然<code>terrain()</code>可用于计算这些指标，但一些地形算法（包括用于计算坡度的Zevenbergen和Thorne方法）并未在这个<strong>terra</strong>函数中实现。许多其他算法——包括曲率、贡献区域和湿度指数 ——是在开源桌面地理信息系统（GIS）软件中实现的。<em>GIS桥梁</em>章介绍了如何从R内部访问这样的GIS功能。</p>
<h2 id="区域操作">区域操作</h2>
<p>与焦点操作一样，<em>区域</em>操作将聚合函数应用于多个栅格单元格。然而，在<em>区域</em>操作的情况下，第二个栅格（通常具有分类值）定义了<em>分区滤波器</em>（或&quot;区域&quot;），与上一节中呈现的<em>焦点</em>操作的预定义邻域窗口相对。因此，定义<em>区域</em>滤波器的栅格单元格不一定要相邻。grain 栅格就是一个很好的例子，不同的粒度大小在整个栅格中不规则地分布。最后，<em>区域</em>操作的结果是按区域分组的汇总表，这就是为什么这个操作在GIS世界中也被称为<em>分区统计</em>。这与返回栅格对象的焦点操作形成了对比。</p>
<p>以下代码块使用<code>zonal()</code>函数来计算与每个粒度类别相关的平均海拔。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">z <span class="operator">=</span> zonal<span class="punctuation">(</span>elev<span class="punctuation">,</span> grain<span class="punctuation">,</span> fun <span class="operator">=</span> <span class="string">&quot;mean&quot;</span><span class="punctuation">)</span></span><br><span class="line">z</span><br><span class="line"><span class="comment">#&gt;   grain elev</span></span><br><span class="line"><span class="comment">#&gt; 1  clay 14.8</span></span><br><span class="line"><span class="comment">#&gt; 2  silt 21.2</span></span><br><span class="line"><span class="comment">#&gt; 3  sand 18.7</span></span><br></pre></td></tr></table></figure>
<p>这将返回每个类别的统计，在这里是每个粒度大小类别的平均海拔。注意：通过将<code>as.raster</code>参数设置为<code>TRUE</code>，也可以获得每个区域的计算统计数据的栅格。</p>
<h2 id="全局操作和距离">全局操作和距离</h2>
<p><em>全局</em>操作是分区操作的特殊情况，整个栅格数据集代表单个区域。整个栅格数据集的描述性统计是最常见的全局操作，例如最小值或最大值——我们已经在章节栅格数据汇总中讨论过这些。</p>
<p>除此之外，全局操作还可用于计算距离和权重栅格。在第一种情况下，可以计算每个单元格到特定目标单元格的距离。例如，人们可能想要计算到最近海岸的距离（参见<code>terra::distance()</code>）。我们也可能想要考虑地形，这意味着，我们不仅对纯粹的距离感兴趣，而且还想避免在前往海岸时穿越山脉。为此，我们可以通过海拔为距离赋权，以便每增加一个海拔米就&quot;延长&quot;欧氏距离。可见性和视域计算也属于全局操作的一类。</p>
<h2 id="矢量数据的-地图代数">矢量数据的&quot;地图代数&quot;</h2>
<p>许多地图代数操作在矢量处理中有对应操作。在仅考虑最大距离（逻辑焦点操作）的情况下计算距离栅格（全局操作）等同于矢量缓冲操作（裁剪章节）。重分类栅格数据（根据输入是局部还是区域函数）等同于溶解矢量数据（空间连接章节）。将两个栅格叠加（局部操作），其中一个包含表示遮罩的<code>NULL</code>或<code>NA</code>值，类似于矢量裁剪（章节）。与空间裁剪非常相似的是交叉两个图层（空间矢量提取章节）。区别在于这两个图层（矢量或栅格）仅共享重叠区域。不过，要小心措辞。有时相同的词在栅格和矢量数据模型中具有略有不同的含义。虽然聚合多边形几何意味着溶解边界，但对于栅格数据几何，它意味着增加单元格大小，从而降低空间分辨率。区域操作根据另一个栅格数据集的区域（类别）使用聚合函数溶解一个栅格的单元格。</p>
<h2 id="合并栅格">合并栅格</h2>
<p>假设我们想计算NDVI（见局部操作章节），并且还想从高程数据中计算研究区域内观测的地形属性。这些计算依赖于遥感信息。相应的图像常常被分割成覆盖特定空间范围的场景，而研究区域通常覆盖多个场景。那么，我们就需要合并研究区域所覆盖的场景。在最简单的情况下，我们可以只是合并这些场景，即将它们并排放置。例如，可以使用数字高程数据（SRTM，ASTER）来实现。在下面的代码块中，我们首先下载了奥地利和瑞士的SRTM高程数据（有关国家代码，请参见<strong>geodata</strong>函数 <code>country_codes()</code>）。第二步，我们将这两个栅格合并为一个。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">aut <span class="operator">=</span> geodata<span class="operator">::</span>elevation_30s<span class="punctuation">(</span>country <span class="operator">=</span> <span class="string">&quot;AUT&quot;</span><span class="punctuation">,</span> path <span class="operator">=</span> tempdir<span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">ch <span class="operator">=</span> geodata<span class="operator">::</span>elevation_30s<span class="punctuation">(</span>country <span class="operator">=</span> <span class="string">&quot;CHE&quot;</span><span class="punctuation">,</span> path <span class="operator">=</span> tempdir<span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">aut_ch <span class="operator">=</span> merge<span class="punctuation">(</span>aut<span class="punctuation">,</span> ch<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><strong>terra</strong> 的 <code>merge()</code>命令结合了两个图像，如果它们重叠，则使用第一个栅格的值。</p>
<p>当重叠的值彼此不对应时，这种合并方法用处不大。当您想合并在不同日期拍摄的场景的光谱图像时，通常会出现这种情况。<code>merge()</code> 命令仍然会工作，但在结果图像中您会看到一个明显的边界。另一方面，<code>mosaic()</code> 命令允许您为重叠区域定义一个函数。例如，我们可以计算平均值 – 这可能会平滑合并结果中的明显边界，但最有可能的是它不会让其消失。</p>
<h1>练习</h1>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>sf<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>dplyr<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>spData<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>E1. 在章节<a href="#%E7%9F%A2%E9%87%8F%E6%95%B0%E6%8D%AE%E7%A9%BA%E9%97%B4%E6%93%8D%E4%BD%9C">2.2</a>中，我们确认了坎特伯雷是新西兰包含最高的100个点中最多点的地区。坎特伯雷地区包含了多少个这些高点？</p>
<p><strong>加分题:</strong> 使用 <code>plot()</code> 函数绘制结果，展示整个新西兰，<code>canterbury</code> 地区以黄色高亮，坎特伯雷的高点用红色的交叉表示（提示: <code>pch = 7</code>），而新西兰其它地区的高点用蓝色的圆表示。参见帮助页面 <code>?points</code> 以获得不同 <code>pch</code> 值的图示。</p>
<p>E2. 哪个地区拥有第二高数量的 <code>nz_height</code> 点，它有多少个点？</p>
<p>E3. 将问题推广到所有地区：新西兰的16个地区中有多少个包含了国内最高100个点中的点？是哪些地区？</p>
<ul>
<li>加分题: 创建一个表格，按照点的数量和地区名字的顺序列出这些地区。</li>
</ul>
<p>E4. 通过查找和绘制美国各州之间以及与其他空间对象的关系来测试你的空间谓词知识。</p>
<p>这个练习的起点是创建一个代表美国科罗拉多州的对象。使用命令<code>colorado = us_states[us_states$NAME == &quot;Colorado&quot;,]</code> (base R) 或使用 <code>filter()</code> 函数 (tidyverse) 完成，并在美国各州的背景下绘制所得对象。</p>
<ul>
<li>创建一个新对象，代表所有与科罗拉多州地理上相交的州，并绘制结果（提示: 使用子集方法 <code>[</code> 是最简洁的方式）。</li>
<li>创建另一个对象，代表所有与科罗拉多州接触（有共享边界的）的对象，并绘制结果（提示: 记住你可以在 base R 的空间子集操作中使用参数 <code>op = st_intersects</code> 和其他空间关系）。</li>
<li>加分题: 从美国东海岸附近的哥伦比亚特区的中心到美国西海岸附近的加利福尼亚州的中心创建一条直线（提示: 第5章描述的函数 <code>st_centroid()</code>、<code>st_union()</code> 和 <code>st_cast()</code> 可能会有帮助），并确定这条长的东西线穿过了哪些州。</li>
</ul>
<p>E5. 使用 <code>dem = rast(system.file(&quot;raster/dem.tif&quot;, package = &quot;spDataLarge&quot;))</code>，并将海拔分为三个类别: 低(&lt;300)，中等和高(&gt;500)。其次，读取 NDVI 栅格（<code>ndvi = rast(system.file(&quot;raster/ndvi.tif&quot;, package = &quot;spDataLarge&quot;))</code>），并计算每个海拔类别的平均 NDVI 和平均海拔。</p>
<p>E6. 对 <code>rast(system.file(&quot;ex/logo.tif&quot;, package = &quot;terra&quot;))</code> 应用线检测滤波器。绘制结果。提示: 阅读 <code>?terra::focal()</code>。</p>
<p>E7. 计算Landsat图像的归一化差异水指数（NDWI; <code>(green - nir)/(green + nir)</code>）。使用 <strong>spDataLarge</strong> 包提供的Landsat图像（<code>system.file(&quot;raster/landsat.tif&quot;, package = &quot;spDataLarge&quot;)</code>）。同时，计算该区域的 NDVI 和 NDWI 之间的相关性（提示: 你可以使用 <code>layerCor()</code> 函数）。</p>
<p>E8. StackOverflow 的一篇<a href="https://stackoverflow.com/questions/35555709/global-raster-of-geographic-distances" title="post">帖子</a>展示了如何使用 <code>raster::distance()</code> 计算到最近海岸线的距离。尝试做类似的事情，但使用 <code>terra::distance()</code>：检索西班牙的数字高程模型，并计算表示该国各地到海岸的距离的栅格（提示: 使用 <code>geodata::elevation_30s()</code>）。将得到的距离从米转换为公里。注意: 在此操作期间，增加输入栅格的单元大小以减少计算时间可能是明智的（<code>aggregate()</code>）。</p>
<p>E9. 尝试通过将海拔栅格与距离栅格结合，修改上述练习中使用的方法；每上升100个海拔米，到海岸的距离应增加10公里。接下来，计算和可视化使用欧几里得距离（E7）创建的栅格与按海拔加权的栅格之间的差异。</p>
]]></content>
      <categories>
        <category>R</category>
        <category>Geocomputaion</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>Geocomputaion</tag>
      </tags>
  </entry>
  <entry>
    <title>(9)地理数据制图</title>
    <url>/2023/08/18/2023-8-18-9%E5%9C%B0%E7%90%86%E6%95%B0%E6%8D%AE%E5%88%B6%E5%9B%BE/</url>
    <content><![CDATA[<blockquote><p>本文由SCY翻译自《Geocomputation with R》<a href="https://r.geocompx.org/adv-map">第九章</a></p>
</blockquote>
<h1>前提条件</h1>
<ul>
<li>本章需要使用我们已经在使用的以下包：</li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>sf<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>terra<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>dplyr<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>spData<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>spDataLarge<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>此外，本章还使用以下可视化包（如果您想开发交互式地图应用程序，请安装shiny）：</li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># remotes::install_github(&quot;r-tmap/tmap@v4&quot;)</span></span><br><span class="line">library<span class="punctuation">(</span>tmap<span class="punctuation">)</span>    <span class="comment"># for static and interactive maps</span></span><br><span class="line">library<span class="punctuation">(</span>leaflet<span class="punctuation">)</span> <span class="comment"># for interactive maps</span></span><br><span class="line">library<span class="punctuation">(</span>ggplot2<span class="punctuation">)</span> <span class="comment"># tidyverse data visualization package</span></span><br></pre></td></tr></table></figure>
<ul>
<li>您还需要按照以下方式读取几个数据集，以进行<em>栅格数据的空间操作</em>部分的内容：</li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">nz_elev <span class="operator">=</span> rast<span class="punctuation">(</span>system.file<span class="punctuation">(</span><span class="string">&quot;raster/nz_elev.tif&quot;</span><span class="punctuation">,</span> package <span class="operator">=</span> <span class="string">&quot;spDataLarge&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<h1>引言</h1>
<p>地理研究中令人满意和重要的一个方面是传达研究结果。制图——地图制作的艺术——是一项古老的技能，涉及沟通、细节关注和创造性元素。在R中进行静态制图非常简单，可以使用<code>plot()</code>函数。通过使用基本R方法，可以创建高级地图。然而，本章的重点是使用专门的制图包进行地图制作。在学习新技能时，首先在一个领域深入掌握知识，然后再进行扩展，这是合乎情理的做法。制图也不例外，因此本章深入介绍了一个包（<strong>tmap</strong>），而不是浅尝辄止地介绍多个包。</p>
<p>除了有趣和富有创意外，制图还具有重要的实际应用。精心制作的地图可能是传达工作结果的最佳方式，但设计不良的地图可能会留下不好的印象。常见的设计问题包括文本的位置、大小和可读性差，以及颜色的选择不慎，正如《地图杂志》的风格<a href="https://www.tandf.co.uk//journals/authors/style/TJOM-suppmaterial-quick-guide.pdf">指南</a>中所述。此外，糟糕的地图制作可能会妨碍结果的传达：</p>
<blockquote>
<p>看起来业余的地图可能会削弱您的受众理解重要信息的能力，减弱专业数据调查的呈现效果。<br>
数千年来，地图已被用于各种各样的目的。<br>
历史上的例子包括3000多年前的旧巴比伦王朝的建筑和土地所有权地图，以及近2000年前托勒密在他的杰作<em>地理学</em>中的世界地图。</p>
</blockquote>
<p>制图活动在历史上曾经只由精英或代表精英进行。随着开源地图制作软件的出现，如R包<strong>tmap</strong>和QGIS中的’print composer’，任何人都可以制作高质量的地图，从而实现了’公民科学’。地图也常常是以易于理解的方式呈现地理计算研究结果的最佳途径。制图因此是地理计算的关键部分，它不仅强调描述世界，还强调<em>改变</em>世界。</p>
<p>本章介绍了如何制作各种类型的地图。接下来的部分将涵盖静态地图的各种情况，包括美学考虑、分面和插图地图。部分章节将介绍动态和交互式地图（包括网络地图和地图应用程序）。最<br>
后，将介绍一系列备选的地图制作包，包括<strong>ggplot2</strong>和<strong>cartogram</strong>。</p>
<h1>静态地图</h1>
<p>静态地图是地理计算的最常见的可视输出类型。它们通常以标准格式保存，包括 <code>.png</code>和<code>.pdf</code>用于图形光栅和矢量输出。最初，静态地图是R唯一能够生成的地图类型。随着<strong>sp</strong>的发布[<a href="mailto:%E8%A7%81@pebesma">见@pebesma</a>{.email}_classes_2005]，自那时以来，许多地图制作技术、函数和软件包得到了发展。然而，尽管有交互式地图的创新，静态绘图仍然是十年后R中地理数据可视化的重点。</p>
<p>通用的 <code>plot()</code> 函数是从矢量和栅格空间对象创建静态地图的最快方法。有时，在项目开发阶段，简单性和速度是首要考虑的因素，这就是 <code>plot()</code> 函数的优势所在。<br>
基本的 R 方法也是可扩展的，<code>plot()</code> 函数提供了许多参数选项。另一种方法是使用 <strong>grid</strong> 软件包，它允许对静态地图进行低级别的控制，如 @murrell_r_2016 的第 <a href="https://www.stat.auckland.ac.nz/~paul/RG2e/chapter14.html">14</a> 章所示。本书的这部分将重点介绍 <strong>tmap</strong>，并强调其基本的美学和布局选项。</p>
<p><strong>tmap</strong>是一个功能强大且灵活的制图软件包，具有合理的默认设置。它具有简洁的语法，允许使用最少的代码创建具有吸引力的地图，这对于 <strong>ggplot2</strong> 用户来说会非常熟悉。它还具有独特的功能，通过<code>tmap_mode()</code>可以生成静态和交互式地图，使用相同的代码。最后，它接受比其他替代方案（如 <strong>ggplot2</strong>）更广泛的空间类别（包括 <strong>sf</strong> 和 <strong>terra</strong> 对象）。</p>
<!--toDo:jn--> <!-- update the below vignettes links --> <!-- (see the vignettes [`tmap-getstarted`](https://cran.r-project.org/web/packages/tmap/vignettes/tmap-getstarted.html) and [`tmap-changes-v2`](https://cran.r-project.org/web/packages/tmap/vignettes/tmap-changes-v2.html), as well as @tennekes_tmap_2018, for further documentation). -->
<h2 id="tmap-基础">tmap 基础</h2>
<p>与<strong>ggplot2</strong>类似，<strong>tmap</strong>基于&quot;图形语法&quot;的理念。这涉及将输入数据与美学（数据如何可视化）分离：每个输入数据集可以通过多种不同的方式进行&quot;映射&quot;，包括在地图上的位置（由数据的<code>geometry</code>定义）、颜色和其他视觉变量。基本构建块是 <code>tm_shape()</code>（定义输入数据：矢量或栅格对象），然后是一个或多个图层元素，如 <code>tm_fill()</code> 和 <code>tm_dots()</code>。以下代码块演示了这种分层结构，生成了图中呈现的地图：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Add fill layer to nz shape</span></span><br><span class="line">tm_shape<span class="punctuation">(</span>nz<span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  tm_fill<span class="punctuation">(</span><span class="punctuation">)</span> </span><br><span class="line"><span class="comment"># Add border layer to nz shape</span></span><br><span class="line">tm_shape<span class="punctuation">(</span>nz<span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  tm_borders<span class="punctuation">(</span><span class="punctuation">)</span> </span><br><span class="line"><span class="comment"># Add fill and border layers to nz shape</span></span><br><span class="line">tm_shape<span class="punctuation">(</span>nz<span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  tm_fill<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  tm_borders<span class="punctuation">(</span><span class="punctuation">)</span> </span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309031738903.png" alt=""><br>
New Zealand’s shape plotted with fill (left), border (middle) and fill and border (right) layers added using tmap functions.</p>
<p>在这种情况下，传递给<code>tm_shape()</code>的对象是<code>nz</code>，一个代表新西兰各个地区的<code>sf</code>对象。添加图层以在视觉上表示<code>nz</code>，使用<code>tm_fill()</code>和<code>tm_borders()</code>分别在上图的左侧面板和中间面板中创建了阴影区。</p>
<ul>
<li><code>tm_fill()</code>: （多）多边形的阴影区域</li>
<li><code>tm_borders()</code>: （多）多边形的边界轮廓</li>
<li><code>tm_polygons()</code>: （多）多边形的阴影区域和边界轮廓</li>
<li><code>tm_lines()</code>: （多）线串的线条</li>
<li><code>tm_symbols()</code>: （多）点、线串和多边形的符号</li>
<li><code>tm_raster()</code>: 栅格数据的彩色单元格（也有用于具有三个图层的栅格的 <code>tm_rgb()</code>）</li>
<li><code>tm_text()</code>: （多）点、线串和多边形的文本信息</li>
</ul>
<!--toDo: jn-->
<!-- update help link -->
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 请参阅 `help(&quot;tmap-element&quot;)` 获取所有可能的图层类型的完整列表。这种图层叠加效果在图的右侧面板中得以体现，这是在填充图层之上添加了边界。 --&gt;</span><br></pre></td></tr></table></figure>
<!--toDo: jn-->
<!-- update when/if -->
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">&gt; `qtm()` 是一个方便的函数，用于创建快速、主题、地图（因此取了一个简洁的名字）。</span><br><span class="line">它非常简洁，对许多情况下都提供了很好的默认可视化效果：例如，`qtm(nz)` 等同于 `tm_shape(nz) + tm_fill() + tm_borders()`。</span><br><span class="line">此外，可以使用多个 `qtm()` 调用简洁地添加图层，例如 `qtm(nz) + qtm(nz_height)`。</span><br><span class="line">缺点是它使得单个图层的美学更难以控制，这就解释了为什么我们在本章中避免教授它。</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure>
<h2 id="地图对象">地图对象</h2>
<p><strong>tmap</strong> 的一个有用特性是它能够存储代表地图的<em>对象</em>。下面的代码块演示了这一点，通过将上图中的最后一个绘图保存为一个<code>tmap</code>类型的对象（注意使用了<code>tm_polygons()</code>，它将<code>tm_fill()+tm_borders()</code>结合成一个函数）：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">map_nz <span class="operator">=</span> tm_shape<span class="punctuation">(</span>nz<span class="punctuation">)</span> <span class="operator">+</span> tm_polygons<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line"><span class="built_in">class</span><span class="punctuation">(</span>map_nz<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] &quot;tmap&quot;</span></span><br></pre></td></tr></table></figure>
<p><code>map_nz</code>可以进行绘图，例如添加额外的图层（如下所示），或者只需在控制台中运行 <code>map_nz</code>，这相当于 <code>print(map_nz)</code>。</p>
<p>可以使用 <code>+ tm_shape(new_obj)</code> 添加新的<em>shapes</em>。在这种情况下，<code>new_obj</code>表示要绘制在之前图层之上的新的空间对象。当以这种方式添加新的形状shape时，所有后续的美学函数都会与它相关联，直到添加另一个新的shape为止。这种语法允许创建具有多个形状和图层的地图，如下面的代码块所示，使用函数 <code>tm_raster()</code>绘制一个栅格图层（设置<code>col_alpha</code> 使图层半透明）：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">map_nz1 <span class="operator">=</span> map_nz <span class="operator">+</span></span><br><span class="line">  tm_shape<span class="punctuation">(</span>nz_elev<span class="punctuation">)</span> <span class="operator">+</span> tm_raster<span class="punctuation">(</span>col_alpha <span class="operator">=</span> <span class="number">0.7</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<!--toDo: jn-->
<!-- explain the SpatRaster object downsampled to 1141 by 877 cells. message -->
<p>Building on the previously created <code>map_nz</code> object, the preceding code creates a new map object <code>map_nz1</code> that contains another shape (<code>nz_elev</code>) representing average elevation across New Zealand (see Figure @ref(fig:tmlayers), left).<br>
More shapes and layers can be added, as illustrated in the code chunk below which creates <code>nz_water</code>, representing New Zealand’s <a href="https://en.wikipedia.org/wiki/Territorial_waters">territorial waters</a>, and adds the resulting lines to an existing map object.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">nz_water <span class="operator">=</span> st_union<span class="punctuation">(</span>nz<span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">  st_buffer<span class="punctuation">(</span><span class="number">22200</span><span class="punctuation">)</span> <span class="operator">|&gt;</span> </span><br><span class="line">  st_cast<span class="punctuation">(</span>to <span class="operator">=</span> <span class="string">&quot;LINESTRING&quot;</span><span class="punctuation">)</span></span><br><span class="line">map_nz2 <span class="operator">=</span> map_nz1 <span class="operator">+</span></span><br><span class="line">  tm_shape<span class="punctuation">(</span>nz_water<span class="punctuation">)</span> <span class="operator">+</span> tm_lines<span class="punctuation">(</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>There is no limit to the number of layers or shapes that can be added to <code>tmap</code> objects, and the same shape can even be used multiple times.<br>
The final map illustrated in Figure @ref(fig:tmlayers) is created by adding a layer representing high points (stored in the object <code>nz_height</code>) onto the previously created <code>map_nz2</code> object with <code>tm_symbols()</code> (see <code>?tm_symbols</code> for details on <strong>tmap</strong>’s point plotting functions).<br>
The resulting map, which has four layers, is illustrated in the right-hand panel of Figure @ref(fig:tmlayers):</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">map_nz3 <span class="operator">=</span> map_nz2 <span class="operator">+</span></span><br><span class="line">  tm_shape<span class="punctuation">(</span>nz_height<span class="punctuation">)</span> <span class="operator">+</span> tm_symbols<span class="punctuation">(</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>A useful and little known feature of <strong>tmap</strong> is that multiple map objects can be arranged in a single ‘metaplot’ with <code>tmap_arrange()</code>.<br>
This is demonstrated in the code chunk below which plots <code>map_nz1</code> to <code>map_nz3</code>, resulting in Figure @ref(fig:tmlayers).</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">tmap_arrange<span class="punctuation">(</span>map_nz1<span class="punctuation">,</span> map_nz2<span class="punctuation">,</span> map_nz3<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<div class="figure" style="text-align: center">
<img data-src="09-mapping_files/figure-html/tmlayers-1.png" alt="Maps with additional layers added to the final map of Figure 9.1." width="100%" />
<p class="caption">(\#fig:tmlayers)Maps with additional layers added to the final map of Figure 9.1.</p>
</div>
<p>More elements can also be added with the <code>+</code> operator.<br>
Aesthetic settings, however, are controlled by arguments to layer functions.</p>
<h2 id="可视化变量">可视化变量</h2>
<p>The plots in the previous section demonstrate <strong>tmap</strong>’s default aesthetic settings.<br>
Gray shades are used for <code>tm_fill()</code> and <code>tm_symbols()</code> layers and a continuous black line is used to represent lines created with <code>tm_lines()</code>.<br>
Of course, these default values and other aesthetics can be overridden.<br>
The purpose of this section is to show how.</p>
<p>There are two main types of map aesthetics: those that change with the data and those that are constant.<br>
Unlike <strong>ggplot2</strong>, which uses the helper function <code>aes()</code> to represent variable aesthetics, <strong>tmap</strong> accepts a few aesthetic arguments, depending on a selected layer type:</p>
<ul>
<li><code>fill</code>: fill color of a polygon</li>
<li><code>col</code>: color of a polygon border, line, point, or raster</li>
<li><code>lwd</code>: line width</li>
<li><code>lty</code>: line type</li>
<li><code>size</code>: size of a symbol</li>
<li><code>shape</code>: shape of a symbol</li>
</ul>
<p>Additionally, we may customize the fill and border color transparency using <code>fill_alpha</code> and <code>col_alpha</code>.</p>
<p>To map a variable to an aesthetic, pass its column name to the corresponding argument, and to set a fixed aesthetic, pass the desired value instead.[^1]<br>
The impact of setting these with fixed values is illustrated in Figure @ref(fig:tmstatic).</p>
<p>[^1]: If there is a clash between a fixed value and a column name, the column name takes precedence.<br>
This can be verified by running the next code chunk after running <code>nz$red = 1:nrow(nz)</code>.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ma1 <span class="operator">=</span> tm_shape<span class="punctuation">(</span>nz<span class="punctuation">)</span> <span class="operator">+</span> tm_polygons<span class="punctuation">(</span>fill <span class="operator">=</span> <span class="string">&quot;red&quot;</span><span class="punctuation">)</span></span><br><span class="line">ma2 <span class="operator">=</span> tm_shape<span class="punctuation">(</span>nz<span class="punctuation">)</span> <span class="operator">+</span> tm_polygons<span class="punctuation">(</span>fill <span class="operator">=</span> <span class="string">&quot;red&quot;</span><span class="punctuation">,</span> fill_alpha <span class="operator">=</span> <span class="number">0.3</span><span class="punctuation">)</span></span><br><span class="line">ma3 <span class="operator">=</span> tm_shape<span class="punctuation">(</span>nz<span class="punctuation">)</span> <span class="operator">+</span> tm_polygons<span class="punctuation">(</span>col <span class="operator">=</span> <span class="string">&quot;blue&quot;</span><span class="punctuation">)</span></span><br><span class="line">ma4 <span class="operator">=</span> tm_shape<span class="punctuation">(</span>nz<span class="punctuation">)</span> <span class="operator">+</span> tm_polygons<span class="punctuation">(</span>lwd <span class="operator">=</span> <span class="number">3</span><span class="punctuation">)</span></span><br><span class="line">ma5 <span class="operator">=</span> tm_shape<span class="punctuation">(</span>nz<span class="punctuation">)</span> <span class="operator">+</span> tm_polygons<span class="punctuation">(</span>lty <span class="operator">=</span> <span class="number">2</span><span class="punctuation">)</span></span><br><span class="line">ma6 <span class="operator">=</span> tm_shape<span class="punctuation">(</span>nz<span class="punctuation">)</span> <span class="operator">+</span> tm_polygons<span class="punctuation">(</span>fill <span class="operator">=</span> <span class="string">&quot;red&quot;</span><span class="punctuation">,</span> fill_alpha <span class="operator">=</span> <span class="number">0.3</span><span class="punctuation">,</span></span><br><span class="line">                                 col <span class="operator">=</span> <span class="string">&quot;blue&quot;</span><span class="punctuation">,</span> lwd <span class="operator">=</span> <span class="number">3</span><span class="punctuation">,</span> lty <span class="operator">=</span> <span class="number">2</span><span class="punctuation">)</span></span><br><span class="line">tmap_arrange<span class="punctuation">(</span>ma1<span class="punctuation">,</span> ma2<span class="punctuation">,</span> ma3<span class="punctuation">,</span> ma4<span class="punctuation">,</span> ma5<span class="punctuation">,</span> ma6<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<div class="figure" style="text-align: center">
<img data-src="09-mapping_files/figure-html/tmstatic-1.png" alt="The impact of changing commonly used fill and border aesthetics to fixed values." width="100%" />
<p class="caption">(\#fig:tmstatic)The impact of changing commonly used fill and border aesthetics to fixed values.</p>
</div>
<p>Like base R plots, arguments defining aesthetics can also receive values that vary.<br>
Unlike the base R code below (which generates the left panel in Figure @ref(fig:tmcol)), <strong>tmap</strong> aesthetic arguments will not accept a numeric vector:</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">plot<span class="punctuation">(</span>st_geometry<span class="punctuation">(</span>nz<span class="punctuation">)</span><span class="punctuation">,</span> col <span class="operator">=</span> nz<span class="operator">$</span>Land_area<span class="punctuation">)</span>  <span class="comment"># works</span></span><br><span class="line">tm_shape<span class="punctuation">(</span>nz<span class="punctuation">)</span> <span class="operator">+</span> tm_fill<span class="punctuation">(</span>col <span class="operator">=</span> nz<span class="operator">$</span>Land_area<span class="punctuation">)</span> <span class="comment"># fails</span></span><br><span class="line"><span class="comment">#&gt; Error: palette should be a character value</span></span><br></pre></td></tr></table></figure>
<p>Instead <code>col</code> (and other aesthetics that can vary such as <code>lwd</code> for line layers and <code>size</code> for point layers) requires a character string naming an attribute associated with the geometry to be plotted.<br>
Thus, one would achieve the desired result as follows (plotted in the right-hand panel of Figure @ref(fig:tmcol)):</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">tm_shape<span class="punctuation">(</span>nz<span class="punctuation">)</span> <span class="operator">+</span> tm_fill<span class="punctuation">(</span>fill <span class="operator">=</span> <span class="string">&quot;Land_area&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<div class="figure" style="text-align: center">
<img data-src="09-mapping_files/figure-html/tmcol-1.png" alt="Comparison of base (left) and tmap (right) handling of a numeric color field." width="45%" /><img data-src="09-mapping_files/figure-html/tmcol-2.png" alt="Comparison of base (left) and tmap (right) handling of a numeric color field." width="45%" />
<p class="caption">(\#fig:tmcol)Comparison of base (left) and tmap (right) handling of a numeric color field.</p>
</div>
<p>Each visual variable has three related additional arguments, with prefixes of <code>.scale</code>, <code>.legend</code>, and <code>.free</code>.<br>
For example, the <code>tm_fill()</code> function has arguments such as <code>fill</code>, <code>fill.scale</code>, <code>fill.legend</code>, and <code>fill.free</code>.<br>
The <code>.scale</code> argument determines how the provided values are represented on the map and in the legend (Section @ref(scales)), while the <code>.legend</code> argument is used to customize the legend settings, such as its title, orientation, or position (Section @ref(legends)).<br>
The <code>.free</code> argument is relevant only for maps with many facets to determine if each facet has the same or different scale and legend (Section @ref(faceted-maps)).</p>
<h2 id="标度">标度</h2>
<p>\index{tmap (package)!scales} Scales control how the values are represented on the map and in the legend, and largely depend on the selected visual variable.<br>
For example, when our visual variable is <code>col</code>, then <code>col.scale</code> controls how the colors of spatial objects are related to the provided values; and when our visual variable is <code>size</code>, then <code>size.scale</code> controls how the sizes represent the provided values.<br>
By default, the used scale is <code>tm_scale()</code>, which selects the visual settings automatically given by the data type (factor, numeric, and integer).</p>
<p>\index{tmap (package)!color breaks} Let’s see how the scales work by customizing polygons’ fill colors.<br>
Color settings are an important part of map design – they can have a major impact on how spatial variability is portrayed as illustrated in Figure @ref(fig:tmpal).<br>
This figure shows four ways of coloring regions in New Zealand depending on median income, from left to right (and demonstrated in the code chunk below):</p>
<ul>
<li>The default setting uses ‘pretty’ breaks, described in the next paragraph</li>
<li><code>breaks</code> allows you to manually set the breaks</li>
<li><code>n</code> sets the number of bins into which numeric variables are categorized</li>
<li><code>values</code> defines the color scheme, for example, <code>BuGn</code></li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">tm_shape<span class="punctuation">(</span>nz<span class="punctuation">)</span> <span class="operator">+</span> tm_polygons<span class="punctuation">(</span>fill <span class="operator">=</span> <span class="string">&quot;Median_income&quot;</span><span class="punctuation">)</span></span><br><span class="line">tm_shape<span class="punctuation">(</span>nz<span class="punctuation">)</span> <span class="operator">+</span> tm_polygons<span class="punctuation">(</span>fill <span class="operator">=</span> <span class="string">&quot;Median_income&quot;</span><span class="punctuation">,</span></span><br><span class="line">                           fill.scale <span class="operator">=</span> tm_scale<span class="punctuation">(</span>breaks <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span> <span class="number">30000</span><span class="punctuation">,</span> <span class="number">40000</span><span class="punctuation">,</span> <span class="number">50000</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">tm_shape<span class="punctuation">(</span>nz<span class="punctuation">)</span> <span class="operator">+</span> tm_polygons<span class="punctuation">(</span>fill <span class="operator">=</span> <span class="string">&quot;Median_income&quot;</span><span class="punctuation">,</span></span><br><span class="line">                           fill.scale <span class="operator">=</span> tm_scale<span class="punctuation">(</span>n <span class="operator">=</span> <span class="number">10</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">tm_shape<span class="punctuation">(</span>nz<span class="punctuation">)</span> <span class="operator">+</span> tm_polygons<span class="punctuation">(</span>fill <span class="operator">=</span> <span class="string">&quot;Median_income&quot;</span><span class="punctuation">,</span></span><br><span class="line">                           fill.scale <span class="operator">=</span> tm_scale<span class="punctuation">(</span>values <span class="operator">=</span> <span class="string">&quot;BuGn&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<div class="figure" style="text-align: center">
<img data-src="09-mapping_files/figure-html/tmpal-1.png" alt="Illustration of settings that affect color settings. The results show (from left to right): default settings, manual breaks, n breaks, and the impact of changing the palette." width="100%" />
<p class="caption">(\#fig:tmpal)Illustration of settings that affect color settings. The results show (from left to right): default settings, manual breaks, n breaks, and the impact of changing the palette.</p>
</div>
<p>\BeginKnitrBlock{rmdnote}<div class="rmdnote">All of the above arguments (<code>breaks</code>, <code>n</code>, and <code>values</code>) also work for other types of visual variables.<br>
For example, <code>values</code> expects a vector of colors or a palette name for <code>fill.scale</code> or <code>col.scale</code>, a vector of sizes for <code>size.scale</code>, or a vector of symbols for <code>shape.scale</code>.</div>\EndKnitrBlock{rmdnote}</p>
<p>\index{tmap (package)!break styles} We are also able to customize scales using a family of functions that start with the <code>tm_scale_</code> prefix.<br>
The most important ones are <code>tm_scale_intervals()</code>, <code>tm_scale_continuous()</code>, and <code>tm_scale_categorical()</code>.</p>
<p>\index{tmap (package)!interval scale} The <code>tm_scale_intervals()</code> function splits the input data values into a set of intervals.<br>
In addition to manually setting <code>breaks,</code> <strong>tmap</strong> allows users to specify algorithms to create breaks with the <code>style</code> argument automatically.<br>
Here are some of the most useful scale functions (Figure @ref(fig:break-styles)):</p>
<ul>
<li><code>style = &quot;pretty&quot;</code>: the default setting, rounds breaks into whole numbers where possible and spaces them evenly</li>
<li><code>style = &quot;equal&quot;</code>: divides input values into bins of equal range and is appropriate for variables with a uniform distribution (not recommended for variables with a skewed distribution as the resulting map may end-up having little color diversity)</li>
<li><code>style = &quot;quantile&quot;</code>: ensures the same number of observations fall into each category (with the potential downside that bin ranges can vary widely)</li>
<li><code>style = &quot;jenks&quot;</code>: identifies groups of similar values in the data and maximizes the differences between categories</li>
<li><code>style = &quot;log10_pretty&quot;</code>: a common logarithmic (the logarithm to base 10) version of the regular pretty style used for variables with a right-skewed distribution</li>
</ul>
<p>\BeginKnitrBlock{rmdnote}<div class="rmdnote">Although <code>style</code> is an argument of <strong>tmap</strong> functions, in fact it originates as an argument in <code>classInt::classIntervals()</code> — see the help page of this function for details.</div>\EndKnitrBlock{rmdnote}</p>
<div class="figure" style="text-align: center">
<img data-src="09-mapping_files/figure-html/break-styles-1.png" alt="Illustration of different interval scales' methods set using the style argument in tmap." width="100%" />
<p class="caption">(\#fig:break-styles)Illustration of different interval scales' methods set using the style argument in tmap.</p>
</div>
<p>\index{tmap (package)!continuous scale} The <code>tm_scale_continuous()</code> function present a large number of colors over continuous color fields and are particularly suited for continuous rasters.<br>
In case of variables with skewed distribution you can also use its variants – <code>tm_scale_continuous_log()</code> and <code>tm_scale_continuous_log1p()</code>.<br>
\index{tmap (package)!categorical scale} Finally, <code>tm_scale_categorical()</code> was designed to represent categorical values and assures that each category receives a unique color (Figure @ref(fig:concat)).</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#&gt; Warning in strwidth(comp$text, units = &quot;inch&quot;, family = comp$fontfamily, : no</span><br><span class="line">#&gt; font could be found for family &quot;monospace&quot;</span><br><span class="line"></span><br><span class="line">#&gt; Warning in strwidth(comp$text, units = &quot;inch&quot;, family = comp$fontfamily, : no</span><br><span class="line">#&gt; font could be found for family &quot;monospace&quot;</span><br><span class="line">#&gt; Warning in strwidth(comp$text, units = &quot;inch&quot;, family = comp$fontfamily, : font</span><br><span class="line">#&gt; family &#x27;monospace&#x27; not found, will use &#x27;sans&#x27; instead</span><br><span class="line"></span><br><span class="line">#&gt; Warning in strwidth(comp$text, units = &quot;inch&quot;, family = comp$fontfamily, : font</span><br><span class="line">#&gt; family &#x27;monospace&#x27; not found, will use &#x27;sans&#x27; instead</span><br></pre></td></tr></table></figure>
<div class="figure" style="text-align: center">
<img data-src="09-mapping_files/figure-html/concat-1.png" alt="Illustration of continuous and categorical scales in tmap." width="100%" />
<p class="caption">(\#fig:concat)Illustration of continuous and categorical scales in tmap.</p>
</div>
<p>\index{tmap (package)!palettes} Palettes define the color ranges associated with the bins and determined by the <code>tm_scale_*()</code> functions, and its <code>breaks</code> and <code>n</code> arguments described above.<br>
The default color palette is specified in <code>tm_layout()</code> (see Section @ref(layouts) to learn more); however, it could be quickly changed using the <code>values</code> argument.<br>
It expects a vector of colors or a new color palette name, which can be find interactively with <code>cols4all::c4a_gui()</code>.<br>
You can also add a <code>-</code> as the color palette name prefix to reverse the palette order.</p>
<p>\BeginKnitrBlock{rmdnote}<div class="rmdnote">All of the default <code>values</code> of the visual variables, such as default color palettes for different types of input variables, can be found with <code>tmap_options()$values.var</code>.</div>\EndKnitrBlock{rmdnote}</p>
<p>There are three main groups of color palettes\index{map making!color palettes}: categorical, sequential and diverging (Figure @ref(fig:colpal)), and each of them serves a different purpose.[^2]<br>
Categorical palettes consist of easily distinguishable colors and are most appropriate for categorical data without any particular order such as state names or land cover classes.<br>
Colors should be intuitive: rivers should be blue, for example, and pastures green.<br>
Avoid too many categories: maps with large legends and many colors can be uninterpretable.</p>
<!--^[
toDo:jn
tmap4??
`fill = "MAP_COLORS"` can be used in maps with a large number of individual polygons (for example, a map of individual countries) to create unique fill colors for adjacent polygons.]
-->
<p>[^2]: A fourth group of color palettes, called bivariate, also exists.<br>
They are used when we want to represent relations between two variables on one map.</p>
<p>The second group is sequential palettes.<br>
These follow a gradient, for example from light to dark colors (light colors often tend to represent lower values), and are appropriate for continuous (numeric) variables.<br>
Sequential palettes can be single (<code>greens</code> goes from light to dark blue, for example) or multi-color/hue (<code>yl_gn_bu</code> is gradient from light yellow to blue via green, for example), as demonstrated in the code chunk below — output not shown, run the code yourself to see the results!</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">tm_shape<span class="punctuation">(</span>nz<span class="punctuation">)</span> <span class="operator">+</span> tm_polygons<span class="punctuation">(</span><span class="string">&quot;Median_income&quot;</span><span class="punctuation">,</span> fill.scale <span class="operator">=</span> tm_scale<span class="punctuation">(</span>values <span class="operator">=</span> <span class="string">&quot;greens&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">tm_shape<span class="punctuation">(</span>nz<span class="punctuation">)</span> <span class="operator">+</span> tm_polygons<span class="punctuation">(</span><span class="string">&quot;Median_income&quot;</span><span class="punctuation">,</span> fill.scale <span class="operator">=</span> tm_scale<span class="punctuation">(</span>values <span class="operator">=</span> <span class="string">&quot;yl_gn_bu&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>The third group, diverging palettes, typically range between three distinct colors (purple-white-green in Figure @ref(fig:colpal)) and are usually created by joining two single-color sequential palettes with the darker colors at each end.<br>
Their main purpose is to visualize the difference from an important reference point, e.g., a certain temperature, the median household income or the mean probability for a drought event.<br>
The reference point’s value can be adjusted in <strong>tmap</strong> using the <code>midpoint</code> argument.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">tm_shape<span class="punctuation">(</span>nz<span class="punctuation">)</span> <span class="operator">+</span> </span><br><span class="line">  tm_polygons<span class="punctuation">(</span><span class="string">&quot;Median_income&quot;</span><span class="punctuation">,</span></span><br><span class="line">              fill.scale <span class="operator">=</span> tm_scale_continuous<span class="punctuation">(</span>values <span class="operator">=</span> <span class="string">&quot;pu_gn_div&quot;</span><span class="punctuation">,</span> midpoint <span class="operator">=</span> <span class="number">28000</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<div class="figure" style="text-align: center">
<img data-src="09-mapping_files/figure-html/colpal-1.png" alt="Examples of categorical, sequential and diverging palettes." width="75%" />
<p class="caption">(\#fig:colpal)Examples of categorical, sequential and diverging palettes.</p>
</div>
<p>There are two important principles for consideration when working with colors: perceptibility and accessibility.<br>
Firstly, colors on maps should match our perception.<br>
This means that certain colors are viewed through our experience and also cultural lenses.<br>
For example, green colors usually represent vegetation or lowlands and blue is connected with water or cool.<br>
Color palettes should also be easy to understand to effectively convey information.<br>
It should be clear which values are lower and which are higher, and colors should change gradually.</p>
<!--toDo:jn--> <!-- update and improve --> <!-- This property is not preserved in the rainbow color palette; therefore, we suggest avoiding it in geographic data visualization. --> <!-- Instead, [the viridis color palettes](https://cran.r-project.org/web/packages/viridis/), also available in **tmap**, can be used. --> Secondly, changes in colors should be accessible to the largest number of people.
<p>Therefore, it is important to use colorblind friendly palettes as often as possible.[^3]</p>
<p>[^3]: See the “Color vision” options and the “Color Blind Friendliness” panel in <code>cols4all::c4a_gui()</code>.</p>
<h2 id="图例">图例</h2>
<p>\index{tmap (package)!legends} After we decided on our visual variable and its properties, we should move our attention toward the related map legend style.<br>
Using the <code>tm_legend()</code> function, we may change its title, position, orientation, or even disable it.<br>
The most important argument in this function is <code>title</code>, which sets the title of the associated legend.<br>
In general, a map legend title should provide two pieces of information: what the legend represents and what are the units of the presented variable.<br>
The following code chunk demonstrates this functionality by providing a more attractive name than the variable name <code>Land_area</code> (note the use of <code>expression()</code> to create superscript text):</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">legend_title <span class="operator">=</span> <span class="built_in">expression</span><span class="punctuation">(</span><span class="string">&quot;Area (km&quot;</span><span class="operator">^</span><span class="number">2</span><span class="operator">*</span><span class="string">&quot;)&quot;</span><span class="punctuation">)</span></span><br><span class="line">map_nza <span class="operator">=</span> tm_shape<span class="punctuation">(</span>nz<span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  tm_polygons<span class="punctuation">(</span>fill <span class="operator">=</span> <span class="string">&quot;Land_area&quot;</span><span class="punctuation">,</span> fill.legend <span class="operator">=</span> tm_legend<span class="punctuation">(</span>title <span class="operator">=</span> legend_title<span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>The default legend orientation in <strong>tmap</strong> is <code>&quot;portrait&quot;</code>, however, an alternative legend orientation, <code>&quot;landscape&quot;</code>, is also possible.<br>
Other than that, we can also customize the location of the legend using the <code>position</code> argument.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">map_nza2 <span class="operator">=</span> tm_shape<span class="punctuation">(</span>nz<span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  tm_polygons<span class="punctuation">(</span>fill <span class="operator">=</span> <span class="string">&quot;Land_area&quot;</span><span class="punctuation">,</span> fill.legend <span class="operator">=</span> tm_legend<span class="punctuation">(</span>title <span class="operator">=</span> legend_title<span class="punctuation">,</span></span><br><span class="line">                                                          orientation <span class="operator">=</span> <span class="string">&quot;landscape&quot;</span><span class="punctuation">,</span></span><br><span class="line">                                                          position <span class="operator">=</span> tm_pos_out<span class="punctuation">(</span><span class="string">&quot;center&quot;</span><span class="punctuation">,</span> <span class="string">&quot;bottom&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>The legend position (and also the position of several other map elements in <strong>tmap</strong>) can be customized using one of a few functions.<br>
The two most important are:</p>
<ul>
<li><code>tm_pos_out()</code>: the default, adds the legend outside of the map frame area. We can customize its location with two values that represent the horizontal position (<code>&quot;left&quot;</code>, <code>&quot;center&quot;</code>, or <code>&quot;right&quot;</code>), and the vertical position (<code>&quot;bottom&quot;</code>, <code>&quot;center&quot;</code>, or <code>&quot;top&quot;</code>)</li>
<li><code>tm_pos_in()</code>: puts the legend inside of the map frame area. We may decided on its position using two arguments, where the first one can be <code>&quot;left&quot;</code>, <code>&quot;center&quot;</code>, or <code>&quot;right&quot;</code>, and the second one can be <code>&quot;bottom&quot;</code>, <code>&quot;center&quot;</code>, or <code>&quot;top&quot;</code>.</li>
</ul>
<p>Alternatively, we may just provide a vector of two values (or two numbers between 0 and 1) here – and in such case, the legend will be put inside the map frame.</p>
<h2 id="布局">布局</h2>
<p>\index{tmap (package)!layouts} The map layout refers to the combination of all map elements into a cohesive map.<br>
Map elements include among others the objects to be mapped, the title, the scale bar, the map grid, and margins, while the color settings covered in the previous section relate to the palette and break-points used to affect how the map looks.<br>
Both may result in subtle changes that can have an equally large impact on the impression left by your maps.</p>
<p>Additional map elements such as graticules \index{tmap (package)!graticules}, north arrows\index{tmap (package)!north arrows}, scale bars\index{tmap (package)!scale bars} and map titles have their own functions: <code>tm_graticules()</code>, <code>tm_compass()</code>, <code>tm_scalebar()</code>, and <code>tm_title()</code> (Figure @ref(fig:na-sb)).[^4]</p>
<p>[^4]: Another additional map elements include <code>tm_grid()</code>, <code>tm_logo()</code> and <code>tm_credits()</code>.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">map_nz <span class="operator">+</span> </span><br><span class="line">  tm_graticules<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  tm_compass<span class="punctuation">(</span>type <span class="operator">=</span> <span class="string">&quot;8star&quot;</span><span class="punctuation">,</span> position <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;left&quot;</span><span class="punctuation">,</span> <span class="string">&quot;top&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  tm_scalebar<span class="punctuation">(</span>breaks <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span> <span class="number">100</span><span class="punctuation">,</span> <span class="number">200</span><span class="punctuation">)</span><span class="punctuation">,</span> text.size <span class="operator">=</span> <span class="number">1</span><span class="punctuation">,</span> position <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;left&quot;</span><span class="punctuation">,</span> <span class="string">&quot;top&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  tm_title<span class="punctuation">(</span><span class="string">&quot;New Zealand&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<div class="figure" style="text-align: center">
<img data-src="09-mapping_files/figure-html/na-sb-1.png" alt="Map with additional elements - a north arrow and scale bar." width="65%" />
<p class="caption">(\#fig:na-sb)Map with additional elements - a north arrow and scale bar.</p>
</div>
<p><strong>tmap</strong> also allows a wide variety of layout settings to be changed, some of which, produced using the following code (see <code>args(tm_layout)</code> or <code>?tm_layout</code> for a full list), are illustrated in Figure @ref(fig:layout1):</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">map_nz <span class="operator">+</span> tm_layout<span class="punctuation">(</span>scale <span class="operator">=</span> <span class="number">4</span><span class="punctuation">)</span></span><br><span class="line">map_nz <span class="operator">+</span> tm_layout<span class="punctuation">(</span>bg.color <span class="operator">=</span> <span class="string">&quot;lightblue&quot;</span><span class="punctuation">)</span></span><br><span class="line">map_nz <span class="operator">+</span> tm_layout<span class="punctuation">(</span>frame <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<div class="figure" style="text-align: center">
<img data-src="09-mapping_files/figure-html/layout1-1.png" alt="Layout options specified by (from left to right) title, scale, bg.color and frame arguments." width="100%" />
<p class="caption">(\#fig:layout1)Layout options specified by (from left to right) title, scale, bg.color and frame arguments.</p>
</div>
<p>The other arguments in <code>tm_layout()</code> provide control over many more aspects of the map in relation to the canvas on which it is placed.<br>
Here are some useful layout settings (some of which are illustrated in Figure @ref(fig:layout2)):</p>
<ul>
<li>Margin settings including <code>outer.margin</code> and <code>inner.margin</code></li>
<li>Font settings controlled by <code>fontface</code> and <code>fontfamily</code></li>
<li>Legend settings including options such as <code>legend.show</code> (whether or not to show the legend) <code>legend.orientation</code>, <code>legend.position</code>, and <code>legend.frame</code></li>
<li>Frame width (<code>frame.lwd</code>) and an option to allow double lines (<code>frame.double.line</code>)</li>
<li>Color settings controlling <code>color.sepia.intensity</code> (how <em>yellowy</em> the map looks) and <code>color.saturation</code> (a color-grayscale)</li>
</ul>
<div class="figure" style="text-align: center">
<img data-src="09-mapping_files/figure-html/layout2-1.png" alt="Illustration of selected layout options." width="100%" />
<p class="caption">(\#fig:layout2)Illustration of selected layout options.</p>
</div>
<h2 id="地图分面">地图分面</h2>
<p>\index{map making!faceted maps} \index{tmap (package)!faceted maps} Faceted maps, also referred to as ‘small multiples’, are composed of many maps arranged side-by-side, and sometimes stacked vertically.<br>
Facets enable the visualization of how spatial relationships change with respect to another variable, such as time.<br>
The changing populations of settlements, for example, can be represented in a faceted map with each panel representing the population at a particular moment in time.<br>
The time dimension could be represented via another <em>visual variable</em> such as color.<br>
However, this risks cluttering the map because it will involve multiple overlapping points (cities do not tend to move over time!).</p>
<p>Typically all individual facets in a faceted map contain the same geometry data repeated multiple times, once for each column in the attribute data (this is the default plotting method for <code>sf</code> objects, see Chapter @ref(spatial-class)).<br>
However, facets can also represent shifting geometries such as the evolution of a point pattern over time.<br>
This use case of faceted plot is illustrated in Figure @ref(fig:urban-facet).</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">urb_1970_2030 <span class="operator">=</span> urban_agglomerations <span class="operator">|&gt;</span> </span><br><span class="line">  filter<span class="punctuation">(</span>year <span class="operator">%in%</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">1970</span><span class="punctuation">,</span> <span class="number">1990</span><span class="punctuation">,</span> <span class="number">2010</span><span class="punctuation">,</span> <span class="number">2030</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">tm_shape<span class="punctuation">(</span>world<span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  tm_polygons<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  tm_shape<span class="punctuation">(</span>urb_1970_2030<span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  tm_symbols<span class="punctuation">(</span>fill <span class="operator">=</span> <span class="string">&quot;black&quot;</span><span class="punctuation">,</span> col <span class="operator">=</span> <span class="string">&quot;white&quot;</span><span class="punctuation">,</span> size <span class="operator">=</span> <span class="string">&quot;population_millions&quot;</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  tm_facets_wrap<span class="punctuation">(</span>by <span class="operator">=</span> <span class="string">&quot;year&quot;</span><span class="punctuation">,</span> nrow <span class="operator">=</span> <span class="number">2</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<div class="figure" style="text-align: center">
<img data-src="09-mapping_files/figure-html/urban-facet-1.png" alt="Faceted map showing the top 30 largest urban agglomerations from 1970 to 2030 based on population projections by the United Nations." width="100%" />
<p class="caption">(\#fig:urban-facet)Faceted map showing the top 30 largest urban agglomerations from 1970 to 2030 based on population projections by the United Nations.</p>
</div>
<p>The preceding code chunk demonstrates key features of faceted maps created using the <code>tm_facets_wrap()</code> function:</p>
<ul>
<li>Shapes that do not have a facet variable are repeated (the countries in <code>world</code> in this case)</li>
<li>The <code>by</code> argument which varies depending on a variable (<code>&quot;year&quot;</code> in this case)</li>
<li>The <code>nrow</code>/<code>ncol</code> setting specifying the number of rows and columns that facets should be arranged into</li>
</ul>
<p>Alternatively, it is possible to use the <code>tm_facets_grid()</code> function that allows to have facets based on up to three different variables: one for <code>rows</code>, one for <code>columns</code>, and possibly one for <code>pages</code>.</p>
<p>In addition to their utility for showing changing spatial relationships, faceted maps are also useful as the foundation for animated maps (see Section @ref(animated-maps)).</p>
<h2 id="插图地图">插图地图</h2>
<p>\index{map making!inset maps} \index{tmap (package)!inset maps} An inset map is a smaller map rendered within or next to the main map.<br>
It could serve many different purposes, including providing a context (Figure @ref(fig:insetmap1)) or bringing some non-contiguous regions closer to ease their comparison (Figure @ref(fig:insetmap2)).<br>
They could be also used to focus on a smaller area in more detail or to cover the same area as the map, but representing a different topic.</p>
<p>In the example below, we create a map of the central part of New Zealand’s Southern Alps.<br>
Our inset map will show where the main map is in relation to the whole New Zealand.<br>
The first step is to define the area of interest, which can be done by creating a new spatial object, <code>nz_region</code>.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">nz_region <span class="operator">=</span> st_bbox<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span>xmin <span class="operator">=</span> <span class="number">1340000</span><span class="punctuation">,</span> xmax <span class="operator">=</span> <span class="number">1450000</span><span class="punctuation">,</span></span><br><span class="line">                      ymin <span class="operator">=</span> <span class="number">5130000</span><span class="punctuation">,</span> ymax <span class="operator">=</span> <span class="number">5210000</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">                    crs <span class="operator">=</span> st_crs<span class="punctuation">(</span>nz_height<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">|&gt;</span> </span><br><span class="line">  st_as_sfc<span class="punctuation">(</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>In the second step, we create a base map showing the New Zealand’s Southern Alps area.<br>
This is a place where the most important message is stated.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">nz_height_map <span class="operator">=</span> tm_shape<span class="punctuation">(</span>nz_elev<span class="punctuation">,</span> bbox <span class="operator">=</span> nz_region<span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  tm_raster<span class="punctuation">(</span>col.scale <span class="operator">=</span> tm_scale_continuous<span class="punctuation">(</span>values <span class="operator">=</span> <span class="string">&quot;YlGn&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">            col.legend <span class="operator">=</span> tm_legend<span class="punctuation">(</span>position <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;left&quot;</span><span class="punctuation">,</span> <span class="string">&quot;top&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  tm_shape<span class="punctuation">(</span>nz_height<span class="punctuation">)</span> <span class="operator">+</span> tm_symbols<span class="punctuation">(</span>shape <span class="operator">=</span> <span class="number">2</span><span class="punctuation">,</span> col <span class="operator">=</span> <span class="string">&quot;red&quot;</span><span class="punctuation">,</span> size <span class="operator">=</span> <span class="number">1</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  tm_scalebar<span class="punctuation">(</span>position <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;left&quot;</span><span class="punctuation">,</span> <span class="string">&quot;bottom&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>The third step consists of the inset map creation.<br>
It gives a context and helps to locate the area of interest.<br>
Importantly, this map needs to clearly indicate the location of the main map, for example by stating its borders.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">nz_map <span class="operator">=</span> tm_shape<span class="punctuation">(</span>nz<span class="punctuation">)</span> <span class="operator">+</span> tm_polygons<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  tm_shape<span class="punctuation">(</span>nz_height<span class="punctuation">)</span> <span class="operator">+</span> tm_symbols<span class="punctuation">(</span>shape <span class="operator">=</span> <span class="number">2</span><span class="punctuation">,</span> col <span class="operator">=</span> <span class="string">&quot;red&quot;</span><span class="punctuation">,</span> size <span class="operator">=</span> <span class="number">0.1</span><span class="punctuation">)</span> <span class="operator">+</span> </span><br><span class="line">  tm_shape<span class="punctuation">(</span>nz_region<span class="punctuation">)</span> <span class="operator">+</span> tm_borders<span class="punctuation">(</span>lwd <span class="operator">=</span> <span class="number">3</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  tm_layout<span class="punctuation">(</span>bg.color <span class="operator">=</span> <span class="string">&quot;lightblue&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>One of the main differences between regular charts (e.g., scatterplots) and maps is that the input data determine the aspect ratio of maps.<br>
Thus, in this case, we need to calculate the aspect ratios of our two main datasets, <code>nz_region</code> and <code>nz</code>.<br>
The following function, <code>norm_dim()</code> returns the normalized width (<code>&quot;w&quot;</code>) and height (<code>&quot;h&quot;</code>) of the object (as <code>&quot;snpc&quot;</code> units understood my the graphic device).</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>grid<span class="punctuation">)</span></span><br><span class="line">norm_dim <span class="operator">=</span> <span class="keyword">function</span><span class="punctuation">(</span>obj<span class="punctuation">)</span><span class="punctuation">&#123;</span></span><br><span class="line">    bbox <span class="operator">=</span> st_bbox<span class="punctuation">(</span>obj<span class="punctuation">)</span></span><br><span class="line">    width <span class="operator">=</span> bbox<span class="punctuation">[[</span><span class="string">&quot;xmax&quot;</span><span class="punctuation">]</span><span class="punctuation">]</span> <span class="operator">-</span> bbox<span class="punctuation">[[</span><span class="string">&quot;xmin&quot;</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line">    height <span class="operator">=</span> bbox<span class="punctuation">[[</span><span class="string">&quot;ymax&quot;</span><span class="punctuation">]</span><span class="punctuation">]</span> <span class="operator">-</span> bbox<span class="punctuation">[[</span><span class="string">&quot;ymin&quot;</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line">    w <span class="operator">=</span> width <span class="operator">/</span> <span class="built_in">max</span><span class="punctuation">(</span>width<span class="punctuation">,</span> height<span class="punctuation">)</span></span><br><span class="line">    h <span class="operator">=</span> height <span class="operator">/</span> <span class="built_in">max</span><span class="punctuation">(</span>width<span class="punctuation">,</span> height<span class="punctuation">)</span></span><br><span class="line">    <span class="built_in">return</span><span class="punctuation">(</span>unit<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span>w<span class="punctuation">,</span> h<span class="punctuation">)</span><span class="punctuation">,</span> <span class="string">&quot;snpc&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line">main_dim <span class="operator">=</span> norm_dim<span class="punctuation">(</span>nz_region<span class="punctuation">)</span></span><br><span class="line">ins_dim <span class="operator">=</span> norm_dim<span class="punctuation">(</span>nz<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>Next, knowing the aspect ratios, we need to specify the sizes and locations of our two maps – the main map and the inset map – using the <code>viewport()</code> function.<br>
A viewport is part of a graphics device we use to draw the graphical elements at a given moment.<br>
The viewport of our main map is just the representation of its aspect ratio.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">main_vp <span class="operator">=</span> viewport<span class="punctuation">(</span>width <span class="operator">=</span> main_dim<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">,</span> height <span class="operator">=</span> main_dim<span class="punctuation">[</span><span class="number">2</span><span class="punctuation">]</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>On the other hand, the viewport of the inset map needs to specify its size and location.<br>
Here, we would make the inset map twice smaller as the main one by multiplying the width and height by 0.5, and we will locate it 0.5 cm from the bottom right of the main map frame.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ins_vp <span class="operator">=</span> viewport<span class="punctuation">(</span>width <span class="operator">=</span> ins_dim<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="operator">*</span> <span class="number">0.5</span><span class="punctuation">,</span> height <span class="operator">=</span> ins_dim<span class="punctuation">[</span><span class="number">2</span><span class="punctuation">]</span> <span class="operator">*</span> <span class="number">0.5</span><span class="punctuation">,</span></span><br><span class="line">                  x <span class="operator">=</span> unit<span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span> <span class="string">&quot;npc&quot;</span><span class="punctuation">)</span> <span class="operator">-</span> unit<span class="punctuation">(</span><span class="number">0.5</span><span class="punctuation">,</span> <span class="string">&quot;cm&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> y <span class="operator">=</span> unit<span class="punctuation">(</span><span class="number">0.5</span><span class="punctuation">,</span> <span class="string">&quot;cm&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">                  just <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;right&quot;</span><span class="punctuation">,</span> <span class="string">&quot;bottom&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>Finally, we combine the two maps by creating a new, blank canvas, printing out the main map, and then placing the inset map inside of the main map viewport.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">grid.newpage<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line">print<span class="punctuation">(</span>nz_height_map<span class="punctuation">,</span> vp <span class="operator">=</span> main_vp<span class="punctuation">)</span></span><br><span class="line">pushViewport<span class="punctuation">(</span>main_vp<span class="punctuation">)</span></span><br><span class="line">print<span class="punctuation">(</span>nz_map<span class="punctuation">,</span> vp <span class="operator">=</span> ins_vp<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<div class="figure" style="text-align: center">
<img data-src="09-mapping_files/figure-html/insetmap1-1.png" alt="Inset map providing a context - location of the central part of the Southern Alps in New Zealand." width="100%" />
<p class="caption">(\#fig:insetmap1)Inset map providing a context - location of the central part of the Southern Alps in New Zealand.</p>
</div>
<p>Inset map can be saved to file either by using a graphic device (see Section @ref(visual-outputs)) or the <code>tmap_save()</code> function and its arguments - <code>insets_tm</code> and <code>insets_vp</code>.</p>
<p>Inset maps are also used to create one map of non-contiguous areas.<br>
Probably, the most often used example is a map of the United States, which consists of the contiguous United States, Hawaii and Alaska.<br>
It is very important to find the best projection for each individual inset in these types of cases (see Chapter @ref(reproj-geo-data) to learn more).<br>
We can use US National Atlas Equal Area for the map of the contiguous United States by putting its EPSG code in the <code>projection</code> argument of <code>tm_shape()</code>.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">us_states_map <span class="operator">=</span> tm_shape<span class="punctuation">(</span>us_states<span class="punctuation">,</span> projection <span class="operator">=</span> <span class="string">&quot;EPSG:2163&quot;</span><span class="punctuation">)</span> <span class="operator">+</span> tm_polygons<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">+</span> </span><br><span class="line">  tm_layout<span class="punctuation">(</span>frame <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>The rest of our objects, <code>hawaii</code> and <code>alaska</code>, already have proper projections; therefore, we just need to create two separate maps:</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">hawaii_map <span class="operator">=</span> tm_shape<span class="punctuation">(</span>hawaii<span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  tm_polygons<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">+</span> </span><br><span class="line">  tm_title<span class="punctuation">(</span><span class="string">&quot;Hawaii&quot;</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  tm_layout<span class="punctuation">(</span>frame <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">,</span> bg.color <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">,</span> </span><br><span class="line">            title.position <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;LEFT&quot;</span><span class="punctuation">,</span> <span class="string">&quot;BOTTOM&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">alaska_map <span class="operator">=</span> tm_shape<span class="punctuation">(</span>alaska<span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  tm_polygons<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">+</span> </span><br><span class="line">  tm_title<span class="punctuation">(</span><span class="string">&quot;Alaska&quot;</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  tm_layout<span class="punctuation">(</span>frame <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">,</span> bg.color <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>The final map is created by combining and arranging these three maps:</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">us_states_map</span><br><span class="line">print<span class="punctuation">(</span>hawaii_map<span class="punctuation">,</span> vp <span class="operator">=</span> grid<span class="operator">::</span>viewport<span class="punctuation">(</span><span class="number">0.35</span><span class="punctuation">,</span> <span class="number">0.1</span><span class="punctuation">,</span> width <span class="operator">=</span> <span class="number">0.2</span><span class="punctuation">,</span> height <span class="operator">=</span> <span class="number">0.1</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">print<span class="punctuation">(</span>alaska_map<span class="punctuation">,</span> vp <span class="operator">=</span> grid<span class="operator">::</span>viewport<span class="punctuation">(</span><span class="number">0.15</span><span class="punctuation">,</span> <span class="number">0.15</span><span class="punctuation">,</span> width <span class="operator">=</span> <span class="number">0.3</span><span class="punctuation">,</span> height <span class="operator">=</span> <span class="number">0.3</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<div class="figure" style="text-align: center">
<img data-src="09-mapping_files/figure-html/insetmap2-1.png" alt="Map of the United States." width="100%" />
<p class="caption">(\#fig:insetmap2)Map of the United States.</p>
</div>
<p>The code presented above is compact and can be used as the basis for other inset maps but the results, in Figure @ref(fig:insetmap2), provide a poor representation of the locations of Hawaii and Alaska.<br>
For a more in-depth approach, see the <a href="https://geocompx.github.io/geocompkg/articles/us-map.html"><code>us-map</code></a> vignette from the <strong>geocompkg</strong>.</p>
<h1>动画地图</h1>
<p>\index{map making!animated maps} \index{tmap (package)!animated maps} Faceted maps, described in Section @ref(faceted-maps), can show how spatial distributions of variables change (e.g., over time), but the approach has disadvantages.<br>
Facets become tiny when there are many of them.<br>
Furthermore, the fact that each facet is physically separated on the screen or page means that subtle differences between facets can be hard to detect.</p>
<p>Animated maps solve these issues.<br>
Although they depend on digital publication, this is becoming less of an issue as more and more content moves online.<br>
Animated maps can still enhance paper reports: you can always link readers to a web-page containing an animated (or interactive) version of a printed map to help make it come alive.<br>
There are several ways to generate animations in R, including with animation packages such as <strong>gganimate</strong>, which builds on <strong>ggplot2</strong> (see Section @ref(other-mapping-packages)).<br>
This section focuses on creating animated maps with <strong>tmap</strong> because its syntax will be familiar from previous sections and the flexibility of the approach.</p>
<p>Figure @ref(fig:urban-animated) is a simple example of an animated map.<br>
Unlike the faceted plot, it does not squeeze multiple maps into a single screen and allows the reader to see how the spatial distribution of the world’s most populous agglomerations evolve over time (see the book’s website for the animated version).</p>
<div class="figure" style="text-align: center">
<img data-src="figures/urban-animated.gif" alt="Animated map showing the top 30 largest urban agglomerations from 1950 to 2030 based on population projects by the United Nations. Animated version available online at: r.geocompx.org." width="100%" />
<p class="caption">(\#fig:urban-animated)Animated map showing the top 30 largest urban agglomerations from 1950 to 2030 based on population projects by the United Nations. Animated version available online at: r.geocompx.org.</p>
</div>
<p>The animated map illustrated in Figure @ref(fig:urban-animated) can be created using the same <strong>tmap</strong> techniques that generate faceted maps, demonstrated in Section @ref(faceted-maps).<br>
There are two differences, however, related to arguments in <code>tm_facets()</code>:</p>
<ul>
<li><code>nrow = 1, ncol = 1</code> are added to keep one moment in time as one layer</li>
<li><code>free.coords = FALSE</code>, which maintains the map extent for each map iteration</li>
</ul>
<p>These additional arguments are demonstrated in the subsequent code chunk[^5]:</p>
<p>[^5]: There is also a shortcut for this approach: <code>tm_facets_pagewise()</code>.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">urb_anim <span class="operator">=</span> tm_shape<span class="punctuation">(</span>world<span class="punctuation">)</span> <span class="operator">+</span> tm_polygons<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">+</span> </span><br><span class="line">  tm_shape<span class="punctuation">(</span>urban_agglomerations<span class="punctuation">)</span> <span class="operator">+</span> tm_symbols<span class="punctuation">(</span>size <span class="operator">=</span> <span class="string">&quot;population_millions&quot;</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  tm_facets<span class="punctuation">(</span>by <span class="operator">=</span> <span class="string">&quot;year&quot;</span><span class="punctuation">,</span> nrow <span class="operator">=</span> <span class="number">1</span><span class="punctuation">,</span> ncol <span class="operator">=</span> <span class="number">1</span><span class="punctuation">,</span> free.coords <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>The resulting <code>urb_anim</code> represents a set of separate maps for each year.<br>
The final stage is to combine them and save the result as a <code>.gif</code> file with <code>tmap_animation()</code>.<br>
The following command creates the animation illustrated in Figure @ref(fig:urban-animated), with a few elements missing, that we will add in during the exercises:</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">tmap_animation<span class="punctuation">(</span>urb_anim<span class="punctuation">,</span> filename <span class="operator">=</span> <span class="string">&quot;urb_anim.gif&quot;</span><span class="punctuation">,</span> delay <span class="operator">=</span> <span class="number">25</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>Another illustration of the power of animated maps is provided in Figure @ref(fig:animus).<br>
This shows the development of states in the United States, which first formed in the east and then incrementally to the west and finally into the interior.<br>
Code to reproduce this map can be found in the script <code>09-usboundaries.R</code>.</p>
<div class="figure" style="text-align: center">
<img data-src="https://user-images.githubusercontent.com/1825120/38543030-5794b6f0-3c9b-11e8-9da9-10ec1f3ea726.gif" alt="Animated map showing population growth, state formation and boundary changes in the United States, 1790-2010. Animated version available online at r.geocompx.org." width="100%" />
<p class="caption">(\#fig:animus)Animated map showing population growth, state formation and boundary changes in the United States, 1790-2010. Animated version available online at r.geocompx.org.</p>
</div>
<h1>交互地图</h1>
<p>\index{map making!interactive maps} \index{tmap (package)!interactive maps} While static and animated maps can enliven geographic datasets, interactive maps can take them to a new level.<br>
Interactivity can take many forms, the most common and useful of which is the ability to pan around and zoom into any part of a geographic dataset overlaid on a ‘web map’ to show context.<br>
Less advanced interactivity levels include popups which appear when you click on different features, a kind of interactive label.<br>
More advanced levels of interactivity include the ability to tilt and rotate maps, as demonstrated in the <strong>mapdeck</strong> example below, and the provision of “dynamically linked” sub-plots which automatically update when the user pans and zooms.</p>
<p>The most important type of interactivity, however, is the display of geographic data on interactive or ‘slippy’ web maps.<br>
The release of the <strong>leaflet</strong> package in 2015 (that uses the leaflet JavaScript library) revolutionized interactive web map creation from within R and a number of packages have built on these foundations adding new features (e.g., <strong>leaflet.extras</strong>) and making the creation of web maps as simple as creating static maps (e.g., <strong>mapview</strong> and <strong>tmap</strong>).<br>
This section illustrates each approach in the opposite order.<br>
We will explore how to make slippy maps with <strong>tmap</strong> (the syntax of which we have already learned), <strong>mapview</strong>\index{mapview (package)}, <strong>mapdeck</strong>\index{mapdeck (package)} and finally <strong>leaflet</strong>\index{leaflet (package)} (which provides low-level control over interactive maps).</p>
<p>A unique feature of <strong>tmap</strong> mentioned in Section @ref(static-maps) is its ability to create static and interactive maps using the same code.<br>
Maps can be viewed interactively at any point by switching to view mode, using the command <code>tmap_mode(&quot;view&quot;)</code>.<br>
This is demonstrated in the code below, which creates an interactive map of New Zealand based on the <code>tmap</code> object <code>map_nz</code>, created in Section @ref(map-obj), and illustrated in Figure @ref(fig:tmview):</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">tmap_mode<span class="punctuation">(</span><span class="string">&quot;view&quot;</span><span class="punctuation">)</span></span><br><span class="line">map_nz</span><br></pre></td></tr></table></figure>
<div class="figure" style="text-align: center">
<iframe src="https://geocompx.org/static/img/tmview-1.html" width="100%" height="400px" data-external="1"></iframe>
<p class="caption">(\#fig:tmview)Interactive map of New Zealand created with tmap in view mode. Interactive version available online at: r.geocompx.org.</p>
</div>
<!--toDo:jn-->
<!-- tmap_leaflet? -->
<p>Now that the interactive mode has been ‘turned on’, all maps produced with <strong>tmap</strong> will launch (another way to create interactive maps is with the <code>tmap_leaflet()</code> function).<br>
Notable features of this interactive mode include the ability to specify the basemap with <code>tm_basemap()</code> (or <code>tmap_options()</code>) as demonstrated below (result not shown):</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">map_nz <span class="operator">+</span> tm_basemap<span class="punctuation">(</span>server <span class="operator">=</span> <span class="string">&quot;OpenTopoMap&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>An impressive and little-known feature of <strong>tmap</strong>’s view mode is that it also works with faceted plots.<br>
The argument <code>sync</code> in <code>tm_facets()</code> can be used in this case to produce multiple maps with synchronized zoom and pan settings, as illustrated in Figure @ref(fig:sync), which was produced by the following code:</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">world_coffee <span class="operator">=</span> left_join<span class="punctuation">(</span>world<span class="punctuation">,</span> coffee_data<span class="punctuation">,</span> by <span class="operator">=</span> <span class="string">&quot;name_long&quot;</span><span class="punctuation">)</span></span><br><span class="line">facets <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;coffee_production_2016&quot;</span><span class="punctuation">,</span> <span class="string">&quot;coffee_production_2017&quot;</span><span class="punctuation">)</span></span><br><span class="line">tm_shape<span class="punctuation">(</span>world_coffee<span class="punctuation">)</span> <span class="operator">+</span> tm_polygons<span class="punctuation">(</span>facets<span class="punctuation">)</span> <span class="operator">+</span> </span><br><span class="line">  tm_facets_wrap<span class="punctuation">(</span>nrow <span class="operator">=</span> <span class="number">1</span><span class="punctuation">,</span> sync <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<div class="figure" style="text-align: center">
<img data-src="figures/interactive-facets.png" alt="Faceted interactive maps of global coffee production in 2016 and 2017 in sync, demonstrating tmap's view mode in action." width="100%" />
<p class="caption">(\#fig:sync)Faceted interactive maps of global coffee production in 2016 and 2017 in sync, demonstrating tmap's view mode in action.</p>
</div>
<p>Switch <strong>tmap</strong> back to plotting mode with the same function:</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">tmap_mode<span class="punctuation">(</span><span class="string">&quot;plot&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; tmap mode set to &#x27;plot&#x27;</span></span><br></pre></td></tr></table></figure>
<p>If you are not proficient with <strong>tmap</strong>, the quickest way to create interactive maps in R may be with <strong>mapview</strong>\index{mapview (package)}.<br>
The following ‘one liner’ is a reliable way to interactively explore a wide range of geographic data formats:</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">mapview<span class="operator">::</span>mapview<span class="punctuation">(</span>nz<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<div class="figure" style="text-align: center">
<img data-src="figures/mapview.png" alt="Illustration of mapview in action." width="100%" />
<p class="caption">(\#fig:mapview)Illustration of mapview in action.</p>
</div>
<p><strong>mapview</strong> has a concise syntax yet is powerful.<br>
By default, it has some standard GIS functionality such as mouse position information, attribute queries (via pop-ups), scale bar, and zoom-to-layer buttons.<br>
It also offers advanced controls including the ability to ‘burst’ datasets into multiple layers and the addition of multiple layers with <code>+</code> followed by the name of a geographic object.<br>
Additionally, it provides automatic coloring of attributes via the <code>zcol</code> argument.<br>
In essence, it can be considered a data-driven <strong>leaflet</strong> API\index{API} (see below for more information about <strong>leaflet</strong>).<br>
Given that <strong>mapview</strong> always expects a spatial object (including <code>sf</code> and <code>SpatRaster</code>) as its first argument, it works well at the end of piped expressions.<br>
Consider the following example where <strong>sf</strong> is used to intersect lines and polygons and then is visualized with <strong>mapview</strong> (Figure @ref(fig:mapview2)).</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>mapview<span class="punctuation">)</span></span><br><span class="line">oberfranken <span class="operator">=</span> subset<span class="punctuation">(</span>franconia<span class="punctuation">,</span> district <span class="operator">==</span> <span class="string">&quot;Oberfranken&quot;</span><span class="punctuation">)</span></span><br><span class="line">trails <span class="operator">|&gt;</span></span><br><span class="line">  st_transform<span class="punctuation">(</span>st_crs<span class="punctuation">(</span>oberfranken<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">  st_intersection<span class="punctuation">(</span>oberfranken<span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">  st_collection_extract<span class="punctuation">(</span><span class="string">&quot;LINESTRING&quot;</span><span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">  mapview<span class="punctuation">(</span>color <span class="operator">=</span> <span class="string">&quot;red&quot;</span><span class="punctuation">,</span> lwd <span class="operator">=</span> <span class="number">3</span><span class="punctuation">,</span> layer.name <span class="operator">=</span> <span class="string">&quot;trails&quot;</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  mapview<span class="punctuation">(</span>franconia<span class="punctuation">,</span> zcol <span class="operator">=</span> <span class="string">&quot;district&quot;</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  breweries</span><br></pre></td></tr></table></figure>
<div class="figure" style="text-align: center">
<img data-src="figures/mapview-example.png" alt="Using mapview at the end of a sf-based pipe expression." width="100%" />
<p class="caption">(\#fig:mapview2)Using mapview at the end of a sf-based pipe expression.</p>
</div>
<p>One important thing to keep in mind is that <strong>mapview</strong> layers are added via the <code>+</code> operator (similar to <strong>ggplot2</strong> or <strong>tmap</strong>).<br>
By default, <strong>mapview</strong> uses the leaflet JavaScript library to render the output maps, which is user-friendly and has a lot of features.<br>
However, some alternative rendering libraries could be more performant (work more smoothly on larger datasets).<br>
<strong>mapview</strong> allows to set alternative rendering libraries (<code>&quot;leafgl&quot;</code> and <code>&quot;mapdeck&quot;</code>) in the <code>mapviewOptions()</code>.[^6]<br>
For further information on <strong>mapview</strong>, see the package’s website at: <a href="https://r-spatial.github.io/mapview/articles/">r-spatial.github.io/mapview/</a>.</p>
<p>[^6]: You may also try to use <code>mapviewOptions(georaster = TRUE)</code> for more performant visualizations of large raster data.</p>
<p>There are other ways to create interactive maps with R.<br>
The <strong>googleway</strong> package\index{googleway (package)}, for example, provides an interactive mapping interface that is flexible and extensible (see the <a href="https://cran.r-project.org/web/packages/googleway/vignettes/googleway-vignette.html"><code>googleway-vignette</code></a> for details).<br>
Another approach by the same author is <a href="https://github.com/SymbolixAU/mapdeck"><strong>mapdeck</strong></a>, which provides access to Uber’s <code>Deck.gl</code> framework\index{mapdeck (package)}.<br>
Its use of WebGL enables it to interactively visualize large datasets up to millions of points.<br>
The package uses Mapbox <a href="https://docs.mapbox.com/help/getting-started/access-tokens/">access tokens</a>, which you must register for before using the package.</p>
<p>\BeginKnitrBlock{rmdnote}<div class="rmdnote">Note that the following block assumes the access token is stored in your R environment as <code>MAPBOX=your_unique_key</code>.<br>
This can be added with <code>usethis::edit_r_environ()</code>.</div>\EndKnitrBlock{rmdnote}</p>
<p>A unique feature of <strong>mapdeck</strong> is its provision of interactive 2.5D perspectives, illustrated in Figure @ref(fig:mapdeck).<br>
This means you can can pan, zoom and rotate around the maps, and view the data ‘extruded’ from the map.<br>
Figure @ref(fig:mapdeck), generated by the following code chunk, visualizes road traffic crashes in the UK, with bar height representing casualties per area.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>mapdeck<span class="punctuation">)</span></span><br><span class="line">set_token<span class="punctuation">(</span>Sys.getenv<span class="punctuation">(</span><span class="string">&quot;MAPBOX&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">crash_data <span class="operator">=</span> read.csv<span class="punctuation">(</span><span class="string">&quot;https://git.io/geocompr-mapdeck&quot;</span><span class="punctuation">)</span></span><br><span class="line">crash_data <span class="operator">=</span> na.omit<span class="punctuation">(</span>crash_data<span class="punctuation">)</span></span><br><span class="line">ms <span class="operator">=</span> mapdeck_style<span class="punctuation">(</span><span class="string">&quot;dark&quot;</span><span class="punctuation">)</span></span><br><span class="line">mapdeck<span class="punctuation">(</span>style <span class="operator">=</span> ms<span class="punctuation">,</span> pitch <span class="operator">=</span> <span class="number">45</span><span class="punctuation">,</span> location <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span> <span class="number">52</span><span class="punctuation">)</span><span class="punctuation">,</span> zoom <span class="operator">=</span> <span class="number">4</span><span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">  add_grid<span class="punctuation">(</span>data <span class="operator">=</span> crash_data<span class="punctuation">,</span> lat <span class="operator">=</span> <span class="string">&quot;lat&quot;</span><span class="punctuation">,</span> lon <span class="operator">=</span> <span class="string">&quot;lng&quot;</span><span class="punctuation">,</span> cell_size <span class="operator">=</span> <span class="number">1000</span><span class="punctuation">,</span></span><br><span class="line">           elevation_scale <span class="operator">=</span> <span class="number">50</span><span class="punctuation">,</span> colour_range <span class="operator">=</span> hcl.colors<span class="punctuation">(</span><span class="number">6</span><span class="punctuation">,</span> <span class="string">&quot;plasma&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<div class="figure" style="text-align: center">
<img data-src="figures/mapdeck-mini.png" alt="Map generated by mapdeck, representing road traffic casualties across the UK. Height of 1 km cells represents number of crashes." width="100%" />
<p class="caption">(\#fig:mapdeck)Map generated by mapdeck, representing road traffic casualties across the UK. Height of 1 km cells represents number of crashes.</p>
</div>
<p>You can zoom and drag the map in the browser, in addition to rotating and tilting it when pressing <code>Cmd</code>/<code>Ctrl</code>.<br>
Multiple layers can be added with the pipe operator, as demonstrated in the <a href="https://cran.r-project.org/web/packages/mapdeck/vignettes/mapdeck.html"><code>mapdeck</code> vignettes</a>.<br>
<strong>mapdeck</strong> also supports <code>sf</code> objects, as can be seen by replacing the <code>add_grid()</code> function call in the preceding code chunk with <code>add_polygon(data = lnd, layer_id = &quot;polygon_layer&quot;)</code>, to add polygons representing London to an interactive tilted map.</p>
<p>Last but not least is <strong>leaflet</strong> which is the most mature and widely used interactive mapping package in R\index{leaflet (package)}.<br>
<strong>leaflet</strong> provides a relatively low-level interface to the Leaflet JavaScript library and many of its arguments can be understood by reading the documentation of the original JavaScript library (see <a href="https://leafletjs.com/">leafletjs.com</a>).</p>
<p>Leaflet maps are created with <code>leaflet()</code>, the result of which is a <code>leaflet</code> map object which can be piped to other <strong>leaflet</strong> functions.<br>
This allows multiple map layers and control settings to be added interactively, as demonstrated in the code below which generates Figure @ref(fig:leaflet) (see <a href="https://rstudio.github.io/leaflet/">rstudio.github.io/leaflet/</a> for details).</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">pal <span class="operator">=</span> colorNumeric<span class="punctuation">(</span><span class="string">&quot;RdYlBu&quot;</span><span class="punctuation">,</span> domain <span class="operator">=</span> cycle_hire<span class="operator">$</span>nbikes<span class="punctuation">)</span></span><br><span class="line">leaflet<span class="punctuation">(</span>data <span class="operator">=</span> cycle_hire<span class="punctuation">)</span> <span class="operator">|&gt;</span> </span><br><span class="line">  addProviderTiles<span class="punctuation">(</span>providers<span class="operator">$</span>CartoDB.Positron<span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">  addCircles<span class="punctuation">(</span>col <span class="operator">=</span> <span class="operator">~</span>pal<span class="punctuation">(</span>nbikes<span class="punctuation">)</span><span class="punctuation">,</span> opacity <span class="operator">=</span> <span class="number">0.9</span><span class="punctuation">)</span> <span class="operator">|&gt;</span> </span><br><span class="line">  addPolygons<span class="punctuation">(</span>data <span class="operator">=</span> lnd<span class="punctuation">,</span> fill <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">)</span> <span class="operator">|&gt;</span> </span><br><span class="line">  addLegend<span class="punctuation">(</span>pal <span class="operator">=</span> pal<span class="punctuation">,</span> values <span class="operator">=</span> <span class="operator">~</span>nbikes<span class="punctuation">)</span> <span class="operator">|&gt;</span> </span><br><span class="line">  setView<span class="punctuation">(</span>lng <span class="operator">=</span> <span class="operator">-</span><span class="number">0.1</span><span class="punctuation">,</span> <span class="number">51.5</span><span class="punctuation">,</span> zoom <span class="operator">=</span> <span class="number">12</span><span class="punctuation">)</span> <span class="operator">|&gt;</span> </span><br><span class="line">  addMiniMap<span class="punctuation">(</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<div class="figure" style="text-align: center">
<img data-src="figures/leaflet-1.png" alt="The leaflet package in action, showing cycle hire points in London. See interactive version [online](https://geocompr.github.io/img/leaflet.html)." width="100%" />
<p class="caption">(\#fig:leaflet)The leaflet package in action, showing cycle hire points in London. See interactive version [online](https://geocompr.github.io/img/leaflet.html).</p>
</div>
<h1>地图应用</h1>
<p>\index{map making!mapping applications} The interactive web maps demonstrated in Section @ref(interactive-maps) can go far.<br>
Careful selection of layers to display, base-maps and pop-ups can be used to communicate the main results of many projects involving geocomputation.<br>
But the web mapping approach to interactivity has limitations:</p>
<ul>
<li>Although the map is interactive in terms of panning, zooming and clicking, the code is static, meaning the user interface is fixed</li>
<li>All map content is generally static in a web map, meaning that web maps cannot scale to handle large datasets easily</li>
<li>Additional layers of interactivity, such a graphs showing relationships between variables and ‘dashboards’ are difficult to create using the web-mapping approach</li>
</ul>
<p>Overcoming these limitations involves going beyond static web mapping and towards geospatial frameworks and map servers.<br>
Products in this field include <a href="https://docs.djangoproject.com/en/4.0/ref/contrib/gis/">GeoDjango</a>\index{GeoDjango} (which extends the Django web framework and is written in <a href="https://github.com/django/django">Python</a>)\index{Python}, <a href="https://github.com/mapserver/mapserver">MapServer</a>\index{MapServer} (a framework for developing web applications, largely written in C and C++)\index{C++} and <a href="https://github.com/geoserver/geoserver">GeoServer</a> (a mature and powerful map server written in Java\index{Java}).<br>
Each of these is scalable, enabling maps to be served to thousands of people daily, assuming there is sufficient public interest in your maps!<br>
The bad news is that such server-side solutions require much skilled developer time to set-up and maintain, often involving teams of people with roles such as a dedicated geospatial database administrator (<a href="https://wiki.gis.com/wiki/index.php/Database_administrator">DBA</a>).</p>
<p>Fortunately for R programmers, web mapping applications can now be rapidly created wih <strong>shiny</strong>.\index{shiny (package)} As described in the open source book <a href="https://mastering-shiny.org/">Mastering Shiny</a>, <strong>shiny</strong> is an R package and framework for converting R code into interactive web applications.<br>
You can embed interactive maps in shiny apps thanks to functions such as <code>tmap::renderTmap()</code> and <a href="https://rstudio.github.io/leaflet/shiny.html"><code>leaflet::renderLeaflet()</code></a>.<br>
This section gives some context, teaches the basics of <strong>shiny</strong> from a web mapping perspective and culminates in a full-screen mapping application in less than 100 lines of code.</p>
<p><strong>shiny</strong> is well documented at <a href="https://shiny.rstudio.com/">shiny.rstudio.com</a>, which highlights the two components of every <strong>shiny</strong> app: ‘front end’ (the bit the user sees) and ‘back end’ code.<br>
In <strong>shiny</strong> apps, these elements are typically created in objects named <code>ui</code> and <code>server</code> within an R script named <code>app.R</code>, which lives in an ‘app folder’.<br>
This allows web mapping applications to be represented in a single file, such as the <a href="https://github.com/geocompx/geocompr/blob/main/apps/CycleHireApp/app.R"><code>CycleHireApp/app.R</code></a> file in the book’s GitHub repo.</p>
<p>\BeginKnitrBlock{rmdnote}<div class="rmdnote">In <strong>shiny</strong> apps these are often split into <code>ui.R</code> (short for user interface) and <code>server.R</code> files, naming conventions used by <code>shiny-server</code>, a server-side Linux application for serving shiny apps on public-facing websites.<br>
<code>shiny-server</code> also serves apps defined by a single <code>app.R</code> file in an ‘app folder’.<br>
Learn more at: <a href="https://github.com/rstudio/shiny-server.">https://github.com/rstudio/shiny-server.</a></div>\EndKnitrBlock{rmdnote}</p>
<p>Before considering large apps, it is worth seeing a minimal example, named ‘lifeApp’, in action.[^7]<br>
The code below defines and launches — with the command <code>shinyApp()</code> — a lifeApp, which provides an interactive slider allowing users to make countries appear with progressively lower levels of life expectancy (see Figure @ref(fig:lifeApp)):</p>
<p>[^7]: The word ‘app’ in this context refers to ‘web application’ and should not be confused with smartphone apps, the more common meaning of the word.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>shiny<span class="punctuation">)</span>    <span class="comment"># for shiny apps</span></span><br><span class="line">library<span class="punctuation">(</span>leaflet<span class="punctuation">)</span>  <span class="comment"># renderLeaflet function</span></span><br><span class="line">library<span class="punctuation">(</span>spData<span class="punctuation">)</span>   <span class="comment"># loads the world dataset </span></span><br><span class="line">ui <span class="operator">=</span> fluidPage<span class="punctuation">(</span></span><br><span class="line">  sliderInput<span class="punctuation">(</span>inputId <span class="operator">=</span> <span class="string">&quot;life&quot;</span><span class="punctuation">,</span> <span class="string">&quot;Life expectancy&quot;</span><span class="punctuation">,</span> <span class="number">49</span><span class="punctuation">,</span> <span class="number">84</span><span class="punctuation">,</span> value <span class="operator">=</span> <span class="number">80</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">      leafletOutput<span class="punctuation">(</span>outputId <span class="operator">=</span> <span class="string">&quot;map&quot;</span><span class="punctuation">)</span></span><br><span class="line">  <span class="punctuation">)</span></span><br><span class="line">server <span class="operator">=</span> <span class="keyword">function</span><span class="punctuation">(</span>input<span class="punctuation">,</span> output<span class="punctuation">)</span> <span class="punctuation">&#123;</span></span><br><span class="line">  output<span class="operator">$</span>map <span class="operator">=</span> renderLeaflet<span class="punctuation">(</span><span class="punctuation">&#123;</span></span><br><span class="line">    leaflet<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">|&gt;</span> </span><br><span class="line">      <span class="comment"># addProviderTiles(&quot;OpenStreetMap.BlackAndWhite&quot;) |&gt;</span></span><br><span class="line">      addPolygons<span class="punctuation">(</span>data <span class="operator">=</span> world<span class="punctuation">[</span>world<span class="operator">$</span>lifeExp <span class="operator">&lt;</span> input<span class="operator">$</span>life<span class="punctuation">,</span> <span class="punctuation">]</span><span class="punctuation">)</span><span class="punctuation">&#125;</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line">shinyApp<span class="punctuation">(</span>ui<span class="punctuation">,</span> server<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<div class="figure" style="text-align: center">
<img data-src="figures/shiny-app.png" alt="Screenshot showing minimal example of a web mapping application created with shiny." width="100%" />
<p class="caption">(\#fig:lifeApp)Screenshot showing minimal example of a web mapping application created with shiny.</p>
</div>
<p>The <strong>user interface</strong> (<code>ui</code>) of lifeApp is created by <code>fluidPage()</code>.<br>
This contains input and output ‘widgets’ — in this case, a <code>sliderInput()</code> (many other <code>*Input()</code> functions are available) and a <code>leafletOutput()</code>.<br>
These are arranged row-wise by default, explaining why the slider interface is placed directly above the map in Figure @ref(fig:lifeApp) (see <code>?column</code> for adding content column-wise).</p>
<p>The <strong>server side</strong> (<code>server</code>) is a function with <code>input</code> and <code>output</code> arguments.<br>
<code>output</code> is a list of objects containing elements generated by <code>render*()</code> function — <code>renderLeaflet()</code> which in this example generates <code>output$map</code>.<br>
Input elements such as <code>input$life</code> referred to in the server must relate to elements that exist in the <code>ui</code> — defined by <code>inputId = &quot;life&quot;</code> in the code above.<br>
The function <code>shinyApp()</code> combines both the <code>ui</code> and <code>server</code> elements and serves the results interactively via a new R process.<br>
When you move the slider in the map shown in Figure @ref(fig:lifeApp), you are actually causing R code to re-run, although this is hidden from view in the user interface.</p>
<p>Building on this basic example and knowing where to find help (see <code>?shiny</code>), the best way forward now may be to stop reading and start programming!<br>
The recommended next step is to open the previously mentioned <a href="https://github.com/geocompx/geocompr/blob/main/apps/CycleHireApp/app.R"><code>CycleHireApp/app.R</code></a> script in an IDE of choice, modify it and re-run it repeatedly.<br>
The example contains some of the components of a web mapping application implemented in <strong>shiny</strong> and should ‘shine’ a light on how they behave.</p>
<p>The <code>CycleHireApp/app.R</code> script contains <strong>shiny</strong> functions that go beyond those demonstrated in the simple ‘lifeApp’ example.<br>
These include <code>reactive()</code> and <code>observe()</code> (for creating outputs that respond to the user interface — see <code>?reactive</code>) and <code>leafletProxy()</code> (for modifying a <code>leaflet</code> object that has already been created).<br>
Such elements are critical to the creation of web mapping applications implemented in <strong>shiny</strong>.<br>
A range of ‘events’ can be programmed including advanced functionality such as drawing new layers or subsetting data, as described in the shiny section of RStudio’s <strong>leaflet</strong> <a href="https://rstudio.github.io/leaflet/shiny.html">website</a>.</p>
<p>\BeginKnitrBlock{rmdnote}<div class="rmdnote">There are a number of ways to run a <strong>shiny</strong> app.<br>
For RStudio users, the simplest way is probably to click on the ‘Run App’ button located in the top right of the source pane when an <code>app.R</code>, <code>ui.R</code> or <code>server.R</code> script is open.<br>
<strong>shiny</strong> apps can also be initiated by using <code>runApp()</code> with the first argument being the folder containing the app code and data: <code>runApp(&quot;CycleHireApp&quot;)</code> in this case (which assumes a folder named <code>CycleHireApp</code> containing the <code>app.R</code> script is in your working directory).<br>
You can also launch apps from a Unix command line with the command <code>Rscript -e 'shiny::runApp(&quot;CycleHireApp&quot;)'</code>.</div>\EndKnitrBlock{rmdnote}</p>
<p>Experimenting with apps such as <code>CycleHireApp</code> will build not only your knowledge of web mapping applications in R, but also your practical skills.<br>
Changing the contents of <code>setView()</code>, for example, will change the starting bounding box that the user sees when the app is initiated.<br>
Such experimentation should not be done at random, but with reference to relevant documentation, starting with <code>?shiny</code>, and motivated by a desire to solve problems such as those posed in the exercises.</p>
<p><strong>shiny</strong> used in this way can make prototyping mapping applications faster and more accessible than ever before (deploying <strong>shiny</strong> apps, <a href="https://shiny.rstudio.com/deploy/">https://shiny.rstudio.com/deploy/</a>, is a separate topic beyond the scope of this chapter).<br>
Even if your applications are eventually deployed using different technologies, <strong>shiny</strong> undoubtedly allows web mapping applications to be developed in relatively few lines of code (86 in the case of CycleHireApp).<br>
That does not stop shiny apps getting rather large.<br>
The Propensity to Cycle Tool (PCT) hosted at <a href="https://www.pct.bike/">pct.bike</a>, for example, is a national mapping tool funded by the UK’s Department for Transport.<br>
The PCT is used by dozens of people each day and has multiple interactive elements based on more than 1000 lines of <a href="https://github.com/npct/pct-shiny/blob/master/regions_www/m/server.R">code</a>.</p>
<p>While such apps undoubtedly take time and effort to develop, <strong>shiny</strong> provides a framework for reproducible prototyping that should aid the development process.<br>
One potential problem with the ease of developing prototypes with <strong>shiny</strong> is the temptation to start programming too early, before the purpose of the mapping application has been envisioned in detail.<br>
For that reason, despite advocating <strong>shiny</strong>, we recommend starting with the longer established technology of a pen and paper as the first stage for interactive mapping projects.<br>
This way your prototype web applications should be limited not by technical considerations, but by your motivations and imagination.</p>
<div class="figure" style="text-align: center">
<iframe src="https://shiny.robinlovelace.net/CycleHireApp/?showcase=0" width="690" height="400px" data-external="1"></iframe>
<p class="caption">(\#fig:CycleHireApp-html)CycleHireApp, a simple web mapping application for finding the closest cycle hiring station based on your location and requirement of cycles. Interactive version available online at r.geocompx.org.</p>
</div>
<h1>其他地图包</h1>
<p><strong>tmap</strong> provides a powerful interface for creating a wide range of static maps (Section @ref(static-maps)) and also supports interactive maps (Section @ref(interactive-maps)).<br>
But there are many other options for creating maps in R.<br>
The aim of this section is to provide a taster of some of these and pointers for additional resources: map making is a surprisingly active area of R package development, so there is more to learn than can be covered here.</p>
<p>The most mature option is to use <code>plot()</code> methods provided by core spatial packages <strong>sf</strong> and <strong>terra</strong>, covered in Sections @ref(basic-map) and @ref(basic-map-raster), respectively.<br>
What we have not mentioned in those sections was that plot methods for vector and raster objects can be combined when the results draw onto the same plot area (elements such as keys in <strong>sf</strong> plots and multi-band rasters will interfere with this).<br>
This behavior is illustrated in the subsequent code chunk which generates Figure @ref(fig:nz-plot).<br>
<code>plot()</code> has many other options which can be explored by following links in the <code>?plot</code> help page and the <strong>sf</strong> vignette <a href="https://cran.r-project.org/web/packages/sf/vignettes/sf5.html"><code>sf5</code></a>.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">g <span class="operator">=</span> st_graticule<span class="punctuation">(</span>nz<span class="punctuation">,</span> lon <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">170</span><span class="punctuation">,</span> <span class="number">175</span><span class="punctuation">)</span><span class="punctuation">,</span> lat <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="operator">-</span><span class="number">45</span><span class="punctuation">,</span> <span class="operator">-</span><span class="number">40</span><span class="punctuation">,</span> <span class="operator">-</span><span class="number">35</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">plot<span class="punctuation">(</span>nz_water<span class="punctuation">,</span> graticule <span class="operator">=</span> g<span class="punctuation">,</span> axes <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> col <span class="operator">=</span> <span class="string">&quot;blue&quot;</span><span class="punctuation">)</span></span><br><span class="line">terra<span class="operator">::</span>plot<span class="punctuation">(</span>nz_elev <span class="operator">/</span> <span class="number">1000</span><span class="punctuation">,</span> add <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> axes <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">)</span></span><br><span class="line">plot<span class="punctuation">(</span>st_geometry<span class="punctuation">(</span>nz<span class="punctuation">)</span><span class="punctuation">,</span> add <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<div class="figure" style="text-align: center">
<img data-src="09-mapping_files/figure-html/nz-plot-1.png" alt="Map of New Zealand created with plot(). The legend to the right refers to elevation (1000 m above sea level)." width="100%" />
<p class="caption">(\#fig:nz-plot)Map of New Zealand created with plot(). The legend to the right refers to elevation (1000 m above sea level).</p>
</div>
<p>The <strong>tidyverse</strong>\index{tidyverse (package)} plotting package <strong>ggplot2</strong> also supports <code>sf</code> objects with <code>geom_sf()</code>\index{ggplot2 (package)}.<br>
The syntax is similar to that used by <strong>tmap</strong>: an initial <code>ggplot()</code> call is followed by one or more layers, that are added with <code>+ geom_*()</code>, where <code>*</code> represents a layer type such as <code>geom_sf()</code> (for <code>sf</code> objects) or <code>geom_points()</code> (for points).</p>
<p><strong>ggplot2</strong> plots graticules by default.<br>
The default settings for the graticules can be overridden using <code>scale_x_continuous()</code>, <code>scale_y_continuous()</code> or <a href="https://github.com/tidyverse/ggplot2/issues/2071"><code>coord_sf(datum = NA)</code></a>.<br>
Other notable features include the use of unquoted variable names encapsulated in <code>aes()</code> to indicate which aesthetics vary and switching data sources using the <code>data</code> argument, as demonstrated in the code chunk below which creates Figure @ref(fig:nz-gg2):</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>ggplot2<span class="punctuation">)</span></span><br><span class="line">g1 <span class="operator">=</span> ggplot<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">+</span> geom_sf<span class="punctuation">(</span>data <span class="operator">=</span> nz<span class="punctuation">,</span> aes<span class="punctuation">(</span>fill <span class="operator">=</span> Median_income<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  geom_sf<span class="punctuation">(</span>data <span class="operator">=</span> nz_height<span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  scale_x_continuous<span class="punctuation">(</span>breaks <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">170</span><span class="punctuation">,</span> <span class="number">175</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">g1</span><br></pre></td></tr></table></figure>
<p>Another benefit of maps based on <strong>ggplot2</strong> is that they can easily be given a level of interactivity when printed using the function <code>ggplotly()</code> from the <strong>plotly</strong> package\index{plotly (package)}.<br>
Try <code>plotly::ggplotly(g1)</code>, for example, and compare the result with other <strong>plotly</strong> mapping functions described at: <a href="https://blog.cpsievert.me/2018/03/30/visualizing-geo-spatial-data-with-sf-and-plotly/">blog.cpsievert.me</a>.</p>
<p>An advantage of <strong>ggplot2</strong> is that it has a strong user community and many add-on packages.<br>
It includes <strong>ggspatial</strong>, which enhances <strong>ggplot2</strong>’s mapping capabilities by providing options to add a north arrow (<code>annotation_north_arrow()</code>) and a scale bar (<code>annotation_scale()</code>), or to add background tiles (<code>annotation_map_tile()</code>).<br>
It also accepts various spatial data classes with <code>layer_spatial()</code>.<br>
Thus, we are able to plot <code>SpatRaster</code> objects from <strong>terra</strong> using this function as seen in Figure @ref(fig:nz-gg2).</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>ggspatial<span class="punctuation">)</span></span><br><span class="line">ggplot<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">+</span> </span><br><span class="line">  layer_spatial<span class="punctuation">(</span>nz_elev<span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  geom_sf<span class="punctuation">(</span>data <span class="operator">=</span> nz<span class="punctuation">,</span> fill <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  annotation_scale<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  scale_x_continuous<span class="punctuation">(</span>breaks <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">170</span><span class="punctuation">,</span> <span class="number">175</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  scale_fill_continuous<span class="punctuation">(</span>na.value <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>ggplot2<span class="punctuation">)</span></span><br><span class="line">g1 <span class="operator">=</span> ggplot<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">+</span> geom_sf<span class="punctuation">(</span>data <span class="operator">=</span> nz<span class="punctuation">,</span> aes<span class="punctuation">(</span>fill <span class="operator">=</span> Median_income<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  geom_sf<span class="punctuation">(</span>data <span class="operator">=</span> nz_height<span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  scale_x_continuous<span class="punctuation">(</span>breaks <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">170</span><span class="punctuation">,</span> <span class="number">175</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">g1</span><br><span class="line">library<span class="punctuation">(</span>ggspatial<span class="punctuation">)</span></span><br><span class="line">ggplot<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">+</span> </span><br><span class="line">  layer_spatial<span class="punctuation">(</span>nz_elev<span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  geom_sf<span class="punctuation">(</span>data <span class="operator">=</span> nz<span class="punctuation">,</span> fill <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  annotation_scale<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  scale_x_continuous<span class="punctuation">(</span>breaks <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">170</span><span class="punctuation">,</span> <span class="number">175</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  scale_fill_continuous<span class="punctuation">(</span>na.value <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; Warning: Removed 1348639 rows containing missing values (`geom_raster()`).</span></span><br></pre></td></tr></table></figure>
<div class="figure" style="text-align: center">
<img data-src="09-mapping_files/figure-html/nz-gg2-1.png" alt="Comparison of map of New Zealand created with ggplot2 alone (left) and ggplot2 and ggspatial (right)." width="45%" /><img data-src="09-mapping_files/figure-html/nz-gg2-2.png" alt="Comparison of map of New Zealand created with ggplot2 alone (left) and ggplot2 and ggspatial (right)." width="45%" />
<p class="caption">(\#fig:nz-gg2)Comparison of map of New Zealand created with ggplot2 alone (left) and ggplot2 and ggspatial (right).</p>
</div>
<p>At the same time, <strong>ggplot2</strong> has a few drawbacks, for example the <code>geom_sf()</code> function is not always able to create a desired legend to use from the spatial <a href="https://github.com/tidyverse/ggplot2/issues/2037">data</a>.<br>
Good additional <strong>ggplot2</strong> resources can be found in the open source <a href="https://ggplot2-book.org/">ggplot2 book</a> and in the descriptions of the multitude of ‘<strong>gg</strong>packages’ such as <strong>ggrepel</strong> and <strong>tidygraph</strong>.</p>
<p>We have covered mapping with <strong>sf</strong>, <strong>terra</strong> and <strong>ggplot2</strong> first because these packages are highly flexible, allowing for the creation of a wide range of static maps.<br>
Before we cover mapping packages for plotting a specific type of map (in the next paragraph), it is worth considering alternatives to the packages already covered for general-purpose mapping (Table @ref(tab:map-gpkg)).</p>
<table>
<caption>(\#tab:map-gpkg)Selected general-purpose mapping packages.</caption>
 <thead>
  <tr>
   <th style="text-align:left;"> Package </th>
   <th style="text-align:left;"> Title </th>
  </tr>
 </thead>
<tbody>
  <tr>
   <td style="text-align:left;"> ggplot2 </td>
   <td style="text-align:left;width: 9cm; "> Create Elegant Data Visualisations Using the Grammar of Graphics </td>
  </tr>
  <tr>
   <td style="text-align:left;"> googleway </td>
   <td style="text-align:left;width: 9cm; "> Accesses Google Maps APIs to Retrieve Data and Plot Maps </td>
  </tr>
  <tr>
   <td style="text-align:left;"> ggspatial </td>
   <td style="text-align:left;width: 9cm; "> Spatial Data Framework for ggplot2 </td>
  </tr>
  <tr>
   <td style="text-align:left;"> leaflet </td>
   <td style="text-align:left;width: 9cm; "> Create Interactive Web Maps with Leaflet </td>
  </tr>
  <tr>
   <td style="text-align:left;"> mapview </td>
   <td style="text-align:left;width: 9cm; "> Interactive Viewing of Spatial Data in R </td>
  </tr>
  <tr>
   <td style="text-align:left;"> plotly </td>
   <td style="text-align:left;width: 9cm; "> Create Interactive Web Graphics via 'plotly.js' </td>
  </tr>
  <tr>
   <td style="text-align:left;"> rasterVis </td>
   <td style="text-align:left;width: 9cm; "> Visualization Methods for Raster Data </td>
  </tr>
  <tr>
   <td style="text-align:left;"> tmap </td>
   <td style="text-align:left;width: 9cm; "> Thematic Maps </td>
  </tr>
</tbody>
</table>
<p>Table @ref(tab:map-gpkg) shows a range of mapping packages are available, and there are many others not listed in this table.<br>
Of note is <strong>mapsf</strong>, which can generate range of geographic visualizations including choropleth, ‘proportional symbol’ and ‘flow’ maps.<br>
These are documented in the <a href="https://cran.r-project.org/web/packages/mapsf/vignettes/mapsf.html"><code>mapsf</code></a>\index{mapsf (package)} vignette.</p>
<!--toDo:jn-->
<!-- recheck the list (rgdal related) -->
<p>Several packages focus on specific map types, as illustrated in Table @ref(tab:map-spkg).<br>
Such packages create cartograms that distort geographical space, create line maps, transform polygons into regular or hexagonal grids, visualize complex data on grids representing geographic topologies, and create 3D visualizations.</p>
<table>
<caption>(\#tab:map-spkg)Selected specific-purpose mapping packages, with associated metrics.</caption>
 <thead>
  <tr>
   <th style="text-align:left;"> Package </th>
   <th style="text-align:left;"> Title </th>
  </tr>
 </thead>
<tbody>
  <tr>
   <td style="text-align:left;"> cartogram </td>
   <td style="text-align:left;"> Create Cartograms with R </td>
  </tr>
  <tr>
   <td style="text-align:left;"> geogrid </td>
   <td style="text-align:left;"> Turn Geospatial Polygons into Regular or Hexagonal Grids </td>
  </tr>
  <tr>
   <td style="text-align:left;"> geofacet </td>
   <td style="text-align:left;"> 'ggplot2' Faceting Utilities for Geographical Data </td>
  </tr>
  <tr>
   <td style="text-align:left;"> linemap </td>
   <td style="text-align:left;"> Line Maps </td>
  </tr>
  <tr>
   <td style="text-align:left;"> tanaka </td>
   <td style="text-align:left;"> Design Shaded Contour Lines (or Tanaka) Maps </td>
  </tr>
  <tr>
   <td style="text-align:left;"> rayshader </td>
   <td style="text-align:left;"> Create Maps and Visualize Data in 2D and 3D </td>
  </tr>
</tbody>
</table>
<p>All of the aforementioned packages, however, have different approaches for data preparation and map creation.<br>
In the next paragraph, we focus solely on the <strong>cartogram</strong> package\index{cartogram (package)}.<br>
Therefore, we suggest to read the <a href="https://github.com/rCarto/linemap">linemap</a>\index{linemap (package)}, <a href="https://github.com/jbaileyh/geogrid">geogrid</a>\index{geogrid (package)}, <a href="https://github.com/hafen/geofacet">geofacet</a>\index{geofacet (package)}, and <a href="https://github.com/tylermorganwall/rayshader">rayshader</a>\index{rayshader (package)} documentations to learn more about them.</p>
<p>A cartogram is a map in which the geometry is proportionately distorted to represent a mapping variable.<br>
Creation of this type of map is possible in R with <strong>cartogram</strong>, which allows for creating continuous and non-contiguous area cartograms.<br>
It is not a mapping package per se, but it allows for construction of distorted spatial objects that could be plotted using any generic mapping package.</p>
<p>The <code>cartogram_cont()</code> function creates continuous area cartograms.<br>
It accepts an <code>sf</code> object and name of the variable (column) as inputs.<br>
Additionally, it is possible to modify the <code>intermax</code> argument - maximum number of iterations for the cartogram transformation.<br>
For example, we could represent median income in New Zeleand’s regions as a continuous cartogram (the right-hand panel of Figure @ref(fig:cartomap1)) as follows:</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>cartogram<span class="punctuation">)</span></span><br><span class="line">nz_carto <span class="operator">=</span> cartogram_cont<span class="punctuation">(</span>nz<span class="punctuation">,</span> <span class="string">&quot;Median_income&quot;</span><span class="punctuation">,</span> itermax <span class="operator">=</span> <span class="number">5</span><span class="punctuation">)</span></span><br><span class="line">tm_shape<span class="punctuation">(</span>nz_carto<span class="punctuation">)</span> <span class="operator">+</span> tm_polygons<span class="punctuation">(</span><span class="string">&quot;Median_income&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#&gt; Warning: Some legend items or map compoments do not fit well (e.g. due to the</span><br><span class="line">#&gt; specified font size).</span><br><span class="line"></span><br><span class="line">#&gt; Warning: Some legend items or map compoments do not fit well (e.g. due to the</span><br><span class="line">#&gt; specified font size).</span><br></pre></td></tr></table></figure>
<div class="figure" style="text-align: center">
<img data-src="09-mapping_files/figure-html/cartomap1-1.png" alt="Comparison of standard map (left) and continuous area cartogram (right)." width="100%" />
<p class="caption">(\#fig:cartomap1)Comparison of standard map (left) and continuous area cartogram (right).</p>
</div>
<p><strong>cartogram</strong> also offers creation of non-contiguous area cartograms using <code>cartogram_ncont()</code> and Dorling cartograms using <code>cartogram_dorling()</code>.<br>
Non-contiguous area cartograms are created by scaling down each region based on the provided weighting variable.<br>
Dorling cartograms consist of circles with their area proportional to the weighting variable.<br>
The code chunk below demonstrates creation of non-contiguous area and Dorling cartograms of US states’ population (Figure @ref(fig:cartomap2)):</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">us_states2163 <span class="operator">=</span> st_transform<span class="punctuation">(</span>us_states<span class="punctuation">,</span> <span class="string">&quot;EPSG:2163&quot;</span><span class="punctuation">)</span></span><br><span class="line">us_states2163_ncont <span class="operator">=</span> cartogram_ncont<span class="punctuation">(</span>us_states2163<span class="punctuation">,</span> <span class="string">&quot;total_pop_15&quot;</span><span class="punctuation">)</span></span><br><span class="line">us_states2163_dorling <span class="operator">=</span> cartogram_dorling<span class="punctuation">(</span>us_states2163<span class="punctuation">,</span> <span class="string">&quot;total_pop_15&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<!--toDo:JN-->
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line"></span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure>
<!--toDo:JN-->
<!-- update -->
<!-- New mapping packages are emerging all the time. -->
<!-- In 2018 alone, a number of mapping packages have been released on CRAN\index{CRAN}, including **mapdeck**, **mapsapi**, and **rayshader**. -->
<!-- In terms of interactive mapping, **leaflet.extras** contains many functions for extending the functionality of **leaflet** (see the end of the [`point-pattern`](https://geocompr.github.io/geocompkg/articles/point-pattern.html) vignette in the **geocompkg** website for examples of heatmaps created by **leaflet.extras**). -->
<!--toDo:JN-->
<!-- add https://github.com/riatelab/fisheye -->
<h1>练习</h1>
<p>These exercises rely on a new object, <code>africa</code>.<br>
Create it using the <code>world</code> and <code>worldbank_df</code> datasets from the <strong>spData</strong> package as follows:</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>spData<span class="punctuation">)</span></span><br><span class="line">africa <span class="operator">=</span> world <span class="operator">|&gt;</span> </span><br><span class="line">  filter<span class="punctuation">(</span>continent <span class="operator">==</span> <span class="string">&quot;Africa&quot;</span><span class="punctuation">,</span> <span class="operator">!</span><span class="built_in">is.na</span><span class="punctuation">(</span>iso_a2<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">|&gt;</span> </span><br><span class="line">  left_join<span class="punctuation">(</span>worldbank_df<span class="punctuation">,</span> by <span class="operator">=</span> <span class="string">&quot;iso_a2&quot;</span><span class="punctuation">)</span> <span class="operator">|&gt;</span> </span><br><span class="line">  select<span class="punctuation">(</span>name<span class="punctuation">,</span> subregion<span class="punctuation">,</span> gdpPercap<span class="punctuation">,</span> HDI<span class="punctuation">,</span> pop_growth<span class="punctuation">)</span> <span class="operator">|&gt;</span> </span><br><span class="line">  st_transform<span class="punctuation">(</span><span class="string">&quot;ESRI:102022&quot;</span><span class="punctuation">)</span> <span class="operator">|&gt;</span> </span><br><span class="line">  st_make_valid<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">|&gt;</span> </span><br><span class="line">  st_collection_extract<span class="punctuation">(</span><span class="string">&quot;POLYGON&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>We will also use <code>zion</code> and <code>nlcd</code> datasets from <strong>spDataLarge</strong>:</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">zion <span class="operator">=</span> read_sf<span class="punctuation">(</span><span class="punctuation">(</span>system.file<span class="punctuation">(</span><span class="string">&quot;vector/zion.gpkg&quot;</span><span class="punctuation">,</span> package <span class="operator">=</span> <span class="string">&quot;spDataLarge&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">nlcd <span class="operator">=</span> rast<span class="punctuation">(</span>system.file<span class="punctuation">(</span><span class="string">&quot;raster/nlcd.tif&quot;</span><span class="punctuation">,</span> package <span class="operator">=</span> <span class="string">&quot;spDataLarge&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>E1. Create a map showing the geographic distribution of the Human Development Index (<code>HDI</code>) across Africa with base <strong>graphics</strong> (hint: use <code>plot()</code>) and <strong>tmap</strong> packages (hint: use <code>tm_shape(africa) + ...</code>).<br>
- Name two advantages of each based on the experience.<br>
- Name three other mapping packages and an advantage of each.<br>
- Bonus: create three more maps of Africa using these three other packages.</p>
<p>E2. Extend the <strong>tmap</strong> created for the previous exercise so the legend has three bins: “High” (<code>HDI</code> above 0.7), “Medium” (<code>HDI</code> between 0.55 and 0.7) and “Low” (<code>HDI</code> below 0.55).<br>
- Bonus: improve the map aesthetics, for example by changing the legend title, class labels and color palette.</p>
<p>E3. Represent <code>africa</code>’s subregions on the map.<br>
Change the default color palette and legend title.<br>
Next, combine this map and the map created in the previous exercise into a single plot.</p>
<p>E4. Create a land cover map of the Zion National Park.<br>
- Change the default colors to match your perception of the land cover categories<br>
- Add a scale bar and north arrow and change the position of both to improve the map’s aesthetic appeal<br>
- Bonus: Add an inset map of Zion National Park’s location in the context of the Utah state. (Hint: an object representing Utah can be subset from the <code>us_states</code> dataset.)</p>
<p>E5. Create facet maps of countries in Eastern Africa:<br>
- With one facet showing HDI and the other representing population growth (hint: using variables <code>HDI</code> and <code>pop_growth</code>, respectively)<br>
- With a ‘small multiple’ per country</p>
<p>E6. Building on the previous facet map examples, create animated maps of East Africa:<br>
- Showing each country in order<br>
- Showing each country in order with a legend showing the HDI</p>
<p>E7. Create an interactive map of HDI in Africa:<br>
- With <strong>tmap</strong><br>
- With <strong>mapview</strong><br>
- With <strong>leaflet</strong><br>
- Bonus: For each approach, add a legend (if not automatically provided) and a scale bar</p>
<p>E8. Sketch on paper ideas for a web mapping app that could be used to make transport or land-use policies more evidence based:<br>
- In the city you live, for a couple of users per day<br>
- In the country you live, for dozens of users per day<br>
- Worldwide for hundreds of users per day and large data serving requirements</p>
<p>E9. Update the code in <code>coffeeApp/app.R</code> so that instead of centering on Brazil the user can select which country to focus on:<br>
- Using <code>textInput()</code><br>
- Using <code>selectInput()</code></p>
<p>E10. Reproduce Figure 9.1 and Figure 9.7 as closely as possible using the <strong>ggplot2</strong> package.</p>
<p>E11. Join <code>us_states</code> and <code>us_states_df</code> together and calculate a poverty rate for each state using the new dataset.<br>
Next, construct a continuous area cartogram based on total population.<br>
Finally, create and compare two maps of the poverty rate: (1) a standard choropleth map and (2) a map using the created cartogram boundaries.<br>
What is the information provided by the first and the second map?<br>
How do they differ from each other?</p>
<p>E12. Visualize population growth in Africa.<br>
Next, compare it with the maps of a hexagonal and regular grid created using the <strong>geogrid</strong> package.</p>
]]></content>
      <categories>
        <category>R</category>
        <category>Geocomputaion</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>Geocomputaion</tag>
      </tags>
  </entry>
  <entry>
    <title>(11)脚本、算法和函数</title>
    <url>/2023/08/20/2023-8-20-11%E8%84%9A%E6%9C%AC%E3%80%81%E7%AE%97%E6%B3%95%E5%92%8C%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<blockquote><p>本文由SCY翻译自《Geocomputation with R》<a href="https://r.geocompx.org/algorithms">第十一章</a></p>
</blockquote>
<h1>前提条件</h1>
<p>本章前提条件最小，因为它主要使用基础的R语言。<strong>sf</strong>包用于检查我们将开发的算法的结果，该算法用于计算多边形的面积。在先前知识方面，本章假设您了解在<em>空间数据</em>章中介绍的地理类以及它们如何用于表示各种各样的输入文件格式。</p>
<h1>引言</h1>
<p><em>引言</em>章阐明了地理计算不仅仅是使用现有的工具，还包括以“可共享的R脚本和函数”的形式开发新工具。本章教授可复现代码的这些基础构件。它还介绍了低级几何算法，这种算法在<em>GIS</em>章中有应用。阅读本章应有助于您理解这类算法是如何工作的，并编写可多次、由多人、在多个数据集上使用的代码。然而，单凭本章自身无法使您成为一名熟练的程序员。编程是困难的，需要大量的实践：</p>
<blockquote>
<p>要理解编程作为一种自成体系的智力活动，您必须转向计算机编程；您必须阅读和编写计算机程序——很多程序。</p>
</blockquote>
<p>有充分的理由去学习编程。虽然本章本身并未教授编程——参见像@wickham_advanced_2019、@gillespie_efficient_2016 和 @xiao_gis_2016 这样的资源，它们教授R语言和其他语言的编程——但它确实提供了一些着眼于几何数据的起点，这些起点可能是发展编程技能的良好基础。</p>
<p>本章还演示并强调了可重复性的重要性。可重复性的优点不仅仅是允许其他人复制您的工作：相对于只运行一次的代码，可重复的代码在各方面通常都更优秀，包括计算效率、‘可扩展性’（代码在大数据集上运行的能力）以及更容易进行适应和维护。</p>
<p>脚本是可重复R代码的基础，这一主题在<em>脚本</em>节中有覆盖。算法是一系列用于修改输入并得出输出的步骤的配方，如<em>几何算法</em>节所述。为了简化共享和可重复性，算法可以被放置在函数中。这是<em>函数</em>节的主题。找出多边形的质心的例子将用于整合这些概念。<em>几何操作</em>章已经介绍了一个质心函数<code>st_centroid()</code>，但这个例子突出显示了看似简单的操作其实是相对复杂代码的结果，这证实了以下的观察：</p>
<blockquote>
<p>关于空间数据问题最吸引人的一点是，对人来说看似极其简单的事情，在计算机上可能出奇地困难。</p>
</blockquote>
<p>这个例子也反映了本章的次要目标，即按照@xiao_gis_2016的说法，不是“复制现有的内容，而是展示现有内容是如何工作的”。</p>
<h1>脚本</h1>
<p>如果说包中分发的函数是R代码的基础构件，那么脚本就是将它们粘合在一起的胶水。脚本应该按照逻辑顺序存储和执行，以创建可复现的工作流，这可以手动完成，也可以使用诸如<strong>targets</strong>这样的工作流自动化工具来完成。</p>
<p>如果你是编程新手，当你第一次遇到脚本时，它们可能看起来很令人生畏，但实际上它们只是普通的文本文件。脚本通常保存为一个扩展名代表它们包含的语言的文件，例如，用Python编写的脚本使用<code>.py</code>扩展名，用Rust编写的脚本使用<code>.rs</code>扩展名。R脚本应该保存为<code>.R</code>扩展名，并且名字应该反映它们的功能。</p>
<p>一个例子是<a href="https://github.com/geocompx/geocompr/blob/main/code/11-hello.R"><code>11-hello.R</code></a>，这是一个存储在书籍仓库的<a href="https://github.com/geocompx/geocompr/blob/main/code/"><code>code</code></a>文件夹中的脚本文件。<code>11-hello.R</code>是一个非常简单的脚本，只包含两行代码，其中一行是注释。</p>
<p>这些脚本通常是科研过程中非常有用的组成部分，特别是当你需要对大量栅格和矢量数据进行处理和后续分析时，它们可以帮助你实现高度自动化和可复现的工作流程。而使用例如<strong>targets</strong>这样的工作流工具，可以进一步提高代码的结构性和可维护性。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Aim: provide a minimal R script</span></span><br><span class="line">print<span class="punctuation">(</span><span class="string">&quot;Hello geocompr&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>这个脚本的内容并不特别令人兴奋，但它说明了一点：脚本不需要复杂。保存的脚本可以通过R命令行中的<code>source()</code>函数完整地调用和执行，如下面所示。这个命令的输出显示，注释会被忽略，但<code>print()</code>命令会被执行：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">source<span class="punctuation">(</span><span class="string">&quot;code/11-hello.R&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] &quot;Hello geocompr&quot;</span></span><br></pre></td></tr></table></figure>
<p>你也可以从系统命令行shell，例如<code>bash</code>和<code>PowerShell</code>，调用R脚本，前提是<code>RScript</code>可执行文件已经<a href="https://www.reddit.com/r/Rlanguage/comments/zaovly/is_anybody_able_to_run_a_r_script_in_powershell/">配置</a>好，例如如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Rscript code/11-hello.R</span><br></pre></td></tr></table></figure>
<p>关于脚本文件中可以和不能包含什么，并没有严格的规定，也没有什么能阻止你保存错误的、不可复制的代码。不包含有效R代码的代码行应该被注释掉，通过在行的开始处添加<code>#</code>，以防止错误，如<code>11-hello.R</code>脚本中的第一行所示。然而，有一些值得遵循的惯例：</p>
<ul>
<li>按顺序编写脚本：就像电影的剧本一样，脚本应该有一个明确的顺序，比如’设置’、‘数据处理’和’保存结果’（大致相当于电影中的’开头’、‘中间’和’结尾’）。</li>
<li>向脚本添加注释，以便其他人（以及你未来的自己）能够理解它。<br>
至少，注释应该说明脚本的目的（见图@ref(fig:codecheck)）并（对于长脚本）将其划分为几个部分。<br>
这可以在RStudio\index{RStudio}中通过快捷键<code>Ctrl+Shift+R</code>来完成，它会创建’可折叠’的代码段标题。</li>
<li>最重要的是，脚本应该是可复制的：能在任何计算机上运行的自包含脚本比只能在你的计算机上、在好天气下运行的脚本更有用。<br>
这涉及到在开始时附加所需的包，从持久性来源（如可靠网站）读取数据，并确保已经采取了之前的步骤。^[<br>
之前的步骤可以用注释或者if语句来指出，比如<code>if (!exists(&quot;x&quot;)) source(&quot;x.R&quot;)</code>（如果对象<code>x</code>不存在，则会运行脚本文件<code>x.R</code>）。<br>
]</li>
</ul>
<p>在R脚本中强制可复制性是困难的，但有一些工具可以帮助。默认情况下，RStudio \index{RStudio} 会’代码检查’ R脚本，并用红色波浪线标出有问题的代码，如下图所示：</p>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309051045079.png" alt=""><br>
Code checking in RStudio. This example, from the script 11-centroid-alg.R, highlights an unclosed curly bracket on line 19.</p>
<blockquote>
<p>📌A useful tool for reproducibility is the <strong>reprex</strong> package.<br>
Its main function <code>reprex()</code> tests lines of R code to check if they are reproducible, and provides markdown output to facilitate communication on sites such as GitHub.<br>
See the web page <a href="http://reprex.tidyverse.org">reprex.tidyverse.org</a> for details.</p>
</blockquote>
<p>本节的内容适用于任何类型的R脚本。对于地理计算脚本的特殊考虑是，它们往往具有外部依赖性，例如在第@ref(read-write)章中重度使用的用于处理地理数据的核心R包所需的GDAL依赖，用于数据导入和导出。运行更专业的地理算法可能需要GIS软件依赖，如第十章所概述。处理地理数据的脚本还常常要求输入数据集以特定格式提供。这种依赖应在脚本的注释中或其所属项目的其他地方进行说明，如脚本 <a href="https://github.com/geocompx/geocompr/blob/main/code/11-centroid-alg.R"><code>11-centroid-alg.R</code></a> 所示。‘防御性’ 编程技巧和良好的错误信息可以通过检查依赖性和与用户沟通（如果某些需求未得到满足）来节省时间。如果语句，用R中的<code>if ()</code>实现，可用于发送消息或运行代码行，只有在满足某些条件时才会这样做。例如，以下代码行会在缺少某个文件时向用户发送消息：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="punctuation">(</span><span class="operator">!</span>file.exists<span class="punctuation">(</span><span class="string">&quot;required_geo_data.gpkg&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="punctuation">&#123;</span></span><br><span class="line">  message<span class="punctuation">(</span><span class="string">&quot;No file, required_geo_data.gpkg is missing!&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">&#125;</span> </span><br><span class="line"><span class="comment">#&gt; No file, required_geo_data.gpkg is missing!</span></span><br></pre></td></tr></table></figure>
<p><code>11-centroid-alg.R</code>脚本所进行的工作在下面的可复制示例中有所展示，该示例创建了一个名为<code>poly_mat</code>的预备对象，代表一个边长为9单位的正方形。这个例子显示了<code>source()</code>可以与URLs一同工作，假设你有互联网连接。如果没有，相同的脚本可以通过<code>source(&quot;code/11-centroid-alg.R&quot;)</code>来调用，前提是你之前已经下载了<a href="https://github.com/geocompx/geocompr">github.com/geocompx/geocompr</a>仓库，并且你正在<code>geocompr</code>文件夹中运行R。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">poly_mat <span class="operator">=</span> cbind<span class="punctuation">(</span></span><br><span class="line">  x <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span> <span class="number">9</span><span class="punctuation">,</span> <span class="number">9</span><span class="punctuation">,</span> <span class="number">0</span><span class="punctuation">,</span> <span class="number">0</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">  y <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span> <span class="number">0</span><span class="punctuation">,</span> <span class="number">9</span><span class="punctuation">,</span> <span class="number">9</span><span class="punctuation">,</span> <span class="number">0</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># Short URL to code/11-centroid-alg.R in the geocompr repo</span></span><br><span class="line">source<span class="punctuation">(</span><span class="string">&quot;https://t.ly/0nzj&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#&gt; [1] &quot;The area is: 81&quot;</span><br><span class="line">#&gt; [1] &quot;The coordinates of the centroid are: 4.5, 4.5&quot;</span><br></pre></td></tr></table></figure>
<h1>几何算法</h1>
<p>我们可以这么理解算法，它相当于烘焙食谱。它们是一整套指导方针，当对输入进行操作时，会得到有用/美味的结果。输入在烘焙的情况下是如面粉和糖的成分，在算法的情况下是数据和输入参数。而烘焙食谱可能导致美味的蛋糕，成功的算法应有带来环境/社会/其他利益的计算结果。在深入可复制示例之前，下面简短的历史将展示算法是如何与脚本（在<em>脚本</em>节中涉及）和函数（可以用来概括算法，使其更便携和易于使用，我们将在<em>函数</em>节中看到）相关联的。</p>
<p>&quot;算法&quot;这个词源自9世纪在巴格达出版的早期数学教科书 <em>Hisab al-jabr w’al-muqabala</em>。这本书被译成拉丁文，并变得非常流行，以至于作者的姓氏，<a href="https://en.wikipedia.org/wiki/Muhammad_ibn_Musa_al-Khwarizmi">al-Khwārizmī</a>，“被永久地当作一个科学术语来记忆：Al-Khwarizmi 变成了 Alchoarismi、Algorismi，最终变成了 algorithm” [@bellos_alex_2011]。在计算时代，算法指的是解决问题的一系列步骤，从而得出预定义的输出。输入必须在适当的数据结构中正式定义[@wise_gis_2001]。算法通常从流程图或伪代码开始，展示过程的目标，然后在代码中实现。为了简化可用性，常见的算法通常被封装在函数内，这些函数可能会隐藏一些或所有已采取的步骤（除非你查看函数的源代码，参见<em>函数</em>节）。</p>
<p>地理算法，比如我们在<em>GIS</em>章节中遇到的，是接收地理数据并通常返回地理结果的算法（同样的东西还有其他术语，比如<em>GIS算法</em>和<em>几何算法</em>）。这可能听起来简单，但这是一个深刻的主题，有一个专门的学术领域，<em>计算几何</em>，致力于它们的研究[@berg_computational_2008]，以及关于该主题的大量书籍。@orourke_computational_1998，例如，使用可复制和免费提供的C代码，以一系列逐渐复杂的几何算法介绍该主题。</p>
<p>几何算法的一个例子是找出多边形的质心的算法。有许多方法来计算质心，其中一些仅适用于特定类型的<a href="https://en.wikipedia.org/wiki/Centroid">空间数据</a>。为了本节的目的，我们选择一种容易可视化的方法：将多边形分解成许多三角形，并找出每个三角形的质心，这种方法由 @kaiser_algorithms_1993 讨论，还简短地在 @orourke_computational_1998 中提到。在编写任何代码之前，进一步将这种方法分解成离散任务会有所帮助（后来称为步骤1到步骤4，这些也可以以示意图或伪代码的形式呈现）：</p>
<ol>
<li>将多边形分成相邻的三角形。</li>
<li>找出每个三角形的质心。</li>
<li>找出每个三角形的面积。</li>
<li>找出三角形质心的面积加权平均值。</li>
</ol>
<p>这些步骤可能听起来很简单，但将单词转换成工作代码需要一些工作和大量的反复试验，即使输入有限制：算法仅适用于<em>凸多边形</em>，它们不包含大于180°的内角，不允许星形（<strong>decido</strong>和<strong>sfdct</strong>软件包可以使用外部库对非凸多边形进行三角剖分，如<a href="https://geocompx.github.io/geocompkg/articles/algorithm.html">algorithm</a> 小册子中所示，该小册子托管在 <a href="https://geocompx.org/">geocompx.org</a> 上）。</p>
<p>表示多边形最简单的数据结构是一个矩阵，其中x和y坐标在每行表示一个顶点，以追踪多边形边界的顺序，其中第一行和最后一行是相同的[@wise_gis_2001]。在这种情况下，我们将用基础的R创建一个有五个顶点的多边形，该多边形建立在<em>GIS  Algorithms</em> [@xiao_gis_2016参见<a href="https://github.com/gisalgs/geom">github.com/gisalgs</a> 以获取 Python 代码]的一个示例上，如下图所示。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># generate a simple matrix representation of a polygon:</span></span><br><span class="line">x_coords <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">10</span><span class="punctuation">,</span> <span class="number">20</span><span class="punctuation">,</span> <span class="number">12</span><span class="punctuation">,</span> <span class="number">0</span><span class="punctuation">,</span> <span class="number">0</span><span class="punctuation">,</span> <span class="number">10</span><span class="punctuation">)</span></span><br><span class="line">y_coords <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span> <span class="number">15</span><span class="punctuation">,</span> <span class="number">20</span><span class="punctuation">,</span> <span class="number">10</span><span class="punctuation">,</span> <span class="number">0</span><span class="punctuation">,</span> <span class="number">0</span><span class="punctuation">)</span></span><br><span class="line">poly_mat <span class="operator">=</span> cbind<span class="punctuation">(</span>x_coords<span class="punctuation">,</span> y_coords<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>现在我们有了一个示例数据集，我们准备进行上面概述的第1步。下面的代码展示了通过创建一个单一的三角形（<code>T1</code>）来实现这一点，该代码演示了该方法；它还通过基于<a href="https://math.stackexchange.com/a/1702606">公式</a>$1/3(a + b + c)$ 来计算其质心，从而演示了第2步，其中$a$到$c$是表示三角形顶点的坐标：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># create a point representing the origin:</span></span><br><span class="line">Origin <span class="operator">=</span> poly_mat<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span> <span class="punctuation">]</span></span><br><span class="line"><span class="comment"># create &#x27;triangle matrix&#x27;:</span></span><br><span class="line">T1 <span class="operator">=</span> rbind<span class="punctuation">(</span>Origin<span class="punctuation">,</span> poly_mat<span class="punctuation">[</span><span class="number">2</span><span class="operator">:</span><span class="number">3</span><span class="punctuation">,</span> <span class="punctuation">]</span><span class="punctuation">,</span> Origin<span class="punctuation">)</span> </span><br><span class="line">C1 <span class="operator">=</span> <span class="punctuation">(</span>T1<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="punctuation">]</span> <span class="operator">+</span> T1<span class="punctuation">[</span><span class="number">2</span><span class="punctuation">,</span><span class="punctuation">]</span> <span class="operator">+</span> T1<span class="punctuation">[</span><span class="number">3</span><span class="punctuation">,</span><span class="punctuation">]</span><span class="punctuation">)</span> <span class="operator">/</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309051050278.png" alt=""><br>
Illustration of polygon centroid calculation problem.</p>
<p>第3步是找出每个三角形的面积，以便计算一个<em>加权平均值</em>，该值会考虑到大三角形的不成比例影响。计算三角形面积的公式如下[@kaiser_algorithms_1993]：</p>
<p>$$<br>
\frac{A_x ( B_y − C_y ) + B_x ( C_y − A_y ) + C_x ( A_y − B_y )}{ 2 }<br>
$$</p>
<p>式中，$A$到$C$是三角形的三个点，而$x$和$y$分别指代 x 和 y 的维度。将这个公式翻译成能够处理矩阵表示形式的三角形 <code>T1</code> 数据的 R 代码如下（函数 <code>abs()</code> 确保了结果为正）：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># calculate the area of the triangle represented by matrix T1:</span></span><br><span class="line"><span class="built_in">abs</span><span class="punctuation">(</span>T1<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">]</span> <span class="operator">*</span> <span class="punctuation">(</span>T1<span class="punctuation">[</span><span class="number">2</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span> <span class="operator">-</span> T1<span class="punctuation">[</span><span class="number">3</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">    T1<span class="punctuation">[</span><span class="number">2</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">]</span> <span class="operator">*</span> <span class="punctuation">(</span>T1<span class="punctuation">[</span><span class="number">3</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span> <span class="operator">-</span> T1<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">    T1<span class="punctuation">[</span><span class="number">3</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">]</span> <span class="operator">*</span> <span class="punctuation">(</span>T1<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span> <span class="operator">-</span> T1<span class="punctuation">[</span><span class="number">2</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">/</span> <span class="number">2</span></span><br><span class="line"><span class="comment">#&gt; [1] 85</span></span><br></pre></td></tr></table></figure>
<p>该代码块输出了正确的结果。^[可以用以下公式（该公式假设底边是水平的）来验证结果：面积是底边宽度与高度乘积的一半，$A = B * H / 2$。在这种情况下 $10 * 10 / 2 = 50$。]问题在于代码比较笨拙，如果我们想要在另一个三角形矩阵上运行它，就必须重新键入。为了使代码更具通用性，我们将在<em>函数</em>节中看到如何将其转换为一个函数。</p>
<p>第4步要求在所有三角形上（如上面所示），而不仅仅是一个三角形上，进行第2步和第3步。这就需要<em>迭代</em>以创建表示多边形的所有三角形，如下图所示。这里使用 <code>lapply()</code>和 <code>vapply()</code>来迭代每个三角形，因为它们在基础 R 中提供了一个简洁的解决方案：^[有关文档，请参见 <code>?lapply</code>，更多关于迭代的信息，请参见第@ref(location)章。]</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">i <span class="operator">=</span> <span class="number">2</span><span class="operator">:</span><span class="punctuation">(</span>nrow<span class="punctuation">(</span>poly_mat<span class="punctuation">)</span> <span class="operator">-</span> <span class="number">2</span><span class="punctuation">)</span></span><br><span class="line">T_all <span class="operator">=</span> lapply<span class="punctuation">(</span>i<span class="punctuation">,</span> <span class="keyword">function</span><span class="punctuation">(</span>x<span class="punctuation">)</span> <span class="punctuation">&#123;</span></span><br><span class="line">  rbind<span class="punctuation">(</span>Origin<span class="punctuation">,</span> poly_mat<span class="punctuation">[</span>x<span class="operator">:</span><span class="punctuation">(</span>x <span class="operator">+</span> <span class="number">1</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="punctuation">]</span><span class="punctuation">,</span> Origin<span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">C_list <span class="operator">=</span> lapply<span class="punctuation">(</span>T_all<span class="punctuation">,</span>  <span class="keyword">function</span><span class="punctuation">(</span>x<span class="punctuation">)</span> <span class="punctuation">(</span>x<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span> <span class="punctuation">]</span> <span class="operator">+</span> x<span class="punctuation">[</span><span class="number">2</span><span class="punctuation">,</span> <span class="punctuation">]</span> <span class="operator">+</span> x<span class="punctuation">[</span><span class="number">3</span><span class="punctuation">,</span> <span class="punctuation">]</span><span class="punctuation">)</span> <span class="operator">/</span> <span class="number">3</span><span class="punctuation">)</span></span><br><span class="line">C <span class="operator">=</span> do.call<span class="punctuation">(</span>rbind<span class="punctuation">,</span> C_list<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">A <span class="operator">=</span> vapply<span class="punctuation">(</span>T_all<span class="punctuation">,</span> <span class="keyword">function</span><span class="punctuation">(</span>x<span class="punctuation">)</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="built_in">abs</span><span class="punctuation">(</span>x<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">]</span> <span class="operator">*</span> <span class="punctuation">(</span>x<span class="punctuation">[</span><span class="number">2</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span> <span class="operator">-</span> x<span class="punctuation">[</span><span class="number">3</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">        x<span class="punctuation">[</span><span class="number">2</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">]</span> <span class="operator">*</span> <span class="punctuation">(</span>x<span class="punctuation">[</span><span class="number">3</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span> <span class="operator">-</span> x<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">        x<span class="punctuation">[</span><span class="number">3</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">]</span> <span class="operator">*</span> <span class="punctuation">(</span>x<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span> <span class="operator">-</span> x<span class="punctuation">[</span><span class="number">2</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span><span class="punctuation">)</span> <span class="punctuation">)</span> <span class="operator">/</span> <span class="number">2</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span> FUN.VALUE <span class="operator">=</span> double<span class="punctuation">(</span><span class="number">1</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309051055873.png" alt=""><br>
Illustration of iterative centroid algorithm with triangles. The X represents the area-weighted centroid in iterations 2 and 3.</p>
<p>现在，我们有条件完成第4步，使用<code>sum(A)</code>来计算总面积，以及使用 <code>weighted.mean(C[, 1], A)</code> 和 <code>weighted.mean(C[, 2], A)</code> 来计算多边形的质心坐标（给警觉的读者一个练习：验证这些命令是否有效）。为了展示算法与脚本之间的联系，本节的内容已经被压缩成 <code>11-centroid-alg.R</code>。我们在<em>脚本</em>节末尾看到，这个脚本如何计算一个正方形的质心。<em>编写脚本</em> 的优点是，它适用于新的 <code>poly_mat</code> 对象（参见下面的练习，以 <code>st_centroid()</code> 为参考来验证这些结果）：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">source<span class="punctuation">(</span><span class="string">&quot;code/11-centroid-alg.R&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] &quot;The area is: 245&quot;</span></span><br><span class="line"><span class="comment">#&gt; [1] &quot;The coordinates of the centroid are: 8.83, 9.22&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面的示例表明，使用基础 R 从基础原理出发，<em>确实可以</em>开发出低级地理操作。它还表明，如果已经存在一个经过验证的解决方案，那么重新发明轮子可能是不值得的：如果我们的目标仅仅是找到多边形的质心\index{centroid}，那么将<code>poly_mat</code>表示为一个<strong>sf</strong>对象并使用现有的<code>sf::st_centroid()</code> 函数可能会更快。然而，从1^st^ 原理编写算法的巨大好处是，你将理解整个过程的每一个步骤，这是使用其他人代码时无法保证的。另一个需要考虑的因素是性能，与低级语言如C++相比，R在进行数字计算方面可能较慢（参见<em>地理计算软件</em>节），并且难以优化。如果目的是开发新方法，那么计算效率不应该是优先考虑的。这一点体现在“过早优化是编程中一切（或至少大部分）邪恶的根源”[@knuth_computer_1974]这一说法中。</p>
<p>算法开发是困难的。这一点应该从开发一个仅仅是一种相对低效的解决方案、对实际问题（实际中凸多边形并不常见）具有有限应用的基础 R 的质心算法中显而易见。这种经验应该会让人更加重视像GEO（它是 <code>sf::st_centroid()</code> 的基础）和CGAL（计算几何算法库）这样的低级地理库，这些库不仅运行快，还适用于多种类型的输入几何。<br>
这些库开源的一个重要优点是，其源代码便于学习、理解，并且（对于具备技能和信心的人）进行修改。^[事实上，CGAL函数 <code>CGAL::centroid()</code> 是由7个子函数组成的，如<a href="https://doc.cgal.org/latest/Kernel_23/group__centroid__grp.html">https://doc.cgal.org/latest/Kernel_23/group__centroid__grp.html</a> 所描述，使其能够适用于多种类型的输入数据，而我们创建的解决方案仅适用于一种非常特定的输入数据类型。GEOS 函数 <code>Centroid::getCentroid()</code> 的底层源代码可以在 <a href="https://github.com/libgeos/geos/search?q=getCentroid">https://github.com/libgeos/geos/search?q=getCentroid</a> 上找到。]</p>
<h1>函数</h1>
<p>与算法类似，函数接收一个输入并返回一个输出。然而，函数是特定编程语言中实现的，而不是“配方”本身。在 R 中，函数本身就是对象，可以以模块化的方式创建和组合。例如，我们可以创建一个执行我们质心生成算法第二步的函数，如下所示：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">t_centroid <span class="operator">=</span> <span class="keyword">function</span><span class="punctuation">(</span>x<span class="punctuation">)</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="punctuation">(</span>x<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span> <span class="punctuation">]</span> <span class="operator">+</span> x<span class="punctuation">[</span><span class="number">2</span><span class="punctuation">,</span> <span class="punctuation">]</span> <span class="operator">+</span> x<span class="punctuation">[</span><span class="number">3</span><span class="punctuation">,</span> <span class="punctuation">]</span><span class="punctuation">)</span> <span class="operator">/</span> <span class="number">3</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>上面的示例演示了<a href="https://adv-r.hadley.nz/functions.html">函数</a>的两个关键组件：1）函数 <em>主体</em>，即定义函数如何处理输入的大括号内的代码；和 2） <em>形式参数</em>，即函数使用的参数列表——在这种情况下是 <code>x</code>（第三个关键组件，环境，超出了本节的范围）。默认情况下，函数返回最后一个被计算的对象（在 <code>t_centroid()</code> 的情况下是质心的坐标）。^[你也可以通过在函数主体中添加 <code>return(output)</code> 明确设置函数的输出，其中 <code>output</code> 是要返回的结果。]</p>
<p>该函数现在适用于你传递给它的任何输入，如下面的命令所示，该命令计算了上一节中示例多边形中第1个三角形的面积：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">t_centroid<span class="punctuation">(</span>T1<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; x_coords y_coords </span></span><br><span class="line"><span class="comment">#&gt;     14.0     11.7</span></span><br></pre></td></tr></table></figure>
<p>我们还可以创建一个函数\index{function}来计算三角形的面积，我们将其命名为 <code>t_area()</code>：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">t_area <span class="operator">=</span> <span class="keyword">function</span><span class="punctuation">(</span>x<span class="punctuation">)</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="built_in">abs</span><span class="punctuation">(</span></span><br><span class="line">    x<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">]</span> <span class="operator">*</span> <span class="punctuation">(</span>x<span class="punctuation">[</span><span class="number">2</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span> <span class="operator">-</span> x<span class="punctuation">[</span><span class="number">3</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">    x<span class="punctuation">[</span><span class="number">2</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">]</span> <span class="operator">*</span> <span class="punctuation">(</span>x<span class="punctuation">[</span><span class="number">3</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span> <span class="operator">-</span> x<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">    x<span class="punctuation">[</span><span class="number">3</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">]</span> <span class="operator">*</span> <span class="punctuation">(</span>x<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span> <span class="operator">-</span> x<span class="punctuation">[</span><span class="number">2</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span><span class="punctuation">)</span></span><br><span class="line">  <span class="punctuation">)</span> <span class="operator">/</span> <span class="number">2</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>注意，在创建函数之后，可以用一行代码计算三角形的面积，避免了冗长代码的重复：函数是一种 <em>泛化</em> 代码的机制。新创建的函数<code>t_area()</code>接受任何对象<code>x</code>，假设其具有与我们一直在使用的“三角形矩阵”数据结构相同的维度，并返回其面积，如下面在<code>T1</code>上的示例：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">t_area<span class="punctuation">(</span>T1<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] 85</span></span><br></pre></td></tr></table></figure>
<p>我们可以通过使用它来找到一个新的三角形矩阵的面积来测试函数的泛化性，该三角形矩阵的高度为1，底边为3：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">t_new <span class="operator">=</span> cbind<span class="punctuation">(</span>x <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">,</span> <span class="number">0</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">              y <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span> <span class="number">0</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">0</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">t_area<span class="punctuation">(</span>t_new<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt;   x </span></span><br><span class="line"><span class="comment">#&gt; 1.5</span></span><br></pre></td></tr></table></figure>
<p>函数的一个有用特性是它们是模块化的。只要你知道输出会是什么，一个函数就可以用作另一个函数的构建块。因此，<code>t_centroid()</code> 和 <code>t_area()</code>可以用作更大的函数的子组件，以执行脚本<code>11-centroid-alg.R</code>的工作：计算任何凸多边形的面积。下面的代码块创建了 <code>poly_centroid()</code> 函数，以模仿针对凸多边形的 <code>sf::st_centroid()</code> 的行为：^[注意，我们创建的函数在 <code>lapply()</code>和 <code>vapply()</code> 函数调用中被迭代地调用。]</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">poly_centroid <span class="operator">=</span> <span class="keyword">function</span><span class="punctuation">(</span>poly_mat<span class="punctuation">)</span> <span class="punctuation">&#123;</span></span><br><span class="line">  Origin <span class="operator">=</span> poly_mat<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span> <span class="punctuation">]</span> <span class="comment"># create a point representing the origin</span></span><br><span class="line">  i <span class="operator">=</span> <span class="number">2</span><span class="operator">:</span><span class="punctuation">(</span>nrow<span class="punctuation">(</span>poly_mat<span class="punctuation">)</span> <span class="operator">-</span> <span class="number">2</span><span class="punctuation">)</span></span><br><span class="line">  T_all <span class="operator">=</span> lapply<span class="punctuation">(</span>i<span class="punctuation">,</span> <span class="keyword">function</span><span class="punctuation">(</span>x<span class="punctuation">)</span> <span class="punctuation">&#123;</span>rbind<span class="punctuation">(</span>Origin<span class="punctuation">,</span> poly_mat<span class="punctuation">[</span>x<span class="operator">:</span><span class="punctuation">(</span>x <span class="operator">+</span> <span class="number">1</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="punctuation">]</span><span class="punctuation">,</span> Origin<span class="punctuation">)</span><span class="punctuation">&#125;</span><span class="punctuation">)</span></span><br><span class="line">  C_list <span class="operator">=</span> lapply<span class="punctuation">(</span>T_all<span class="punctuation">,</span> t_centroid<span class="punctuation">)</span></span><br><span class="line">  C <span class="operator">=</span> do.call<span class="punctuation">(</span>rbind<span class="punctuation">,</span> C_list<span class="punctuation">)</span></span><br><span class="line">  A <span class="operator">=</span> vapply<span class="punctuation">(</span>T_all<span class="punctuation">,</span> t_area<span class="punctuation">,</span> FUN.VALUE <span class="operator">=</span> double<span class="punctuation">(</span><span class="number">1</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">  <span class="built_in">c</span><span class="punctuation">(</span>weighted.mean<span class="punctuation">(</span>C<span class="punctuation">[</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">]</span><span class="punctuation">,</span> A<span class="punctuation">)</span><span class="punctuation">,</span> weighted.mean<span class="punctuation">(</span>C<span class="punctuation">[</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span><span class="punctuation">,</span> A<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">poly_centroid<span class="punctuation">(</span>poly_mat<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] 8.83 9.22</span></span><br></pre></td></tr></table></figure>
<p>像 <code>poly_centroid()</code> 这样的函数可以进一步扩展以提供不同类型的输出。例如，要将结果作为类 <code>sfg</code> 的对象返回，可以使用 ‘包装器’ 函数来修改 <code>poly_centroid()</code> 的输出，然后返回结果：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">poly_centroid_sfg <span class="operator">=</span> <span class="keyword">function</span><span class="punctuation">(</span>x<span class="punctuation">)</span> <span class="punctuation">&#123;</span></span><br><span class="line">  centroid_coords <span class="operator">=</span> poly_centroid<span class="punctuation">(</span>x<span class="punctuation">)</span></span><br><span class="line">  sf<span class="operator">::</span>st_point<span class="punctuation">(</span>centroid_coords<span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>我们可以通过以下方式验证输出与 <code>sf::st_centroid()</code> 的输出相同：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">poly_sfc <span class="operator">=</span> sf<span class="operator">::</span>st_polygon<span class="punctuation">(</span><span class="built_in">list</span><span class="punctuation">(</span>poly_mat<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">identical<span class="punctuation">(</span>poly_centroid_sfg<span class="punctuation">(</span>poly_mat<span class="punctuation">)</span><span class="punctuation">,</span> sf<span class="operator">::</span>st_centroid<span class="punctuation">(</span>poly_sfc<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] FALSE</span></span><br></pre></td></tr></table></figure>
<h1>编程</h1>
<p>在本章中，我们的速度很快，从脚本到函数，再到算法这个棘手的主题。我们不仅在抽象层面上讨论了它们，还创建了针对特定问题的工作示例：</p>
<ul>
<li>介绍并演示了在’多边形矩阵’上运行的脚本<code>11-centroid-alg.R</code></li>
<li>描述了允许此脚本工作的各个步骤，被称为算法\，一个计算性的配方</li>
<li>为了通用化这个算法，我们将其转换成模块化的函数，最终组合成上一节中的函数<code>poly_centroid()</code></li>
</ul>
<p>每一个可能看似简单。然而，熟练的编程是复杂的，涉及将每个元素——脚本、算法和函数——<em>组合</em>成一个<em>系统</em>，具有效率和风格。最终的结果应该是健壮且用户友好的工具，供其他人使用。如我们预期本书的大多数读者将是编程新手，能够遵循并复现前面几节的结果是一个重大成就。编程需要许多小时的专门学习和实践才能熟练。</p>
<p>面对希望以有效方式实现新算法的开发者的挑战，可以通过考虑创建一个简单但并非用于生产的函数所付出的努力量来考虑：在当前状态下，<code>poly_centroid()</code>在大多数（非凸）多边形上失败！这提出了一个问题：如何通用化这个函数？两个选项是（1）找到三角化非凸多边形的方法（这是本章支持的在线<a href="https://geocompx.github.io/geocompkg/articles/algorithm.html">算法</a>文章所涵盖的主题）和（2）探索其他不依赖于三角网格的质心算法。</p>
<p>一个更广泛的问题是：当已经有高性能的算法被实现并打包成诸如<code>st_centroid()</code>这样的函数时，是否值得编程解决方案？在这个特定情况下，简单的答案是’否’。在更广泛的背景下，考虑到学习编程的好处，答案是’视情况而定’。在编程中，很容易浪费时间尝试实现一种方法，只有到最后才发现有人已经做了艰苦的工作。你可以把这一章看作是通往几何算法编程魔法的垫脚石。然而，它也可以被看作是何时尝试编程一个通用解决方案，以及何时使用现有的更高级解决方案的一堂课。肯定会有编写新函数是最佳方案的时候，但也会有使用已经存在的函数是最佳方案的时候。</p>
<p>“不要重复发明轮子”一样适用于编程，甚至更适用于生活中的其他方面。项目开始时进行一点研究和思考可以帮助决定编程时间最好如何使用。以下三个原则也可以帮助最大化编写代码时的努力，无论它是一个简单的脚本还是由数百个函数组成的包：</p>
<ol>
<li><a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself">DRY</a>（不要重复自己）：尽量减少代码重复，并以更少的代码行解决特定问题。<br>
这一原则在《R for Data Science》[@grolemund_r_2016]的函数章节中有解释。</li>
<li><a href="https://en.wikipedia.org/wiki/KISS_principle">KISS</a>（保持简单愚蠢）：这一原则建议首先尝试简单解决方案，优先于复杂解决方案，需要时使用依赖项，目标是保持脚本简洁。<br>
这一原则是<a href="https://www.nature.com/articles/d41586-018-05004-4">名言</a>“事物应尽量简单，但不能更简单”的计算类比。</li>
<li>模块性：如果你的代码被划分成明确定义的片段，它将更容易维护。一个函数应该只做一件事，但要做得非常好。如果你的函数变得太长，考虑将其拆分成多个小函数，每个都可以用于其他目的，支持DRY和KISS原则。</li>
</ol>
<p>我们不能保证这一章会立即让你能够为你的工作创建完美的函数。然而，我们确信其内容将帮助你决定何时是适当的尝试时机（当没有其他现有的函数解决问题，当编程任务在你的能力范围内，当解决方案的好处可能大于开发它的时间成本）。通过使用上述原则，结合通过完成上面的实例获得的实践经验，你将建立你的脚本编写、包编写和编程技能。编程的第一步可能会很慢（下面的练习不应该匆忙完成），但长期的回报可能会很大。</p>
<h1>练习</h1>
<p>E1. 阅读脚本 <a href="https://github.com/geocompx/geocompr/blob/main/code/11-centroid-alg.R"><code>11-centroid-alg.R</code></a>，它位于书籍GitHub仓库的 <code>code</code> 文件夹中。</p>
<ul>
<li>它遵循了在章节<a href="#%E8%84%9A%E6%9C%AC">1.3</a>中介绍的哪些最佳实践？</li>
<li>在你的电脑上通过一个IDE\index{IDE}（比如 RStudio\index{RStudio}）创建这个脚本的一个版本（最好是通过逐行键入脚本，用你自己的编码风格和你自己的注释，而不是复制粘贴——这将帮助你学会如何键入脚本）。以一个方形多边形为例（例如，通过 <code>poly_mat = cbind(x = c(0, 9, 9, 0, 0), y = c(0, 0, 9, 9, 0))</code> 创建），逐行执行脚本。</li>
<li>可以对脚本进行哪些更改以使其更具可重复性？</li>
<li>如何改进文档？</li>
</ul>
<p>E2. 在几何算法部分，我们计算了由 <code>poly_mat</code> 表示的多边形的面积和地理质心分别为245和8.8, 9.2。</p>
<ul>
<li>参考脚本 <a href="https://github.com/geocompx/geocompr/blob/main/code/11-centroid-alg.R"><code>11-centroid-alg.R</code></a> 在你自己的电脑上重现结果（奖励：键入命令 - 尽量避免复制粘贴）。</li>
<li>结果正确吗？通过将 <code>poly_mat</code> 转换为名为 <code>poly_sfc</code> 的 <code>sfc</code> 对象（使用 <code>st_polygon()</code>（提示：此函数接受 <code>list()</code> 类对象）），然后使用 <code>st_area()</code> 和 <code>st_centroid()</code> 来验证结果。</li>
</ul>
<p>E3. 之前提到我们创建的算法只适用于<em>凸包</em>。定义凸包（见几何运算章节），并测试该算法在一个<em>非</em>凸包的多边形上的效果。</p>
<ul>
<li>奖励1：思考为什么该方法仅适用于凸包，并注意要对算法做哪些更改才能使其适用于其他类型的多边形。</li>
<li>奖励2：基于 <code>11-centroid-alg.R</code> 的内容，仅使用基础R函数编写一个算法，找出以矩阵形式表示的线串的总长度。</li>
</ul>
<!-- Todo: 添加表示线串的矩阵的示例，演示代码以验证答案，建议解构为奖励的其他函数。 -->
<p>E4. 在函数部分，我们创建了不同版本的 <code>poly_centroid()</code> 函数，它们生成了 <code>sfg</code> 类的输出（<code>poly_centroid_sfg()</code>）和类型稳定的 <code>matrix</code> 输出（<code>poly_centroid_type_stable()</code>）。<br>
进一步扩展该函数，创建一个版本（例如，名为 <code>poly_centroid_sf()</code>），该版本是类型稳定的（仅接受 <code>sf</code> 类的输入）<em>并且</em>返回 <code>sf</code> 对象（提示：你可能需要用命令 <code>sf::st_coordinates(x)</code> 将对象 <code>x</code> 转换为矩阵）。</p>
<ul>
<li>通过运行 <code>poly_centroid_sf(sf::st_sf(sf::st_sfc(poly_sfc)))</code> 来验证它的工作原理</li>
<li>当你尝试运行 <code>poly_centroid_sf(poly_mat)</code> 时，你得到什么错误信息？</li>
</ul>
]]></content>
      <categories>
        <category>R</category>
        <category>Geocomputaion</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>Geocomputaion</tag>
      </tags>
  </entry>
  <entry>
    <title>产水量计算</title>
    <url>/2020/10/20/2023-8-20-%E4%BA%A7%E6%B0%B4%E9%87%8F%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<blockquote><p>本文由SCY原创，转载注明出处。</p>
</blockquote>
<h1>产水量模型</h1>
<p>InVEST模型的产水量：水库水电生产模块，不仅评估了景观中各次一级流域对产水的相对贡献量，而且有助于研究土地利用格局变化如何影响年地表产水量和水电生产。</p>
<p>模拟景观格局变化和水文过程的关系是个科学难题。用来模拟这些关系及其相关 过程的复杂模型（如WEAP水资源评估和规划系统模型）要求较高的数据和资源资料，并且要求大量专业知识。为满足更多学科背景需求，使用易获取的数据，InVEST模型绘制和模拟用于景观水电生产的年平均产水量，而不是直接评估土地利用/覆被变化导致的水电减产，因为这一过程在逐日和逐月的时间尺度上主要由流入水量变化决定。 因此，InVEST模型计算了景观中各子流域对产水的相对贡献量及其对应的水电产量。 水库经济使用年限内的水电生产净现值也可以通过年收益还原法计算。</p>
<span id="more"></span>
<h1><em>工作原理</em></h1>
<p>模型运行基于栅格地图。模型估算了研究区各次一级流域对水电生产贡献水量及其经济价值。模块包括三个组件，按顺序运行。</p>
<ol>
<li>模型估算了每栅格单元降水量减去实际蒸散发后的水量即水源供给量。 模型不做地表水、地下水、基流的区分，而是假设每个栅格单元的产水通过上述途径汇集到信息点。然后，模型计算出次一级流域产水量的总量和平均值。栅格计算有助于确定决定流域产汇流空间异质性的关键因素，如土壤类型，降水量，植被类型等。 但是，这组模型的基础理论基于次一级流域到流域尺度，对次一级流域过程的模型解释是可信的，因此产水量的总量和/或平均值结果也应当维持在次一级流域水平上。模型仅为校准和模型检验提供输出结果的栅格数据。这些栅格数据图件不能用于水文过程的解释说明，或作为任何类型的决策信息源。</li>
<li>模型计算了用于水电生产的水源供给量，即将水源供给总量减去除水电生产以外的其他用水量。</li>
<li>模型计算了到达水库水流的发电量及其水库有效使用年期内的经济价值。</li>
</ol>
<p><em><strong>NOTE</strong></em>: Water Yield 模块运行的前提条件是假设栅格单元的产水量都是通过地表径流或 者地下径流的方式汇集到流域出口，在这个前提条件下计算每个栅格单元的产水量, 即降水量减去植被蒸腾与地表蒸散。</p>
<p><em><strong>产水量评估模型</strong></em></p>
<p>产水量评估模块基于Budyko水热耦合平衡假设（1974）和年平均降水量数据。首先，确定研究区每个栅格单元$x$的年产水量$Y(x)$，公式如下：</p>
<p>$$<br>
Y(x)=\left(1-\frac{A E T(x)}{P(x)}\right) \cdot P(x)<br>
$$</p>
<p>$AET(x)$表示栅格单元$x$的年实际蒸散量、$P(x)$表示栅格单元$x$的年降水量。</p>
<p>水量平衡公式中，土地利用/覆被类型的植被蒸散发$\frac{A E T(x)}{P(x)}$计算，采用Fu和Zhang等提出的Budyko水热耦合平衡假设公式：</p>
<p>$$<br>
\frac{A E T(x)}{P(x)}=1+\frac{P E T(x)}{P(x)}-\left[1+\left(\frac{P E T(x)}{P(x)}\right)^{\omega}\right]^{1 / \omega}<br>
$$</p>
<p>$PET(x)$<strong>表示潜在蒸散量</strong>、$ω(x)$表示自然气候-土壤性质的非物理参数。<br>
潜在蒸散量$PET(x)$定义为：</p>
<p>$$<br>
{PET}(x)=K_{c}\left(\ell_{x}\right) \cdot E T_{0}(x)<br>
$$</p>
<p>式中，$ET_0(x)$表示栅格单元$x$的参考作物蒸散，$K_c(\ell_x)$表示栅格单元$x$中特定土地利用/覆被类型的植物（植被）蒸散系数。$ET_0(x)$通过参考作物蒸散量反映当地气候条件，例如苜蓿的蒸散量反映其草地生境气候。$K_c(\ell_x)$很大程度上取决于栅格单元$x$中土地利用/覆被的植被性质。在土地利用/覆被图中，$K_c$用于将$ET_0(x)$修正为栅格单元中特定作物或植被类型蒸散量。</p>
<p>$ω(x)$是一个经验参数，通常用$\frac{A W C \times N}{P}$线性函数表示，式中$N$表示每年的降水事件数，$AWC$表示植物可利用水含量。虽然基于全球数据的$ ω(x)  $公式亟待进一步研究， InVEST模型采用Donohue等人提出的公式表达，定义为：</p>
<p>$$<br>
$$</p>
<ul>
<li>$AWC(x)$表示土壤有效含水量（mm），由土壤质地和土壤有效深度决定，用来确定土壤为植物生长储存和提供的总水量。由植物利用水分含量$(PAWC)$， 以及土壤的最大根系埋藏深度和植物根系深度的最小值决定：</li>
</ul>
<p>$$<br>
A W C(x)=\operatorname{Min}( Re st.layer.depth, root.depth ) \cdot PAWC<br>
$$</p>
<p>土壤的最大根系埋藏深度是指由于环境的物理和化学特征不同，植物根系在土壤中能够延伸的最大深度（也叫土壤深度）。植物根系深度通常指特定植物类型的根系生物量为95%的土层深度。$PAWC$表示植物利用水分含量，即田间持水量和萎蔫点之间的差值。</p>
<ul>
<li>$Z$为经验常数，又称<code>季节常数</code>，能够代表区域降水分布及其他水文地质特征。$Z$与$N$正相关，$N$是每年降水发生次数。1.25为$ω(x)$基数，即裸地（根系深度为0）的植被年需水量和年降水量比值。$ω(x)$上限为5。</li>
</ul>
<p>其他土地利用/覆被类型（开放水域，城市，湿地）的实际蒸散发通过参考作物蒸散$ET_0(x)$直接计算，由降水量决定其最大值：</p>
<p>$$<br>
A E T(x)=\operatorname{Min}\left(K_{c}\left(\ell_{x}\right) \cdot E T_{0}(x), P(x)\right)<br>
$$</p>
<p>$ET_0(x)$表示参考作物蒸散，而$K_c(\ell_x)$表示特定土地利用/覆被类型蒸腾作用的影响因子。</p>
<h1><em><strong>数据需求</strong></em></h1>
<p>模型使用的数据需求列表如下，关于数据来源和预处理的详细信息见附录。所有数据输入前，应先定义栅格数据投影，栅格单位为米（m）。</p>
<h2 id="土壤的最大根系埋藏深度（必需）：">土壤的最大根系埋藏深度（必需）：</h2>
<p>每个栅格对应一个土壤的最大根系埋藏深度平均值的GIS栅格数据集。土壤的最大根系埋藏深度是指由于环境的物理和化学特征不同，植物根系在土壤中能够延伸的最大深度，单位毫米（mm）。根系限制层深度可从一些土壤图中获得。如果无法获得根系限制层深度或按土壤类型划分的可扎根深度，可使用土壤深度作为替代。如果有几个土壤层是详细的，那么限制根系层的深度就是非限制性土壤层的深度之和。</p>
<p>*命名：*用户自定义，但若为ESRI GRID格式，文件名不能有空格并且少于13个字， 若为TIF或IMG格式，命名可能更长。</p>
<p><em>格式：</em> GIS标准栅格文件（如：ESRI GRID，TIF或IMG），每个栅格对应一个土壤的最大根系埋藏深度平均值，单位毫米（mm）。</p>
<p><em>数据获得：</em></p>
<ol>
<li><a href="http://globalchange.bnu.edu.cn/research/cdtb.jsp" title="http://globalchange.bnu.edu.cn/research/cdtb.jsp">http://globalchange.bnu.edu.cn/research/cdtb.jsp</a> （单位为m，需转化为mm，已下载处理，上传百度☁️）<br>
原文 <a href="https://doi.org/10.1038/s41597-019-0345-6" title="https://doi.org/10.1038/s41597-019-0345-6">https://doi.org/10.1038/s41597-019-0345-6</a></li>
<li>SoilGrids250m 2017-03 - Depth to bedrock (R horizon)  （单位为cm，需转化为mm）<a href="https://data.isric.org/geonetwork/srv/eng/catalog.search#/metadata/bfb01655-db81-4571-b6eb-3caae86c037a" title="https://data.isric.org/geonetwork/srv/eng/catalog.search#/metadata/bfb01655-db81-4571-b6eb-3caae86c037a">https://data.isric.org/geonetwork/srv/eng/catalog.search#/metadata/bfb01655-db81-4571-b6eb-3caae86c037a</a></li>
</ol>
<h2 id="年降水量（必需）：">年降水量（必需）：</h2>
<p>每个栅格对应一个非空值的<strong>年平均降水量</strong>的GIS栅格数据集，单位毫米（mm）。</p>
<p><em>命名</em>：用户自定义，但若为ESRI GRID格式，文件名不能有空格并且少于13个字， 若为TIF或IMG格式，命名可能更长。</p>
<p><em>格式</em>：GIS标准栅格文件（如：ESRI GRID，TIF或IMG），每个栅格对应一个年平 均降水量。</p>
<p><em>数据获得</em>：</p>
<ol>
<li>利用<a href="https://www.wolai.com/pLvSQy6dLBrwJX9ATDTiy4" title="日值（v3）数据">日值（v3）数据</a>进行差值。</li>
<li>国家地球系统科学数据中心：中国1km分辨率年降水量数据（2001-2020年）已下载直接使用，单位为0.1mm  <a href="http://www.geodata.cn/data/datadetails.html?dataguid=113786088533256&amp;docid=3549" title="http://www.geodata.cn/data/datadetails.html?dataguid=113786088533256&amp;docid=3549">http://www.geodata.cn/data/datadetails.html?dataguid=113786088533256&amp;docid=3549</a></li>
<li>WorldClim (v 2.1) 数据范围：1970-2000，月值，最大精度：30s ，单位:mm <a href="https://www.worldclim.org/data/worldclim21.html" title="https://www.worldclim.org/data/worldclim21.html">https://www.worldclim.org/data/worldclim21.html</a></li>
<li>GEE （“UCSB-CHG/CHIRPS/DAILY”)数据集，完整教程见<a href="https://www.wolai.com/mQ6iivaJ3BAPg21kq2uXsE" title="编程分享-利用GEE得到研究区年、月、日降水量数据">编程分享-利用GEE得到研究区年、月、日降水量数据</a></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="variable constant_">ROI</span> = ee.<span class="title class_">FeatureCollection</span>(<span class="string">&quot;users/rice20220411/AH&quot;</span>);</span><br><span class="line"><span class="title class_">Map</span>.<span class="title function_">addLayer</span>(<span class="variable constant_">ROI</span>,&#123;&#125;,<span class="string">&#x27;ROI&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">2015</span>;i&lt;=<span class="number">2021</span>;i++)&#123;</span><br><span class="line"><span class="keyword">var</span> CHIRPS_Daily = ee.<span class="title class_">ImageCollection</span>(<span class="string">&quot;UCSB-CHG/CHIRPS/DAILY&quot;</span>)</span><br><span class="line">.<span class="title function_">filterDate</span>(i+<span class="string">&#x27;-01-01&#x27;</span>, i+<span class="string">&#x27;-12-31&#x27;</span>)</span><br><span class="line"> .<span class="title function_">select</span>(<span class="string">&#x27;precipitation&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> CHIRPS_Year_mean = CHIRPS_Daily.<span class="title function_">mean</span>().<span class="title function_">clip</span>(<span class="variable constant_">ROI</span>)</span><br><span class="line"><span class="keyword">var</span> precipitationVis = &#123;</span><br><span class="line">  <span class="attr">min</span>: <span class="number">1.0</span>,</span><br><span class="line">  <span class="attr">max</span>: <span class="number">17.0</span>,</span><br><span class="line">  <span class="attr">palette</span>: [<span class="string">&#x27;001137&#x27;</span>, <span class="string">&#x27;0aab1e&#x27;</span>, <span class="string">&#x27;e7eb05&#x27;</span>, <span class="string">&#x27;ff4a2d&#x27;</span>, <span class="string">&#x27;e90000&#x27;</span>],</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">print</span>(CHIRPS_Year_mean)</span><br><span class="line"><span class="title class_">Map</span>.<span class="title function_">addLayer</span>(CHIRPS_Year_mean, precipitationVis, i+<span class="string">&#x27;_CHIRPS_Year_mean&#x27;</span>);</span><br><span class="line"><span class="comment">// Map.addLayer(CHIRPS_Daily.first().clip(ROI), precipitationVis, &#x27;CHIRPS_Year_mean_first&#x27;);</span></span><br><span class="line"><span class="title class_">Export</span>.<span class="property">image</span>.<span class="title function_">toDrive</span>(&#123;</span><br><span class="line">      <span class="attr">image</span>: CHIRPS_Year_mean,</span><br><span class="line">      <span class="attr">description</span>: i+<span class="string">&#x27;year_mean&#x27;</span>,</span><br><span class="line">      <span class="attr">region</span>: <span class="variable constant_">ROI</span>,</span><br><span class="line">      <span class="attr">maxPixels</span>: <span class="number">1e13</span>,</span><br><span class="line">      <span class="attr">folder</span>: <span class="string">&#x27;CHIRPS&#x27;</span></span><br><span class="line">    &#125;) </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="植物可利用水量（必需）：">植物可利用水量（必需）：</h2>
<p>每个栅格对应一个植物可利用水的GIS栅格数据集。 植物可利用水（PAWC）是指土壤土层中为植物生长提供的水量所占比例。PAWC是[0,1]的小数。</p>
<p><em>命名</em>：用户自定义，但若为ESRI GRID格式，文件名不能有空格并且少于13个字， 若为TIF或IMG格式，命名可能更长。 </p>
<p><em>格式</em>：GIS标准栅格文件（如：ESRI GRID，TIF或IMG），每个栅格对应一个植物可利用水含量百分比。</p>
<p><em>数据获得</em>：（下载好处理好后传百度☁️）</p>
<p>SoilGrids250m 2017-03 - “Derived available soil water capacity (volumetric fraction) until wilting point” (<a href="https://data.isric.org/geonetwork/srv/eng/catalog.search#/metadata/e33e75c0-d9ab-46b5-a915-cb344345099c" title="https://data.isric.org/geonetwork/srv/eng/catalog.search#/metadata/e33e75c0-d9ab-46b5-a915-cb344345099c">https://data.isric.org/geonetwork/srv/eng/catalog.search#/metadata/e33e75c0-d9ab-46b5-a915-cb344345099c</a>)  SoilGrids 2.0版目前不提供AWC。SoilGrids 2017提供7个土壤深度区间的AWC层。所有7个深度区间都需要下载，然后合并成一个单一的图层，以便在模型中使用。</p>
<p>栅格值以整数百分比的形式给出（如25，表示AWC值为25%）。<br>
（标准）深度区间的平均值，如0-5厘米或0-30厘米，可以通过使用数字积分，如梯形规则，对深度区间内的预测值进行加权平均来得出：</p>
<p>$$<br>
\left(\frac{1}{(b-a)}\right)\left(\frac{1}{2}\right) \sum_{k=1}^{N-1}\left(x_{k+1}-x_{k}\right)\left(f\left(x_{k}\right)+f\left(x_{k+1}\right)\right)<br>
$$</p>
<p>其中，$N$是深度数，$x_k$是第$k$个深度，$f(x_k)$是目标变量（即土壤属性）在深度$x_k$的值。</p>
<p>操作步骤：</p>
<ol>
<li>从ISRIC网站上下载所有可用的深度区间。深度区间为0cm-200cm。注意，每个栅格的大小为1.5GB。</li>
<li>使用 GIS 缓冲区工具，在你要建模的流域/感兴趣的区域周围创建一个缓冲区。由于SoilGrids数据的分辨率为250米，因此缓冲区的宽度为250或500米。这样做是为了确保土壤数据完全覆盖你正在建模的流域，边界周围没有漏洞。</li>
<li>使用缓冲流域，将所有原始的ISRIC AWC 栅格数据剪辑到你感兴趣的区域。在ArcGIS中，这可以通过空间分析工具<code>掩模提取</code>来完成。在这个例子中，我们将把剪下的图层称为AWC_sl1_clip.tif、AWC_sl2_clip.tif … AWC_sl7_clip.tif。</li>
<li>使用GIS栅格计算器工具来计算合并后的AWC层。将其代入上面的方程，我们可以得到：<br>
$$(1/(200-0)) * (1/2) * ( ((5-0) * (AWC_sl1_clip.tif + AWC_sl2_clip.tif)) + ((15-5) * (AWC_sl2_clip.tif + AWC_sl3_clip.tif)) + ((30-15) * (AWC_sl3_clip.tif + AWC_sl4_clip.tif)) + ((60-30) * (AWC_sl4_clip.tif + AWC_sl5_clip.tif)) + ((100-60) * (AWC_sl5_clip.tif + AWC_sl6_clip.tif)) + ((200-100) * ( AWC_sl6_clip.tif + AWC_sl7_clip.tif)) )$$<br>
将此公式输入光栅计算器，根据需要调整文件名。</li>
<li>得到的栅格应该包含0-100范围内的数值，代表整数百分比。该模型<strong>要求AWC以分数</strong>的形式给出，因此将步骤4中计算的<strong>栅格除以100</strong>。</li>
<li>重新投影AWC分数层，使其具有与其他模型输入相同的投影坐标系统。这个栅格现在可以用作模型的可用水含量输入。</li>
</ol>
<h2 id="年平均潜在蒸散发（必需）：">年平均潜在蒸散发（必需）：</h2>
<p> 每个栅格对应一个<strong>年平均潜在蒸散发</strong>的GIS栅格数据集。潜在蒸散发是指水分充足的情况下，通过土壤蒸发和植物（如苜蓿或其他草类等健康植被）蒸散作用可能散逸的水量，单位毫米（mm）。</p>
<p><em>命名</em>：用户自定义，但若为ESRI GRID格式，文件名不能有空格并且少于13个字，若为TIF或IMG格式，命名可能更长。 </p>
<p><em>格式</em>：GIS标准栅格文件（如：ESRI GRID，TIF或IMG），每个栅格对应一个年平均潜在蒸散发。</p>
<p><em>数据获得</em>：</p>
<ul>
<li>FA0工具计算，详见<a href="https://www.wolai.com/sWbxWLVBydbK2t5aT584Fa" title="使用EToCalculator 计算潜在蒸散发详细教程">使用EToCalculator 计算潜在蒸散发详细教程</a><a href="https://blog.sciencenet.cn/blog-3459054-1308734.html" title="https://blog.sciencenet.cn/blog-3459054-1308734.html">https://blog.sciencenet.cn/blog-3459054-1308734.html</a></li>
<li>Global Aridity Index and Potential Evapotranspiration (ET0) Climate Database v2 (Penman Monteith Evapotranspiration equation，30弧秒，1970-2000，暂时未使用，有待验证。) <a href="https://figshare.com/articles/dataset/Global_Aridity_Index_and_Potential_Evapotranspiration_ET0_Climate_Database_v2/7504448/3" title="https://figshare.com/articles/dataset/Global_Aridity_Index_and_Potential_Evapotranspiration_ET0_Climate_Database_v2/7504448/3">https://figshare.com/articles/dataset/Global_Aridity_Index_and_Potential_Evapotranspiration_ET0_Climate_Database_v2/7504448/3</a></li>
<li>大部分研究采用，Modified-Hargreaves 法对潜在蒸散量进行计算。<br>
式中：$ET_0$代表栅格单元上的潜在蒸散量（mm）；$RA$为太阳大气顶层辐射 （$MJ·m^{-2}·d^{-1}$）；$T_a$为不同小流域的日最高温均值和日最低温均值的平均值（°C）； $T_d$为小流域上的日最高温均值和日最低温均值的差值（°C）；$P$为小流域的降雨量 （mm）。</li>
</ul>
<p>$$<br>
ET_{0}=0.0013 \times 0.408 \times R A \times\left(T_{\mathrm{a}}+17\right) \times\left(T_{\mathrm{d}}-0.0123 P\right)^{0.76}<br>
$$</p>
<ul>
<li>GEE获取 (Penman-Monteith法)（代码传GEE和GitHub） 已经下载全国区域的2000-2020年数据压缩上传百度云     </li>
</ul>
<p> 原文链接 <a href="https://doi.org/10.1016/j.rse.2018.12.031" title="https://doi.org/10.1016/j.rse.2018.12.031">https://doi.org/10.1016/j.rse.2018.12.031</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//完美运行，输入坐标即可，获取每年的平均值。</span></span><br><span class="line"><span class="comment">//加入矢量边界之后直接运行var </span></span><br><span class="line"><span class="keyword">var</span> <span class="variable constant_">ROI</span> = table.<span class="title function_">geometry</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Map.addLayer(ROI,&#123;&#125;,&#x27;ROI&#x27;);</span></span><br><span class="line"><span class="keyword">var</span> imgcol_PMLV2_v016_8d = ee.<span class="title class_">ImageCollection</span>(<span class="string">&#x27;projects/pml_evapotranspiration/PML/OUTPUT/PML_V2_8day_v016&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> imgcol_PMLV2_v016_8d = ee.<span class="title class_">ImageCollection</span>(imgcol_PMLV2_v016_8d.<span class="title function_">toList</span>(<span class="number">2000</span>));</span><br><span class="line"><span class="title function_">print</span>(imgcol_PMLV2_v016_8d);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pkg_export = <span class="built_in">require</span>(<span class="string">&#x27;users/kongdd/pkgs:pkg_export.js&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;drive&quot;</span>,</span><br><span class="line">    <span class="attr">range</span>: [<span class="number">110</span>,<span class="number">34</span>,<span class="number">114</span>,<span class="number">40</span>],<span class="comment">//ROI, // [73, 25, 105, 40], </span></span><br><span class="line">    <span class="attr">cellsize</span>: <span class="number">1</span>/<span class="number">240</span>,</span><br><span class="line">    <span class="comment">// crsTransform : [463.312716528, 0, -20015109.354, 0, -463.312716527, 10007554.677], // prj.crsTransform;</span></span><br><span class="line">    <span class="comment">// scale        : 463.3127165275, // prj.scale</span></span><br><span class="line">    <span class="attr">crs</span>: <span class="string">&#x27;EPSG:4326&#x27;</span>, <span class="comment">// &#x27;SR-ORG:6974&#x27;, // EPSG:4326</span></span><br><span class="line">    <span class="attr">folder</span>: <span class="string">&#x27;ET0&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> imgcol_years = <span class="title function_">aggregateToYearly</span>(imgcol_PMLV2_v016_8d, <span class="number">2010</span>, <span class="number">2019</span>, <span class="number">0.01</span>);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">aggregateToYearly</span>(<span class="params">imgcol, year_begin, year_end, scale_factor</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> bands = [<span class="string">&#x27;ET_pot&#x27;</span>]; <span class="comment">//,&#x27;qc&#x27;</span></span><br><span class="line">    <span class="keyword">var</span> years = ee.<span class="property">List</span>.<span class="title function_">sequence</span>(year_begin, year_end);</span><br><span class="line">    <span class="keyword">var</span> imgcol_years = years.<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params">year</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> date_begin = ee.<span class="property">Date</span>.<span class="title function_">fromYMD</span>(year,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">var</span> date_end   = ee.<span class="property">Date</span>.<span class="title function_">fromYMD</span>(year,<span class="number">12</span>,<span class="number">31</span>);</span><br><span class="line">        <span class="keyword">var</span> ydays = date_begin.<span class="title function_">advance</span>(<span class="number">1</span>, <span class="string">&#x27;year&#x27;</span>).<span class="title function_">difference</span>(date_begin, <span class="string">&#x27;day&#x27;</span>);</span><br><span class="line">        <span class="keyword">var</span> imgcol_year = imgcol.<span class="title function_">filterDate</span>(date_begin, date_end);</span><br><span class="line">        <span class="keyword">var</span> scale = ydays.<span class="title function_">multiply</span>(scale_factor);</span><br><span class="line">        <span class="keyword">return</span> imgcol_year.<span class="title function_">select</span>(bands)</span><br><span class="line">            <span class="comment">//.multiply(scale_factor).</span></span><br><span class="line">            .<span class="title function_">mean</span>()</span><br><span class="line">            .<span class="title function_">multiply</span>(scale)</span><br><span class="line">            .<span class="title function_">toFloat</span>()</span><br><span class="line">            .<span class="title function_">set</span>(<span class="string">&#x27;system:time_start&#x27;</span>, date_begin.<span class="title function_">millis</span>())</span><br><span class="line">            .<span class="title function_">set</span>(<span class="string">&#x27;system:id&#x27;</span>, date_begin.<span class="title function_">format</span>());</span><br><span class="line">    &#125;);</span><br><span class="line">    imgcol_years = ee.<span class="title class_">ImageCollection</span>(imgcol_years);</span><br><span class="line">    <span class="comment">// pkg_export.ExportImg(img_year, task, range, cellsize, type, folder_yearly, crs, crsTransform);</span></span><br><span class="line">    <span class="keyword">return</span> imgcol_years;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> imgcol_years = imgcol_years.<span class="title function_">filterBounds</span>(<span class="variable constant_">ROI</span>);</span><br><span class="line"><span class="title function_">print</span>(imgcol_years);</span><br><span class="line"><span class="comment">//var batch = require(&#x27;users/fitoprincipe/geetools:batch&#x27;);</span></span><br><span class="line"><span class="comment">//batch.Download.ImageCollection.toDrive(imgcol_years,&quot;ETO&quot;, &#123;</span></span><br><span class="line"><span class="comment">//scale: 1/240&#125;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pkg_export.<span class="title class_">ExportImgCol</span>(imgcol_years.<span class="title function_">limit</span>(<span class="number">10</span>), <span class="string">&#x27;ET0&#x27;</span>, options);</span><br></pre></td></tr></table></figure>
<p>GEE批量导出方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">var</span> runButtons = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#task-pane&#x27;</span>).<span class="property">shadowRoot</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&quot;.run-button&quot;</span>)</span><br><span class="line">     runButtons.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">e</span>) &#123;e.<span class="title function_">click</span>()&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">runTaskList</span>()</span><br><span class="line"><span class="built_in">setTimeout</span>( </span><br><span class="line">    <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">       <span class="keyword">var</span> taskDialog = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&quot;ee-image-config-dialog&quot;</span>) <span class="comment">//table的话-image-改成-table-</span></span><br><span class="line">        taskDialog.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">e</span>) &#123;e.<span class="property">shadowRoot</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;ee-dialog&quot;</span>).<span class="property">shadowRoot</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;paper-dialog&quot;</span>).<span class="title function_">querySelector</span>(<span class="string">&quot;.ok-button&quot;</span>).<span class="title function_">click</span>()&#125;)</span><br><span class="line"> &#125;,<span class="number">5</span> * <span class="number">1000</span> );  </span><br></pre></td></tr></table></figure>
<h2 id="土地利用-覆被（必需）：">土地利用/覆被（必需）：</h2>
<p>每个栅格对应一个土地利用类型的GIS栅格数据集。 土地利用类型代码定义为<strong>整数</strong>。 </p>
<p>*命名：*用户自定义，但若为ESRI GRID格式，文件名不能有空格并且少于13个字， 若为TIF或IMG格式，命名可能更长。 </p>
<p>*格式：*GIS标准栅格文件（如：ESRI GRID，TIF或IMG），每个栅格对应一个土地利用类型代码（如：1表示森林，3表示草地，等）。地类代码必须与生物物理系数表中的地类代码一致。</p>
<p><em>数据获取得：</em></p>
<ol>
<li>Land cover classification gridded maps from 1992 to present derived from satellite observations <a href="https://cds.climate.copernicus.eu/cdsapp#!/dataset/satellite-land-cover?tab=overview" title="https://cds.climate.copernicus.eu/cdsapp#!/dataset/satellite-land-cover?tab=overview">https://cds.climate.copernicus.eu/cdsapp#!/dataset/satellite-land-cover?tab=overview</a></li>
<li>ESA全球10米<a href="https://esa-worldcover.org/en" title="https://esa-worldcover.org/en">https://esa-worldcover.org/en</a></li>
<li>GLOBELAND30 包含2000，2010，2020三期数据。<a href="http://www.globallandcover.com/defaults.html?src=/Scripts/map/defaults/download.html&amp;head=download&amp;type=data" title="http://www.globallandcover.com/defaults.html?src=/Scripts/map/defaults/download.html&amp;head=download&amp;type=data">http://www.globallandcover.com/defaults.html?src=/Scripts/map/defaults/download.html&amp;head=download&amp;type=data</a><br>
<code>note:</code>汾河流域在图幅N49_35,山西省全域需要图幅N49_30,N49_35,N49_40,N50_35,N50_40</li>
<li>Sentinel-2 Land Use/ Land Cover Downloader 2017-2021年数据，10米分辨率。 <a href="https://www.arcgis.com/apps/instant/media/index.html?appid=fc92d38533d440078f17678ebc20e8e2" title="https://www.arcgis.com/apps/instant/media/index.html?appid=fc92d38533d440078f17678ebc20e8e2">https://www.arcgis.com/apps/instant/media/index.html?appid=fc92d38533d440078f17678ebc20e8e2</a> </li>
<li>1990-2021全国30米数据（每年更新） <a href="https://zenodo.org/record/5816591#.YzQUF-xBwbk" title="https://zenodo.org/record/5816591#.YzQUF-xBwbk">https://zenodo.org/record/5816591#.YzQUF-xBwbk</a></li>
</ol>
<h2 id="流域（必需）：">流域（必需）：</h2>
<p>用多边形表示流域的图形文件（shapefile）。即与研究区水电生产研究相关的所有小流域图层。 </p>
<p><em>命名：</em> 用户定义，但文件名不能有空格 </p>
<p>*格式： *图形文件（.shp） </p>
<p>*属性表横列：*每一行表示一个小流域</p>
<p>*属性表纵列：*必须包含定义为整数的“ws_id”字段，每个小流域赋予唯一数值。</p>
<h2 id="次一级小流域（必需）：">次一级小流域（必需）：</h2>
<p>流域图层中选定区域中用多图形文件（shapefile）。生成次一级小流域的工具和方法，详见 “DEM数据处理”章节。</p>
<p>*格式：*图形文件（.shp） </p>
<p>*属性表横列：*每一行表示一个次一级小流域</p>
<p>*属性表纵列：*必须包含定义为整数的“subws_id”字段，每个次一级小流域赋予唯一数值。</p>
<h2 id="生物物理系数表（必需）：">生物物理系数表（必需）：</h2>
<p>土地利用/覆被（LULC）类型表，包括用于该工具使用的生物物理系数数据。注意事项：这些数据主要针对每种土地利用类型属性而非栅格图栅格单元属性。</p>
<p>*命名：*文件名由字母、数字和下划线组成，不能有空格。</p>
<p>*格式：*ArcGIS模型的*.dbf或*.mdb格式，独立运行模块要求一个*.csv文件。</p>
<p>*属性表横列：*每一行表示一个土地利用类型 。</p>
<p>*属性表纵列：*每一列包含每种土地利用类型的不同属性，属性命名如下：</p>
<p>Lucode（土地利用类型代码）：每种土地利用类型地类代码（如：1表示森林， 3表示草地，等），必须与上述土地利用类型栅格图保持一致。</p>
<p>LULC_desc：土地利用类型的描述性命名（可选填）。</p>
<p> LULC_veg：包括使用的实际蒸散发AET计算公式。植被覆盖地类 （不包括湿地）赋值为1，其他土地利用类型（包括湿地、城市用地、水体）赋值为0。</p>
<p>root_depth：植被覆盖地类的最大根系深度，单位毫米（mm），取整数。植物根系深度通常指特定植物类型的根系生物量为95%的土层深度。对不适用一般 Budyko干燥指数（即应使用公式2计算实际蒸散发AET）的土地利用类型而言， 不需要根系深度数据，设为N/A。</p>
<p>Kc ：每种土地利用类型的植物蒸散系数，通过将植物生理学特性与苜蓿相比较，将苜蓿的参考作物蒸散修正为特定土地利用类型的潜在蒸散量。因此土地利用类型的植物蒸散系数取值为[0，1.5]的小数（在某些非常潮湿的热带区域，水分充足）。</p>
<h2 id="季节常数Z（必需）：">季节常数Z（必需）：</h2>
<p>是根据季节性降水分布定义的从1 到30排序浮动值。 </p>
<h2 id="用水需求表（必需）：">用水需求表（必需）：</h2>
<p>土地利用类型表，表示不同土地利用类型的消耗性用水量。消耗性用水量是指提供植物和作物生长，被人类和畜牧消耗，或其他应从 流域水量平衡中扣除的水量。</p>
<p>*命名：*文件名由字母、数字和下划线组成，不能有空格。 </p>
<p>*格式：*ArcGIS模型的*.dbf或*.mdb格式，独立运行模块要求一个*.csv文件 属性表横列：每一行表示一个土地利用类型，并且必须包含土地利用栅格图中所 有土地覆被属性值。 </p>
<p>*属性表纵列：*每一列包含每种土地利用类型的不同用水需求属性，属性命名如下：</p>
<p>lucode（土地利用类型代码）：每种土地利用类型地类代码（如：1表示森林， 3表示草地，等），必须与上述土地利用类型栅格图保持一致。 </p>
<p>demand：每种土地利用类型的预测平均消耗性用水量。土地利用类型图中的用水量用立方米/年/栅格单元表示。注意事项：由于区域越大，相同土地覆被类型消耗的水量可能，因此用水量的栅格计算方法十分重要。</p>
<h1>结果分析</h1>
<p>output\per_pixel\fractp（分数）：模型估算每个栅格单元降水量的实际蒸散发占比（实际蒸发量/降水量）。这是栅格单元的实际蒸散发占降水量的平均值。</p>
<p>output\per_pixel\aet（mm）：模型估算栅格单元实际蒸散发。</p>
<p>output\per_pixel\wyield（mm）：模型估算栅格单元产水量。</p>
<ul>
<li>output\subwatershed_results_wyield.shp 和 output\subwatershed_results_wyield.csv：包含模型估算次一级流域生物物理学参数值的shapefile文件和表格，属性包括：
<ul>
<li>precip_mn（mm）：次一级流域栅格单元的平均降水量。</li>
<li>PET_mn（mm）：次一级流域栅格单元的平均潜在蒸散发。</li>
<li>AET_mn（mm）：次一级流域栅格单元的平均实际蒸散发。</li>
<li>wyield_mn（mm）：次一级流域栅格单元的平均产水量。</li>
<li>num_pixel：次一级流域栅格单元的数量。</li>
<li>wyield_vol（$ m^3  $）：次一级流域产水量体积。</li>
<li>wyield_ha（$ m^3  $）：次一级流域每公顷产水量体积。</li>
</ul>
</li>
<li>output\watershed_results_wyield.shp 和 output\watershed_results_wyield.csv ： 包含模型估算每个小流域生物物理学参数值的shapefile文件和表格： 运行产水量评估模块时，输出结果的生物物理学参数如下：
<ul>
<li>precip_mn（mm）：每个小流域栅格单元的平均降水量。</li>
<li>PET_mn（mm）：每个小流域栅格单元的平均潜在蒸散发。</li>
<li>AET_mn（mm）：每个小流域栅格单元的平均实际蒸散发。</li>
<li>wyield_mn（mm）：每个小流域栅格单元的平均产水量。</li>
<li>num_pixel：每个小流域栅格单元的数量。</li>
<li>wyield_vol（$ m^3  $）：每个小流域内产水量体积。</li>
<li>wyield_ha（$ m^3  $）：每个小流域每公顷产水量体积。 </li>
</ul>
</li>
</ul>
<p><strong><code>Note:</code></strong> **产水量（wyield_vol）**字段数据是模型估算研究区流域的每一个次一级流域的年平均<em>产汇流</em>水量。字段数值可以用于确定对全年产水量贡献最大的次一级流域。</p>
<p><a href="https://www.wolai.com/pLvSQy6dLBrwJX9ATDTiy4" title="日值（v3）数据">日值（v3）数据</a></p>
<p><a href="https://www.wolai.com/sWbxWLVBydbK2t5aT584Fa" title="使用EToCalculator 计算潜在蒸散发详细教程">使用EToCalculator 计算潜在蒸散发详细教程</a></p>
<p><a href="https://www.wolai.com/mQ6iivaJ3BAPg21kq2uXsE" title="编程分享-利用GEE得到研究区年、月、日降水量数据">编程分享-利用GEE得到研究区年、月、日降水量数据</a></p>
]]></content>
      <categories>
        <category>Ecosystem service</category>
        <category>Annual Water Yield</category>
      </categories>
      <tags>
        <tag>Ecosystem service</tag>
        <tag>Annual Water Yield</tag>
      </tags>
  </entry>
  <entry>
    <title>(12)统计学习</title>
    <url>/2023/08/21/2023-8-21-12%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<blockquote><p>本文由SCY翻译自《Geocomputation with R》<a href="https://r.geocompx.org/spatial-cv">第十二章</a></p>
</blockquote>
<h1>前提条件</h1>
<p>本章假设您已经具备地理数据分析的熟练技能，例如通过学习并完成章节<em>空间数据</em>至<em>地理数据重投影</em>中的练习来获得。强烈推荐熟悉广义线性模型（GLM）和机器学习。</p>
<p>本章使用以下的R包：^[虽然不需要附加，但还必须安装<strong>GGally</strong>、<strong>lgr</strong>、<strong>kernlab</strong>、<strong>mlr3measures</strong>、<strong>paradox</strong>、<strong>pROC</strong>、<strong>progressr</strong> 和 <strong>spDataLarge</strong>包。]</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>sf<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>terra<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>dplyr<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>future<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>lgr<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>mlr3<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>mlr3learners<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>mlr3extralearners<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>mlr3spatiotempcv<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>mlr3tuning<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>mlr3viz<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>progressr<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>当然，所需数据将在适当的时候附上。</p>
<h1>引言</h1>
<p>统计学习主要关注使用统计和计算模型来识别数据中的模式，并根据这些模式进行预测。由于其起源，统计学习是 R 语言的一大优势（见章节<em>地理计算软件</em>）。^[几十年来，将统计技术应用于地理数据一直是地统计学、空间统计学和点模式分析领域中的一个活跃的研究课题。统计学习结合了统计和机器学习的方法，并可分为监督和无监督技术。这两者越来越多地应用于从物理学、生物学和生态学到地理学和经济学等各个学科]。</p>
<p>本章重点介绍有训练数据集的监督技术，而非像聚类这样的无监督技术。响应变量可以是二元的（如山体滑坡发生与否）、分类的（土地利用）、整数（物种丰富度计数）或数值的（以 pH 衡量的土壤酸度）。监督技术用于建模——响应与一个或多个预测变量之间的关系——这些响应是基于一组观测样本而已知的。</p>
<p>大多数机器学习研究的主要目的是进行良好的预测。机器学习在“大数据”时代蓬勃发展，因为其方法对输入变量几乎没有假设，并且能处理巨大的数据集。机器学习适用于预测未来客户行为、推荐服务（音乐、电影、接下来购买什么）、面部识别、自动驾驶、文本分类和预测性维护（基础设施、产业）等任务。</p>
<p>本章基于一个案例研究：（空间）预测山体滑坡。<br>
该应用与定义在<em>引言</em>章中的地理计算的应用性有关，并说明了机器学习在唯一目的是预测时如何借鉴统计学领域。因此，本章首先使用广义线性模型介绍建模和交叉验证的概念。在此基础上，该章实施了一个更典型的机器学习算法，即支持向量机（SVM）。模型的<strong>预测性能</strong>将使用空间交叉验证（CV）进行评估，该方法考虑到地理数据是特殊的。</p>
<p>CV确定模型泛化到新数据的能力，通过将数据集（反复）分割为训练集和测试集。它使用训练数据来拟合模型，并检查其在对测试数据进行预测时的性能。CV 有助于检测过拟合，因为过于紧密地预测训练数据（噪声）的模型通常会在测试数据上表现不佳。</p>
<p>随机分割空间数据可能导致训练点与测试点在空间上是邻近的。由于空间自相关，在这种情况下，测试数据集和训练数据集将不是独立的，因此交叉验证无法检测出可能的过拟合。空间交叉验证缓解了这个问题，并且是本章的<strong>核心</strong>主题。</p>
<h1>案例: 滑坡敏感性</h1>
<p>本案例研究基于南厄瓜多尔滑坡地点的一个数据集，如下图所示，并在@muenchow_geomorphic_2012中详细描述。该论文中使用的数据集的一个子集提供在<strong>spDataLarge</strong>包中，可以如下加载：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">data<span class="punctuation">(</span><span class="string">&quot;lsl&quot;</span><span class="punctuation">,</span> <span class="string">&quot;study_mask&quot;</span><span class="punctuation">,</span> package <span class="operator">=</span> <span class="string">&quot;spDataLarge&quot;</span><span class="punctuation">)</span></span><br><span class="line">ta <span class="operator">=</span> terra<span class="operator">::</span>rast<span class="punctuation">(</span>system.file<span class="punctuation">(</span><span class="string">&quot;raster/ta.tif&quot;</span><span class="punctuation">,</span> package <span class="operator">=</span> <span class="string">&quot;spDataLarge&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>T上面的代码加载了三个对象：一个名为<code>lsl</code>的<code>data.frame</code>，一个名为<code>study_mask</code>的<code>sf</code>对象，以及一个名为<code>ta</code>的<code>SpatRaster</code>，其中包含地形属性栅格。<code>lsl</code>包含一个因子列<code>lslpts</code>，其中<code>TRUE</code>对应于观察到的滑坡’发起点’，坐标存储在列<code>x</code>和<code>y</code>中。^[滑坡发起点位于滑坡多边形的断崖中。有关进一步的详细信息。]<br>
有175个滑坡点和175个非滑坡点，如<code>summary(lsl$lslpts)</code>所示。这175个非滑坡点是从研究区域随机抽样的，但必须落在滑坡多边形周围的小缓冲区之外。</p>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309051146030.png" alt=""><br>
Landslide initiation points (red) and points unaffected by landsliding (blue) in Southern Ecuador.</p>
<p><code>lsl</code>的前三行，四舍五入为两位有效数字，可以在下表中找到。</p>
<table class="table" style="margin-left: auto; margin-right: auto;">
<caption>Structure of the lsl dataset.</caption>
 <thead>
  <tr>
   <th style="text-align:left;">   </th>
   <th style="text-align:right;"> x </th>
   <th style="text-align:right;"> y </th>
   <th style="text-align:left;"> lslpts </th>
   <th style="text-align:right;"> slope </th>
   <th style="text-align:right;"> cplan </th>
   <th style="text-align:right;"> cprof </th>
   <th style="text-align:right;"> elev </th>
   <th style="text-align:right;"> log10_carea </th>
  </tr>
 </thead>
<tbody>
  <tr>
   <td style="text-align:left;"> 1 </td>
   <td style="text-align:right;"> 713888 </td>
   <td style="text-align:right;"> 9558537 </td>
   <td style="text-align:left;"> FALSE </td>
   <td style="text-align:right;"> 34 </td>
   <td style="text-align:right;"> 0.023 </td>
   <td style="text-align:right;"> 0.003 </td>
   <td style="text-align:right;"> 2400 </td>
   <td style="text-align:right;"> 2.8 </td>
  </tr>
  <tr>
   <td style="text-align:left;"> 2 </td>
   <td style="text-align:right;"> 712788 </td>
   <td style="text-align:right;"> 9558917 </td>
   <td style="text-align:left;"> FALSE </td>
   <td style="text-align:right;"> 39 </td>
   <td style="text-align:right;"> -0.039 </td>
   <td style="text-align:right;"> -0.017 </td>
   <td style="text-align:right;"> 2100 </td>
   <td style="text-align:right;"> 4.1 </td>
  </tr>
  <tr>
   <td style="text-align:left;"> 350 </td>
   <td style="text-align:right;"> 713826 </td>
   <td style="text-align:right;"> 9559078 </td>
   <td style="text-align:left;"> TRUE </td>
   <td style="text-align:right;"> 35 </td>
   <td style="text-align:right;"> 0.020 </td>
   <td style="text-align:right;"> -0.003 </td>
   <td style="text-align:right;"> 2400 </td>
   <td style="text-align:right;"> 3.2 </td>
  </tr>
</tbody>
</table>
<p>要对滑坡易发性进行建模，我们需要一些预测因子。由于地形属性经常与滑坡有关[@muenchow_geomorphic_2012]，我们已经从<code>ta</code>提取到<code>lsl</code>中以下的地形属性：</p>
<ul>
<li><code>slope</code>：坡度角（°）</li>
<li><code>cplan</code>：平面曲率（rad m^−1^）表示坡度的汇聚或发散，从而表示水流</li>
<li><code>cprof</code>：剖面曲率（rad m^-1^）作为流速加速的衡量标准，也称为坡度角的下坡变化</li>
<li><code>elev</code>：海拔高度（m a.s.l.）作为研究区不同海拔带植被和降水的表示</li>
<li><code>log10_carea</code>：集水区面积（log10 m^2^）的常用对数，表示流向某个位置的水量</li>
</ul>
<p>使用R-GIS桥计算地形属性并将其提取到滑坡点（参见本章末尾的练习部分）可能是一个值得尝试的练习。</p>
<h1>在R中的传统建模方法</h1>
<p>在介绍<strong>mlr3</strong>包之前，这是一个提供统一接口以访问数十种学习算法的 umbrella 包，值得先看一下R传统的建模接口。这一介绍到有监督的统计学习为进行空间CV提供了基础，并有助于更好地理解随后呈现的<strong>mlr3</strong>方法。</p>
<p>监督学习涉及将响应变量作为预测因子的函数进行预测。在R中，建模函数通常使用公式来指定（有关R公式的更多详细信息，请参阅<code>?formula</code>）。以下命令指定并运行一个广义线性模型：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">fit <span class="operator">=</span> glm<span class="punctuation">(</span>lslpts <span class="operator">~</span> slope <span class="operator">+</span> cplan <span class="operator">+</span> cprof <span class="operator">+</span> elev <span class="operator">+</span> log10_carea<span class="punctuation">,</span></span><br><span class="line">          family <span class="operator">=</span> binomial<span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">          data <span class="operator">=</span> lsl<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>理解这三个输入参数各自的意义是非常有价值的：</p>
<ul>
<li>一个公式，用于指定由预测因子决定的滑坡发生（<code>lslpts</code>）</li>
<li>一个家族（family），用于指定模型的类型，在这个例子中是<code>binomial</code>，因为响应是二元的（见<code>?family</code>）</li>
<li>包含响应和预测因子（作为列）的数据框</li>
</ul>
<p>可以如下打印这个模型的结果（<code>summary(fit)</code>提供了关于结果的更详细的描述）：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="built_in">class</span><span class="punctuation">(</span>fit<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] &quot;glm&quot; &quot;lm&quot;</span></span><br><span class="line">fit</span><br><span class="line"><span class="comment">#&gt; </span></span><br><span class="line"><span class="comment">#&gt; Call:  glm(formula = lslpts ~ slope + cplan + cprof + elev + log10_carea, </span></span><br><span class="line"><span class="comment">#&gt;     family = binomial(), data = lsl)</span></span><br><span class="line"><span class="comment">#&gt; </span></span><br><span class="line"><span class="comment">#&gt; Coefficients:</span></span><br><span class="line"><span class="comment">#&gt; (Intercept)        slope        cplan        cprof         elev  log10_carea  </span></span><br><span class="line"><span class="comment">#&gt;    2.511364     0.079011   -28.941961   -17.563601     0.000179    -2.274877  </span></span><br><span class="line"><span class="comment">#&gt; </span></span><br><span class="line"><span class="comment">#&gt; Degrees of Freedom: 349 Total (i.e. Null);  344 Residual</span></span><br><span class="line"><span class="comment">#&gt; Null Deviance:	    485 </span></span><br><span class="line"><span class="comment">#&gt; Residual Deviance: 373 	AIC: 385</span></span><br></pre></td></tr></table></figure>
<p>模型对象<code>fit</code>，其类别为<code>glm</code>，包含了定义响应和预测因子之间拟合关系的系数。这个对象也可以用于预测。这是通过通用的<code>predict()</code>方法来完成的，在这个案例中，它调用了<code>predict.glm()</code>函数。将<code>type</code>设置为<code>response</code>会返回<code>lsl</code>中每个观测的预测概率（即滑坡发生的概率），如下图所示（见<code>?predict.glm</code>）：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">pred_glm <span class="operator">=</span> predict<span class="punctuation">(</span>object <span class="operator">=</span> fit<span class="punctuation">,</span> type <span class="operator">=</span> <span class="string">&quot;response&quot;</span><span class="punctuation">)</span></span><br><span class="line">head<span class="punctuation">(</span>pred_glm<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt;      1      2      3      4      5      6 </span></span><br><span class="line"><span class="comment">#&gt; 0.1901 0.1172 0.0952 0.2503 0.3382 0.1575</span></span><br></pre></td></tr></table></figure>
<p>通过将系数应用于预测因子的栅格数据，可以创建空间分布图。这可以手动完成，也可以使用<code>terra::predict()</code>来完成。除了一个模型对象（<code>fit</code>）外，这个函数还需要一个具有预测因子（栅格层）的<code>SpatRaster</code>，这些预测因子的名称应与模型输入数据框中的名称相同（见下图）。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># making the prediction</span></span><br><span class="line">pred <span class="operator">=</span> terra<span class="operator">::</span>predict<span class="punctuation">(</span>ta<span class="punctuation">,</span> model <span class="operator">=</span> fit<span class="punctuation">,</span> type <span class="operator">=</span> <span class="string">&quot;response&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309051151962.png" alt=""><br>
Spatial distribution mapping of landslide susceptibility using a GLM.</p>
<p>在进行预测时，我们忽略了空间自相关，因为我们假设平均预测准确性在有或没有空间自相关结构的情况下保持不变。然而，也可以将空间自相关结构纳入模型和预测中。<br>
尽管这超出了本书的范围，但我们为感兴趣的读者提供了一些查阅的方向：</p>
<ol>
<li>回归克里金（Regression Kriging）的预测结合了回归的预测和回归残差的克里金。</li>
<li>人们还可以向广义最小二乘模型[<code>nlme::gls()</code>]添加空间相关（依赖）结构。</li>
<li>人们也可以使用混合效应建模方法。</li>
</ol>
<p>基本上，随机效应对响应变量施加了依赖结构，从而使某一类的观察结果与另一类的观察结果更相似。类别可以是蜜蜂巢、猫头鹰巢、植被样带或高度分层。这种混合建模方法假设随机截距是正态和独立分布的。这甚至可以通过使用正态和空间依赖的随机截距来扩展。然而，为此，你可能需要采用贝叶斯建模方法，因为频率论软件工具在这方面尤其有限，尤其是对于更复杂的模型。</p>
<p>空间分布图是模型（上图）的一个非常重要的结果。更重要的是，基础模型在制作这些图时有多好，因为如果模型的预测性能差，预测图就毫无用处。评估二项模型预测性能的最流行指标是接收器操作特性曲线下的面积（AUROC）。这是一个介于0.5和1.0之间的值，其中0.5表示模型不比随机模型好，1.0表示两个类的完美预测。因此，AUROC越高，模型的预测能力越好。以下代码块使用<code>roc()</code>计算模型的AUROC值，该函数将响应和预测值作为输入。<code>auc()</code>返回曲线下的面积。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">pROC<span class="operator">::</span>auc<span class="punctuation">(</span>pROC<span class="operator">::</span>roc<span class="punctuation">(</span>lsl<span class="operator">$</span>lslpts<span class="punctuation">,</span> fitted<span class="punctuation">(</span>fit<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; Area under the curve: 0.8216</span></span><br></pre></td></tr></table></figure>
<p>AUROC\index{AUROC} 值为</p>
<!-- `r # round(pROC::auc(pROC::roc(lsl$lslpts, fitted(fit))), 2)` -->
<p>0.82 代表了一个良好的拟合。然而，这是一个过于乐观的估计，因为我们是在完整数据集上进行的计算。为了得到一个偏差较小的评估，我们需要使用交叉验证，并且在处理空间数据的情况下，应使用空间CV。</p>
<h2 id="介绍（空间）交叉验证">介绍（空间）交叉验证</h2>
<p>交叉验证属于重采样方法的家族 [@james_introduction_2013]。基本思想是将数据集（反复）分为训练集和测试集，其中训练数据用于拟合模型，然后将该模型应用于测试集。通过使用如二项式案例中的AUROC这样的性能度量，将预测值与测试集中已知的响应值进行比较，从而得到模型将学习到的关系泛化到独立数据的能力的偏差较小的评估。例如，100次重复的5折交叉验证意味着将数据随机分为五个部分（折叠），每个折叠都被用作一次测试集（见下图的上行）。这保证了每个观测值都在测试集中使用一次，并需要拟合五个模型。随后，这一过程重复100次。当然，每次重复中的数据分割都会有所不同。总体而言，这合计为500个模型，而所有模型的平均性能度量（AUROC）即为模型的整体预测能力。</p>
<p>然而，地理数据是特殊的。正如我们将在<em>运输</em>章节中看到的，地理学的“第一定律”指出，彼此靠近的点通常比远离的点更相似 [@miller_tobler_2004]。这意味着这些点在统计上并不独立，因为在传统的CV中，训练点和测试点通常过于靠近（见下图的第一行）。靠近“测试”观测值的“训练”观测值可能提供一种“偷窥预览”：这些信息本应对训练数据集不可用。为了缓解这一问题，“空间划分”被用于将观测值分为空间上不相交的子集（使用观测值的坐标进行<em>k</em>-均值聚类；@brenning_spatial_2012；见下图的第二行）。这种划分策略是空间CV和传统CV之间的<strong>唯一</strong>差异。因此，空间CV导致了对模型预测性能的偏差较小的评估，从而有助于避免过拟合。</p>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309051156779.png" alt=""><br>
Spatial visualization of selected test and training observations for cross-validation of one repetition. Random (upper row) and spatial partitioning (lower row).</p>
<h1>使用<strong>mlr3</strong>进行空间交叉验证</h1>
<p>如<a href="https://CRAN.R-project.org/view=MachineLearning">CRAN 机器学习任务视图</a>所描述的，有数十个用于统计学的包。熟悉其中每一个包，包括如何进行交叉验证和超参数调整，可能是一个耗时的过程。比较来自不同包的模型结果可能更为繁琐。<strong>mlr3</strong> 包和生态系统是为了解决这些问题而开发的。它充当一个“元包”，为包括分类、回归、生存分析和聚类在内的流行的有监督和无监督统计学习技术提供统一的接口 [@lang_mlr3_2019; @becker_mlr3_2022]。标准化的 <strong>mlr3</strong> 接口基于八个“构建块”。<br>
如下图所示，这些构建块有明确的顺序。</p>
<p>(ref:building-blocks) mlr3包的基础构建块。来源：@becker_mlr3_2022。（得到了友好地重新使用此图的许可。）</p>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309051206276.png" alt=""><br>
(ref:building-blocks)</p>
<p><strong>mlr3</strong> 建模过程包含三个主要阶段。<br>
首先，**任务（task）**指定了数据（包括响应变量和预测变量）和模型类型（如回归或分类）。<br>
其次，<strong>学习器（learner）</strong> 定义了应用于创建的任务的特定学习算法。<br>
第三，**重采样（resampling）**方法评估了模型的预测性能，即其泛化到新数据的能力。</p>
<h2 id="广义线性模型">广义线性模型</h2>
<p>要在 <strong>mlr3</strong>中实现GLM，我们必须创建一个包含滑坡数据的<strong>任务（task）</strong>。由于响应是二元（两类变量）且具有空间维度，我们使用 <strong>mlr3spatiotempcv</strong> 包的<code>TaskClassifST$new()</code>创建一个分类任务[@schratz_mlr3spatiotempcv_2021，对于非空间任务，使用 <code>mlr3::TaskClassif$new()</code> 或对于回归任务使用<code>mlr3::TaskRegr$new()</code>，其他任务类型请参见 <code>?Task</code>]。^[<strong>mlr3</strong> 生态系统大量使用 <strong>data.table</strong> 和 <strong>R6</strong> 类。尽管你可能在不了解 <strong>data.table</strong> 或 <strong>R6</strong> 的具体情况下使用 <strong>mlr3</strong>，但了解它们可能相当有帮助。要了解更多关于 <strong>data.table</strong> 的信息，请参考 <a href="https://rdatatable.gitlab.io/data.table/index.html%E3%80%82%E8%A6%81%E4%BA%86%E8%A7%A3%E6%9B%B4%E5%A4%9A%E5%85%B3%E4%BA%8E">https://rdatatable.gitlab.io/data.table/index.html。要了解更多关于</a> <strong>R6</strong>，我们推荐阅读《Advanced R》书的<a href="https://adv-r.hadley.nz/fp.html">第14章</a> [@wickham_advanced_2019]。]<br>
这些 <code>Task*$new()</code> 函数的第一个重要参数是 <code>backend</code>。<code>backend</code> 期望输入数据包括响应变量和预测变量。<code>target</code> 参数指示响应变量的名称（在我们的例子中是 <code>lslpts</code>），而 <code>positive</code> 决定响应变量的两个因子水平中哪一个表示滑坡起点（在我们的例子中是 <code>TRUE</code>）。<code>lsl</code> 数据集的所有其他变量将作为预测因子。对于空间交叉验证，我们需要提供一些额外的参数。<code>coordinate_names</code> 参数期望坐标列的名称（参见<em>空间交叉验证</em>章节和图3）。另外，我们应该指示使用的坐标参考系统（<code>crs</code>）并决定是否希望在建模中使用坐标作为预测因子（<code>coords_as_features</code>）。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># create task</span></span><br><span class="line">task <span class="operator">=</span> mlr3spatiotempcv<span class="operator">::</span>TaskClassifST<span class="operator">$</span>new<span class="punctuation">(</span></span><br><span class="line">  id <span class="operator">=</span> <span class="string">&quot;ecuador_lsl&quot;</span><span class="punctuation">,</span></span><br><span class="line">  backend <span class="operator">=</span> mlr3<span class="operator">::</span>as_data_backend<span class="punctuation">(</span>lsl<span class="punctuation">)</span><span class="punctuation">,</span> </span><br><span class="line">  target <span class="operator">=</span> <span class="string">&quot;lslpts&quot;</span><span class="punctuation">,</span> </span><br><span class="line">  positive <span class="operator">=</span> <span class="string">&quot;TRUE&quot;</span><span class="punctuation">,</span></span><br><span class="line">  coordinate_names <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;x&quot;</span><span class="punctuation">,</span> <span class="string">&quot;y&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">  coords_as_features <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">,</span></span><br><span class="line">  crs <span class="operator">=</span> <span class="string">&quot;EPSG:32717&quot;</span></span><br><span class="line">  <span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>注意，<code>mlr3spatiotempcv::as_task_classif_st()</code> 也接受一个 <code>sf</code>-对象作为 <code>backend</code> 参数的输入。在这种情况下，你可能只想额外指定 <code>coords_as_features</code> 参数。我们没有将 <code>lsl</code> 转换为一个 <code>sf</code>-对象，因为 <code>TaskClassifST$new()</code> 在背景中会将其转换回一个非空间的 <code>data.table</code> 对象。对于简短的数据探索，<strong>mlr3viz</strong> 包的 <code>autoplot()</code> 函数可能会很方便，因为它会绘制响应与所有预测因子的关系，以及所有预测因子之间的关系（未显示）。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># plot response against each predictor</span></span><br><span class="line">mlr3viz<span class="operator">::</span>autoplot<span class="punctuation">(</span>task<span class="punctuation">,</span> type <span class="operator">=</span> <span class="string">&quot;duo&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># plot all variables against each other</span></span><br><span class="line">mlr3viz<span class="operator">::</span>autoplot<span class="punctuation">(</span>task<span class="punctuation">,</span> type <span class="operator">=</span> <span class="string">&quot;pairs&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>创建了任务之后，我们需要选择一个<strong>学习器（learner）</strong>，以确定要使用的统计学\index{statistical learning}方法。所有分类的<strong>学习器</strong>以 <code>classif.</code> 开头，所有回归的学习器以 <code>regr.</code> 开头（详见 <code>?Learner</code>）。<code>mlr3extralearners::list_mlr3learners()</code> 列出了所有可用的学习器以及 <strong>mlr3</strong> 从哪个软件包中导入了它们（表 @ref(tab:lrns)）。要了解能够对二元响应变量进行建模的学习器，我们可以运行：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">mlr3extralearners<span class="operator">::</span>list_mlr3learners<span class="punctuation">(</span></span><br><span class="line">  filter <span class="operator">=</span> <span class="built_in">list</span><span class="punctuation">(</span><span class="built_in">class</span> <span class="operator">=</span> <span class="string">&quot;classif&quot;</span><span class="punctuation">,</span> properties <span class="operator">=</span> <span class="string">&quot;twoclass&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> </span><br><span class="line">  select <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;id&quot;</span><span class="punctuation">,</span> <span class="string">&quot;mlr3_package&quot;</span><span class="punctuation">,</span> <span class="string">&quot;required_packages&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">  head<span class="punctuation">(</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<table>
<caption>Sample of available learners for binomial tasks in the mlr3 package.</caption>
 <thead>
  <tr>
   <th style="text-align:left;"> Class </th>
   <th style="text-align:left;"> Name </th>
   <th style="text-align:left;"> Short name </th>
   <th style="text-align:left;"> Package </th>
  </tr>
 </thead>
<tbody>
  <tr>
   <td style="text-align:left;"> classif.adaboostm1 </td>
   <td style="text-align:left;"> ada Boosting M1 </td>
   <td style="text-align:left;"> adaboostm1 </td>
   <td style="text-align:left;"> RWeka </td>
  </tr>
  <tr>
   <td style="text-align:left;"> classif.binomial </td>
   <td style="text-align:left;"> Binomial Regression </td>
   <td style="text-align:left;"> binomial </td>
   <td style="text-align:left;"> stats </td>
  </tr>
  <tr>
   <td style="text-align:left;"> classif.featureless </td>
   <td style="text-align:left;"> Featureless classifier </td>
   <td style="text-align:left;"> featureless </td>
   <td style="text-align:left;"> mlr </td>
  </tr>
  <tr>
   <td style="text-align:left;"> classif.fnn </td>
   <td style="text-align:left;"> Fast k-Nearest Neighbour </td>
   <td style="text-align:left;"> fnn </td>
   <td style="text-align:left;"> FNN </td>
  </tr>
  <tr>
   <td style="text-align:left;"> classif.gausspr </td>
   <td style="text-align:left;"> Gaussian Processes </td>
   <td style="text-align:left;"> gausspr </td>
   <td style="text-align:left;"> kernlab </td>
  </tr>
  <tr>
   <td style="text-align:left;"> classif.IBk </td>
   <td style="text-align:left;"> k-Nearest Neighbours </td>
   <td style="text-align:left;"> ibk </td>
   <td style="text-align:left;"> RWeka </td>
  </tr>
</tbody>
</table>
<p>这将产生所有能够处理两类问题（有或没有滑坡）的学习器。我们选择在<em>传统建模</em>节中使用的二项分类方法，该方法在 <strong>mlr3learners</strong> 中实现为 <code>classif.log_reg</code>。另外，我们需要指定 <code>predict.type</code>，它决定了预测的类型，<code>prob</code> 会得出滑坡发生概率在0到1之间的预测值（这对应于 <code>predict.glm</code> 中的 <code>type = response</code>）。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">learner <span class="operator">=</span> mlr3<span class="operator">::</span>lrn<span class="punctuation">(</span><span class="string">&quot;classif.log_reg&quot;</span><span class="punctuation">,</span> predict_type <span class="operator">=</span> <span class="string">&quot;prob&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>要访问学习器的帮助页面并找出它来自哪个包，我们可以运行：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">learner<span class="operator">$</span>help<span class="punctuation">(</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<!--
Having specified a learner and a task, we can train our model which basically executes the `glm()` command in the background for our task. 

<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">learner<span class="operator">$</span>train<span class="punctuation">(</span>task<span class="punctuation">)</span></span><br><span class="line">learner<span class="operator">$</span>model</span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">fit <span class="operator">=</span> glm<span class="punctuation">(</span>lslpts <span class="operator">~</span> .<span class="punctuation">,</span> family <span class="operator">=</span> binomial<span class="punctuation">(</span>link <span class="operator">=</span> <span class="string">&quot;logit&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> </span><br><span class="line">          data <span class="operator">=</span> select<span class="punctuation">(</span>lsl<span class="punctuation">,</span> <span class="operator">-</span>x<span class="punctuation">,</span> <span class="operator">-</span>y<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">identical<span class="punctuation">(</span>fit<span class="operator">$</span>coefficients<span class="punctuation">,</span> learner<span class="operator">$</span>model<span class="operator">$</span>coefficients<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<p>使用 <strong>mlr3</strong>进行建模的设置步骤可能看似繁琐。但请记住，这个单一的接口提供了访问 <code>mlr3extralearners::list_mlr3learners()</code> 显示的130多个学习器的途径；学习每个学习器的接口将会更加繁琐！其他优点包括简单的重采样技术的并行化和调整机器学习超参数的能力。最重要的是，<strong>mlr3spatiotempcv</strong> [@schratz_mlr3spatiotempcv_2021] 中的（空间）重采样非常直接，只需要两个额外的步骤：指定一个重采样方法并运行它。我们将使用100重复的5折空间CV：根据我们 <code>task</code> 中提供的坐标选择五个分区，并重复该划分100次：[^13]</p>
<p>[^13]: 请注意，<strong>sperrorest</strong> 包最初在R中实现了空间交叉验证 [@brenning_spatial_2012]。其功能已经被集成到 <strong>mlr3</strong> 生态系统中，这就是为什么我们使用 <strong>mlr3</strong> [@schratz_hyperparameter_2019]。<strong>tidymodels</strong> 框架是R中另一个用于简化建模的 umbrella-package；然而，它最近才通过 <strong>spatialsample</strong> 集成了对空间交叉验证的支持，迄今为止只支持一种空间重采样方法。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">resampling <span class="operator">=</span> mlr3<span class="operator">::</span>rsmp<span class="punctuation">(</span><span class="string">&quot;repeated_spcv_coords&quot;</span><span class="punctuation">,</span> folds <span class="operator">=</span> <span class="number">5</span><span class="punctuation">,</span> repeats <span class="operator">=</span> <span class="number">100</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>要执行空间重采样，我们运行<code>resample()</code>，使用之前指定的任务、学习器和重采样策略。这需要一些时间（在现代笔记本电脑上大约需要15秒），因为它计算了500个重采样分区和500个模型。<br>
作为性能度量，我们再次选择AUROC。要获取它，我们使用重采样结果输出对象（<code>score_spcv_glm</code>）的<code>score()</code>方法。这将返回一个具有500行的<code>data.table</code>对象——每个模型一行。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># reduce verbosity</span></span><br><span class="line">lgr<span class="operator">::</span>get_logger<span class="punctuation">(</span><span class="string">&quot;mlr3&quot;</span><span class="punctuation">)</span><span class="operator">$</span>set_threshold<span class="punctuation">(</span><span class="string">&quot;warn&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># run spatial cross-validation and save it to resample result glm (rr_glm)</span></span><br><span class="line">rr_spcv_glm <span class="operator">=</span> mlr3<span class="operator">::</span>resample<span class="punctuation">(</span>task <span class="operator">=</span> task<span class="punctuation">,</span></span><br><span class="line">                             learner <span class="operator">=</span> learner<span class="punctuation">,</span></span><br><span class="line">                             resampling <span class="operator">=</span> resampling<span class="punctuation">)</span></span><br><span class="line"><span class="comment"># compute the AUROC as a data.table</span></span><br><span class="line">score_spcv_glm <span class="operator">=</span> rr_spcv_glm<span class="operator">$</span>score<span class="punctuation">(</span>measure <span class="operator">=</span> mlr3<span class="operator">::</span>msr<span class="punctuation">(</span><span class="string">&quot;classif.auc&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># keep only the columns you need</span></span><br><span class="line">score_spcv_glm <span class="operator">=</span> score_spcv_glm<span class="punctuation">[</span><span class="punctuation">,</span> .<span class="punctuation">(</span>task_id<span class="punctuation">,</span> learner_id<span class="punctuation">,</span> resampling_id<span class="punctuation">,</span> </span><br><span class="line">                                    classif.auc<span class="punctuation">)</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<p>前面代码块的输出是模型预测性能的偏差减少评估。我们已经将其保存为书籍GitHub仓库中的<code>extdata/12-bmr_score.rds</code>。如有需要，您可以按照以下方式读取它：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">score <span class="operator">=</span> readRDS<span class="punctuation">(</span><span class="string">&quot;extdata/12-bmr_score.rds&quot;</span><span class="punctuation">)</span></span><br><span class="line">score_spcv_glm <span class="operator">=</span> score<span class="punctuation">[</span>learner_id <span class="operator">==</span> <span class="string">&quot;classif.log_reg&quot;</span> <span class="operator">&amp;</span> </span><br><span class="line">                         resampling_id <span class="operator">==</span> <span class="string">&quot;repeated_spcv_coords&quot;</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<p>要计算所有500个模型的AUROC均值，我们运行：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">mean<span class="punctuation">(</span>score_spcv_glm<span class="operator">$</span>classif.auc<span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">  <span class="built_in">round</span><span class="punctuation">(</span><span class="number">2</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] 0.77</span></span><br></pre></td></tr></table></figure>
<p>为了更全面地理解这些结果，让我们将它们与来自100次重复的5折非空间交叉验证的AUROC值进行比较；非空间交叉验证的代码在这里没有显示，但将在练习部分进行探讨）。<br>
如预期，与传统的交叉验证方法相比，空间交叉验证的结果平均而言产生了较低的AUROC值，这强调了后者由于空间自相关而过于乐观的预测性能。</p>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309051217339.png" alt=""><br>
Boxplot showing the difference in GLM AUROC values on spatial and conventional 100-repeated 5-fold cross-validation.</p>
<h2 id="机器学习超参数的空间调优">机器学习超参数的空间调优</h2>
<p><em>空间交叉验证</em>节绍了机器学习作为统计学习的一部分。回顾一下，我们遵循<a href="https://machinelearningmastery.com/linear-regression-for-machine-learning/">Jason Brownlee</a>对机器学习的以下定义：</p>
<blockquote>
<p>机器学习，更具体地说是预测建模领域，主要关注的是最小化模型的错误或以解释性为代价做出尽可能准确的预测。在应用机器学习中，我们将从许多不同的领域借用、重用和窃取算法，包括统计学，并将它们用于这些目的。</p>
</blockquote>
<p>在节<em>广义线性模型</em>中，使用了广义线性模型（GLM）来预测滑坡敏感性。本节介绍了用于同一目的的支持向量机（SVM）。随机森林模型可能比SVM更受欢迎；然而，调整超参数对模型性能的积极影响在SVM的情况下更为明显[@probst_hyperparameters_2018]。由于（空间）超参数调整是本节的主要目标，我们将使用SVM。对于希望应用随机森林模型的人，我们建议阅读这一章，然后继续阅读章节<em>生态</em>，在其中我们将应用目前涵盖的概念和技术，基于随机森林模型制作空间分布图。</p>
<p>SVM（支持向量机）寻找最佳可能的’超平面’来分隔类别（在分类情况下）并估计具有特定超参数的’核’以在类别之间创建非线性边界[@james_introduction_2013]。<br>
机器学习算法通常具有超参数和参数。参数可以从数据中估算，而超参数则在学习开始之前设置（另请参见<a href="https://machinelearningmastery.com/difference-between-a-parameter-and-a-hyperparameter/">machine mastery blog</a>和mlr3书中的<a href="https://mlr3book.mlr-org.com/optimization.html">超参数优化章节</a>）。最优的超参数配置通常在特定的搜索空间内找到，并在交叉验证方法的帮助下确定。这称为超参数调优，是本节的主要话题。</p>
<p>一些SVM实现，如由<strong>kernlab</strong>提供的，允许自动调整超参数，通常基于随机抽样（见图3的上行）。这适用于非空间数据，但对于应进行’空间调优’的空间数据则用处不大。</p>
<p>在定义空间调优之前，我们将设置用于SVM的<strong>mlr3</strong>构建块，这些在<em>glm</em>节中已经介绍过。分类任务保持不变，因此我们可以简单地重用在节<em>glm</em>中创建的<code>task</code>对象。实现SVM的学习器可以使用<strong>mlr3extralearners</strong>的<code>list_mlr3learners()</code>命令找到。</p>
<p>在选项中，我们将使用<strong>kernlab</strong>软件包[@karatzoglou_kernlab_2004]的<code>ksvm()</code>。为了允许非线性关系，我们使用流行的径向基函数（或高斯）核（“rbfdot”），这也是<code>ksvm()</code>的默认设置。将<code>type</code>参数设置为<code>&quot;C-svc&quot;</code>确保<code>ksvm()</code>正在解决一个分类任务。为确保调优不会因一个失败的模型而停止，我们还定义了一个后备学习器（更多信息请参考<a href="https://mlr3book.mlr-org.com/technical.html#fallback-learners%EF%BC%89%E3%80%82">https://mlr3book.mlr-org.com/technical.html#fallback-learners）。</a></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">lrn_ksvm <span class="operator">=</span> mlr3<span class="operator">::</span>lrn<span class="punctuation">(</span><span class="string">&quot;classif.ksvm&quot;</span><span class="punctuation">,</span> predict_type <span class="operator">=</span> <span class="string">&quot;prob&quot;</span><span class="punctuation">,</span> kernel <span class="operator">=</span> <span class="string">&quot;rbfdot&quot;</span><span class="punctuation">,</span></span><br><span class="line">                     type <span class="operator">=</span> <span class="string">&quot;C-svc&quot;</span><span class="punctuation">)</span></span><br><span class="line">lrn_ksvm<span class="operator">$</span>fallback <span class="operator">=</span> lrn<span class="punctuation">(</span><span class="string">&quot;classif.featureless&quot;</span><span class="punctuation">,</span> predict_type <span class="operator">=</span> <span class="string">&quot;prob&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>下一步是指定一个重采样策略。<br>
我们再次将使用100次重复的5折空间交叉验证（CV）\index{cross-validation!spatial CV}。</p>
<!-- 在我们的论文中，我们一致同意使用“性能估计级别”和“调优级别”，而不是说“外部和内部重采样” -->
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># performance estimation level</span></span><br><span class="line">perf_level <span class="operator">=</span> mlr3<span class="operator">::</span>rsmp<span class="punctuation">(</span><span class="string">&quot;repeated_spcv_coords&quot;</span><span class="punctuation">,</span> folds <span class="operator">=</span> <span class="number">5</span><span class="punctuation">,</span> repeats <span class="operator">=</span> <span class="number">100</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>请注意，这与节<em>glm</em>中用于GLM的重采样所用的代码完全相同；我们只是在这里重复它作为提醒。</p>
<p>到目前为止，这个过程与节<em>glm</em>中描述的过程相同。然而，下一步是新的：调整超参数。使用相同的数据进行性能评估和调优可能会导致过于乐观的结果[@cawley_overfitting_2010]。这可以通过使用嵌套的空间交叉验证（CV）来避免。</p>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309051230694.png" alt=""><br>
Schematic of hyperparameter tuning and performance estimation levels in CV. [Figure was taken from Schratz et al. (2019). Permission to reuse it was kindly granted.]</p>
<p>这意味着我们将每个折叠再次分成五个空间上不重叠的子折叠，这些子折叠用于确定最佳的超参数\index{hyperparameter}（下面代码块中的<code>tune_level</code>对象；见上图以获取视觉表示）。为了找到最优的超参数组合，我们在这些子折叠中分别拟合50个模型（下面代码块中的<code>terminator</code>对象），并为超参数C和Sigma随机选择值。C和Sigma的随机选择值还受到预定义调优空间（<code>search_space</code>对象）的额外限制。调优空间的范围是根据文献中推荐的值来选择的[@schratz_hyperparameter_2019]。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># five spatially disjoint partitions</span></span><br><span class="line">tune_level <span class="operator">=</span> mlr3<span class="operator">::</span>rsmp<span class="punctuation">(</span><span class="string">&quot;spcv_coords&quot;</span><span class="punctuation">,</span> folds <span class="operator">=</span> <span class="number">5</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># use 50 randomly selected hyperparameters</span></span><br><span class="line">terminator <span class="operator">=</span> mlr3tuning<span class="operator">::</span>trm<span class="punctuation">(</span><span class="string">&quot;evals&quot;</span><span class="punctuation">,</span> n_evals <span class="operator">=</span> <span class="number">50</span><span class="punctuation">)</span></span><br><span class="line">tuner <span class="operator">=</span> mlr3tuning<span class="operator">::</span>tnr<span class="punctuation">(</span><span class="string">&quot;random_search&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># define the outer limits of the randomly selected hyperparameters</span></span><br><span class="line">search_space <span class="operator">=</span> paradox<span class="operator">::</span>ps<span class="punctuation">(</span></span><br><span class="line">  C <span class="operator">=</span> paradox<span class="operator">::</span>p_dbl<span class="punctuation">(</span>lower <span class="operator">=</span> <span class="operator">-</span><span class="number">12</span><span class="punctuation">,</span> upper <span class="operator">=</span> <span class="number">15</span><span class="punctuation">,</span> trafo <span class="operator">=</span> <span class="keyword">function</span><span class="punctuation">(</span>x<span class="punctuation">)</span> <span class="number">2</span><span class="operator">^</span>x<span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">  sigma <span class="operator">=</span> paradox<span class="operator">::</span>p_dbl<span class="punctuation">(</span>lower <span class="operator">=</span> <span class="operator">-</span><span class="number">15</span><span class="punctuation">,</span> upper <span class="operator">=</span> <span class="number">6</span><span class="punctuation">,</span> trafo <span class="operator">=</span> <span class="keyword">function</span><span class="punctuation">(</span>x<span class="punctuation">)</span> <span class="number">2</span><span class="operator">^</span>x<span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>下一步是根据所有定义超参数调优的特性，使用<code>AutoTuner$new()</code>来修改学习器<code>lrn_ksvm</code>。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">at_ksvm <span class="operator">=</span> mlr3tuning<span class="operator">::</span>AutoTuner<span class="operator">$</span>new<span class="punctuation">(</span></span><br><span class="line">  learner <span class="operator">=</span> lrn_ksvm<span class="punctuation">,</span></span><br><span class="line">  resampling <span class="operator">=</span> tune_level<span class="punctuation">,</span></span><br><span class="line">  measure <span class="operator">=</span> mlr3<span class="operator">::</span>msr<span class="punctuation">(</span><span class="string">&quot;classif.auc&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">  search_space <span class="operator">=</span> search_space<span class="punctuation">,</span></span><br><span class="line">  terminator <span class="operator">=</span> terminator<span class="punctuation">,</span></span><br><span class="line">  tuner <span class="operator">=</span> tuner</span><br><span class="line"><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>现在调优设置已完成，用于确定一个折叠的最佳超参数将拟合250个模型。重复这个过程针对每个折叠，我们最终得到125,000（250 * 5）个模型用于每次重复。重复100次意味着拟合总共125,000个模型以确定最佳超参数（见图）。这些将用于性能评估，这需要拟合另外500个模型（5个折叠 * 100次重复；参见图。<br>
为了更清晰地描述性能评估处理链，让我们记录下我们给计算机的命令：</p>
<ol>
<li>性能层次（图的左上部分）- 将数据集分成五个空间上不交叠的（外部）子折叠。</li>
<li>调优层次（图的左下部分）- 使用性能层次的第一个折叠，并再次将其空间上分成五个（内部）子折叠进行超参数调优。在这些内部子折叠中使用50个随机选定的超参数，即拟合250个模型。</li>
<li>性能估计 - 使用上一步（调优层次）中的最佳超参数组合，并将其应用于性能层次中的第一个外部折叠以估计性能（AUROC）。</li>
<li>重复步骤2和3，针对其余四个外部折叠。</li>
<li>重复步骤2至4，共100次。</li>
</ol>
<p>超参数调优和性能估计的过程在计算上是非常密集的。为了减少模型运行时间，<strong>mlr3</strong>提供了使用<strong>future</strong>包进行并行化\index{parallelization}的可能性。由于我们即将进行嵌套交叉验证，我们可以决定是否希望并行化内部循环或外部循环（见图的左下部分）。由于前者将运行125,000个模型，而后者仅运行500个，很明显我们应该并行化内部循环。要设置内部循环的并行化，我们执行：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>future<span class="punctuation">)</span></span><br><span class="line"><span class="comment"># execute the outer loop sequentially and parallelize the inner loop</span></span><br><span class="line">future<span class="operator">::</span>plan<span class="punctuation">(</span><span class="built_in">list</span><span class="punctuation">(</span><span class="string">&quot;sequential&quot;</span><span class="punctuation">,</span> <span class="string">&quot;multisession&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> </span><br><span class="line">             workers <span class="operator">=</span> <span class="built_in">floor</span><span class="punctuation">(</span>availableCores<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">/</span> <span class="number">2</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>确实，我们指示<strong>future</strong>包仅使用可用核心的一半而非全部（默认设置），这样做是为了在使用高性能计算集群的情况下允许其他可能的用户也能在同一个集群上工作。</p>
<p>现在，我们已经为执行嵌套空间交叉验证做好了准备。指定<code>resample()</code>参数的过程与使用GLM时完全相同，唯一的区别是<code>store_models</code>和<code>encapsulate</code>参数。将前者设置为<code>TRUE</code>将允许我们提取超参数调优结果，这在我们计划对调优进行后续分析时非常重要。后者确保即使其中一个模型出错，处理过程也会继续。这避免了由于一个失败的模型而导致整个过程停止，这在大规模模型运行中是非常需要的。一旦处理完成，可以查看失败的模型。处理完成后，最好使用<code>future:::ClusterRegistry(&quot;stop&quot;)</code>明确地停止并行化。最后，我们将输出对象（<code>result</code>）保存到磁盘，以防我们希望在另一个R会话中使用它。</p>
<p>在运行以下代码之前，请注意，由于它将执行包括125,500个模型在内的空间交叉验证，所以这是一个耗时的过程。在现代笔记本电脑上轻松运行半天也是可能的。需要注意的是，运行时间取决于多个方面：CPU速度、所选算法、所选核心数以及数据集。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">progressr<span class="operator">::</span>with_progress<span class="punctuation">(</span>expr <span class="operator">=</span> <span class="punctuation">&#123;</span></span><br><span class="line">  rr_spcv_svm <span class="operator">=</span> mlr3<span class="operator">::</span>resample<span class="punctuation">(</span>task <span class="operator">=</span> task<span class="punctuation">,</span></span><br><span class="line">                               learner <span class="operator">=</span> at_ksvm<span class="punctuation">,</span> </span><br><span class="line">                               <span class="comment"># outer resampling (performance level)</span></span><br><span class="line">                               resampling <span class="operator">=</span> perf_level<span class="punctuation">,</span></span><br><span class="line">                               store_models <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">,</span></span><br><span class="line">                               encapsulate <span class="operator">=</span> <span class="string">&quot;evaluate&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># stop parallelization</span></span><br><span class="line">future<span class="operator">:::</span>ClusterRegistry<span class="punctuation">(</span><span class="string">&quot;stop&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># compute the AUROC values</span></span><br><span class="line">score_spcv_svm <span class="operator">=</span> rr_spcv_svm<span class="operator">$</span>score<span class="punctuation">(</span>measure <span class="operator">=</span> mlr3<span class="operator">::</span>msr<span class="punctuation">(</span><span class="string">&quot;classif.auc&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span> </span><br><span class="line"><span class="comment"># keep only the columns you need</span></span><br><span class="line">score_spcv_svm <span class="operator">=</span> score_spcv_svm<span class="punctuation">[</span><span class="punctuation">,</span> .<span class="punctuation">(</span>task_id<span class="punctuation">,</span> learner_id<span class="punctuation">,</span> resampling_id<span class="punctuation">,</span> classif.auc<span class="punctuation">)</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<p>如果你不想在本地运行代码，我们已经将 <a href="https://github.com/geocompx/geocompr/blob/main/extdata/12-bmr_score.rds">score_svm</a> 保存在本书的GitHub仓库中。你可以按照以下方式加载它们：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">score <span class="operator">=</span> readRDS<span class="punctuation">(</span><span class="string">&quot;extdata/12-bmr_score.rds&quot;</span><span class="punctuation">)</span></span><br><span class="line">score_spcv_svm <span class="operator">=</span> score<span class="punctuation">[</span>learner_id <span class="operator">==</span> <span class="string">&quot;classif.ksvm.tuned&quot;</span> <span class="operator">&amp;</span> </span><br><span class="line">                         resampling_id <span class="operator">==</span> <span class="string">&quot;repeated_spcv_coords&quot;</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<p>让我们看一下最终的AUROC：模型区分两个类别的能力。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># final mean AUROC</span></span><br><span class="line"><span class="built_in">round</span><span class="punctuation">(</span>mean<span class="punctuation">(</span>score_spcv_svm<span class="operator">$</span>classif.auc<span class="punctuation">)</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] 0.74</span></span><br></pre></td></tr></table></figure>
<p>在这个特定情况下，似乎GLM（汇总的AUROC是 <code>r score[resampling_id == &quot;repeated_spcv_coords&quot; &amp; learner_id == &quot;classif.log_reg&quot;, round(mean(classif.auc), 2)]</code>）比SVM略好一些。为了保证一个绝对公平的比较，还应确保两个模型使用完全相同的划分——这是我们在这里没有展示，但在背后默默使用的（更多信息请参见本书GitHub仓库中的<code>code/12_cv.R</code>）。为此，<strong>mlr3</strong>提供了<code>benchmark_grid()</code>和<code>benchmark()</code>函数[参见<a href="https://mlr3book.mlr-org.com/perf-eval-cmp.html#benchmarking%EF%BC%8C@becker_mlr3_2022">https://mlr3book.mlr-org.com/perf-eval-cmp.html#benchmarking，@becker_mlr3_2022</a>]。我们将在练习中更详细地探讨这些函数。还请注意，在SVM的随机搜索中使用超过50次迭代可能会产生导致模型具有更好AUROC的超参数\index{hyperparameter} [@schratz_hyperparameter_2019]。另一方面，增加随机搜索迭代次数也会增加总模型数量，从而增加运行时间。</p>
<p>到目前为止，空间CV已被用于评估学习算法泛化到未见数据的能力。对于预测性制图目的，人们会在完整的数据集上调整超参数。这将在<em>生态</em>章中讨论。</p>
<h1>结论</h1>
<p>重采样方法是数据科学家工具箱中的一个重要组成部分[@james_introduction_2013]。本章使用交叉验证来评估各种模型的预测性能。具有空间坐标的观测值可能由于空间自相关而不是统计上独立的，这违反了交叉验证的一个基本假设。空间CV通过减少空间自相引入的偏见来解决这个问题。</p>
<p><strong>mlr3</strong>软件包便于使用（空间）重采样技术，结合最受欢迎的统计学习技术，包括线性回归，如广义加性模型之类的半参数模型，以及如随机森林，SVMs和增强回归树[@bischl_mlr:_2016;@schratz_hyperparameter_2019]等机器学习技术。机器学习算法通常需要超参数输入，其中最优的“调整”可能需要数千次模型运行，这需要大量的计算资源，消耗大量时间、RAM和/或核心。<strong>mlr3</strong>通过启用并行化来解决这个问题。</p>
<p>总体而言，机器学习及其用于理解空间数据是一个大领域，本章提供了基础知识，但还有更多需要学习。我们推荐以下方向的资源：</p>
<ul>
<li><strong>mlr3 book</strong> [@becker_mlr3_2022; <a href="https://mlr-org.github.io/mlr-tutorial/release/html/">https://mlr-org.github.io/mlr-tutorial/release/html/</a>]，特别是<a href="https://mlr3book.mlr-org.com/spatiotemporal.html">关于处理时空数据的章节</a></li>
<li>关于超参数\index{hyperparameter}调整的学术论文[@schratz_hyperparameter_2019]</li>
<li>关于如何使用<strong>mlr3spatiotempcv</strong>的学术论文[@schratz_mlr3spatiotempcv_2021]</li>
<li>在处理时空数据的情况下，应当在进行CV时考虑空间和时间自相关[@meyer_improving_2018]</li>
</ul>
<h1>练习</h1>
<p>E1. 使用R-GIS桥梁（参见GIS软件桥梁章节），从通过<code>terra::rast(system.file(&quot;raster/ta.tif&quot;, package = &quot;spDataLarge&quot;))$elev</code>加载的<code>elev</code>数据集中计算以下地形属性：</p>
<ul>
<li>坡度</li>
<li>平面曲率</li>
<li>轮廓曲率</li>
<li>流域面积</li>
</ul>
<p>E2. 从相应的输出栅格中提取值到<code>lsl</code>数据框（通过<code>data(&quot;lsl&quot;, package = &quot;spDataLarge&quot;)</code>），并添加名为<code>slope</code>、<code>cplan</code>、<code>cprof</code>、<code>elev</code>和<code>log_carea</code>的新变量。</p>
<p>E3. 结合GLM使用派生的地形属性栅格，制作一个与图12.2中显示的相似的空间预测地图。<br>
运行<code>data(&quot;study_mask&quot;, package = &quot;spDataLarge&quot;)</code>将学习区域的掩码附加上。</p>
<p>E4. 基于GLM学习器计算100次重复的5折非空间交叉验证和空间CV，并利用箱线图比较两种重采样策略的AUROC值。</p>
<p>提示：你需要指定一个非空间重采样策略。</p>
<p>另一个提示：你可能想借助<code>mlr3::benchmark()</code>和<code>mlr3::benchmark_grid()</code>（更多信息，请参考<a href="https://mlr3book.mlr-org.com/performance.html#benchmarking%EF%BC%89%E4%B8%80%E6%AC%A1%E6%80%A7%E8%A7%A3%E5%86%B3%E7%BB%83%E4%B9%A04%E8%87%B36%E3%80%82">https://mlr3book.mlr-org.com/performance.html#benchmarking）一次性解决练习4至6。</a><br>
在做此操作时，请记住计算可能需要很长时间，可能需要几天。<br>
这当然取决于你的系统。<br>
你拥有的RAM和核心越多，计算时间就会越短。</p>
<p>E5. 使用二次判别分析（QDA）对滑坡敏感性进行建模。<br>
评估QDA的预测性能。<br>
QDA和GLM的空间交叉验证平均AUROC值之间有什么区别？</p>
<p>E6. 不调整超参数运行SVM。<br>
使用$\sigma$ = 1 和 <em>C</em> = 1的<code>rbfdot</code>核。<br>
否则，在<strong>kernlab</strong>的<code>ksvm()</code>中不指定超参数将初始化自动的非空间超参数调整。</p>
]]></content>
      <categories>
        <category>R</category>
        <category>Geocomputaion</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>Geocomputaion</tag>
      </tags>
  </entry>
  <entry>
    <title>(10)连接到GIS的桥梁</title>
    <url>/2023/08/19/2023-8-19-10%E8%BF%9E%E6%8E%A5%E5%88%B0GIS%E8%BD%AF%E4%BB%B6%E7%9A%84%E6%A1%A5%E6%A2%81/</url>
    <content><![CDATA[<blockquote><p>本文由SCY翻译自《Geocomputation with R》<a href="https://r.geocompx.org/gis">第十章</a></p>
</blockquote>
<p>R 等具有交互式控制台的语言的一个特点——严格来说是一个读取-求值-打印循环（REPL）—— 是你与它们互动的方式。与其依赖于在屏幕的不同部分上指点和点击，你可以将命令键入控制台，并使用 <code>Enter</code> 键执行它们。使用像RStudio或VS Code这样的交互式开发环境时，一个常见且有效的工作流程是将代码键入源文件的源编辑器中，并使用像<code>Ctrl+Enter</code>这样的快捷方式来控制代码的交互式执行。</p>
<span id="more"></span>
<h1>前提条件</h1>
<ul>
<li>本章需要安装 QGIS、SAGA和GRASS，并附加以下包：</li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>sf<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>terra<span class="punctuation">)</span></span><br><span class="line">remotes<span class="operator">::</span>install_github<span class="punctuation">(</span><span class="string">&quot;r-tmap/tmap&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; </span></span><br><span class="line"><span class="comment">#&gt; ── R CMD build ─────────────────────────────────────────────────────────────────</span></span><br><span class="line"><span class="comment">#&gt; * checking for file ‘/private/var/folders/x6/0mbmh6790tz0rrgmt0bqqs3m0000gn/T/RtmpjyIDsf/remotesc09c4ea71a88/r-tmap-tmap-1a2b4a7/DESCRIPTION’ ... OK</span></span><br><span class="line"><span class="comment">#&gt; * preparing ‘tmap’:</span></span><br><span class="line"><span class="comment">#&gt; * checking DESCRIPTION meta-information ... OK</span></span><br><span class="line"><span class="comment">#&gt; * checking for LF line-endings in source and make files and shell scripts</span></span><br><span class="line"><span class="comment">#&gt; * checking for empty or unneeded directories</span></span><br><span class="line"><span class="comment">#&gt; * looking to see if a ‘data/datalist’ file should be added</span></span><br><span class="line"><span class="comment">#&gt; * building ‘tmap_3.3-4.tar.gz’</span></span><br></pre></td></tr></table></figure>
<!--toDo:jn-->
<!-- qgisprocess to CRAN -->
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">remotes<span class="operator">::</span>install_github<span class="punctuation">(</span><span class="string">&quot;r-spatial/qgisprocess&quot;</span><span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>qgisprocess<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>Rsagacmd<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>rgrass<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>rstac<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>gdalcubes<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<h1>引言</h1>
<p>R 等具有交互式控制台的<a href="https://en.wikipedia.org/wiki/Interpreter_(computing)">interpreted</a>语言的一个特点——严格来说是一个读取-求值-打印循环（REPL）—— 是你与它们互动的方式。与其依赖于在屏幕的不同部分上指点和点击，你可以将命令键入控制台，并使用 <code>Enter</code> 键执行它们。使用像RStudio或VS Code这样的交互式开发环境时，一个常见且有效的工作流程是将代码键入源文件的源编辑器中，并使用像<code>Ctrl+Enter</code>这样的快捷方式来控制代码的交互式执行。</p>
<p>命令行界面（CLI）并不是R的独特属性：大多数早期的计算环境都依赖于命令行“shell”，直到计算机鼠标在20世纪90年代的发明和广泛采用后，图形用户界面（GUI）才变得普遍。例如，GRASS 是最长持续开发的开源GIS软件，最初依赖于其命令行界面，直到它获得GUI。大多数流行的GIS软件项目都是由GUI驱动的。你<em>可以</em>通过系统终端和嵌入式CLI与QGIS、SAGA、GRASS和gvSIG 进行交互，但它们的设计鼓励大多数人通过“点和击”与之交互。根据流行QGIS软件的创建者的说法：这样做的无意的后果是，大多数GIS用户错失了由CLI驱动和可编程方法带来的优势。</p>
<blockquote>
<p>随着“现代”GIS 软件的出现，大多数人希望点击完成任务。这很好，但命令行为你提供了大量的灵活性和力量。很多时候，你可以在命令行上以GUI的一小部分时间来完成某些操作。</p>
</blockquote>
<p>“CLI 与 GUI” 的辩论不必是敌对的：两种工作方式都有优点，取决于一系列因素，包括任务（如绘制新要素适合GUI）、所需的可重复性水平和用户的技能组合。GRASS是一个主要基于CLI但也有突出GUI的GIS软件的很好例子。同样，虽然R主要关注其CLI，但像RStudio这样的IDE为提高可访问性提供了 GUI。软件不能被整齐地分类为基于CLI或基于GUI。然而，交互式命令行界面在以下方面具有几个重要优势：</p>
<ul>
<li>自动化重复任务</li>
<li>实现透明度和可重复性</li>
<li>通过提供修改现有功能和实现新功能的工具来鼓励软件开发</li>
<li>发展具有高需求的未来防护和高效编程技能</li>
<li>提高触摸打字，这是数字时代的一项关键技能</li>
</ul>
<p>另一方面，良好的GUI也有优势，包括：</p>
<ul>
<li>“浅”学习曲线意味着地理数据可以在无需数小时学习新语言的情况下进行探索和可视化</li>
<li>支持“数字化”（创建新矢量数据集），包括跟踪、捕捉和拓扑工具。（<strong>mapedit</strong> R包允许在从R打开的浏览器窗口中快速编辑少量空间特性，但不支持专业的大规模制图数字化。）</li>
<li>通过地面控制点和正射校正实现地理参考</li>
<li>支持立体测图（例如，LiDAR 和运动结构）</li>
</ul>
<p>专用GIS软件项目的另一个优点是它们通过“GIS桥梁”提供对数百个“地理算法”的访问。这些增强R解决地理数据问题能力的计算配方桥梁是本章的主题。</p>
<blockquote>
<p>📌命令行界面是一个通过键入和输入连续命令（命令行）与计算机程序互动的环境。<br>
Linux中的<code>bash</code>和Windows中的<code>PowerShell</code>是众所周知的例子，它们允许用户控制操作系统的几乎任何部分。<br>
像RStudio和VS Code这样的集成开发环境（IDE）提供代码自动补全和其他功能，以改善用户在开发代码时的体验。</p>
</blockquote>
<p>R是可重复数据分析工作流与GIS之间建立桥梁的自然选择，因为它<em>起源</em>于一个接口语言。R（及其前身S）的一个关键特性是，它提供了访问其他语言（特别是 FORTRAN和C）中的统计算法的途径，但是来自一种功能强大的高级函数语言，并具有直观的REPL环境，而C和FORTRAN缺乏这样的环境。R继续这一传统，与众多语言接口，特别是 C++。</p>
<p>尽管R不是作为命令行GIS设计的，但其与专用GIS接口的能力赋予了它惊人的地理空间能力。借助GIS桥梁，R可以复制更多样化的工作流，通过从编程环境和一致的CLI控制它们，还能增加额外的可重复性、可扩展性和生产力优势。此外，R 在地理计算的某些领域超越了 GIS，包括交互式/动画地图制作和空间统计建模。</p>
<p>本章重点介绍了三个成熟的开源GIS产品的“桥梁”，在表中总结：</p>
<ul>
<li>QGIS，通过<strong>qgisprocess</strong>包</li>
<li>SAGA，通过<strong>Rsagacmd</strong>包</li>
<li>GRASS，通过<strong>rgrass</strong>包</li>
</ul>
<p>还有其他相关的桥梁，包括不再维护的R包<strong>RPyGeo</strong>，作为专有 GIS软件的接口。<br>
还有一些重大进展，使开源GIS软件能够从QGIS（见 <a href="https://docs.qgis.org/3.28/en/docs/training_manual/processing/r_intro.html">docs.qgis.org</a>）和GRASS（见 <a href="https://grasswiki.osgeo.org/wiki/R_statistics/rgrass#R_within_GRASS">grasswiki.osgeo.org</a>）编写和执行R脚本。</p>
<p>Table: Comparison between three open-source GIS. Hybrid refers to the support of vector and raster operations.</p>
<table>
<thead>
<tr>
<th style="text-align:left">GIS</th>
<th style="text-align:left">First release</th>
<th style="text-align:left">No. functions</th>
<th style="text-align:left">Support</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">QGIS</td>
<td style="text-align:left">2002</td>
<td style="text-align:left">&gt;1000</td>
<td style="text-align:left">hybrid</td>
</tr>
<tr>
<td style="text-align:left">SAGA</td>
<td style="text-align:left">2004</td>
<td style="text-align:left">&gt;600</td>
<td style="text-align:left">hybrid</td>
</tr>
<tr>
<td style="text-align:left">GRASS</td>
<td style="text-align:left">1982</td>
<td style="text-align:left">&gt;500</td>
<td style="text-align:left">hybrid</td>
</tr>
</tbody>
</table>
<p>除了上面提到的三种R-GIS桥接方法外,本章还简要介绍了R语言与空间库、空间数据库以及基于云的地球观测数据处理的接口。</p>
<h1><strong>qgisprocess</strong>：连接到QGIS及更远的桥梁</h1>
<p>是最受欢迎的开源GIS。QGIS提供了一个统一的接口来访问QGIS的本地地理算法、GDAL，以及当它们被安装时，来自<em>提供商</em>如GRASS和SAGA。自2020年夏季发布的3.14版本以来，QGIS随附了用于访问大量地理计算功能的<code>qgis_process</code>命令行工具。<code>qgis_process</code>提供了对标准QGIS安装中的300 多个地理算法的访问，以及通过插件对诸如GRASS和SAGA这样的外部提供商的1,000 多个算法的访问。</p>
<p><strong>qgisprocess</strong> 包提供了从 R 访问<code>qgis_process</code>的能力。该包要求安装QGIS以及本章中使用的任何其他相关插件，如 GRASS 和SAGA，并且系统可以访问它们。有关安装说明，请参阅<strong>qgisprocess</strong>的<a href="https://r-spatial.github.io/qgisprocess/">文档</a>。如果您已经安装了Docker，那么使用<strong>qgisprocess</strong>的快速方法是通过本项目开发的<code>qgis</code>镜像。假设您已经安装了Docker并且有足够的计算资源，您可以使用以下命令运行带有<strong>qgisprocess</strong>和相关插件的R会话（有关详细信息，请参阅 <a href="https://github.com/geocompx/docker">geocompx/docker</a> 仓库）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -e DISABLE_AUTH=<span class="literal">true</span> -p 8786:8787 ghcr.io/geocompx/docker:qgis</span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>qgisprocess<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>此包会自动尝试检测QGIS的安装，并在找不到时发出警告。^[你可以使用<code>qgis_configure()</code>查看检测过程的详细信息。]当配置失败时有几个可能的解决方案：你可以设置<code>options(qgisprocess.path = &quot;path/to/your_qgis_process&quot;)</code>，或者设置<code>R_QGISPROCESS_PATH</code>环境变量。上述方法也可用于你有多个 QGIS 安装并想决定使用哪一个时。更多细节，请参考<strong>qgisprocess</strong>的<a href="https://r-spatial.github.io/qgisprocess/articles/qgisprocess.html">’入门’小插图</a>。</p>
<p>接下来，我们可以找到在我们的计算机上可用的插件（意味着不同的软件）。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">qgis_plugins<span class="punctuation">(</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>这告诉我们，GRASS（<code>grassprovider</code>）和SAGA（<code>processing_saga_nextgen</code>）插件在系统上是可用的，但尚未启用。因为我们在本章后面需要它们，所以让我们启用它们。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">qgis_enable_plugins<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;grassprovider&quot;</span><span class="punctuation">,</span> <span class="string">&quot;processing_saga_nextgen&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> </span><br><span class="line">                    quiet <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>请注意，除了在您的系统上安装 SAGA 之外，您还需要安装 QGIS Python 插件 Processing Saga NextGen。您可以在 QGIS 内部通过<a href="https://docs.qgis.org/latest/en/docs/training_manual/qgis_plugins/fetching_plugins.html">插件管理器</a>进行安装，或者在 Linux 上至少可以借助Python包<a href="https://github.com/3liz/qgis-plugin-manager">qgis-plugin-manager</a>以编程方式进行。</p>
<p><code>qgis_providers()</code>会列出软件的名称和可用地理算法的相应数量。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">qgis_providers<span class="punctuation">(</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>输出表确认我们可以通过QGIS接口使用QGIS地理算法（<code>native</code>、<code>qgis</code>、<code>3d</code>）和来自第三方提供商GDAL、SAGA和GRASS 的外部算法。</p>
<p>我们现在已经准备好使用QGIS及其伙伴在R内部进行一些地理计算了！让我们尝试两个示例案例研究。第一个展示如何将具有不同边界的两个多边形数据集统一。第二个专注于从表示为栅格的数字高程模型中获取新信息。</p>
<h2 id="矢量数据">矢量数据</h2>
<p>假设你有两个具有不同空间单位（例如，区域、行政单位）的多边形对象。我们的目标是将这两个对象合并为一个，包括所有边界线和相关属性。我们再次使用已经遇到的不一致的多边形。<strong>spData</strong>包中提供了这两个多边形数据集，我们希望对这两个数据集都使用地理坐标参考系统（CRS）。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">data<span class="punctuation">(</span><span class="string">&quot;incongruent&quot;</span><span class="punctuation">,</span> <span class="string">&quot;aggregating_zones&quot;</span><span class="punctuation">,</span> package <span class="operator">=</span> <span class="string">&quot;spData&quot;</span><span class="punctuation">)</span></span><br><span class="line">incongr_wgs <span class="operator">=</span> st_transform<span class="punctuation">(</span>incongruent<span class="punctuation">,</span> <span class="string">&quot;EPSG:4326&quot;</span><span class="punctuation">)</span></span><br><span class="line">aggzone_wgs <span class="operator">=</span> st_transform<span class="punctuation">(</span>aggregating_zones<span class="punctuation">,</span> <span class="string">&quot;EPSG:4326&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#&gt; The legacy packages maptools, rgdal, and rgeos, underpinning the sp package,</span><br><span class="line">#&gt; which was just loaded, will retire in October 2023.</span><br><span class="line">#&gt; Please refer to R-spatial evolution reports for details, especially</span><br><span class="line">#&gt; https://r-spatial.org/r/2023/05/15/evolution4.html.</span><br><span class="line">#&gt; It may be desirable to make the sf package available;</span><br><span class="line">#&gt; package maintainers should consider adding sf to Suggests:.</span><br><span class="line">#&gt; The sp package is now running under evolution status 2</span><br><span class="line">#&gt;      (status 2 uses the sf package in place of rgdal)</span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309032040589.png" alt=""><br>
Illustration of two areal units: incongruent (black lines) and aggregating zones (red borders).</p>
<p>要找到执行这项工作的算法，我们可以搜索 <code>qgis_algorithms()</code> 函数的输出。这个函数返回一个数据框，包含所有可用的提供者和它们包含的算法。因此，如果你看不到预期的提供者，可能是因为你还需要安装一些外部GIS软件。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">qgis_algo <span class="operator">=</span> qgis_algorithms<span class="punctuation">(</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><code>qgis_algo</code>对象包含许多列，但通常我们只对<code>algorithm</code>列感兴趣，该列结合了提供商和算法名称的信息。假设函数的简短描述中包含单词&quot;union&quot;，我们可以运行以下代码来找到感兴趣的算法：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">grep<span class="punctuation">(</span><span class="string">&quot;union&quot;</span><span class="punctuation">,</span> qgis_algo<span class="operator">$</span>algorithm<span class="punctuation">,</span> value <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>上述列表中的一个算法，<code>&quot;native:union&quot;</code>，听起来很有希望。下一步是找出这个算法是做什么的，以及我们如何使用它。这是<code>qgis_show_help()</code>的作用，它返回算法的简短总结，包括算法的功能、参数和输出。^[我们还可以使用<code>qgis_get_description()</code>、<code>qgis_get_argument_specs()</code>和<code>qgis_get_output_specss()</code>独立提取其中的一些信息。] 这使得输出相当长。以下命令返回一个数据框，每一行代表<code>&quot;native:union&quot;</code>所需的一个参数，每一列包含与之关联的名称、描述、类型、默认值、可用值和可接受值：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">alg <span class="operator">=</span> <span class="string">&quot;native:union&quot;</span></span><br><span class="line">union_arguments <span class="operator">=</span> qgis_get_argument_specs<span class="punctuation">(</span>alg<span class="punctuation">)</span></span><br><span class="line">union_arguments</span><br></pre></td></tr></table></figure>
<p>包含在<code>union_arguments$name</code>中的参数有<code>INPUT</code>、<code>OVERLAY</code>、<code>OVERLAY_FIELDS_PREFIX</code>和<code>OUTPUT</code>。<code>union_arguments$acceptable_values</code>包含每个参数可能的输入值的列表。许多函数需要代表矢量层路径的输入；对于这样的参数，<strong>qgisprocess</strong>函数接受<code>sf</code>对象。当期望的是“指向栅格层的路径”时，可以使用<strong>terra</strong>和<strong>stars</strong>包中的对象。这可能非常方便，但是当你仅仅为了将其提交给<strong>qgisprocess</strong>算法而读取空间数据时，我们建议提供磁盘上空间数据的路径。<strong>qgisprocess</strong>执行地理算法的第一件事是将存储在你的R会话中的空间数据导出到QGIS所知道的格式，例如.gpkg或.tif文件。这可能会增加算法的运行时间。</p>
<p><strong>qgisprocess</strong>的主要功能是<code>qgis_run_algorithm()</code>，它将输入发送到QGIS并返回输出。它接受所使用的算法名称和帮助列表中显示的一组命名参数，并执行预期的计算。在我们的情况下，三个参数看起来很重要——<code>INPUT</code>、<code>OVERLAY</code>和<code>OUTPUT</code>。第一个参数<code>INPUT</code>是我们的主要矢量对象<code>incongr_wgs</code>，而第二个参数<code>OVERLAY</code>是<code>aggzone_wgs</code>。最后一个参数<code>OUTPUT</code>是输出文件名，如果没有提供，<strong>qgisprocess</strong>会自动选择并在<code>tempdir()</code>中创建。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">union <span class="operator">=</span> qgis_run_algorithm<span class="punctuation">(</span>alg<span class="punctuation">,</span></span><br><span class="line">  INPUT <span class="operator">=</span> incongr_wgs<span class="punctuation">,</span> OVERLAY <span class="operator">=</span> aggzone_wgs</span><br><span class="line"><span class="punctuation">)</span></span><br><span class="line">union</span><br></pre></td></tr></table></figure>
<p>运行上述代码行将会把我们的两个输入对象保存到临时的.gpkg文件中，然后在它们上面运行所选算法，并返回一个临时的.gpkg文件作为输出。<strong>qgisprocess</strong>包将<code>qgis_run_algorithm()</code>的结果存储为一个列表，在本例中，包含指向输出文件的路径。我们可以用<code>read_sf()</code>将这个文件读回R（例如，<code>union_sf = read_sf(union[[1]])</code>），或者直接用<code>st_as_sf()</code>。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">union_sf <span class="operator">=</span> st_as_sf<span class="punctuation">(</span>union<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>请注意，QGIS的并集操作通过使用两个输入层的交集和对称差集来将两个输入层合并为一个层（顺便说一下，这也是在 GRASS 和 SAGA 中进行并集操作时的默认设置）。这与<code>st_union(incongr_wgs, aggzone_wgs)</code>（见练习）<strong>不</strong>相同！</p>
<p>结果<code>union_sf</code>是一个多边形，特征数量比两个输入对象都要多。然而，注意其中许多多边形较小，并不代表实际区域，而是由于我们两个数据集具有不同细节层次的结果。这些错误的副产品被称为割缝多边形。识别割缝的一种方法是找到相对非常小的区域的多边形，例如，在这里是25000平方米，然后将它们去除。让我们寻找一个合适的算法。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">grep<span class="punctuation">(</span><span class="string">&quot;clean&quot;</span><span class="punctuation">,</span> qgis_algo<span class="operator">$</span>algorithm<span class="punctuation">,</span> value <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>这次找到的算法，<code>v.clean</code>，不包括在QGIS中，而是在GRASS GIS中。GRASS GIS的<code>v.clean</code>是一个用于清理空间矢量数据拓扑的强大工具。重要的是，我们可以通过<strong>qgisprocess</strong>来使用它。</p>
<p>与前一步类似，我们应该从查看此算法的帮助开始。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">qgis_show_help<span class="punctuation">(</span><span class="string">&quot;grass7:v.clean&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>我们在这里省略了输出，因为帮助文本相当长，并且包含许多参数。^[还要注意，这些参数与QGIS的参数不同，都是小写的。]这是因为<code>v.clean</code>是一个多功能工具——它可以清理不同类型的几何体并解决不同类型的拓扑问题。</p>
<p>对于这个示例，让我们仅关注几个参数，但我们鼓励你访问<a href="https://grass.osgeo.org/grass-stable/manuals/v.clean.html">该算法的文档</a>以了解更多关于<code>v.clean</code>的功能。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">qgis_get_argument_specs<span class="punctuation">(</span><span class="string">&quot;grass7:v.clean&quot;</span><span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">  select<span class="punctuation">(</span>name<span class="punctuation">,</span> description<span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">  slice_head<span class="punctuation">(</span>n <span class="operator">=</span> <span class="number">4</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>此算法的主要参数是<code>input</code>——我们的矢量对象。接下来，我们需要选择一个工具——清理方法。^[也可以选择多个工具，然后按顺序执行。]<code>v.clean</code>中存在大约十几个工具，可以用来删除重复的几何体、删除线之间的小角度或删除小面积等。在这个情况下，我们对最后一个工具<code>rmarea</code>感兴趣。其中一些工具，包括<code>rmarea</code>，期望一个附加参数<code>threshold</code>，其行为取决于所选工具。在我们的情况下，<code>rmarea</code>工具将删除所有小于或等于提供的<code>threshold</code>的面积。请注意，无论输入图层的坐标参考系统如何，阈值都必须以平方米为单位指定。</p>
<p>让我们运行这个算法，把输出转化为新的<code>sf</code>对象——<code>clean_sf</code></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">clean <span class="operator">=</span> qgis_run_algorithm<span class="punctuation">(</span><span class="string">&quot;grass7:v.clean&quot;</span><span class="punctuation">,</span></span><br><span class="line">  input <span class="operator">=</span> union_sf<span class="punctuation">,</span> </span><br><span class="line">  tool <span class="operator">=</span> <span class="string">&quot;rmarea&quot;</span><span class="punctuation">,</span> threshold <span class="operator">=</span> <span class="number">25000</span></span><br><span class="line"><span class="punctuation">)</span></span><br><span class="line">clean_sf <span class="operator">=</span> st_as_sf<span class="punctuation">(</span>clean<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>结果，图右侧面板，看起来是我们期待的结果——消除了细碎的面。</p>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309032057977.png" alt=""><br>
Sliver polygons colored in red (left panel). Cleaned polygons (right panel).</p>
<h2 id="栅格数据">栅格数据</h2>
<p>数字高程模型（DEMs）包含每个栅格单元的高程信息。它们被用于许多目的，包括卫星导航、水流模型、表面分析或可视化。在这里，我们有兴趣从DEM栅格中推导出可用作统计学习预测因子的新信息。例如，各种地形参数可能有助于滑坡的预测。</p>
<p>对于本节，我们将使用<code>dem.tif</code>——蒙贡研究区域的数字高程模型（从Land Process Distributed Active Archive Center下载，也可参见<code>?dem.tif</code>）。它的分辨率约为30乘30米，并使用投影的CRS。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>qgisprocess<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>terra<span class="punctuation">)</span></span><br><span class="line">dem <span class="operator">=</span> system.file<span class="punctuation">(</span><span class="string">&quot;raster/dem.tif&quot;</span><span class="punctuation">,</span> package <span class="operator">=</span> <span class="string">&quot;spDataLarge&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><strong>terra</strong>包的<code>terrain()</code>命令已经允许计算一些基本的地形特征，例如坡度、方位、TPI（<em>地形位置指数</em>）、TRI（<em>地形崎岖指数</em>）、粗糙度和流向。然而，GIS程序提供了许多的地形特征，其中一些在某些情境下可能更适合。例如，地形湿润指数（TWI）在研究水文和生物过程方面被发现有用。让我们使用<code>&quot;wetness&quot;</code>作为关键字搜索此索引的算法列表。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">qgis_algo <span class="operator">=</span> qgis_algorithms<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line">grep<span class="punctuation">(</span><span class="string">&quot;wetness&quot;</span><span class="punctuation">,</span> qgis_algo<span class="operator">$</span>algorithm<span class="punctuation">,</span> value <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">  head<span class="punctuation">(</span><span class="number">2</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>上述代码的输出表明，所需的算法存在于SAGA GIS软件中。^[TWI也可以使用<code>r.topidx</code> GRASS GIS功能来计算。]虽然SAGA是混合GIS，但其主要关注点一直是栅格处理，特别是数字高程模型（土壤性质、地形属性、气候参数）。因此，SAGA特别擅长快速处理大型（高分辨率）栅格数据集。</p>
<p><code>&quot;sagang:sagawetnessindex&quot;</code>算法实际上是一个修改过的TWI，其结果是对位于山谷底部的单元格的更现实的土壤湿润潜力。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">qgis_show_help<span class="punctuation">(</span><span class="string">&quot;sagang:sagawetnessindex&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; Saga wetness index (sagang:sagawetnessindex)</span></span><br><span class="line"><span class="comment">#&gt; Description</span></span><br></pre></td></tr></table></figure>
<p>在这里，我们坚持对所有参数使用默认值。因此，我们只需指定一个参数——输入的<code>DEM</code>。当然，在应用此算法时，您应确保默认值与您的研究目标相符。^[有关“sagang：sagawetnessindex”的其他参数的解释详见<a href="https://gis.stackexchange.com/a/323454/20955%E3%80%82">https://gis.stackexchange.com/a/323454/20955。</a>]<code>&quot;sagang:sagawetnessindex&quot;</code>不是返回一个而是四个栅格——集水区域、集水坡度、修改后的集水区域和地形湿润指数。</p>
<p>在从QGIS中运行SAGA算法之前，我们将默认的栅格输出格式从<code>.tif</code>更改为SAGA的本地栅格格式<code>.sdat</code>。因此，从现在开始，我们自己不指定的所有输出栅格都将写入<code>.sdat</code>格式。根据您使用的软件版本（SAGA、GDAL），这可能不是必需的，但通常这会在尝试读取使用SAGA创建的输出栅格时减少不必的麻烦。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">options<span class="punctuation">(</span>qgisprocess.tmp_raster_ext <span class="operator">=</span> <span class="string">&quot;.sdat&quot;</span><span class="punctuation">)</span></span><br><span class="line">dem_wetness <span class="operator">=</span> qgis_run_algorithm<span class="punctuation">(</span><span class="string">&quot;sagang:sagawetnessindex&quot;</span><span class="punctuation">,</span></span><br><span class="line">  DEM <span class="operator">=</span> dem</span><br><span class="line"><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<!-- The result, `dem_wetness`, is a list with file paths to the four outputs. -->
<p>我们可以通过在<code>qgis_as_terra()</code>函数中提供输出名称来读取选定的输出。既然我们已经从 QGIS 内部完成了 SAGA 处理，我们将栅格输出格式更改回<code>.tif</code>。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">dem_wetness_twi <span class="operator">=</span> qgis_as_terra<span class="punctuation">(</span>dem_wetness<span class="operator">$</span>TWI<span class="punctuation">)</span></span><br><span class="line"><span class="comment"># plot(dem_wetness_twi)</span></span><br><span class="line">options<span class="punctuation">(</span>qgisprocess.tmp_raster_ext <span class="operator">=</span> <span class="string">&quot;.tif&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>你可以在下图的左侧面板上看到TWI地图。地形湿润指数是无单位的：其低值代表不会积聚水的区域，而较高的值显示将以增加的水平积聚水的区域。</p>
<p>数字高程模型的信息也可以分类，例如，到geomorphons——代表地形形态的10个类别的地貌现象，例如斜坡、山脊或山谷。这些表型在许多研究中被使用，包括滑坡敏感性、生态系统服务、人类流动性和数字土壤制图。</p>
<p>geomorphons算法的原始实现是在GRASS GIS中创建的，我们可以在<strong>qgisprocess</strong>列表中找到它，名为<code>&quot;grass7:r.geomorphon&quot;</code>：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">grep<span class="punctuation">(</span><span class="string">&quot;geomorphon&quot;</span><span class="punctuation">,</span> qgis_algo<span class="operator">$</span>algorithm<span class="punctuation">,</span> value <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] &quot;grass7:r.geomorphon&quot; &quot;sagang:geomorphons&quot; </span></span><br><span class="line">qgis_show_help<span class="punctuation">(</span><span class="string">&quot;grass7:r.geomorphon&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># output not shown</span></span><br></pre></td></tr></table></figure>
<p>计算geomorphons需要一个输入的DEM（数字高程模型，<code>elevation</code>），并且可以通过一组可选参数进行自定义。这些包括，<code>search</code> ——用于计算视线长度的值，以及<code>-m</code> ——一个标志，指定搜索值将以米为单位提供（而不是单元格数量）。关于附加参数的更多信息可以在原始论文和<a href="https://grass.osgeo.org/grass-stable/manuals/r.geomorphon.html">GRASS GIS文档</a>中找到。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">dem_geomorph <span class="operator">=</span> qgis_run_algorithm<span class="punctuation">(</span><span class="string">&quot;grass7:r.geomorphon&quot;</span><span class="punctuation">,</span></span><br><span class="line">  elevation <span class="operator">=</span> dem<span class="punctuation">,</span></span><br><span class="line">  `-m` <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> search <span class="operator">=</span> <span class="number">120</span></span><br><span class="line"><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>我们的输出，<code>dem_geomorph$forms</code>，包含一个有10个类别的栅格文件——每一个都代表一个地形形态。我们可以使用<code>qgis_as_terra()</code>将其读入R中，然后进行可视化或在后续的计算中使用它。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">dem_geomorph_terra <span class="operator">=</span> qgis_as_terra<span class="punctuation">(</span>dem_geomorph<span class="operator">$</span>forms<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>有趣的是，一些geomorphons与TWI（地形湿润指数）值之间存在联系，如图所示。最大的TWI值主要出现在山谷和凹地中，而最低的值则如预期那样出现在山脊上。</p>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309032105108.png" alt=""><br>
Topographic wetness index (TWI, left panel) and geomorphons (right panel) derived for the Mongón study area.</p>
<h1>SAGA GIS</h1>
<p>自动地质科学分析系统（System for Automated Geoscientific Analyses，简称SAGA；表提供了通过命令行界面（在Windows下是<code>saga_cmd.exe</code>，在Linux下是<code>saga_cmd</code>）执行SAGA模块的可能性（参见<a href="https://sourceforge.net/p/saga-gis/wiki/Executing%20Modules%20with%20SAGA%20CMD/">SAGA模块的wiki页面</a>）。此外，还有一个Python接口（SAGA Python API）。<strong>Rsagacmd</strong>使用前者从R内部运行SAGA。</p>
<p>在本节中，我们将使用<strong>Rsagacmd</strong>来划分秘鲁Mongón研究区域在2000年9月22日的归一化植被指数（NDVI）的相似值区域，方法是使用SAGA GIS中的种子区域生长算法。^[阅读章节了解如何从遥感图像计算NDVI的详细信息。]</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ndvi <span class="operator">=</span> rast<span class="punctuation">(</span>system.file<span class="punctuation">(</span><span class="string">&quot;raster/ndvi.tif&quot;</span><span class="punctuation">,</span> package <span class="operator">=</span> <span class="string">&quot;spDataLarge&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>要开始使用<strong>Rsagacmd</strong>，我们需要运行<code>saga_gis()</code>函数。它有两个主要用途：</p>
<ul>
<li>它动态地^[这意味着可用的库将取决于安装的SAGA GIS版本。]创建一个新对象，该对象包含指向所有有效SAGA-GIS库和工具的链接</li>
<li>它设置了一般的包选项，例如<code>raster_backend</code>（用于处理栅格数据的R包）、<code>vector_backend</code>（用于处理矢量数据的R包）和<code>cores</code>（用于处理的CPU核心的最大数量，默认值：全部）</li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>Rsagacmd<span class="punctuation">)</span></span><br><span class="line">saga <span class="operator">=</span> saga_gis<span class="punctuation">(</span>raster_backend <span class="operator">=</span> <span class="string">&quot;terra&quot;</span><span class="punctuation">,</span> vector_backend <span class="operator">=</span> <span class="string">&quot;sf&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>我们的<code>saga</code>对象包含指向所有可用SAGA工具的连接。它被组织为库列表（工具组），库内部有工具列表。我们可以使用<code>$</code>符号访问任何工具（记得使用TAB键进行自动补全）。</p>
<p>种子区域生长算法的工作分为两个主要步骤。首先，通过在指定大小的局部窗口中找到方差最小的单元格来生成初始单元格（“种子”）。然后，使用区域生长算法将种子的相邻像素合并以创建均匀区域。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">sg <span class="operator">=</span> saga<span class="operator">$</span>imagery_segmentation<span class="operator">$</span>seed_generation</span><br></pre></td></tr></table></figure>
<p>在上述示例中，我们首先指向了<code>imagery_segmentation</code>库，然后是其<code>seed_generation</code>工具。我们还将其分配给了<code>sg</code>对象，以便在下一步中不重新输入整个工具代码。^[你可以在<a href="https://saga-gis.sourceforge.io/saga_tool_doc/8.3.0/imagery_segmentation_2.html%E4%B8%8A%E4%BA%86%E8%A7%A3%E6%9B%B4%E5%A4%9A%E5%85%B3%E4%BA%8E%E8%AF%A5%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BF%A1%E6%81%AF%E3%80%82">https://saga-gis.sourceforge.io/saga_tool_doc/8.3.0/imagery_segmentation_2.html上了解更多关于该工具的信息。</a>]如果我们只输入<code>sg</code>，我们将得到该工具的快速概述和一个带有其参数、描述和默认值的数据框。你还可以使用<code>tidy(sg)</code>仅提取参数表。<code>seed_generation</code>工具将栅格数据集作为其第一个参数（<code>features</code>）；可选参数包括指定初始多边形大小的<code>band_width</code>。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ndvi_seeds <span class="operator">=</span> sg<span class="punctuation">(</span>ndvi<span class="punctuation">,</span> band_width <span class="operator">=</span> <span class="number">2</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># plot(ndvi_seeds$seed_grid)</span></span><br></pre></td></tr></table></figure>
<p>我们的输出是三个对象的列表：<code>variance</code> ——局部方差的栅格图，<code>seed_grid</code> ——生成种子的栅格图，以及<code>seed_points</code> ——生成种子的空间矢量对象。</p>
<p>我们使用的第二个SAGA GIS工具是<code>seeded_region_growing</code>。^[你可以在<a href="https://saga-gis.sourceforge.io/saga_tool_doc/8.3.0/imagery_segmentation_3.html%E4%B8%8A%E4%BA%86%E8%A7%A3%E6%9B%B4%E5%A4%9A%E5%85%B3%E4%BA%8E%E8%AF%A5%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BF%A1%E6%81%AF%E3%80%82">https://saga-gis.sourceforge.io/saga_tool_doc/8.3.0/imagery_segmentation_3.html上了解更多关于该工具的信息。</a>]<code>seeded_region_growing</code>工具需要两个输入：我们在前一步计算的<code>seed_grid</code>和<code>ndvi</code>栅格对象。此外，我们可以指定几个参数，例如<code>normalize</code>来标准化输入特征，<code>neighbour</code>（4或8-邻域）和<code>method</code>。最后一个参数可以设置为<code>0</code>或<code>1</code>（区域生长基于栅格单元格的值及其位置，或仅基于值）。</p>
<p>在这里，我们只会将<code>method</code>更改为<code>1</code>，这意味着我们的输出区域将仅基于它们的NDVI值的相似性创建。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">srg <span class="operator">=</span> saga<span class="operator">$</span>imagery_segmentation<span class="operator">$</span>seeded_region_growing</span><br><span class="line">ndvi_srg <span class="operator">=</span> srg<span class="punctuation">(</span>ndvi_seeds<span class="operator">$</span>seed_grid<span class="punctuation">,</span> ndvi<span class="punctuation">,</span> method <span class="operator">=</span> <span class="number">1</span><span class="punctuation">)</span></span><br><span class="line">plot<span class="punctuation">(</span>ndvi_srg<span class="operator">$</span>segments<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>工具返回了三个对象的列表：<code>segments</code>、<code>similarity</code>、<code>table</code>。<code>similarity</code>对象是一个栅格，显示种子与其他单元之间的相似性，而<code>table</code>是一个数据框，存储有关输入种子的信息。最后，<code>ndvi_srg$segments</code>是一个栅格，显示我们的结果区域。我们可以使用<code>as.polygons()</code>和<code>st_as_sf()</code>将其转换为多边形。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ndvi_segments <span class="operator">=</span> ndvi_srg<span class="operator">$</span>segments <span class="operator">|&gt;</span></span><br><span class="line">  as.polygons<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">  st_as_sf<span class="punctuation">(</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309032113571.png" alt=""><br>
Normalized difference vegetation index (NDVI, left panel) and NDVI-based segments derived using the seeded region growing algorithm for the Mongón study area.</p>
<p>生成的多边形（段）代表具有相似值的区域。它们还可以使用各种技术（例如，<em>k</em>-均值聚类、区域化（例如，SKATER）或监督分类方法）进一步聚合成更大的多边形。您可以在练习中尝试这样做。</p>
<p>R还具有其他工具来实现用相似值创建多边形（所谓的段）的目标。它包括<strong>SegOptim</strong>包，该包允许运行几种图像分割算法，以及<strong>supercells</strong>，实现了用于处理地理空间数据的超像素算法SLIC。</p>
<h1>GRASS GIS</h1>
<p>美国陆军工程研究实验室（USA-CERL）于1982年至1995年创建了地理资源分析支持系统（GRASS）的核心。自1997年以来，学术界一直在继续这项工作。与SAGA类似，GRASS最初专注于栅格处理，但自GRASS 6.0以来，才添加了先进的矢量功能。</p>
<p>GRASS将输入数据存储在GRASS GIS数据库中。关于矢量数据，GRASS默认是一个拓扑GIS，即它只存储一次相邻要素的几何形状。SQLite是矢量属性管理的默认数据库驱动程序，属性与几何形状（即GRASS GIS数据库）通过键链接（<a href="https://grasswiki.osgeo.org/wiki/Vector_Database_Management#GRASS_GIS_vector_management_model">GRASS GIS矢量管理</a>）。</p>
<p>在使用GRASS之前，必须设置GRASS GIS数据库（也可在R内部设置），用户可能会发现这个过程开始时有点吓人。首先，GRASS数据库需要自己的目录，其中又包含一个位置（有关详细信息，请参见<a href="https://grass.osgeo.org/grass-stable/manuals/grass_database.html">GRASS GIS数据库</a>帮助页面<a href="https://grass.osgeo.org/grass-stable/manuals/index.html">grass.osgeo.org</a>）。位置存储一个项目或一个区域的地理数据。在一个位置内，可以存在几个地图集，通常是指不同的用户或不同的任务。每个位置还有一个PERMANENT地图集——一个自动创建的强制性地图集。为了与项目的所有用户共享地理数据，数据库所有者可以将空间数据添加到PERMANENT地图集。此外，PERMANENT地图集存储栅格数据的投影、空间范围和默认分辨率。总而言之，GRASS GIS数据库可能包含许多位置（同一位置的所有数据具有相同的CRS），每个位置可以存储许多地图集（数据集组）。有关GRASS空间数据库系统的更多信息，请参阅<a href="https://grass.osgeo.org/grass-stable/manuals/helptext.html">GRASS GIS快速入门</a>。要在R中快速使用GRASS，我们将使用<strong>link2GI</strong>包，不过，人们也可以逐步设置GRASS GIS数据库。参见<a href="https://grasswiki.osgeo.org/wiki/R_statistics/rgrass#GRASS_within_R">GRASS within R</a>了解如何操作。请注意，如果第一次使用GRASS，接下来的段落中的代码说明可能难以理解，但通过逐行运行代码并检查中间结果，背后的推理应该会变得更加清晰。</p>
<p>在此，我们通过地理信息科学中最有趣的问题之一——旅行推销员问题引入<strong>rgrass</strong>。假设一位旅行推销员想要拜访24个客户。此外，他想在家开始和结束他的旅程，总共有25个地点，同时以尽可能短的距离覆盖。解决这个问题有一个最佳解决方案；然而，对于现代计算机来说，检查所有可能的解决方案（大部分）是不可能的。在我们的案例中，可能的解决方案数量对应于<code>(25 - 1)! / 2</code>，即24的阶乘除以2（因为我们不区分前进或后退方向）。即使一次迭代可以在纳秒内完成，这仍相当于9837145年。幸运的是，有聪明、近乎最优的解决方案，可以在这难以想象的时间的微小部分内运行。GRASS GIS提供了其中的一个解决方案（有关详细信息，请参阅<a href="https://grass.osgeo.org/grass-stable/manuals/v.net.salesman.html">v.net.salesman</a>）。在我们的用例中，我们想找到伦敦街道上前25个自行车站（而不是客户）之间的最短路径（我们简单地假设第一个自行车站对应于我们的旅行推销员的家）。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">data<span class="punctuation">(</span><span class="string">&quot;cycle_hire&quot;</span><span class="punctuation">,</span> package <span class="operator">=</span> <span class="string">&quot;spData&quot;</span><span class="punctuation">)</span></span><br><span class="line">points <span class="operator">=</span> cycle_hire<span class="punctuation">[</span><span class="number">1</span><span class="operator">:</span><span class="number">25</span><span class="punctuation">,</span> <span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<p>除了自行车租赁点数据外，我们还需要该区域的街道网络。我们可以使用<strong>osmdata</strong>包的帮助从OpenStreetMap下载它。为此，我们将街道网络的查询（在OSM语言中称为“高速公路”）限制为<code>points</code>的边界框，并将相应的数据附加为<code>sf</code>对象。<code>osmdata_sf()</code>返回一个包含几个空间对象（点、线、多边形等）的列表，但在这里，我们只保留与其相关ID的线对象。^[为了方便读者，可以使用<code>data(&quot;london_streets&quot;, package = &quot;spDataLarge&quot;)</code>将<code>london_streets</code>附加到全局环境中。]</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>osmdata<span class="punctuation">)</span></span><br><span class="line">b_box <span class="operator">=</span> st_bbox<span class="punctuation">(</span>points<span class="punctuation">)</span></span><br><span class="line">london_streets <span class="operator">=</span> opq<span class="punctuation">(</span>b_box<span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">  add_osm_feature<span class="punctuation">(</span>key <span class="operator">=</span> <span class="string">&quot;highway&quot;</span><span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">  osmdata_sf<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line">london_streets <span class="operator">=</span> london_streets<span class="punctuation">[[</span><span class="string">&quot;osm_lines&quot;</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line">london_streets <span class="operator">=</span> select<span class="punctuation">(</span>london_streets<span class="punctuation">,</span> osm_id<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>现在我们有了数据，可以开始并启动GRASS会话了。幸运的是，<strong>link2GI</strong>包中的<code>linkGRASS()</code>让我们只用一行代码就可以设置GRASS环境。您唯一需要提供的是一个确定空间数据库的投影和范围的空间对象。首先，<code>linkGRASS()</code> 会在您的计算机上找到所有的GRASS安装。由于我们将<code>ver_select</code>设置为<code>TRUE</code>，我们可以交互式地选择找到的GRASS安装之一。如果只有一个安装，<code>linkGRASS()</code>会自动选择它。其次，<code>linkGRASS()</code> 建立了与GRASS GIS的连接。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>rgrass<span class="punctuation">)</span></span><br><span class="line">link2GI<span class="operator">::</span>linkGRASS<span class="punctuation">(</span>london_streets<span class="punctuation">,</span> ver_select <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>在我们能使用GRASS地理算法之前，我们需要将数据添加到GRASS的空间数据库中。幸运的是，方便的函数<code>write_VECT()</code>为我们做到了这一点。（对于栅格数据，请使用<code>write_RAST()</code>。）在我们的例子中，我们在只使用第一个属性列的情况下添加街道和自行车租赁点数据，并在GRASS中将它们命名为<code>london_streets</code>和<code>points</code>。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">write_VECT<span class="punctuation">(</span>terra<span class="operator">::</span>vect<span class="punctuation">(</span>london_streets<span class="punctuation">)</span><span class="punctuation">,</span> vname <span class="operator">=</span> <span class="string">&quot;london_streets&quot;</span><span class="punctuation">)</span></span><br><span class="line">write_VECT<span class="punctuation">(</span>terra<span class="operator">::</span>vect<span class="punctuation">(</span>points<span class="punctuation">[</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">]</span><span class="punctuation">)</span><span class="punctuation">,</span> vname <span class="operator">=</span> <span class="string">&quot;points&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><strong>rgrass</strong>包期望其输入和输出为<strong>terra</strong>对象。因此，我们需要使用<code>vect()</code>函数将我们的<code>sf</code>空间矢量转换为<strong>terra</strong>的<code>SpatVector</code>，以便能够使用<code>write_VECT()</code>。^[您可以通过阅读<a href="https://geocompx.org/post/2021/spatial-classes-conversion/">在R中不同空间类之间的转换</a>博客文章和<a href="https://CRAN.R-project.org/package=rgrass/vignettes/coerce.html">对象格式之间的强制转换</a>小册子了解更多关于在R中转换空间类的信息]</p>
<p>现在，这两个数据集都存在于GRASS GIS数据库中。要执行我们的网络分析，我们需要一个拓扑清洁的街道网络。GRASS的<code>&quot;v.clean&quot;</code>负责去除重复项、小角度和悬挂等。在这里，我们在每个交叉点处断开线条，以确保后续的路由算法实际上可以在交叉口右转或左转，并将输出保存在名为<code>streets_clean</code>的GRASS对象中。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">execGRASS<span class="punctuation">(</span></span><br><span class="line">  cmd <span class="operator">=</span> <span class="string">&quot;v.clean&quot;</span><span class="punctuation">,</span> input <span class="operator">=</span> <span class="string">&quot;london_streets&quot;</span><span class="punctuation">,</span> output <span class="operator">=</span> <span class="string">&quot;streets_clean&quot;</span><span class="punctuation">,</span></span><br><span class="line">  tool <span class="operator">=</span> <span class="string">&quot;break&quot;</span><span class="punctuation">,</span> flags <span class="operator">=</span> <span class="string">&quot;overwrite&quot;</span></span><br><span class="line"><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>📌要了解GRASS GIS模块的可能参数和标志，您可以使用<code>help</code>标志。<br>
例如，尝试<code>execGRASS(&quot;g.region&quot;, flags = &quot;help&quot;)</code>。</p>
</blockquote>
<p>我们的一些自行车站点可能不会完全位于街道段上。然而，为了找到它们之间的最短路线，我们需要将它们连接到最近的街道段上。<code>&quot;v.net&quot;</code>的连接操作符就是这样做的。我们将其输出保存在<code>streets_points_con</code>中。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">execGRASS<span class="punctuation">(</span></span><br><span class="line">  cmd <span class="operator">=</span> <span class="string">&quot;v.net&quot;</span><span class="punctuation">,</span> input <span class="operator">=</span> <span class="string">&quot;streets_clean&quot;</span><span class="punctuation">,</span> output <span class="operator">=</span> <span class="string">&quot;streets_points_con&quot;</span><span class="punctuation">,</span></span><br><span class="line">  points <span class="operator">=</span> <span class="string">&quot;points&quot;</span><span class="punctuation">,</span> operation <span class="operator">=</span> <span class="string">&quot;connect&quot;</span><span class="punctuation">,</span> threshold <span class="operator">=</span> <span class="number">0.001</span><span class="punctuation">,</span></span><br><span class="line">  flags <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;overwrite&quot;</span><span class="punctuation">,</span> <span class="string">&quot;c&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>得到的清洁数据集作为<code>&quot;v.net.salesman&quot;</code>算法的输入，该算法最终找到所有自行车租赁站之间的最短路线。其中一个参数是<code>center_cats</code>，它需要一个数字范围作为输入。这个范围代表应该计算最短路径的点。由于我们想计算所有自行车站的路线，所以我们将其设置为<code>1-25</code>。要访问旅行推销员算法的GRASS帮助页面，请运行<code>execGRASS(&quot;g.manual&quot;, entry = &quot;v.net.salesman&quot;)</code>。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">execGRASS<span class="punctuation">(</span></span><br><span class="line">  cmd <span class="operator">=</span> <span class="string">&quot;v.net.salesman&quot;</span><span class="punctuation">,</span> input <span class="operator">=</span> <span class="string">&quot;streets_points_con&quot;</span><span class="punctuation">,</span></span><br><span class="line">  output <span class="operator">=</span> <span class="string">&quot;shortest_route&quot;</span><span class="punctuation">,</span> center_cats <span class="operator">=</span> paste0<span class="punctuation">(</span><span class="string">&quot;1-&quot;</span><span class="punctuation">,</span> nrow<span class="punctuation">(</span>points<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">  flags <span class="operator">=</span> <span class="string">&quot;overwrite&quot;</span></span><br><span class="line"><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>要查看我们的结果，我们将结果读入R，将其转换为仅保留几何图形的sf对象，并借助<strong>mapview</strong>包进行可视化。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">route <span class="operator">=</span> read_VECT<span class="punctuation">(</span><span class="string">&quot;shortest_route&quot;</span><span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">  st_as_sf<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">  st_geometry<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line">mapview<span class="operator">::</span>mapview<span class="punctuation">(</span>route<span class="punctuation">)</span> <span class="operator">+</span> points</span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309032153101.png" alt=""><br>
Shortest route (blue line) between 24 cycle hire stations (blue dots) on the OSM street network of London.</p>
<p>在此过程中有一些重要的注意事项：</p>
<ul>
<li>我们本可以使用GRASS的空间数据库，从而允许更快的处理。这意味着我们仅在开始时导出了地理数据。然后我们创建了新对象，但只将最终结果导入回R。要找出当前可用的数据集，请运行<code>execGRASS(&quot;g.list&quot;, type = &quot;vector,raster&quot;, flags = &quot;p&quot;)</code>。</li>
<li>我们也可以从R内部访问已经存在的GRASS空间数据库。在将数据导入R之前，您可能想要进行一些（空间）子集选择。对于矢量数据，请使用<code>&quot;v.select&quot;</code>和<code>&quot;v.extract&quot;</code>。<code>&quot;db.select&quot;</code>让您选择矢量图层的属性表的子集，而不返回相应的几何图形。</li>
<li>您也可以从正在运行的GRASS会话中启动R。</li>
<li>请参考出色的<a href="https://grass.osgeo.org/grass-stable/manuals/">GRASS在线帮助</a>或<code>execGRASS(&quot;g.manual&quot;, flags = &quot;i&quot;)</code>了解有关每个可用GRASS地理算法的更多信息。</li>
</ul>
<h1>何时使用什么?</h1>
<p>推荐单一的R-GIS界面是困难的，因为使用取决于个人偏好、手头的任务和您对不同GIS软件包的熟悉程度，这反过来可能取决于您的研究领域。正如之前提到的，SAGA特别擅长快速处理大型（高分辨率）栅格数据集，常被水文学家、气候学家和土壤科学家使用。另一方面，GRASS GIS是此处介绍的唯一支持拓扑空间数据库的GIS，这对于网络分析甚至模拟研究特别有用。与GRASS和SAGA-GIS相比，QGIS更加用户友好，尤其对于初次使用GIS的用户，可能是最受欢迎的开源GIS。因此，<strong>qgisprocess</strong>是大多数用例的合适选择。<br>
其主要优势包括：</p>
<ul>
<li>对多个GIS的统一访问，因此提供了&gt;1000个地理算法包括重复功能，例如，您可以使用QGIS-，SAGA-或GRASS-地理算法执行覆盖操作</li>
<li>自动数据格式转换（SAGA使用<code>.sdat</code>网格文件，GRASS使用其自己的数据库格式，但QGIS将处理相应的转换）</li>
<li>它自动将地理R对象传递给QGIS地理算法并返回到R</li>
<li>支持命名参数和自动默认值检索的便利功能（受<strong>rgrass</strong>的启发）</li>
</ul>
<p>当然，有些情况下您肯定应该使用其他R-GIS桥梁。虽然QGIS是唯一提供对几个GIS软件包统一界面的GIS，但它只提供对相应第三方地理算法的子集的访问。因此，要使用SAGA和GRASS的完整功能集，请坚持使用<strong>Rsagacmd</strong>和<strong>rgrass</strong>。此外，如果您想借助地理数据库运行模拟，请直接使用<strong>rgrass</strong>，因为<strong>qgisprocess</strong>每次调用都会启动新的GRASS会话。最后，如果您需要拓扑正确的数据和/或空间数据库管理功能，例如多用户访问，我们推荐使用GRASS。</p>
<p>请注意，还有一些GIS软件包具有脚本接口，但没有专门的R包可以访问它们：gvSig、OpenJump和Orfeo Toolbox。^[请注意，<strong>link2GI</strong>提供了与Orfeo Toolbox的部分集成，并且您还可以通过<strong>qgisprocess</strong>访问Orfeo Toolbox地理算法。还要注意，可以通过R包<strong>traudem</strong>从R中访问TauDEM。]</p>
<h1>其他桥梁</h1>
<p>本章到目前为止的重点是R与桌面GIS软件的接口。我们强调这些桥梁，因为专用的GIS软件是众所周知的，是理解地理数据的常见“入门方式”。它们还提供了许多地理算法的访问途径。</p>
<p>其他的“桥梁”包括指向空间库的接口、空间数据库以及网络映射服务。本节只提供了部分可能性的剖析。由于R的灵活性，通过其调用系统中的其他程序和与其他语言的集成（尤其是通过<strong>Rcpp</strong>和<strong>reticulate</strong>），许多其他的桥梁是可能的。目的不是全面覆盖，而是展示在本章开头引用的那句话中访问“灵活性和力量”的其他方式。</p>
<h2 id="GDAL-桥梁">GDAL 桥梁</h2>
<p>GDAL 是一个支持许多地理数据格式的底层库。GDAL 如此有效，以至于大多数GIS程序在后台使用GDAL 来导入和导出地理数据，而不是重新发明轮子并使用定制的读写代码。但是，GDAL 提供的不仅仅是数据I/O。它拥有用于矢量和栅格数据的<a href="https://gdal.org/programs/index.html">地理处理工具</a>，用于在线服务栅格数据的<a href="https://gdal.org/programs/gdal2tiles.html#gdal2tiles">瓦片</a>创建功能，以及对矢量数据的快速<a href="https://gdal.org/programs/gdal_rasterize.html#gdal-rasterize">栅格化</a>功能。由于GDAL是一个命令行工具，因此可以通过R中的<code>system()</code>命令访问其所有命令。</p>
<p>下面的代码段演示了这一功能：<code>linkGDAL()</code>在计算机上搜索工作的GDAL安装，并将可执行文件的位置添加到PATH变量中，从而允许调用GDAL（通常仅在Windows下需要）。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">link2GI<span class="operator">::</span>linkGDAL<span class="punctuation">(</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>现在我们可以使用<code>system()</code>函数调用GDAL的任何工具。例如，<code>ogrinfo</code>提供矢量数据集的元数据。在这里，我们将使用两个附加标志调用此工具：<code>-al</code>列出所有层的所有特征，<code>-so</code>仅获取摘要（而不是完整的几何列表）。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">our_filepath <span class="operator">=</span> system.file<span class="punctuation">(</span><span class="string">&quot;shapes/world.gpkg&quot;</span><span class="punctuation">,</span> package <span class="operator">=</span> <span class="string">&quot;spData&quot;</span><span class="punctuation">)</span></span><br><span class="line">cmd <span class="operator">=</span> paste<span class="punctuation">(</span><span class="string">&quot;ogrinfo -al -so&quot;</span><span class="punctuation">,</span> our_filepath<span class="punctuation">)</span></span><br><span class="line">system<span class="punctuation">(</span>cmd<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; INFO: Open of `.../spData/shapes/world.gpkg&#x27;</span></span><br><span class="line"><span class="comment">#&gt;       using driver `GPKG&#x27; successful.</span></span><br><span class="line"><span class="comment">#&gt;</span></span><br><span class="line"><span class="comment">#&gt; Layer name: world</span></span><br><span class="line"><span class="comment">#&gt; Geometry: Multi Polygon</span></span><br><span class="line"><span class="comment">#&gt; Feature Count: 177</span></span><br><span class="line"><span class="comment">#&gt; Extent: (-180.000000, -89.900000) - (179.999990, 83.645130)</span></span><br><span class="line"><span class="comment">#&gt; Layer SRS WKT:</span></span><br><span class="line"><span class="comment">#&gt; ...</span></span><br></pre></td></tr></table></figure>
<p>其他常用的GDAL工具包括：</p>
<ul>
<li><code>gdalinfo</code>：提供栅格数据集的元数据</li>
<li><code>gdal_translate</code>：在不同的栅格文件格式之间转换</li>
<li><code>ogr2ogr</code>：在不同的矢量文件格式之间转换</li>
<li><code>gdalwarp</code>：重新投影、转换和剪裁栅格数据集</li>
<li><code>gdaltransform</code>：转换坐标</li>
</ul>
<p>访问<a href="https://gdal.org/programs/">https://gdal.org/programs/</a> 查看GDAL工具的完整列表，并阅读它们的帮助文件。</p>
<p>通过<strong>link2GI</strong>提供的对GDAL的“链接”，可以用作从R或系统CLI进行更高级GDAL工作的基础。TauDEM (<a href="http://hydrology.usu.edu/taudem">http://hydrology.usu.edu/taudem</a>) 和Orfeo Toolbox (<a href="https://www.orfeo-toolbox.org/">https://www.orfeo-toolbox.org/</a>) 是提供命令行界面的其他空间数据处理库/程序——上述示例展示了如何通过R通过系统命令行访问这些库。反过来，这可能是以新的R包形式为这些库创建适当接口的起点。</p>
<p>然而，在深入研究创建新桥梁的项目之前，重要的是要意识到现有R包的功能，以及<code>system()</code>调用可能不是平台无关的（可能在某些计算机上失败）。此外，<strong>sf</strong>通过<strong>Rcpp</strong>提供的R/C++接口，将GDAL、GEOS和PROJ提供的大部分功能带到R中，从而避免了<code>system()</code>调用。</p>
<h2 id="连接到空间数据库的桥梁">连接到空间数据库的桥梁</h2>
<p>空间数据库管理系统（空间DBMS）以结构化的方式存储空间和非空间数据。它们可以通过唯一标识符（主键和外键）以及空间来组织大量的数据集合到相关表（实体）中（例如，考虑空间连接）。这很有用，因为地理数据集很容易变得庞大和混乱。数据库能够基于空间和非空间字段有效地存储和查询大型数据集，并提供多用户访问和拓扑支持。</p>
<p>最重要的开源空间数据库是PostGIS。^[SQLite/SpatiaLite肯定也很重要，但实际上我们已经介绍了这种方法，因为GRASS在后台使用SQLite。]<br>
R到空间DBMS（如PostGIS）的桥梁很重要，允许访问庞大的数据存储，而无需将几个千兆字节的地理数据加载到RAM中，从而可能导致R会话崩溃。本节的其余部分将展示如何基于<em>PostGIS in Action, Second Edition</em> 中的“Hello real world”从R调用PostGIS。^[感谢Manning Publications、Regina Obe和Leo Hsu允许使用这个例子。]</p>
<p>以下代码需要有效的互联网连接，因为我们正在访问一个位于QGIS Cloud (<a href="https://qgiscloud.com/">https://qgiscloud.com/</a>)中的PostgreSQL/PostGIS数据库。^[QGIS Cloud让您将地理数据和地图存储在云中。在后台，它使用QGIS Server和PostgreSQL/PostGIS。这样，读者可以在无需在本地机器上安装PostgreSQL/PostGIS的情况下跟随PostGIS示例。感谢QGIS Cloud团队托管这个例子。]<br>
我们的第一步是通过提供数据库的名称、主机名和用户信息来创建与数据库的连接。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>RPostgreSQL<span class="punctuation">)</span></span><br><span class="line">conn <span class="operator">=</span> dbConnect<span class="punctuation">(</span></span><br><span class="line">  drv <span class="operator">=</span> PostgreSQL<span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">  dbname <span class="operator">=</span> <span class="string">&quot;rtafdf_zljbqm&quot;</span><span class="punctuation">,</span> host <span class="operator">=</span> <span class="string">&quot;db.qgiscloud.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">  port <span class="operator">=</span> <span class="string">&quot;5432&quot;</span><span class="punctuation">,</span> user <span class="operator">=</span> <span class="string">&quot;rtafdf_zljbqm&quot;</span><span class="punctuation">,</span> password <span class="operator">=</span> <span class="string">&quot;d3290ead&quot;</span></span><br><span class="line"><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>我们的新对象<code>conn</code>只是我们的R会话与数据库之间的已建立的链接。它不存储任何数据。</p>
<p>经常的第一个问题是：“数据库中可以找到哪些表？”可以使用<code>dbListTables()</code>如下回答：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">dbListTables<span class="punctuation">(</span>conn<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] &quot;spatial_ref_sys&quot; &quot;topology&quot;        &quot;layer&quot;           &quot;restaurants&quot;</span></span><br><span class="line"><span class="comment">#&gt; [5] &quot;highways&quot;</span></span><br></pre></td></tr></table></figure>
<p>答案是五个表。在这里，我们只对<code>restaurants</code>和<code>highways</code>表感兴趣。前者代表美国的快餐餐厅的位置，后者是美国的主要公路。要了解表中可用的属性，我们可以运行<code>dbListFields</code>：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">dbListFields<span class="punctuation">(</span>conn<span class="punctuation">,</span> <span class="string">&quot;highways&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] &quot;qc_id&quot;        &quot;wkb_geometry&quot; &quot;gid&quot;          &quot;feature&quot;</span></span><br><span class="line"><span class="comment">#&gt; [5] &quot;name&quot;         &quot;state&quot;</span></span><br></pre></td></tr></table></figure>
<p>现在，由于我们知道了可用的数据集，我们可以执行一些查询——向数据库提出一些问题。查询需要用数据库能理解的语言提供——通常是SQL。第一个查询将从<code>highways</code>表中选择马里兰州（<code>MD</code>）的<code>US Route 1</code>。注意，如果<code>read_sf()</code>提供了与数据库的开放连接和查询，它就可以从数据库中读取地理数据。此外，<code>read_sf()</code>需要知道哪一列代表几何体（这里是：<code>wkb_geometry</code>）。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">query <span class="operator">=</span> paste<span class="punctuation">(</span></span><br><span class="line">  <span class="string">&quot;SELECT *&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;FROM highways&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;WHERE name = &#x27;US Route 1&#x27; AND state = &#x27;MD&#x27;;&quot;</span></span><br><span class="line"><span class="punctuation">)</span></span><br><span class="line">us_route <span class="operator">=</span> read_sf<span class="punctuation">(</span>conn<span class="punctuation">,</span> query <span class="operator">=</span> query<span class="punctuation">,</span> geom <span class="operator">=</span> <span class="string">&quot;wkb_geometry&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>这将产生一个名为<code>us_route</code>的<code>MULTILINESTRING</code>类型的<strong>sf</strong>对象。</p>
<p>如前所述，我们还可以不仅提出非空间问题，而且可以基于数据集的空间属性查询。为了展示这一点，下一个示例在选定的公路周围增加了35公里（35,000米）的缓冲区。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">query <span class="operator">=</span> paste<span class="punctuation">(</span></span><br><span class="line">  <span class="string">&quot;SELECT ST_Union(ST_Buffer(wkb_geometry, 35000))::geometry&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;FROM highways&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;WHERE name = &#x27;US Route 1&#x27; AND state = &#x27;MD&#x27;;&quot;</span></span><br><span class="line"><span class="punctuation">)</span></span><br><span class="line">buf <span class="operator">=</span> read_sf<span class="punctuation">(</span>conn<span class="punctuation">,</span> query <span class="operator">=</span> query<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>注意，这是一个使用您应该已经熟悉的函数（<code>ST_Union()</code>，<code>ST_Buffer()</code>）的空间查询。您还可以在<strong>sf</strong>包中找到它们，尽管在这里它们是用小写字母写的（<code>st_union()</code>，<code>st_buffer()</code>）。实际上，<strong>sf</strong>包的函数名称在很大程度上遵循PostGIS的命名惯例。^[前缀<code>st</code>代表空间/时间。]</p>
<p>最后的查询将找到所有Hardee’s餐厅（标记为<code>HDE</code>），它们位于所选公路周围的35公里缓冲区内。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">query <span class="operator">=</span> paste<span class="punctuation">(</span></span><br><span class="line">  <span class="string">&quot;SELECT *&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;FROM restaurants r&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;WHERE EXISTS (&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;SELECT gid&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;FROM highways&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;WHERE&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;ST_DWithin(r.wkb_geometry, wkb_geometry, 35000) AND&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;name = &#x27;US Route 1&#x27; AND&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;state = &#x27;MD&#x27; AND&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;r.franchise = &#x27;HDE&#x27;);&quot;</span></span><br><span class="line"><span class="punctuation">)</span></span><br><span class="line">hardees <span class="operator">=</span> read_sf<span class="punctuation">(</span>conn<span class="punctuation">,</span> query <span class="operator">=</span> query<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>最后，按照以下方式关闭数据库连接是一种良好的做法：^[在这里关闭连接非常重要，因为QGIS云（免费版本）仅允许同时进行十个连接。]</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">RPostgreSQL<span class="operator">::</span>postgresqlCloseConnection<span class="punctuation">(</span>conn<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309032205602.png" alt=""><br>
Visualization of the output of previous PostGIS commands showing the highway (black line), a buffer (light yellow) and four restaurants (red points) within the buffer.</p>
<p>与PostGIS不同，<strong>sf</strong>只支持空间矢量数据。</p>
<!--toDo:jn-->
<!-- reconsider referening to rpostgis -- https://github.com/r-spatial/discuss/issues/58 -->
<p>要查询和操作存储在PostGIS数据库中的栅格数据，请使用<strong>rpostgis</strong>包，或者使用诸如<code>rastertopgsql</code>这样的命令行工具，该工具是PostGIS安装的一部分。</p>
<p>这个小节仅是PostgreSQL/PostGIS的简要介绍。尽管如此，我们还是想鼓励在空间数据库管理系统（DBMS）中存储地理和非地理数据的做法，而只将那些需要进行进一步的地理统计分析的数据子集附加到R的全局环境中。有关所提及的SQL查询的更详细描述以及关于PostgreSQL/PostGIS的更全面介绍。PostgreSQL/PostGIS是一种出色的开源空间数据库选择。SQLite/SpatiaLite轻量级数据库引擎以及在背景中使用SQLite的GRASS同样也是如此。</p>
<p>如果您的数据集对于PostgreSQL/PostGIS来说过大，并且您需要大规模的空间数据管理和查询性能，那么探索分布式计算系统上的大规模地理查询可能是值得的。这样的系统超出了本书的范围，但值得一提的是，提供此功能的开源软件确实存在。在此领域的重要项目包括<a href="http://www.geomesa.org/">GeoMesa</a>和<a href="https://sedona.apache.org/">Apache Sedona</a>。<a href="https://cran.r-project.org/package=apache.sedona"><strong>apache.sedona</strong></a>包提供了对后者的接口。</p>
<h1>云技术和服务的桥梁</h1>
<p>近年来，云技术在互联网上越来越突出。这也包括使用云技术来存储和处理空间数据。主要的云计算提供商（如亚马逊网络服务、微软Azure / Planetary Computer、谷歌云平台等）在其平台上提供了大量的开放地球观测数据，例如完整的Sentinel-2档案。我们可以使用R直接连接并处理这些档案中的数据，理想情况下是从同一云和地区的机器中进行。</p>
<p>三个有前途的发展使得在云平台上使用此类图像档案变得更加<em>简单</em>和<em>高效</em>，它们分别是<a href="https://stacspec.org">时空资产目录（STAC）</a>、<a href="https://www.cogeo.org/">云优化的GeoTIFF（COG）</a>图像文件格式，以及数据立方体的概念。</p>
<p>除了托管大型数据档案，近几年还推出了许多基于云的服务来处理地球观测数据。其中包括OpenEO倡议——一种在编程语言（包括R）和各种基于云的服务之间的统一接口。</p>
<h2 id="STAC，COGs，和云端的数据立方体">STAC，COGs，和云端的数据立方体</h2>
<p>时空资产目录（STAC）是一个用于描述时空数据的通用描述格式，用于描述云平台上的各种数据集，包括图像、合成孔径雷达（SAR）数据和点云。除了简单的静态目录描述，STAC-API还提供了一项网络服务，以通过空间、时间和其他属性查询目录中的项目（例如图像）。在R中，<strong>rstac</strong>包允许连接到STAC-API端点并搜索项目。在下面的示例中，我们请求与预定义区域和时间相交的<a href="https://registry.opendata.aws/sentinel-2-l2a-cogs">亚马逊网络服务上的Sentinel-2云优化GeoTIFF（COG）数据集</a>中的所有图像。结果包含所有找到的图像及其元数据（例如云覆盖）和指向AWS上实际文件的URL。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>rstac<span class="punctuation">)</span></span><br><span class="line"><span class="comment"># Connect to the STAC-API endpoint for Sentinel-2 data</span></span><br><span class="line"><span class="comment"># and search for images intersecting our AOI</span></span><br><span class="line">s <span class="operator">=</span> stac<span class="punctuation">(</span><span class="string">&quot;https://earth-search.aws.element84.com/v0&quot;</span><span class="punctuation">)</span></span><br><span class="line">items <span class="operator">=</span> s <span class="operator">|&gt;</span></span><br><span class="line">  stac_search<span class="punctuation">(</span></span><br><span class="line">    collections <span class="operator">=</span> <span class="string">&quot;sentinel-s2-l2a-cogs&quot;</span><span class="punctuation">,</span></span><br><span class="line">    bbox <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">7.1</span><span class="punctuation">,</span> <span class="number">51.8</span><span class="punctuation">,</span> <span class="number">7.2</span><span class="punctuation">,</span> <span class="number">52.8</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">    datetime <span class="operator">=</span> <span class="string">&quot;2020-01-01/2020-12-31&quot;</span></span><br><span class="line">  <span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">  post_request<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">  items_fetch<span class="punctuation">(</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>云存储与本地硬盘不同，传统图像文件格式在基于云的地理处理中表现不佳。广义而言，云优化GeoTIFF格式是GeoTIFF的一种特定类型，使得可以高效地从云存储中仅读取图像的某些部分。<br>
因此，以较低分辨率读取图像或读取图像的矩形子集变得更加高效。作为R用户，您无需安装任何东西即可使用COG，因为<a href="https://gdal.org">GDAL</a>（以及使用它的任何包）已经可以与COG一起工作。然而，请注意，在浏览数据提供商的目录时，COG的可用性是一个很大的优势。</p>
<p>对于较大的感兴趣区域，请求的图像仍然相对难以处理：它们可能使用不同的地图投影，可能在空间上重叠，空间分辨率通常取决于光谱带。<strong>gdalcubes</strong>包可用于从单个图像中抽象出来，并创建和处理图像集合为四维数据立方体。</p>
<p>下面的代码展示了一个最小示例，用于从前一个STAC-API搜索返回的Sentinel-2图像创建较低分辨率（250m）的最大NDVI合成。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>gdalcubes<span class="punctuation">)</span></span><br><span class="line"><span class="comment"># Filter images by cloud cover and create an image collection object</span></span><br><span class="line">collection <span class="operator">=</span> stac_image_collection<span class="punctuation">(</span>items<span class="operator">$</span>features<span class="punctuation">,</span></span><br><span class="line">  property_filter <span class="operator">=</span> <span class="keyword">function</span><span class="punctuation">(</span>x<span class="punctuation">)</span> <span class="punctuation">&#123;</span></span><br><span class="line">    x<span class="punctuation">[[</span><span class="string">&quot;eo:cloud_cover&quot;</span><span class="punctuation">]</span><span class="punctuation">]</span> <span class="operator">&lt;</span> <span class="number">10</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># Define extent, resolution (250m, daily) and CRS of the target data cube</span></span><br><span class="line">v <span class="operator">=</span> cube_view<span class="punctuation">(</span></span><br><span class="line">  srs <span class="operator">=</span> <span class="string">&quot;EPSG:3857&quot;</span><span class="punctuation">,</span> extent <span class="operator">=</span> collection<span class="punctuation">,</span> dx <span class="operator">=</span> <span class="number">250</span><span class="punctuation">,</span> dy <span class="operator">=</span> <span class="number">250</span><span class="punctuation">,</span></span><br><span class="line">  dt <span class="operator">=</span> <span class="string">&quot;P1D&quot;</span></span><br><span class="line"><span class="punctuation">)</span> <span class="comment"># &quot;P1D&quot; is an ISO 8601 duration string</span></span><br><span class="line"><span class="comment"># Create and process the data cube</span></span><br><span class="line">cube <span class="operator">=</span> raster_cube<span class="punctuation">(</span>collection<span class="punctuation">,</span> v<span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">  select_bands<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;B04&quot;</span><span class="punctuation">,</span> <span class="string">&quot;B08&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">  apply_pixel<span class="punctuation">(</span><span class="string">&quot;(B08-B04)/(B08+B04)&quot;</span><span class="punctuation">,</span> <span class="string">&quot;NDVI&quot;</span><span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">  reduce_time<span class="punctuation">(</span><span class="string">&quot;max(NDVI)&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># gdalcubes_options(parallel = 8)</span></span><br><span class="line"><span class="comment"># plot(cube, zlim = c(0, 1))</span></span><br></pre></td></tr></table></figure>
<p>为了通过云覆盖来过滤图像，我们提供一个属性过滤函数，在创建图像集合时应用于每个STAC结果项。该函数接收图像的可用元数据作为输入列表，并返回一个逻辑值，只有函数返回TRUE的图像才会被考虑。在这种情况下，我们忽略了10%或更多云覆盖的图像。有关更多详细信息，请参考<a href="https://appelmar.github.io/ogh2021/tutorial.html">2021年OpenGeoHub夏季学校上展示的教程</a>。</p>
<p>STAC、COGs和数据立方体的组合形成了一种云——本地工作流程，用于在云中分析（大型）卫星图像集合。这些工具已经构成了某些工具的支柱，例如<strong>sits</strong> R包，该包允许对大型地球观测数据进行土地利用和土地覆盖分类。该包从云服务中可用的图像集合中构建EO数据立方体，并使用各种机器学习算法对数据立方体进行土地分类。有关<strong>sits</strong>的更多信息，请访问<a href="https://e-sensing.github.io/sitsbook/">https://e-sensing.github.io/sitsbook/</a> 或阅读相关文章。</p>
<h2 id="openEO">openEO</h2>
<p>是一个倡议，通过定义用于处理数据的通用语言来支持云服务之间的互操作性。初始想法已在<a href="https://r-spatial.org/2016/11/29/openeo.html">r-spatial.org博客文章</a>中描述，旨在让用户能够轻松地在云服务之间切换，并尽可能减少代码更改。<a href="https://processes.openeo.org">标准化流程</a>使用多维数据立方体模型作为数据的接口。<br>
用户可以通过R、Python、JavaScript、QGIS或网络编辑器连接到8个不同的后端（请参见<a href="https://hub.openeo.org">https://hub.openeo.org</a>），并定义（和链接）集合上的流程。由于后端之间的功能和数据可用性存在差异，因此<strong>openeo</strong> R包会动态加载来自连接后端的可用流程和集合。然后，用户可以加载图像集合，应用和链接流程，提交作业，以及探索和绘制结果。</p>
<p>以下代码将连接到<a href="https://openeo.cloud/">openEO平台后端</a>，请求可用数据集、流程和输出格式，定义一个流程图来从Sentinel-2数据计算最大NDVI图像，并在登录到后端后最终执行该图。openEO平台后端包括一个免费层次，可以通过现有的机构或社交平台帐户进行注册。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>openeo<span class="punctuation">)</span></span><br><span class="line">con <span class="operator">=</span> connect<span class="punctuation">(</span>host <span class="operator">=</span> <span class="string">&quot;https://openeo.cloud&quot;</span><span class="punctuation">)</span></span><br><span class="line">p <span class="operator">=</span> processes<span class="punctuation">(</span><span class="punctuation">)</span> <span class="comment"># load available processes</span></span><br><span class="line">collections <span class="operator">=</span> list_collections<span class="punctuation">(</span><span class="punctuation">)</span> <span class="comment"># load available collections</span></span><br><span class="line">formats <span class="operator">=</span> list_file_formats<span class="punctuation">(</span><span class="punctuation">)</span> <span class="comment"># load available output formats</span></span><br><span class="line"><span class="comment"># Load Sentinel-2 collection</span></span><br><span class="line">s2 <span class="operator">=</span> p<span class="operator">$</span>load_collection<span class="punctuation">(</span></span><br><span class="line">  id <span class="operator">=</span> <span class="string">&quot;SENTINEL2_L2A&quot;</span><span class="punctuation">,</span></span><br><span class="line">  spatial_extent <span class="operator">=</span> <span class="built_in">list</span><span class="punctuation">(</span></span><br><span class="line">    west <span class="operator">=</span> <span class="number">7.5</span><span class="punctuation">,</span> east <span class="operator">=</span> <span class="number">8.5</span><span class="punctuation">,</span></span><br><span class="line">    north <span class="operator">=</span> <span class="number">51.1</span><span class="punctuation">,</span> south <span class="operator">=</span> <span class="number">50.1</span></span><br><span class="line">  <span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">  temporal_extent <span class="operator">=</span> <span class="built_in">list</span><span class="punctuation">(</span><span class="string">&quot;2021-01-01&quot;</span><span class="punctuation">,</span> <span class="string">&quot;2021-01-31&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">  bands <span class="operator">=</span> <span class="built_in">list</span><span class="punctuation">(</span><span class="string">&quot;B04&quot;</span><span class="punctuation">,</span> <span class="string">&quot;B08&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># Compute NDVI vegetation index</span></span><br><span class="line">compute_ndvi <span class="operator">=</span> p<span class="operator">$</span>reduce_dimension<span class="punctuation">(</span></span><br><span class="line">  data <span class="operator">=</span> s2<span class="punctuation">,</span> dimension <span class="operator">=</span> <span class="string">&quot;bands&quot;</span><span class="punctuation">,</span></span><br><span class="line">  reducer <span class="operator">=</span> <span class="keyword">function</span><span class="punctuation">(</span>data<span class="punctuation">,</span> context<span class="punctuation">)</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="punctuation">(</span>data<span class="punctuation">[</span><span class="number">2</span><span class="punctuation">]</span> <span class="operator">-</span> data<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">)</span> <span class="operator">/</span> <span class="punctuation">(</span>data<span class="punctuation">[</span><span class="number">2</span><span class="punctuation">]</span> <span class="operator">+</span> data<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">)</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># Compute maximum over time</span></span><br><span class="line">reduce_max <span class="operator">=</span> p<span class="operator">$</span>reduce_dimension<span class="punctuation">(</span></span><br><span class="line">  data <span class="operator">=</span> compute_ndvi<span class="punctuation">,</span> dimension <span class="operator">=</span> <span class="string">&quot;t&quot;</span><span class="punctuation">,</span></span><br><span class="line">  reducer <span class="operator">=</span> <span class="keyword">function</span><span class="punctuation">(</span>x<span class="punctuation">,</span> y<span class="punctuation">)</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="built_in">max</span><span class="punctuation">(</span>x<span class="punctuation">)</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># Export as GeoTIFF</span></span><br><span class="line">result <span class="operator">=</span> p<span class="operator">$</span>save_result<span class="punctuation">(</span>reduce_max<span class="punctuation">,</span> formats<span class="operator">$</span>output<span class="operator">$</span>GTiff<span class="punctuation">)</span></span><br><span class="line"><span class="comment"># Login, see https://docs.openeo.cloud/getting-started/r/#authentication</span></span><br><span class="line">login<span class="punctuation">(</span></span><br><span class="line">  login_type <span class="operator">=</span> <span class="string">&quot;oidc&quot;</span><span class="punctuation">,</span> provider <span class="operator">=</span> <span class="string">&quot;egi&quot;</span><span class="punctuation">,</span></span><br><span class="line">  config <span class="operator">=</span> <span class="built_in">list</span><span class="punctuation">(</span>client_id <span class="operator">=</span> <span class="string">&quot;...&quot;</span><span class="punctuation">,</span> secret <span class="operator">=</span> <span class="string">&quot;...&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># Execute processes</span></span><br><span class="line">compute_result<span class="punctuation">(</span>graph <span class="operator">=</span> result<span class="punctuation">,</span> output_file <span class="operator">=</span> tempfile<span class="punctuation">(</span>fileext <span class="operator">=</span> <span class="string">&quot;.tif&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<h1>练习</h1>
<p>E1. 使用 <strong>qgisprocess</strong> 通过GRASS GIS的 <code>r.sun</code> 计算 <code>system.file(&quot;raster/dem.tif&quot;, package = &quot;spDataLarge&quot;)</code> 区域在3月21日上午11点的全球太阳辐射。</p>
<p>E2. 使用 <strong>Rsagacmd</strong> 计算 <code>system.file(&quot;raster/dem.tif&quot;, package = &quot;spDataLarge&quot;)</code> 的集水区域和集水区坡度。</p>
<p>E3. 继续在SAGA GIS部分创建的 <code>ndvi_segments</code> 对象上工作。从 <code>ndvi</code> 栅格中提取平均NDVI值，并使用 <code>kmeans()</code> 将它们分组到六个集群中。可视化结果。</p>
<p>E4. 附加 <code>data(random_points, package = &quot;spDataLarge&quot;)</code> 并读取 <code>system.file(&quot;raster/dem.tif&quot;, package = &quot;spDataLarge&quot;)</code> 到R中。从 <code>random_points</code> 随机选择一个点，并找到从该点可以看到的所有 <code>dem</code> 像素（提示：可以使用GRASS GIS计算视域）。可视化结果。例如，绘制一个山体阴影，你的视域输出的数字高程模型和点。另外，尝试使用 <code>mapview</code>。</p>
<p>E5. 通过系统调用为磁盘上存储的光栅文件使用 <code>gdalinfo</code>。你能在那里找到什么信息？</p>
<p>E6. 使用 <code>gdalwarp</code> 降低你的光栅文件的分辨率（例如，如果分辨率是0.5，将其改为1）。注意：在此练习中将使用 <code>-tr</code> 和 <code>-r</code> 标志。</p>
<p>E7. 从本章中介绍的QGIS Cloud中的PostgreSQL/PostGIS数据库中查询所有加利福尼亚州的高速公路。</p>
<p>E8. <code>ndvi.tif</code> 光栅（<code>system.file(&quot;raster/ndvi.tif&quot;, package = &quot;spDataLarge&quot;)</code>）包含了基于2000年9月22日的Landsat数据为Mongón研究区域计算的NDVI。使用 <strong>rstac</strong>，<strong>gdalcubes</strong> 和 <strong>terra</strong> 从2020-08-01到2020-10-31为同一区域下载Sentinel-2图像，计算其NDVI，然后将其与 <code>ndvi.tif</code> 的结果进行比较。</p>
]]></content>
      <categories>
        <category>R</category>
        <category>Geocomputaion</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>Geocomputaion</tag>
      </tags>
  </entry>
  <entry>
    <title>(13)（应用）运输</title>
    <url>/2023/08/22/2023-8-22-13%E8%BF%90%E8%BE%93/</url>
    <content><![CDATA[<blockquote><p>本文由SCY翻译自《Geocomputation with R》<a href="https://r.geocompx.org/transport">第十三章</a></p>
</blockquote>
<h1>前提条件</h1>
<ul>
<li>本章使用下列包：^[13-transport-1]</li>
</ul>
<p>^[13-transport-1]：<strong>nabor</strong> 必须安装。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>sf<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>dplyr<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>spDataLarge<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>stplanr<span class="punctuation">)</span>      <span class="comment"># for processing geographic transport data</span></span><br><span class="line">library<span class="punctuation">(</span>tmap<span class="punctuation">)</span>         <span class="comment"># map making (see Chapter 9)</span></span><br><span class="line">library<span class="punctuation">(</span>ggplot2<span class="punctuation">)</span>      <span class="comment"># data visualization package</span></span><br><span class="line">library<span class="punctuation">(</span>sfnetworks<span class="punctuation">)</span>   <span class="comment"># spatial network classes and functions </span></span><br></pre></td></tr></table></figure>
<h1>引言</h1>
<p>很少有其他部门的地理空间比交通更有形。移动(克服距离)的努力是地理学“第一定律”的核心，Waldo Tobler 在1970年定义如下(Tobler 1970) :</p>
<blockquote>
<p>一切事物都与其他事物相关，但是近的事物比远的事物更相关。</p>
</blockquote>
<p>这个“定律”是空间自相关和其他关键地理概念的基础。它适用于各种各样的现象，如友谊网络和生态多样性，可以用交通成本来解释——在时间、精力和金钱方面——这些构成了“距离摩擦”。从这个角度来看，运输技术具有颠覆性，改变了包括移动人员和货物在内的地理实体之间的空间关系: “运输的目的是克服空间”(Rodrigue，Comtois，and Slack 2013)。</p>
<p>运输是一个固有的空间活动，包括从一个起点‘ A’到目的地‘ B’，通过无限的位置之间。因此，交通运输研究人员长期以来一直采用地理和计算方法来理解运动模式，以及干预措施如何能够提高他们的表现，这并不令人惊讶(Lovelace 2021)。</p>
<p>本章介绍了不同地理层次运输系统的地理分析:</p>
<ul>
<li><strong>Areal units</strong>: 交通模式可以通过参考区域总量来理解，比如主要的出行方式(例如，汽车、自行车或步行) ，以及生活在特定区域的人们的平均出行距离(见第13.3节)</li>
<li><strong>Desire lines</strong>: 表示“起点-目的地”数据的直线，记录有多少人在地理空间的不同地点(点或区域)之间旅行(或可能旅行) ，这是第13.4节的主题</li>
<li><strong>Nodes</strong>: 这些是交通系统中可以代表共同起点和目的地的点，以及公共交通站点，如公共汽车站和火车站，这是第13.5节的主题</li>
<li><strong>Routes</strong>: 这些线路表示沿着路由网络沿着所需的线路和节点之间的路径。路由(可以表示为单行字符串或多个<em>短段</em>)和生成它们的<em>路由引擎</em>，在第13.6节中介绍</li>
<li><strong>Route networks</strong>: 这些代表了一个区域内的道路、路径和其他线性特征的系统，在第13.6节中有介绍。<br>
它们可以表示为地理特征（通常是组成完整网络的短路段）或结构化为一个相互连接的图，不同段上的交通流量被运输模型师称为“流量”(Hollander 2016)。</li>
</ul>
<p>This highlights an important feature of transport systems: they are closely linked to broader phenomena and land-use patterns.<br>
另一个关键层次是<strong>代理</strong>，如你我以及使我们能够移动的交通工具，比如自行车和公交车。这些可以在像<a href="http://www.matsim.org/">MATSim</a>和<a href="https://github.com/a-b-street/abstreet">A/B Street</a>这样的软件中以计算方式表示，它们使用基于代理的建模（ABM）框架，通常具有很高的空间和时间分辨率，来表示交通系统的动态性(Horni，Nagel 和 Axhausen 2016)。尽管ABM是一种具有很大整合潜力的强大的交通研究方法，尤其是与R的空间类(Thiele 2014; Lovelace and Dumont 2016) ，但它不在本章的范围内。除了地理层次和代理之外，许多交通模型中的基本分析单位是<strong>行程</strong>，即从一个起点’A’到一个终点’B’的单一目的地之旅(Hollander 2016)。行程连接了交通系统的不同层次，并可以简单地表示为连接<em>区域</em>质心（<em>节点</em>）的地理<em>需求线</em>，或作为遵循交通<em>路线网络</em>的路线。在这种情况下，<em>代理人</em>通常是在交通网络内移动的点实体。</p>
<p>交通系统是动态的(Xie and Levinson 2011)。尽管本章的重点是交通系统的<em>地理</em>分析，但它也提供了如何使用这种方法来模拟变化情景的见解，在第13.8节中有介绍。地理交通建模的目的可以理解为以捕捉其本质的方式简化这些时空系统的复杂性。选择适当的地理分析层次可以在不失去其最重要的特征和变量的情况下，简化这种复杂性，从而实现更好的决策和更有效的干预(Hollander 2016)。</p>
<p>通常，模型被设计用来解决特定问题，比如如何提高交通系统的安全性或环境性能。因此，本章围绕一个政策情境展开，将在下一节中介绍，即：如何增加布里斯托尔市的自行车使用？第14章演示了地理计算的一个相关应用：优先考虑新自行车店的位置。章节之间有一个联系：新的和有效定位的自行车基础设施可以使人们开始骑自行车，从而增加对自行车店和当地经济活动的需求。这突出了交通系统的一个重要特点：它们与更广泛的现象和土地利用模式密切相关。</p>
<h1>布里斯托尔案例研究</h1>
<p>本章使用的案例研究位于英格兰西部的布里斯托尔市，距离威尔士首都加的夫约30公里以东。该地区的交通网络概览在下图中展示，图中展示了多样的交通基础设施，包括自行车、公共交通和私家车。</p>
<p>布里斯托尔是一个充满活力和多样性的城市，拥有各种各样的交通选项。从自行车道到公交线路，再到繁忙的高速公路，布里斯托尔的交通网络反映了其居民多样化的出行需求。这为进行地理和交通研究提供了一个极为丰富的背景。</p>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309051448576.png" alt=""><br>
Bristol’s transport network represented by colored lines for active (green), public (railways, black) and private motor (red) modes of travel. Black border lines represent the inner city boundary (highlighted in yellow) and the larger Travel To Work Area (TTWA).</p>
<p>布里斯托尔是英格兰第十大的市议会，拥有50万人口，尽管其交通服务覆盖区域更广泛（参见13.3节）。该市拥有一个充满活力的经济体，包括航空航天、媒体、金融服务和旅游公司，以及两所主要大学。尽管布里斯托尔的人均收入较高，但也有严重贫困的地区(布里斯托尔市议会2015年)。</p>
<p>从交通角度看，布里斯托尔的铁路和公路连接非常便利，活跃出行的水平相对较高。根据<a href="https://www.gov.uk/government/statistical-data-sets/how-often-and-time-spent-walking-and-cycling-at-local-authority-level-cw010#table-cw0103">Active People Survey</a>，19%的市民每月至少骑一次自行车，88%的人每月至少走一次路（全国平均分别为15%和81%）。2011年的人口普查数据显示，8%的人口自行车上班，而全国平均仅为3%。</p>
<p>与许多城市一样，布里斯托尔面临严重的交通拥堵、空气质量和体力不活跃的问题。自行车出行能有效地解决这些问题：与步行相比，自行车更有可能替代汽车出行，因为其典型<a href="https://en.wikipedia.org/wiki/Bicycle_performance">速度</a>为15-20 km/h，而步行为4-6 km/h。因此，布里斯托尔的<a href="https://www.bristol.gov.uk/council-and-mayor/policies-plans-and-strategies/bristol-transport-strategy">交通战略</a>对自行车出行有着雄心勃勃的计划。</p>
<p>为了强调政策考虑在交通研究中的重要性，本章旨在为那些负责让人们从汽车转向更可持续出行方式（特别是步行和自行车）的人（如交通规划师、政治家和其他利益相关者）提供证据。更广泛的目标是演示地理计算如何支持基于证据的交通规划。</p>
<p>在本章中，你将学习如何：</p>
<ul>
<li>描述城市交通行为的地理模式</li>
<li>识别支持多模式出行的关键公共交通节点</li>
<li>分析旅行&quot;愿望线&quot;，找出哪里有许多人驾车短途出行</li>
<li>识别鼓励少开车、多骑自行车的自行车路线位置</li>
</ul>
<p>为了在实践方面展开本章的内容，下一节将开始加载关于旅行模式的区域数据。这些区域级别的数据集虽小，但对于获取对城市整体交通系统的基本了解至关重要。</p>
<h1>交通区域</h1>
<p>尽管交通系统主要基于线性特征和节点——包括路径和车站——从面数据开始通常更有意义，以将连续空间划分为可触及的单位 (Hollander 2016)。除了定义研究区域的边界（在这种情况下是布里斯托尔）之外，对交通研究人员尤为感兴趣的两种区域类型是：起源区域和目的区域。通常，相同的地理单位用于起点和目的地。然而，不同的分区系统，例如 ‘<a href="https://data.gov.uk/dataset/workplace-zones-a-new-geography-for-workplace-statistics3">工作区</a>’，可能更适合代表在有许多’旅行吸引点’的区域内旅行目的地的增加密度 (国家统计局2014年)。</p>
<p>最简单定义研究区域的方式通常是第一个由OpenStreetMap返回的匹配边界。这可以通过诸如 <code>osmdata::getbb(&quot;Bristol&quot;, format_out = &quot;sf_polygon&quot;,  limit = 1)</code> 的命令来完成。这返回一个 <code>sf</code> 对象（或者如果没有指定 <code>limit = 1</code>，则返回一组 <code>sf</code> 对象），代表最大匹配城市区域的范围，要么是边界框的矩形多边形，要么是一个详细的多边形边界。[^13-transport-2]对于布里斯托尔，返回了一个详细的多边形，由 <strong>spDataLarge</strong> 包中的 <code>bristol_region</code> 对象表示。请参见上图中的内部蓝色边界：这种方法有几个问题：</p>
<p>[^13-transport-2]: 在第一个匹配没有提供正确名称的情况下，应指定国家或地区，例如位于美国的布里斯托尔应为 <code>Bristol Tennessee</code>。</p>
<ul>
<li>第一个由OSM返回的OSM边界可能不是当地政府使用的官方边界</li>
<li>即使OSM返回官方边界，这也可能不适合交通研究，因为它们与人们的旅行路线关系不大</li>
</ul>
<p>工作通勤区域（TTWAs）通过创建一个类似于水文流域的分区系统来解决这些问题。TTWAs最初被定义为连续区域，在其中75%的人口前往工作(Coombes, Green, and Openshaw 1986)，这是本章使用的定义。由于布里斯托尔是一个主要的雇主，吸引了周边城镇的旅行，因此其TTWA比城市界限要大得多（见上图）。代表这一以交通为导向的边界的多边形存储在由章节开始时加载的 <strong>spDataLarge</strong> 包提供的 <code>bristol_ttwa</code> 对象中。</p>
<p>本章使用的起点和终点区域是相同的：官方定义的中等地理分辨率区域（它们的<a href="https://www.ons.gov.uk/peoplepopulationandcommunity/populationandmigration/populationestimates/bulletins/annualsmallareapopulationestimates/2014-10-23">官方</a>名称是中层超级输出区域或MSOAs）。<br>
每个区域大约有8,000人。这种行政区域可以为交通分析提供重要的背景信息，例如可能最受特定干预措施影响的人群类型(例如, Moreno-Monroy, Lovelace, and Ramos 2017)。</p>
<p>这些区域的地理分辨率很重要：小区域具有高地理分辨率通常更可取，但它们在大区域中的高数量可能对处理（尤其是对于起点-终点分析，在其中可能性作为区域数量的非线性函数增加）有影响 (Hollander 2016)。</p>
<blockquote>
<p>📌与小区域相关的另一个问题与匿名规则有关。为了使在区域内无法推断个人身份，详细社会人口统计变量通常仅在低地理分辨率下可用。例如，旅行方式的年龄和性别细分在英国的地方当局层面上可用，但不在更高的输出区域层面上，其中每个区域大约包含100户家庭。有关更多详细信息，请参阅 <a href="http://www.ons.gov.uk/methodology/geography%E3%80%82">www.ons.gov.uk/methodology/geography。</a></p>
</blockquote>
<p>本章中使用的102个区域存储在 <code>bristol_zones</code> 中，如下图所示。注意，在人口密集地区，区域变得更小：每个区域都有类似数量的人。<code>bristol_zones</code> 不包含关于交通的属性数据，只有每个区域的名称和代码：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="built_in">names</span><span class="punctuation">(</span>bristol_zones<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] &quot;geo_code&quot; &quot;name&quot;     &quot;geometry&quot;</span></span><br></pre></td></tr></table></figure>
<p>为了添加旅行数据，我们将执行<em>属性连接</em>，这是在<em>矢量属性连接</em>节中描述的常见任务。我们将使用来自英国2011年人口普查关于工作通勤的问题的旅行数据，该数据存储在 <code>bristol_od</code> 中，由 <a href="https://www.ons.gov.uk/help/localstatistics">ons.gov.uk</a> 数据门户提供。<code>bristol_od</code> 是一个关于英国2011年人口普查中各区域间通勤旅行的起点-终点（OD）数据集。第一列是起始区域的ID，第二列是目的区域。<code>bristol_od</code> 的行数比 <code>bristol_zones</code> 多，代表的是区域<em>之间</em>的旅行，而不是区域本身：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">nrow<span class="punctuation">(</span>bristol_od<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] 2910</span></span><br><span class="line">nrow<span class="punctuation">(</span>bristol_zones<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] 102</span></span><br></pre></td></tr></table></figure>
<p>前一个代码块的结果显示，每个区域有超过10个起点-终点（OD）对，这意味着在将其与 <code>bristol_zones</code> 进行连接之前，我们需要对起点-终点数据进行聚合，如下图所示<br>
：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">zones_attr <span class="operator">=</span> bristol_od <span class="operator">|&gt;</span> </span><br><span class="line">  group_by<span class="punctuation">(</span>o<span class="punctuation">)</span> <span class="operator">|&gt;</span> </span><br><span class="line">  summarize<span class="punctuation">(</span>across<span class="punctuation">(</span>where<span class="punctuation">(</span><span class="built_in">is.numeric</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">sum</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">|&gt;</span> </span><br><span class="line">  dplyr<span class="operator">::</span>rename<span class="punctuation">(</span>geo_code <span class="operator">=</span> o<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>前面的代码块执行了以下操作：</p>
<ul>
<li>按照起点区域（包含在<code>o</code>列中）对数据进行了分组</li>
<li><em>如果</em>在<code>bristol_od</code> 数据集中的变量是数值型的，就对它们进行了聚合，以找出每个区域中按交通方式分布的人口总数[^13-transport-3]</li>
<li>将分组变量<code>o</code>重命名，使其与<code>bristol_zones</code>对象中的ID列<code>geo_code</code>匹配</li>
</ul>
<p>[^13-transport-3]: <code>_if</code> 后缀要求对变量提出一个 <code>TRUE</code>/<code>FALSE</code> 的问题，在这个情况下是’是否为数值型?’ 只有返回 true 的变量会被汇总。</p>
<p>由此产生的对象<code>zones_attr</code>是一个数据框，其行代表各个区域和一个ID变量。我们可以使用<code>%in%</code>操作符验证这些ID是否与<code>zones</code>数据集中的ID匹配，操作如下：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">summary<span class="punctuation">(</span>zones_attr<span class="operator">$</span>geo_code <span class="operator">%in%</span> bristol_zones<span class="operator">$</span>geo_code<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt;    Mode    TRUE </span></span><br><span class="line"><span class="comment">#&gt; logical     102</span></span><br></pre></td></tr></table></figure>
<p>结果显示，新对象中包含所有102个区域，而<code>zone_attr</code>具有可以与区域连接的形式[^13-transport-4]。这是通过使用连接函数 <code>left_join()</code> 来完成的（注意，在这里<code>inner_join()</code>也会产生相同的结果）。</p>
<p>[^13-transport-4]: 在实际数据中，检查ID在反方向上是否匹配也同样重要。这可以通过改变<code>summary()</code>命令中ID的顺序来完成——<code>summary(bristol_zones$geo_code %in% zones_attr$geo_code)</code>——或者通过如下使用<code>setdiff()</code>：<code>setdiff(bristol_zones$geo_code, zones_attr$geo_code)</code>。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">zones_joined <span class="operator">=</span> left_join<span class="punctuation">(</span>bristol_zones<span class="punctuation">,</span> zones_attr<span class="punctuation">,</span> by <span class="operator">=</span> <span class="string">&quot;geo_code&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="built_in">sum</span><span class="punctuation">(</span>zones_joined<span class="operator">$</span><span class="built_in">all</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] 238805</span></span><br><span class="line"><span class="built_in">names</span><span class="punctuation">(</span>zones_joined<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] &quot;geo_code&quot;   &quot;name&quot;       &quot;all&quot;        &quot;bicycle&quot;    &quot;foot&quot;      </span></span><br><span class="line"><span class="comment">#&gt; [6] &quot;car_driver&quot; &quot;train&quot;      &quot;geometry&quot;</span></span><br></pre></td></tr></table></figure>
<p>结果是<code>zones_joined</code>，它包含新的列，代表研究区域内每个区域起始的总出行次数（接近四分之一百万次）以及它们的出行方式（自行车、步行、汽车和火车）。出行起点的地理分布在下图的左侧地图中有所体现。这显示了大多数区域在研究区内有0至4000次的出行起始。生活在布里斯托尔市中心附近的人进行的出行次数更多，而在城市边缘的则较少。这是为什么呢？记住我们只在研究区域内处理出行：边缘区域低出行次数可以归因于这些周边区域的许多人会前往研究区域之外的其他地区。通过一个特殊的目的地ID，研究区域之外的出行可以被包括在区域模型中，该ID涵盖了任何前往模型中未表示的区域的出行(Hollander 2016)。然而，<code>bristol_od</code>中的数据简单地忽略了这样的出行：它是一个“区域内”的模型。</p>
<p>与OD（出发-目的地）数据集可以聚合到出发区域的方式相同，它们也可以被聚合以提供关于目的地区域的信息。人们倾向于聚集在中心地区。这解释了为什么下图右侧面板中表示的空间分布相对不均匀，最常见的目的地区域集中在布里斯托尔市中心。结果是<code>zones_od</code>，其中包含一个新列，报告了任何出行方式的目的地数量，如下所创建：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">zones_destinations <span class="operator">=</span> bristol_od <span class="operator">|&gt;</span> </span><br><span class="line">  group_by<span class="punctuation">(</span>d<span class="punctuation">)</span> <span class="operator">|&gt;</span> </span><br><span class="line">  summarize<span class="punctuation">(</span>across<span class="punctuation">(</span>where<span class="punctuation">(</span><span class="built_in">is.numeric</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">sum</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">|&gt;</span> </span><br><span class="line">  select<span class="punctuation">(</span>geo_code <span class="operator">=</span> d<span class="punctuation">,</span> all_dest <span class="operator">=</span> <span class="built_in">all</span><span class="punctuation">)</span></span><br><span class="line">zones_od <span class="operator">=</span> inner_join<span class="punctuation">(</span>zones_joined<span class="punctuation">,</span> zones_destinations<span class="punctuation">,</span> by <span class="operator">=</span> <span class="string">&quot;geo_code&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>下面的代码创建了一个简化版本的下图（参见书籍GitHub仓库的 <a href="https://github.com/geocompx/geocompr/tree/main/code"><code>code</code></a> 文件夹中的 <code>12-zones.R</code> 文件以重现该图，以及有关使用<strong>tmap</strong>创建分面地图的详细信息）：</p>
<!-- toDo: rl   -->
<!-- qtm does not exist... -->
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">qtm<span class="punctuation">(</span>zones_od<span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;all&quot;</span><span class="punctuation">,</span> <span class="string">&quot;all_dest&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  tm_layout<span class="punctuation">(</span>panel.labels <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;Origin&quot;</span><span class="punctuation">,</span> <span class="string">&quot;Destination&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309051544306.png" alt=""><br>
Number of trips (commuters) living and working in the region. The left map shows zone of origin of commute trips; the right map shows zone of destination (generated by the script 13-zones.R).</p>
<h1>欲望线</h1>
<p>欲望线连接起点和终点，表示人们<em>想要</em>去的地方，通常是在各个区域之间。它们代表了从A点到B点最快的“直线”或“鸟飞”路线，如果没有建筑物和弯曲道路的阻碍的话（我们将在下一节看到如何将欲望线转化为实际路线）。通常，欲望线在地理上表示为每个区域的地理（或人口加权）中心的起点和终点。这是我们将在本节中创建和使用的欲望线类型，尽管值得注意的是，“抖动”技术能够增加多个起点和终点，以提高基于OD数据构建的分析的空间覆盖和准确性 (Lovelace，Félix 和 Carlino 2022)。</p>
<p>我们已经在数据集<code>bristol_od</code>中加载了代表欲望线的数据。这个起点-终点（OD）数据框对象表示在<code>o</code>和<code>d</code>所代表的区域之间旅行的人数，如下表所示。要按所有旅行对OD数据进行排序，然后只过滤出前5名，请输入：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">od_top5 <span class="operator">=</span> bristol_od <span class="operator">|&gt;</span> </span><br><span class="line">  slice_max<span class="punctuation">(</span><span class="built_in">all</span><span class="punctuation">,</span> n <span class="operator">=</span> <span class="number">5</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>Table: Sample of the top 5 origin-destination pairs in the Bristol OD data frame, representing travel desire lines between zones in the study area.</p>
<table>
<thead>
<tr>
<th style="text-align:left">o</th>
<th style="text-align:left">d</th>
<th style="text-align:right">all</th>
<th style="text-align:right">bicycle</th>
<th style="text-align:right">foot</th>
<th style="text-align:right">car_driver</th>
<th style="text-align:right">train</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">E02003043</td>
<td style="text-align:left">E02003043</td>
<td style="text-align:right">1493</td>
<td style="text-align:right">66</td>
<td style="text-align:right">1296</td>
<td style="text-align:right">64</td>
<td style="text-align:right">8</td>
</tr>
<tr>
<td style="text-align:left">E02003047</td>
<td style="text-align:left">E02003043</td>
<td style="text-align:right">1300</td>
<td style="text-align:right">287</td>
<td style="text-align:right">751</td>
<td style="text-align:right">148</td>
<td style="text-align:right">8</td>
</tr>
<tr>
<td style="text-align:left">E02003031</td>
<td style="text-align:left">E02003043</td>
<td style="text-align:right">1221</td>
<td style="text-align:right">305</td>
<td style="text-align:right">600</td>
<td style="text-align:right">176</td>
<td style="text-align:right">7</td>
</tr>
<tr>
<td style="text-align:left">E02003037</td>
<td style="text-align:left">E02003043</td>
<td style="text-align:right">1186</td>
<td style="text-align:right">88</td>
<td style="text-align:right">908</td>
<td style="text-align:right">110</td>
<td style="text-align:right">3</td>
</tr>
<tr>
<td style="text-align:left">E02003034</td>
<td style="text-align:left">E02003043</td>
<td style="text-align:right">1177</td>
<td style="text-align:right">281</td>
<td style="text-align:right">711</td>
<td style="text-align:right">100</td>
<td style="text-align:right">7</td>
</tr>
</tbody>
</table>
<p>生成的表格提供了关于布里斯托尔通勤（上班往返）出行模式的快照。它表明，在前5大起点-终点（OD）组合中，步行是最受欢迎的出行方式，而<code>E02003043</code> 区域是一个受欢迎的目的地（布里斯托尔市中心，所有前5大OD组合的目的地），并且<em>区内</em> 出行，从<code>E02003043</code> 区域的一个部分到另一个部分（表的第一行），是数据集中出行最多的OD组合。但从政策角度看，表中呈现的原始数据用处有限：除了它仅包含了2,910个OD组合中的一小部分之外，它几乎没有告诉我们<em>在哪里</em>需要政策措施，或者<em>有多少比例</em>的出行是通过步行和骑自行车完成的。<br>
以下命令计算了由这些积极模式完成的每条欲望线的百分比：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">bristol_od<span class="operator">$</span>Active <span class="operator">=</span> <span class="punctuation">(</span>bristol_od<span class="operator">$</span>bicycle <span class="operator">+</span> bristol_od<span class="operator">$</span>foot<span class="punctuation">)</span> <span class="operator">/</span></span><br><span class="line">  bristol_od<span class="operator">$</span><span class="built_in">all</span> <span class="operator">*</span> <span class="number">100</span></span><br></pre></td></tr></table></figure>
<p>有两种主要类型的OD（起点-终点）组合：<em>区间（Interzonal）</em> 和 <em>区内（Intrazonal）</em>。区间的OD组合代表了目的地与起点不同区域之间的出行。区内的OD组合代表了在同一区域内的出行（参见表的顶行）。以下代码块将 <code>od_bristol</code> 分为这两种类型：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">od_intra <span class="operator">=</span> filter<span class="punctuation">(</span>bristol_od<span class="punctuation">,</span> o <span class="operator">==</span> d<span class="punctuation">)</span></span><br><span class="line">od_inter <span class="operator">=</span> filter<span class="punctuation">(</span>bristol_od<span class="punctuation">,</span> o <span class="operator">!=</span> d<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>下一步是将区间（interzonal）的OD组合转换为一个表示“欲望线（desire lines）”的<code>sf</code>对象，这可以通过使用 <strong>stplanr</strong> 函数 <code>od2line()</code> 来在地图上进行绘制。[^13-transport-5]</p>
<p>[^13-transport-5]: <code>od2line()</code> 的工作方式是通过匹配 <code>bristol_od</code> 对象的前两列中的ID与地理 <code>zones_od</code> 对象中的 <code>zone_code</code> ID列。需要注意的是，该操作会发出一个警告，因为 <code>od2line()</code> 是通过将每一对起点-终点分配给其起源和目的地区域的<em>质心</em>\index{centroid}来工作的。对于实际应用，人们会使用由投影数据生成的质心值，或者更好地使用<em>基于人口加权</em>的质心[@lovelace_propensity_2017]。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">desire_lines <span class="operator">=</span> od2line<span class="punctuation">(</span>od_inter<span class="punctuation">,</span> zones_od<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; Creating centroids representing desire line start and end points.</span></span><br></pre></td></tr></table></figure>
<p>下图展示了结果的示例，其简化版本可以通过以下命令创建（要完全复制该图形，请查看 <code>13-desire.R</code> 中的代码，有关使用 <strong>tmap</strong> 进行可视化的详细信息，请参见章节<em>高级制图</em>）：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">qtm<span class="punctuation">(</span>desire_lines<span class="punctuation">,</span> lines.lwd <span class="operator">=</span> <span class="string">&quot;all&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309051558946.png" alt=""><br>
Desire lines representing trip patterns in Bristol, with width representing number of trips and color representing the percentage of trips made by active modes (walking and cycling). The four black lines represent the interzonal OD pairs in Table 7.1.</p>
<p>该地图显示，市中心主导了该地区的交通模式，这暗示政策应当优先考虑这里，尽管也可以看到一些边缘的次中心。欲望线是交通系统中重要的概括性组成部分。更具体的组成部分包括节点，这些节点有特定的目的地（而不是欲望线中所表示的假设直线）。下一节将涵盖节点。</p>
<h1>节点</h1>
<p>在地理交通数据集中，节点是组成交通网络的主要线性特征之间的点。大致上，有两种主要类型的交通节点：</p>
<ol>
<li>不直接位于网络上的节点，例如区域质心或个体的起点和终点（如住宅和工作场所）。</li>
<li>是交通网络一部分的节点。<br>
从技术上讲，一个节点可以位于交通网络上的任何点，但实际上它们通常是特殊类型的顶点，例如路径（交叉口）之间的交点和进入或退出交通网络的点，如公交站和火车站[^13-transport-6]。</li>
</ol>
<p>交通网络可以表示为图形，其中每个段通过地理线（代表边）与网络中的一个或多个其他边相连。可以通过“质心连接器”添加网络之外的节点，这些新的路线段连接到网络上附近的节点(Hollander 2016)[^13-transport-7]。网络中的每个节点然后通过一个或多个代表网络上个别段的“边”进行连接。我们将在<em>路线网络</em>节中看到如何将交通网络表示为图。</p>
<p>公共交通站点是特别重要的节点，可以表示为两种类型的节点：是道路的一部分的公交站，或由距离铁路轨道数百米的行人入口点代表的大型铁路站。我们将使用火车站来说明与布里斯托尔市增加自行车使用相关的公共交通节点。这些站由 <strong>spDataLarge</strong> 在 <code>bristol_stations</code> 中提供。</p>
<p>一个常见的障碍是，从家到工作的距离太远，无法步行或骑自行车。公共交通可以通过为进入城市的常见路线提供快速和高容量的选择来减少这一障碍。从积极出行的角度来看，长途旅行的公共交通“腿”将旅行分为三部分：</p>
<ul>
<li>起点腿，通常从住宅区到公共交通站</li>
<li>公共交通腿，通常从离旅行起点最近的站到离目的地最近的站</li>
<li>目的地腿，从下车站到目的地</li>
</ul>
<p>在<em>欲望线</em>节进行的分析的基础上，公共交通节点可用于为可乘坐公共汽车和（在本例中使用的）火车的旅行构建三部分欲望线。第一阶段是确定具有最多公共交通出行的欲望线，在我们的情况下这很容易，因为我们之前创建的数据集 <code>desire_lines</code> 已经包含了描述火车旅行数量的变量（也可以使用如 <a href="http://www.opentripplanner.org/">OpenTripPlanner</a> 等公共交通路线服务来估计公共交通潜力）。为了使该方法更容易遵循，我们将仅选择关于铁路使用方面的前三条欲望线。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">desire_rail <span class="operator">=</span> top_n<span class="punctuation">(</span>desire_lines<span class="punctuation">,</span> n <span class="operator">=</span> <span class="number">3</span><span class="punctuation">,</span> wt <span class="operator">=</span> train<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>现在的挑战是将每一条这样的线分解为三部分，代表通过公共交通节点的出行。这可以通过将一条欲望线转换为一个由三个线几何体组成的多线字符串对象来实现，这三个线几何体分别代表行程的起点、公共交通和终点阶段。这个操作可以分为三个阶段：矩阵创建（代表起点、终点和表示铁路站的“途经”点）、最近邻标识和转换为多线字符串。这些都由<code>line_via()</code>函数来完成。这个<strong>stplanr</strong>函数接受输入线和点，并返回一份欲望线的副本——具体细节请参见<a href="https://docs.ropensci.org/stplanr/reference/line_via.html"><code>?line_via()</code></a>。<br>
输出与输入线相同，只不过它有新的几何列，代表通过公共交通节点的行程，如下所示：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ncol<span class="punctuation">(</span>desire_rail<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] 9</span></span><br><span class="line">desire_rail <span class="operator">=</span> line_via<span class="punctuation">(</span>desire_rail<span class="punctuation">,</span> bristol_stations<span class="punctuation">)</span></span><br><span class="line">ncol<span class="punctuation">(</span>desire_rail<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] 12</span></span><br></pre></td></tr></table></figure>
<p>如下图所示，初始的 <code>desire_rail</code> 线现在有三个额外的几何列表列，分别代表从家到起点站、从那里到目的地，以及最后从目的地站到目的地的旅行。在这种情况下，目的地段非常短（步行距离），但起点段可能足够远，以证明需要在骑行基础设施上进行投资，以鼓励人们在上班途中到居住区周围的三个起点站骑自行车，如下图所示。</p>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309051613261.png" alt=""><br>
Station nodes (red dots) used as intermediary points that convert straight desire lines with high rail usage (thin green lines) into three legs: to the origin station (orange) via public transport (blue) and to the destination (pink, not visible because it is so short).</p>
<h1>路线</h1>
<p>从地理角度看，路线是不再直线的需求线：起点和终点与旅行的需求线表示相同，但从A到B的路径更为复杂。路线的几何形状通常（但不总是）由交通网络决定。</p>
<p>虽然需求线仅包含两个顶点（其起点和终点），但路线可以包含任意数量的顶点，代表由直线连接的A和B之间的点：这就是linestring几何形状的定义。覆盖大距离或遵循复杂网络的路线可能有数百个顶点；基于网格或简化道路网络的路线通常较少。</p>
<p>路线是由需求线生成的，或更常见地，由包含代表需求线的坐标对的矩阵生成。这个路由过程是由一系列广义定义的<em>路由引擎</em>完成的：软件和Web服务，它们返回描述如何从起点到终点的几何形状和属性。根据它们相对于R运行的<em>位置</em>，路由引擎可以被分类为：</p>
<ul>
<li>内存路由，使用使路线计算成为可能的R包</li>
<li>本地托管的、外部于R的路由引擎，可以从R中调用</li>
<li>由外部实体远程托管的路由引擎，提供一个可以从R中调用的Web API</li>
</ul>
<p>在描述每一个之前，值得概述分类路由引擎的其他方式。路由引擎可以是多模式的，意味着它们可以计算由多种交通方式组成的行程，或者不是。多模式路由引擎可以返回由不同交通方式组成的多个<em>段</em>的结果。从住宅区到商业区的最佳路线可能涉及1）步行到最近的公交车站，2）乘公交车到离目的地最近的节点，以及3）步行到目的地，给定一组输入参数。这三段之间的转换点通常被称为“进入”和“出口”，意味着上下公共交通工具。像R5这样的多模式路由引擎比如OSRM这样的’单一模式’路由引擎更为复杂，并且有更大的输入数据要求。</p>
<p>多模式引擎的一个主要优势是它们能够表示由火车、公共汽车等组成的“公共交通”行程。多模型路由引擎需要代表公共交通网络的输入数据集，通常以General Transit Feed Specification（<a href="https://developers.google.com/transit/gtfs">GTFS</a>）文件形式，这些可以用<a href="https://r-transit.github.io/tidytransit/index.html"><strong>tidytransit</strong></a>和<a href="https://ipeagit.github.io/gtfstools/"><strong>gtfstools</strong></a>包（也有其他用于处理GTFS文件的包和工具）中的函数进行处理。对于专注于特定（非公共）交通方式的项目，单一模式路由引擎可能就足够了。另一种分类路由引擎（或设置）的方式是通过输出的地理级别：路线、段和环节。</p>
<h2 id="路线、段和环节">路线、段和环节</h2>
<p>路由引擎可以在三个地理级别生成输出：路线、段和环节：</p>
<ul>
<li><strong>路线</strong>级别的输出每个起点-终点对包含一个单一特征（通常是数据框表示中的多线几何和关联行），意味着每次行程的数据有一行。</li>
<li><strong>段</strong>级别的输出在每个起点-终点对内的每个<em>模式</em>都包含一个单一特征和相关属性。对于仅涉及一种模式的行程（例如，从家到工作的驾驶，忽略走到汽车的短距离），段与路线相同：即汽车行程。对于涉及公共交通的行程，段提供关键信息。<strong>r5r</strong>函数<code>detailed_itineraries()</code>返回的段有时令人困惑地被称为“环节”。</li>
<li>环节级别的输出提供了有关路线的最详细信息，具有交通网络的每个小段的记录。通常，环节在长度上类似于，或与，OpenStreetMap中的道路相同。<strong>cyclestreets</strong>函数<code>journey()</code>返回在环节级别的数据，这些数据可以通过对<strong>stplanr</strong>中<code>route()</code>函数返回的起点和终点级别数据进行分组而聚合。</li>
</ul>
<p>大多数路由引擎默认返回路线级别的输出，尽管多模式引擎通常在段级别提供输出（每个连续运动的单一交通模式一个特征）。  环节级别的输出有提供更多细节的优点。  <strong>cyclestreets</strong>包返回每条路线的多个“安静度”级别，使得可以识别自行车网络中的“最薄弱环节”。  环节级别输出的劣势包括增加的文件大小和与额外细节相关的复杂性。</p>
<p>使用函数<code>stplanr::overline()</code>[@morgan_travel_2020]，路线级别的结果可以转换为环节级别的结果。在使用环节或段级别的数据时，通过对表示行程起点和终点的列进行分组，并汇总/聚合包含环节级别数据的列，可以返回路线级别的统计数据。</p>
<h2 id="使用R进行内存内路由">使用R进行内存内路由</h2>
<p>R中的路由引擎允许将存储为R对象的<em>内存内</em>路由网络用作路由计算的基础。选项包括<a href="https://luukvdmeer.github.io/sfnetworks/"><strong>sfnetworks</strong></a>、<a href="https://atfutures.github.io/dodgr/"><strong>dodgr</strong></a> 和 <a href="https://github.com/vlarmet/cppRouting"><strong>cppRouting</strong></a> 包，每个包都提供了它们自己的类系统来表示路由网络，这是下一节的主题。</p>
<p>尽管快速和灵活，使用原生R的路由选项通常比用于现实路由计算的专用路由引擎更难设置。路由是一个复杂问题，开源路由引擎已经投入了很多时间，这些引擎可以下载并在本地主机上运行。另一方面，基于R的路由引擎可能非常适用于模型实验和网络上变化影响的统计分析。在单一语言中更改路由网络特性（或与不同路由段类型相关联的权重）、重新计算路由和分析多个场景下的结果对研究应用有益。</p>
<h2 id="本地托管的专用路由引擎">本地托管的专用路由引擎</h2>
<p><strong>本地托管</strong>的路由引擎包括OpenTripPlanner、<a href="https://github.com/valhalla/valhalla">Valhalla</a> 和R5（它们是多模式的），以及OpenStreetMap路由机器（OSRM）（它是“单模式”的）。这些可以通过<strong>opentripplanner</strong>、<a href="https://github.com/chris31415926535/valhallr"><strong>valhalla</strong></a>、<strong>r5r</strong> 和 <a href="https://github.com/riatelab/osrm"><strong>osrm</strong></a> 包从R中访问(Morgan 等，2019; Pereira 等，2021)。本地托管的路由引擎在用户的计算机上运行，但在一个与R分开的进程中。它们的优点包括执行速度和对不同运输模式的权重配置文件的控制。劣势包括在本地表示复杂网络的困难；时间动态（主要是由于交通）；以及需要专用外部软件。</p>
<h2 id="远程托管的专用路由引擎">远程托管的专用路由引擎</h2>
<p><strong>远程托管</strong>的路由引擎使用web API发送有关起点和终点的查询并返回结果。基于开源路由引擎的路由服务，例如OSRM的公开可用服务，在从R调用时与本地托管实例的工作方式相同，只需更新指定“基础URL”的参数即可。然而，由于外部路由服务托管在专用机器上（通常由有激励生成准确路由的商业公司资助），这可能给它们带来优势，包括：</p>
<ul>
<li>提供全球（或通常至少在大区域内）的路由服务</li>
<li>已建立的路由服务通常会定期更新，并且经常能够响应交通水平</li>
<li>路由服务通常在专用硬件和软件上运行，包括像负载均衡器这样的系统以确保性能稳定</li>
</ul>
<p>远程路由服务的劣势包括批量作业不可能时的速度（它们通常依赖于一条条路由的基础上通过互联网进行数据传输）、价格（例如，谷歌路由API限制了免费查询的数量）和许可问题。</p>
<p><a href="http://symbolixau.github.io/googleway/"><strong>googleway</strong></a> 和 <a href="https://walker-data.com/mapboxapi/articles/navigation.html"><strong>mapbox</strong></a> 包通过提供对Google和Mapbox的路由服务的访问来展示这种方法。免费（但有速率限制）的路由服务包括 <a href="http://project-osrm.org/">OSRM</a> 和 <a href="https://openrouteservice.org/">openrouteservice.org</a>，它们可以通过 <a href="https://rgeomatic.hypotheses.org/category/osrm"><strong>osrm</strong></a> 和 <a href="https://github.com/GIScience/openrouteservice-r"><strong>openrouteservice</strong></a> 包从R中访问，后者不在CRAN上。还有更具体的路由服务，例如由 <a href="https://www.cyclestreets.net/">CycleStreets.net</a> 提供的，这是一个自行车旅行规划器和非营利性交通技术公司“为骑自行车者，由骑自行车者”。虽然R用户可以通过 <a href="https://rpackage.cyclestreets.net/"><strong>cyclestreets</strong></a> 包访问CycleStreets路由，但许多路由服务缺乏R接口，这代表了一个巨大的软件包开发机会：构建一个R包以提供一个接口到web API可能是一种有益的经历。</p>
<p>R包用于计算和导入代表交通网络上路由的数据的广泛范围是一种优势，这意味着该语言近年来越来越多地用于交通研究。然而，这种包和方法的激增的一个小缺点是有很多包和函数名称需要记住。<br>
<strong>stplanr</strong> 包通过提供一个用于生成路由的统一接口 <code>route()</code> 函数来解决这个问题。该函数接受广泛的输入，包括地理欲望线（使用 <code>l =</code> 参数）、坐标甚至表示独特地址的文本字符串，并返回作为一致 <code>sf</code> 对象的路由数据。</p>
<!-- TODO: 在某个时候我希望创建一个专用的路由包，如果它被创建了，请提及（RL 2022-07） -->
<h2 id="路径规划：一个实际示例">路径规划：一个实际示例</h2>
<p>与其对部分生成的<em>所有</em>期望线进行路径规划，我们专注于高度政策相关的一个子集。在尝试处理整个数据集之前，先对一个子集进行计算密集型操作通常是明智的，这同样适用于路径规划。路径规划可能需要消耗大量时间和内存，并生成大型对象，这是因为路线对象的详细几何形状和额外属性。因此，我们将在本节中过滤期望线，然后计算路径。</p>
<p>当骑行替代开车出行时，效益最大。短距离（大约5公里，以20公里/小时的速度可以在15分钟内骑完）有相对较高的被骑行的概率，当使用<a href="https://www.sciencedirect.com/science/article/pii/S0967070X21003401">电动自行车</a>进行出行时，最大距离会增加(Lovelace 等，2017)。以下代码片段考虑了这些因素，过滤了期望线，并返回了表示OD对（起点到终点对）的对象 <code>desire_lines_short</code>，在这些OD对之间有很多（100+）短距离（2.5至5公里的欧几里得距离）的车程：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">desire_lines<span class="operator">$</span>distance_km <span class="operator">=</span> <span class="built_in">as.numeric</span><span class="punctuation">(</span>st_length<span class="punctuation">(</span>desire_lines<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">/</span> <span class="number">1000</span></span><br><span class="line">desire_lines_short <span class="operator">=</span> desire_lines <span class="operator">|&gt;</span> </span><br><span class="line">  filter<span class="punctuation">(</span>car_driver <span class="operator">&gt;=</span> <span class="number">100</span><span class="punctuation">,</span> distance_km <span class="operator">&lt;=</span> <span class="number">5</span><span class="punctuation">,</span> distance_km <span class="operator">&gt;=</span> <span class="number">2.5</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，<code>st_length()</code> 计算了每个期望线的长度。<strong>dplyr</strong> 的 <code>filter()</code> 函数基于上述标准过滤了 <code>desire_lines</code> 数据集。下一步是将这些期望线转换为路线。这是通过下面的代码块中使用公开可用的OSRM服务和 <strong>stplanr</strong> 的 <code>route()</code> 和 <code>route_osrm()</code> 函数来完成的：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">routes_short <span class="operator">=</span> route<span class="punctuation">(</span>l <span class="operator">=</span> desire_lines_short<span class="punctuation">,</span> route_fun <span class="operator">=</span> route_osrm<span class="punctuation">,</span></span><br><span class="line">                     osrm.profile <span class="operator">=</span> <span class="string">&quot;bike&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>输出是 <code>routes_short</code>，一个代表适用于骑自行车的交通网络上的路线的 <code>sf</code> 对象（至少根据 OSRM 路由引擎是这样），每个期望线对应一个。注意：像上面的命令中那样调用外部路由引擎只有在有互联网连接的情况下才能工作（有时还需要存储在环境变量中的 API 密钥，尽管在这种情况下不需要）。除了 <code>desire_lines</code> 对象中包含的列之外，新的路线数据集还包含 <code>distance</code>（这次是指路线距离）和 <code>duration</code>（以秒为单位）列，这些提供了有关每条路线性质的潜在有用额外信息。我们将绘制沿着这些线路进行许多短途汽车行驶的期望线和骑行路线。通过使路线的宽度与可能被替换的汽车行驶数量成比例，提供了一种有效的方式来优先考虑对道路网络进行干预(Lovelace 等 2017)。<br>
下面的代码块绘制了期望线和路线，该图显示了人们驾驶短距离的路线：<a href="%E6%B3%A8%E6%84%8F%EF%BC%8C%E7%BA%A2%E8%89%B2%E7%9A%84%E8%B7%AF%E7%BA%BF%E5%92%8C%E9%BB%91%E8%89%B2%E7%9A%84%E6%9C%9F%E6%9C%9B%E7%BA%BF%E7%9A%84%E8%B5%B7%E7%82%B9%E5%B9%B6%E4%B8%8D%E5%AE%8C%E5%85%A8%E7%9B%B8%E5%90%8C%E3%80%82%E8%BF%99%E6%98%AF%E5%9B%A0%E4%B8%BA%E5%8C%BA%E5%9F%9F%E8%B4%A8%E5%BF%83%E5%BE%88%E5%B0%91%E4%BD%8D%E4%BA%8E%E8%B7%AF%E7%BA%BF%E7%BD%91%E7%BB%9C%E4%B8%8A%EF%BC%9A%E7%9B%B8%E5%8F%8D%EF%BC%8C%E8%B7%AF%E7%BA%BF%E8%B5%B7%E6%BA%90%E4%BA%8E%E8%B7%9D%E7%A6%BB%E8%B4%A8%E5%BF%83%E6%9C%80%E8%BF%91%E7%9A%84%E4%BA%A4%E9%80%9A%E7%BD%91%E7%BB%9C%E8%8A%82%E7%82%B9%E3%80%82%E8%BF%98%E8%A6%81%E6%B3%A8%E6%84%8F%EF%BC%8C%E5%81%87%E8%AE%BE%E8%B7%AF%E7%BA%BF%E8%B5%B7%E6%BA%90%E4%BA%8E%E5%8C%BA%E5%9F%9F%E8%B4%A8%E5%BF%83%EF%BC%8C%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8C%96%E5%81%87%E8%AE%BE%EF%BC%8C%E7%94%A8%E4%BA%8E%E5%87%8F%E5%B0%91%E8%AE%A1%E7%AE%97%E6%89%80%E6%9C%89%E5%8F%AF%E8%83%BD%E8%B5%B7%E7%82%B9%E5%92%8C%E7%BB%88%E7%82%B9%E7%BB%84%E5%90%88%E4%B9%8B%E9%97%B4%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E6%89%80%E9%9C%80%E7%9A%84%E8%AE%A1%E7%AE%97%E8%B5%84%E6%BA%90%5B@hollander_transport_2016%5D%E3%80%82">^13-transport-8</a></p>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309051636508.png" alt=""><br>
Routes along which many (100+) short (&lt;5km Euclidean distance) car journeys are made (red) overlaying desire lines representing the same trips (black) and zone centroids (dots).</p>
<p>通过在交互式地图上绘制结果，例如使用 <code>mapview::mapview(st_geometry(routes_short))</code>，可以看到许多短途汽车行程发生在布拉德利斯托克（Bradley Stoke）及其周围，距离布里斯托尔（Bristol）市中心大约10公里以北。找出该地区高度依赖汽车的原因很容易：根据<a href="https://en.wikipedia.org/wiki/Bradley_Stoke">维基百科</a>，布拉德利斯托克是“欧洲最大的由私人投资建设的新城镇”，这暗示了有限的公共交通供应。此外，该城镇被包括M4和M5高速公路在内的大型（对自行车不友好）的道路结构所环绕（tallon 2007)。</p>
<p>将旅行需求线转换为路线有很多好处。重要的是要记住，我们不能确定有多少（如果有的话）行程会沿着路由引擎计算出的确切路线进行。然而，路线和街道/道路/段级别的结果可能具有很高的政策相关性。路段结果可以根据可用数据(Lovelace 等 2017)，实现在最需要的地方优先进行投资。</p>
<h1>路线网络</h1>
<p>虽然路线通常包含有关旅行<em>行为</em>的数据，在与需求线和OD（起点-终点）对相同的地理层级上，路线网络数据集通常代表物理交通网络。路线网络中的每个<em>段</em>大致对应于交叉口之间的连续街道段，并且只出现一次，尽管段的平均长度取决于数据源（本节中使用的由OSM（开放街道地图）派生的<code>bristol_ways</code>数据集中的段平均长度刚好超过200米，标准差接近500米）。段长度的可变性可以由这样一个事实来解释：在一些农村地区，交叉口相距很远，而在密集的城市区域，每隔几米就有交叉口和其他段的断点。</p>
<p>路线网络可以是交通数据分析项目的输入或输出，或者两者都是。任何涉及路线计算的交通研究都需要内部或外部路由引擎中的路线网络数据集（在后一种情况下，路线网络数据不一定需要导入到R中）。然而，路线网络在许多交通研究项目中也是重要的输出：总结诸如特定段上可能进行的潜在行程数量的数据，并以路线网络的形式表示，可以帮助在最需要的地方优先进行投资。</p>
<p>为了演示如何从路线级别的数据中创建路线网络作为输出，想象一个简单的模式转移场景。假设0到3公里的路线距离之间的50%的汽车行程被自行车取代，这一百分比每增加1公里的路线距离就减少10个百分点，以至于6公里的汽车行程有20%被自行车取代，而8公里或更长的汽车行程没有被自行车取代。当然，这是一个不现实的情景(Lovelace 等 2017)，但它是一个有用的起点。<br>
在这种情况下，我们可以按照以下方式模拟从汽车到自行车的模式转移：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">uptake <span class="operator">=</span> <span class="keyword">function</span><span class="punctuation">(</span>x<span class="punctuation">)</span> <span class="punctuation">&#123;</span></span><br><span class="line">  case_when<span class="punctuation">(</span></span><br><span class="line">    x <span class="operator">&lt;=</span> <span class="number">3</span> <span class="operator">~</span> <span class="number">0.5</span><span class="punctuation">,</span></span><br><span class="line">    x <span class="operator">&gt;=</span> <span class="number">8</span> <span class="operator">~</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="literal">TRUE</span> <span class="operator">~</span> <span class="punctuation">(</span><span class="number">8</span> <span class="operator">-</span> x<span class="punctuation">)</span> <span class="operator">/</span> <span class="punctuation">(</span><span class="number">8</span> <span class="operator">-</span> <span class="number">3</span><span class="punctuation">)</span> <span class="operator">*</span> <span class="number">0.5</span></span><br><span class="line">  <span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line">routes_short_scenario <span class="operator">=</span> routes_short <span class="operator">|&gt;</span> </span><br><span class="line">  mutate<span class="punctuation">(</span>uptake <span class="operator">=</span> uptake<span class="punctuation">(</span>distance <span class="operator">/</span> <span class="number">1000</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">|&gt;</span> </span><br><span class="line">  mutate<span class="punctuation">(</span>bicycle <span class="operator">=</span> bicycle <span class="operator">+</span> car_driver <span class="operator">*</span> uptake<span class="punctuation">,</span></span><br><span class="line">         car_driver <span class="operator">=</span> car_driver <span class="operator">*</span> <span class="punctuation">(</span><span class="number">1</span> <span class="operator">-</span> uptake<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="built_in">sum</span><span class="punctuation">(</span>routes_short_scenario<span class="operator">$</span>bicycle<span class="punctuation">)</span> <span class="operator">-</span> <span class="built_in">sum</span><span class="punctuation">(</span>routes_short<span class="operator">$</span>bicycle<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] 3733</span></span><br></pre></td></tr></table></figure>
<p>在创建了一个大约有4000次行程从驾驶转向骑自行车的场景后，我们现在可以模拟这个更新后的模拟自行车活动将在哪里发生。为此，我们将使用<strong>stplanr</strong>包中的<code>overline()</code>函数。该函数在交叉口（两条或更多的折线几何相交的地方）处断开折线，并计算每个唯一路段的聚合统计信息(Morgan 和 Lovelace 2020)，它将包含路线的对象和要汇总的属性的名称作为第一和第二个参数：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">route_network_scenario <span class="operator">=</span> overline<span class="punctuation">(</span>routes_short_scenario<span class="punctuation">,</span> attrib <span class="operator">=</span> <span class="string">&quot;bicycle&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>前面两个代码块的输出总结如下面的图所示。</p>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309051646384.png" alt=""><br>
Illustration of the percentage of car trips switching to cycling as a function of distance (left) and route network level results of this function (right).</p>
<p>具有在路段级别的记录的交通网络，通常带有诸如道路类型和宽度之类的属性，构成了一种常见的路线网络。这种路线网络数据集在全球范围内都可以从OpenStreetMap获得，并可以使用诸如<strong>osmdata</strong>和<strong>osmextract</strong>这样的软件包进行下载。为了节省下载和准备OSM的时间，我们将使用来自<strong>spDataLarge</strong>包的<code>bristol_ways</code>对象，这是一个带有LINESTRING几何图形和属性的<code>sf</code>对象，代表了案例研究区域内交通网络的一个样本（详见<code>?bristol_ways</code>以获取详细信息），如下面的输出所示：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">summary<span class="punctuation">(</span>bristol_ways<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt;      highway       maxspeed             ref                     geometry   </span></span><br><span class="line"><span class="comment">#&gt;  cycleway:1721   Length:6160        Length:6160        LINESTRING   :6160  </span></span><br><span class="line"><span class="comment">#&gt;  rail    :1017   Class :character   Class :character   epsg:4326    :   0  </span></span><br><span class="line"><span class="comment">#&gt;  road    :3422   Mode  :character   Mode  :character   +proj=long...:   0</span></span><br></pre></td></tr></table></figure>
<p>输出显示<code>bristol_ways</code>代表了交通网络上刚刚超过6千个路段。这种和其他地理网络可以表示为数学图，网络上的节点由边连接。一些R软件包已经为处理这样的图而开发，尤其是<strong>igraph</strong>。您可以手动将路线网络转换为<code>igraph</code>对象，但地理属性将会丢失。为了克服<strong>igraph</strong>的这一局限性，开发了<strong>sfnetworks</strong>软件包，该软件包能够同时将路线网络表示为图<em>和</em>地理线。我们将在<code>bristol_ways</code>对象上演示<strong>sfnetworks</strong>的功能。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">bristol_ways<span class="operator">$</span>lengths <span class="operator">=</span> st_length<span class="punctuation">(</span>bristol_ways<span class="punctuation">)</span></span><br><span class="line">ways_sfn <span class="operator">=</span> as_sfnetwork<span class="punctuation">(</span>bristol_ways<span class="punctuation">)</span></span><br><span class="line"><span class="built_in">class</span><span class="punctuation">(</span>ways_sfn<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] &quot;sfnetwork&quot; &quot;tbl_graph&quot; &quot;igraph&quot;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ways_sfn</span><br><span class="line"><span class="comment">#&gt; # A sfnetwork with 5728 nodes and 4915 edges</span></span><br><span class="line"><span class="comment">#&gt; # A directed multigraph with 1013 components with spatially explicit edges</span></span><br><span class="line"><span class="comment">#&gt; # Node Data:     5,728 × 1 (active)</span></span><br><span class="line"><span class="comment">#&gt; # Edge Data:     4,915 × 7</span></span><br><span class="line"><span class="comment">#&gt;    from    to highway maxspeed ref                              geometry lengths</span></span><br><span class="line"><span class="comment">#&gt;   &lt;int&gt; &lt;int&gt; &lt;fct&gt;   &lt;fct&gt;    &lt;fct&gt;                    &lt;LINESTRING [°]&gt;     [m]</span></span><br><span class="line"><span class="comment">#&gt; 1     1     2 road    &lt;NA&gt;     B3130 (-2.61 51.4, -2.61 51.4, -2.61 51.…    218.</span></span><br><span class="line"><span class="comment">#&gt; # … </span></span><br></pre></td></tr></table></figure>
<p>由于空间考虑，前一个代码块的输出（最后的输出被缩短，仅包含最重要的8行）显示<code>ways_sfn</code>是一个复合对象，以图和空间形式包含节点和边。<code>ways_sfn</code>是<code>sfnetwork</code>类，该类基于<strong>igraph</strong>包中的<code>igraph</code>类。在下面的示例中，计算了’边介数’，也就是经过每条边的最短路径的数量（有关更多详细信息，请参见<code>?igraph::betweenness</code>）。边介数计算的输出显示在下图，该图以用<code>overline()</code>函数计算的自行车路线网络数据集作为叠加层进行比较。结果表明，每个图的边代表一个路段：靠近道路网络中心的路段具有最高的介数值，而靠近布里斯托尔中心的路段基于这些简单数据集具有更高的自行车潜力。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ways_centrality <span class="operator">=</span> ways_sfn <span class="operator">|&gt;</span> </span><br><span class="line">  activate<span class="punctuation">(</span><span class="string">&quot;edges&quot;</span><span class="punctuation">)</span> <span class="operator">|&gt;</span>  </span><br><span class="line">  mutate<span class="punctuation">(</span>betweenness <span class="operator">=</span> tidygraph<span class="operator">::</span>centrality_edge_betweenness<span class="punctuation">(</span>lengths<span class="punctuation">)</span><span class="punctuation">)</span> </span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309051653021.png" alt=""><br>
Illustration of route network datasets. The grey lines represent a simplified road network, with segment thickness proportional to betweenness. The green lines represent potential cycling flows (one way) calculated with the code above</p>
<p>人们还可以使用<strong>sfnetworks</strong>包中的这种路由网络的图表示法来找到起点和终点之间的最短路线。<!-- TODO: 如果时间允许，基于这一点制作一个练习（RL 2022-07） -->与可能的情况相比，本节介绍的方法相对简单。<strong>sfnetworks</strong>开放的双重图/空间功能使得许多新的强大技术得以实现，这些在本节中无法完全涵盖。然而，本节确实为进一步探索和研究该领域提供了一个坚实的起点。最后一点是，我们上面使用的示例数据集相对较小。也可能值得考虑如何将工作适应到更大的网络：在数据的子集上测试方法，并确保您有足够的RAM将有所帮助，尽管也值得探索其他优化用于大型网络的交通网络分析工具，比如R5 (Alessandretti 等 2022)。</p>
<h1>优先考虑新基础设施</h1>
<p>本节演示了地理计算如何在交通规划领域创造与政策相关的成果。我们将使用一个简单的方法（出于教育目的）来识别可持续交通基础设施投资的有希望的地点。</p>
<p>本章概述的数据驱动方法的一个优点是其模块性：每个方面本身就很有用，并可以融入更广泛的分析中。使我们达到这一阶段的步骤包括在<em>路线</em>节中识别短途但依赖汽车的通勤路线（由欲望线生成），以及使用<strong>sfnetworks</strong>包在<em>路线网络</em>中分析路由网络特性。本章的最后一个代码块将这些分析纵向结合，通过在代表距离自行车基础设施很近的区域的新数据集上覆盖上一节中的自行车潜力估计。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">existing_cycleways_buffer <span class="operator">=</span> bristol_ways <span class="operator">|&gt;</span> </span><br><span class="line">  filter<span class="punctuation">(</span>highway <span class="operator">==</span> <span class="string">&quot;cycleway&quot;</span><span class="punctuation">)</span> <span class="operator">|&gt;</span>    <span class="comment"># 1) filter out cycleways</span></span><br><span class="line">  st_union<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">|&gt;</span>                       <span class="comment"># 2) unite geometries</span></span><br><span class="line">  st_buffer<span class="punctuation">(</span>dist <span class="operator">=</span> <span class="number">100</span><span class="punctuation">)</span>               <span class="comment"># 3) create buffer</span></span><br></pre></td></tr></table></figure>
<p>下一步是创建一个数据集，该数据集代表网络上存在高自行车潜力但几乎没有为自行车提供便利设施的点：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">route_network_no_infra <span class="operator">=</span> st_difference<span class="punctuation">(</span></span><br><span class="line">  route_network_scenario<span class="punctuation">,</span></span><br><span class="line">  route_network_scenario <span class="operator">|&gt;</span> st_set_crs<span class="punctuation">(</span>st_crs<span class="punctuation">(</span>existing_cycleways_buffer<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">  existing_cycleways_buffer</span><br><span class="line"><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#&gt; Warning: attribute variables are assumed to be spatially constant throughout</span><br><span class="line">#&gt; all geometries</span><br></pre></td></tr></table></figure>
<p>前面代码块的结果显示在下图中，该图显示了具有高度依赖汽车、具有高自行车潜力但没有自行车道的路线。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">tmap_mode<span class="punctuation">(</span><span class="string">&quot;view&quot;</span><span class="punctuation">)</span></span><br><span class="line">qtm<span class="punctuation">(</span>route_network_no_infra<span class="punctuation">,</span> basemaps <span class="operator">=</span> leaflet<span class="operator">::</span>providers<span class="operator">$</span>Esri.WorldTopoMap<span class="punctuation">,</span></span><br><span class="line">    lines.lwd <span class="operator">=</span> <span class="number">5</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<!-- toDo: rl -->
<!-- the next figure must be updated -->
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#&gt; Warning: Some legend items or map compoments do not fit well (e.g. due to the</span><br><span class="line">#&gt; specified font size).</span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309051701347.png" alt=""><br>
Potential routes along which to prioritise cycle infrastructure in Bristol to reduce car dependency. The static map provides an overview of the overlay between existing infrastructure and routes with high car-bike switching potential (left). The screenshot the interactive map generated from the <code>qtm()</code> function highlights Whiteladies Road as somewhere that would benefit from a new cycleway (right).</p>
<p>该方法存在一些局限性：实际上，人们并不总是前往区域中心或始终使用特定模式的最短路径算法。然而，结果展示了如何使用地理数据分析来突出可能特别有益于新投资自行车道的地方，尽管这种方法很简单。为了在实践中指导交通规划设计，这种分析需要大幅扩展——包括使用更大的输入数据集。</p>
<h1>旅行的未来方向</h1>
<p>这一章提供了使用地理计算进行交通研究的可能性的一个概览，并使用开放数据和可复制代码探讨了构成城市交通系统的一些关键地理元素。这些结果有助于规划需要投资的地方。</p>
<p>交通系统在多个相互作用的层面上运行，这意味着地理计算方法有很大的潜力，可以生成有关它们如何运作以及不同干预措施可能产生的影响的见解。在这一领域还有更多可以做的事情：基于本章提供的基础，有很多方向可以进行拓展。</p>
<p>交通是许多国家温室气体排放增长最快的来源，并将成为“尤其是在发达国家中最大的温室气体排放部门”。交通相关的排放在社会上分布不均，但（与食物和供暖不同）对幸福来说并非必需品。通过需求减少、车队电气化以及积极采取像步行和骑自行车这样的活动出行方式，该部门有很大的快速减碳潜力。新技术可以通过更多的汽车共享来减少对汽车的依赖。诸如无桩自行车和电动滑板车方案这样的“微移动”系统也正在出现，以General Bikeshare Feed Specification（GBFS）格式创建有价值的数据集，可以用<a href="https://github.com/simonpcouch/gbfs"><strong>gbfs</strong></a>包进行导入和处理。</p>
<p>从方法论的角度看，本章提供的基础可以通过在分析中包括更多变量来进行扩展。例如，通过使用R语言的统计建模能力，这可以用来预测当前和未来的自行车使用水平。</p>
<p>这种类型的分析是Propensity to Cycle Tool（PCT）的基础，这是一个用R语言开发的，用于优先考虑英格兰各地自行车投资的公开可访问的映射工具（lovelace 2017）。类似的工具可以用于鼓励与空气污染和公共交通准入等其他主题相关的基于证据的交通政策。</p>
<h1>练习</h1>
<p>E1. 在本章的大部分分析中，我们关注的是主动模式，但是驾驶行程呢？</p>
<ul>
<li>在<code>desire_lines</code>对象中，有多大比例的行程是通过驾驶完成的？</li>
<li>有多大比例的<code>desire_lines</code>的直线长度为5公里或更远？</li>
<li>在长度超过5公里的<code>desire_lines</code>中，有多大比例的行程是通过驾驶完成的？</li>
<li>绘制那些长度小于5公里且其中超过50%的行程是通过汽车完成的<code>desire_lines</code>。</li>
<li>你注意到这些依赖汽车但<code>desire_lines</code>较短的地方有什么特点？</li>
</ul>
<p>E2. 如果在离现有自行车道超过100米的区段上建造了上图中展示的所有路线，会增加多少长度的自行车道？</p>
<p>E3. <code>desire_lines</code>中表示的行程有多大比例在<code>routes_short_scenario</code>对象中得到了体现？</p>
<ul>
<li>奖励：所有行程中有多大比例发生在穿越<code>routes_short_scenario</code>的<code>desire_lines</code>上？</li>
</ul>
<p>E4. 本章展示的分析旨在教授如何将地理计算方法应用于交通研究。<br>
如果你是在政府或交通咨询公司中真正进行这项工作，你会有哪三个不同的做法？</p>
<p>E5. 显然，上图中识别的路线只是部分情况。<br>
你会如何扩展这个分析？</p>
<p>E6. 假设你想通过创建投资基于场所的自行车政策的关键<em>区域</em>（而不是路线）来扩展场景，比如无车区、自行车停车点和减少汽车停车策略。<br>
栅格数据集如何协助完成这项工作？</p>
<ul>
<li>奖励：开发一个光栅层，将布里斯托地区划分为100个单元格（10x10），并从<code>bristol_ways</code>数据集（参见章节 @ref(location)）估算每个单元格中道路的平均速度限制。</li>
</ul>
]]></content>
      <categories>
        <category>R</category>
        <category>Geocomputaion</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>Geocomputaion</tag>
      </tags>
  </entry>
  <entry>
    <title>(14)地理营销</title>
    <url>/2023/08/23/2023-8-23-14%E5%9C%B0%E7%90%86%E8%90%A5%E9%94%80/</url>
    <content><![CDATA[<blockquote><p>本文由SCY翻译自《Geocomputation with R》<a href="https://r.geocompx.org/location">第十四章</a></p>
</blockquote>
<ul>
<li>T本章要求使用下列包 (<strong>tmaptools</strong> 必须安装）:</li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>sf<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>dplyr<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>purrr<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>terra<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>osmdata<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>spDataLarge<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>必要的数据将会在适当的时候下载。</li>
</ul>
<p>为了方便读者并确保易于复现，我们已将下载的数据放在 <strong>spDataLarge</strong> 包中供使用。</p>
<h1>引言</h1>
<p>本章展示了在第一部分和第二部分学到的技能如何应用于特定领域：地理营销（有时也称为位置分析或位置智能）。这是一个广泛的研究和商业应用领域。地理营销的典型例子是如何选择一个新店的位置。这里的目标是吸引最多的顾客，最终实现最大的利润。此外，还有许多非商业应用可以利用这种技术来造福公众，例如选择新的卫生服务设施的位置。</p>
<p>人类对于位置分析来说是基本要素，特别是人们可能会在哪里花费时间和其他资源。有趣的是，生态学的概念和模型与用于店铺选址分析的概念和模型非常相似。动植物可以在某些“最优”位置最好地满足其需求，这些位置是基于随空间变化的变量确定的。这是地理计算和地理信息科学的一个重要优势：概念和方法可以转移到其他领域。例如，北极熊更喜欢气温较低且食物（海豹和海狮）丰富的北纬地区。同样地，人类倾向于聚集在某些地方，创造出类似于北极地区的生态位的经济位。位置分析的主要任务是基于现有数据找出这些特定服务的“最优位置”在哪里。典型的研究问题包括：</p>
<ul>
<li>目标群体居住在哪里，他们经常去哪些地区？</li>
<li>竞争的商店或服务位于哪里？</li>
<li>有多少人可以轻松到达特定的商店？</li>
<li>现有的服务是否过度或不足地利用了市场潜力？</li>
<li>公司在特定地区的市场份额是多少？</li>
</ul>
<p>本章通过一个基于实际数据的假设案例研究，演示了地理计算如何回答这些问题。</p>
<h1>案例研究：德国自行车商店</h1>
<p>假设您正在德国开设一家自行车连锁店。这些店铺应该位于尽可能多的潜在顾客所在的城市地区。此外，一个虚构的调查（仅用于本章，非商业用途！）表明，单身年轻男性（年龄在20到40岁之间）最有可能购买您的产品：这就是<em>目标受众</em>。幸运的是，您有足够的资本来开设多家店铺。但是，它们应该放在哪里呢？咨询公司（雇佣地理营销分析师的公司）通常会收取高额费用来回答此类问题。幸运的是，借助开放数据和开源软件，我们可以自己解决这些问题。以下几节将演示如何将本书前几章学到的技术应用于执行服务位置分析中的常见步骤：</p>
<ul>
<li>整理来自德国人口普查的输入数据</li>
<li>将表格化的人口普查数据转换为栅格对象</li>
<li>识别人口密度较高的大都市地区</li>
<li>为这些地区下载详细的地理数据（使用<strong>osmdata</strong>从OpenStreetMap下载）</li>
<li>使用地图代数创建评分栅格，以评估不同位置的相对吸引力</li>
</ul>
<p>尽管我们将这些步骤应用于一个特定的案例研究，但它们可以推广到许多店铺选址或公共服务提供的情景。</p>
<h1>整理数据</h1>
<p>德国政府提供了分辨率为1公里或100米的栅格化人口普查数据。下面的代码块用于下载、解压缩和读取1公里分辨率的数据。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">download.file<span class="punctuation">(</span><span class="string">&quot;https://tinyurl.com/ybtpkwxz&quot;</span><span class="punctuation">,</span> </span><br><span class="line">              destfile <span class="operator">=</span> <span class="string">&quot;census.zip&quot;</span><span class="punctuation">,</span> mode <span class="operator">=</span> <span class="string">&quot;wb&quot;</span><span class="punctuation">)</span></span><br><span class="line">unzip<span class="punctuation">(</span><span class="string">&quot;census.zip&quot;</span><span class="punctuation">)</span> <span class="comment"># unzip the files</span></span><br><span class="line">census_de <span class="operator">=</span> readr<span class="operator">::</span>read_csv2<span class="punctuation">(</span>list.files<span class="punctuation">(</span>pattern <span class="operator">=</span> <span class="string">&quot;Gitter.csv&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>请注意，<code>census_de</code> 数据也可以从 <strong>spDataLarge</strong> 包中获取：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">data<span class="punctuation">(</span><span class="string">&quot;census_de&quot;</span><span class="punctuation">,</span> package <span class="operator">=</span> <span class="string">&quot;spDataLarge&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><code>census_de</code> 对象是一个包含13个变量的数据框，涵盖德国境内超过360,000个栅格单元。对于我们的工作，我们只需要其中的一个子集：东向坐标 (<code>x</code>)、北向坐标 (<code>y</code>)、居民数量（人口；<code>pop</code>）、平均年龄（<code>mean_age</code>）、女性比例（<code>women</code>）和平均家庭规模（<code>hh_size</code>）。下面的代码块从这些变量中选择并将其从德文重命名为英文，并在表格 @ref(tab:census-desc) 中进行了总结。此外，<code>mutate()</code> 函数被用于将值-1和-9（表示“未知”）转换为 <code>NA</code>。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pop = population, hh_size = household size</span></span><br><span class="line">input <span class="operator">=</span> select<span class="punctuation">(</span>census_de<span class="punctuation">,</span> x <span class="operator">=</span> x_mp_1km<span class="punctuation">,</span> y <span class="operator">=</span> y_mp_1km<span class="punctuation">,</span> pop <span class="operator">=</span> Einwohner<span class="punctuation">,</span></span><br><span class="line">                      women <span class="operator">=</span> Frauen_A<span class="punctuation">,</span> mean_age <span class="operator">=</span> Alter_D<span class="punctuation">,</span> hh_size <span class="operator">=</span> HHGroesse_D<span class="punctuation">)</span></span><br><span class="line"><span class="comment"># set -1 and -9 to NA</span></span><br><span class="line">input_tidy <span class="operator">=</span> dplyr<span class="operator">::</span>mutate<span class="punctuation">(</span>input<span class="punctuation">,</span></span><br><span class="line">  dplyr<span class="operator">::</span>across<span class="punctuation">(</span>.cols <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span>pop<span class="punctuation">,</span> women<span class="punctuation">,</span> mean_age<span class="punctuation">,</span> hh_size<span class="punctuation">)</span><span class="punctuation">,</span> </span><br><span class="line">                .fns <span class="operator">=</span>  <span class="operator">~</span>ifelse<span class="punctuation">(</span>.x <span class="operator">%in%</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="operator">-</span><span class="number">1</span><span class="punctuation">,</span> <span class="operator">-</span><span class="number">9</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="literal">NA</span><span class="punctuation">,</span> .x<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>Table: Categories for each variable in census data from Datensatzbeschreibung…xlsx located in the downloaded file census.zip (see Figure @ref(fig:census-stack) for their spatial distribution).</p>
<table>
<thead>
<tr>
<th style="text-align:center">Class</th>
<th style="text-align:center">Population</th>
<th style="text-align:center">% female</th>
<th style="text-align:center">Mean age</th>
<th style="text-align:center">Household size</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">3-250</td>
<td style="text-align:center">0-40</td>
<td style="text-align:center">0-40</td>
<td style="text-align:center">1-2</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">250-500</td>
<td style="text-align:center">40-47</td>
<td style="text-align:center">40-42</td>
<td style="text-align:center">2-2.5</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">500-2000</td>
<td style="text-align:center">47-53</td>
<td style="text-align:center">42-44</td>
<td style="text-align:center">2.5-3</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">2000-4000</td>
<td style="text-align:center">53-60</td>
<td style="text-align:center">44-47</td>
<td style="text-align:center">3-3.5</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">4000-8000</td>
<td style="text-align:center">&gt;60</td>
<td style="text-align:center">&gt;47</td>
<td style="text-align:center">&gt;3.5</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">&gt;8000</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h1>创建人口普查栅格</h1>
<p>在预处理之后，可以使用<code>rast()</code>函数将数据转换为<code>SpatRaster</code>对象。当将其 <code>type</code> 参数设置为 <code>xyz</code> 时，输入数据框的 <code>x</code> 和 <code>y</code> 列应该对应于正规栅格上的坐标。所有其余列（在这里是 <code>pop</code>、<code>women</code>、<code>mean_age</code>、<code>hh_size</code>）将用作栅格图层的值（请参阅图 @ref(fig:census-stack)；还可以在我们的 GitHub 存储库中的<code>code/14-location-figures.R</code> 文件中找到相关代码）。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">input_ras <span class="operator">=</span> terra<span class="operator">::</span>rast<span class="punctuation">(</span>input_tidy<span class="punctuation">,</span> type <span class="operator">=</span> <span class="string">&quot;xyz&quot;</span><span class="punctuation">,</span> crs <span class="operator">=</span> <span class="string">&quot;EPSG:3035&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">input_ras</span><br><span class="line"><span class="comment">#&gt; class       : SpatRaster </span></span><br><span class="line"><span class="comment">#&gt; dimensions  : 868, 642, 4  (nrow, ncol, nlyr)</span></span><br><span class="line"><span class="comment">#&gt; resolution  : 1000, 1000  (x, y)</span></span><br><span class="line"><span class="comment">#&gt; extent      : 4031000, 4673000, 2684000, 3552000  (xmin, xmax, ymin, ymax)</span></span><br><span class="line"><span class="comment">#&gt; coord. ref. : ETRS89-extended / LAEA Europe (EPSG:3035) </span></span><br><span class="line"><span class="comment">#&gt; source(s)   : memory</span></span><br><span class="line"><span class="comment">#&gt; names       : pop, women, mean_age, hh_size </span></span><br><span class="line"><span class="comment">#&gt; min values  :   1,     1,        1,       1 </span></span><br><span class="line"><span class="comment">#&gt; max values  :   6,     5,        5,       5</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>📌请注意，我们使用的是等面积投影（EPSG:3035；欧洲兰伯特等面积投影），即每个栅格单元的面积相同，这里是1000 x 1000平方米。由于我们主要使用诸如每个栅格单元的居民数量或女性比例等密度数据，因此每个栅格单元的面积相同非常重要，以避免“苹果与橙子比较”。请注意，在地理坐标系（CRS）中，栅格单元的面积在向极地方向不断减小，因此需要谨慎处理。</p>
</blockquote>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309051728640.png" alt=""><br>
Gridded German census data of 2011 (see Table @ref(tab:census-desc) for a description of the classes).</p>
<p>下一步是根据前面章节提到的调查，使用 <strong>terra</strong> 函数 <code>classify()</code> 对存储在 <code>input_ras</code> 中的栅格图层的值进行重新分类。对于人口数据，我们使用类均值将类别转换为数值数据类型。假设栅格单元的值为1（‘class 1’ 中的单元包含3到250名居民），则栅格单元的人口被假定为127；如果值为2（包含250到500名居民的单元），则人口被假定为375，依此类推（请参阅上表）。对于’类别6’，栅格单元的值被选为8000名居民，因为这些单元包含的人口超过8000人。当然，这些都是对真实人口的近似值，而不是精确值。^[在这个重新分类阶段引入的潜在误差将在练习中进行探讨。]然而，这个详细级别足以划定大都市区域（请参阅下一节）。</p>
<p>与变量 <code>pop</code> 不同，该变量表示总人口的绝对估计，其他变量被重新分类为与调查中使用的权重相对应的权重。例如，变量 <code>women</code> 中的’类别1’代表的是人口中女性占0到40%的地区；这些地区被重新分类为较高的权重3，因为目标人群主要是男性。同样地，包含最年轻人口和最高比例的单身家庭的类别被重新分类为高权重。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">rcl_pop <span class="operator">=</span> matrix<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">127</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">,</span> <span class="number">375</span><span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">,</span> <span class="number">1250</span><span class="punctuation">,</span> </span><br><span class="line">                   <span class="number">4</span><span class="punctuation">,</span> <span class="number">4</span><span class="punctuation">,</span> <span class="number">3000</span><span class="punctuation">,</span> <span class="number">5</span><span class="punctuation">,</span> <span class="number">5</span><span class="punctuation">,</span> <span class="number">6000</span><span class="punctuation">,</span> <span class="number">6</span><span class="punctuation">,</span> <span class="number">6</span><span class="punctuation">,</span> <span class="number">8000</span><span class="punctuation">)</span><span class="punctuation">,</span> </span><br><span class="line">                 ncol <span class="operator">=</span> <span class="number">3</span><span class="punctuation">,</span> byrow <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br><span class="line">rcl_women <span class="operator">=</span> matrix<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">4</span><span class="punctuation">,</span> <span class="number">5</span><span class="punctuation">,</span> <span class="number">0</span><span class="punctuation">)</span><span class="punctuation">,</span> </span><br><span class="line">                   ncol <span class="operator">=</span> <span class="number">3</span><span class="punctuation">,</span> byrow <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br><span class="line">rcl_age <span class="operator">=</span> matrix<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">,</span> <span class="number">0</span><span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">,</span> <span class="number">5</span><span class="punctuation">,</span> <span class="number">0</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">                 ncol <span class="operator">=</span> <span class="number">3</span><span class="punctuation">,</span> byrow <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br><span class="line">rcl_hh <span class="operator">=</span> rcl_women</span><br><span class="line">rcl <span class="operator">=</span> <span class="built_in">list</span><span class="punctuation">(</span>rcl_pop<span class="punctuation">,</span> rcl_women<span class="punctuation">,</span> rcl_age<span class="punctuation">,</span> rcl_hh<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>请注意，我们确保了列表中重新分类矩阵的顺序与 <code>input_ras</code> 的元素顺序相同。例如，第一个元素在两种情况下都对应于人口。随后，<code>for</code> 循环\index{loop!for} 将重新分类矩阵应用于相应的栅格图层。最后，下面的代码块确保 <code>reclass</code> 图层与 <code>input_ras</code> 的图层具有相同的名称。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">reclass <span class="operator">=</span> input_ras</span><br><span class="line"><span class="keyword">for</span> <span class="punctuation">(</span>i <span class="keyword">in</span> <span class="built_in">seq_len</span><span class="punctuation">(</span>terra<span class="operator">::</span>nlyr<span class="punctuation">(</span>reclass<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="punctuation">&#123;</span></span><br><span class="line">  reclass<span class="punctuation">[[</span>i<span class="punctuation">]</span><span class="punctuation">]</span> <span class="operator">=</span> terra<span class="operator">::</span>classify<span class="punctuation">(</span>x <span class="operator">=</span> reclass<span class="punctuation">[[</span>i<span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">,</span> rcl <span class="operator">=</span> rcl<span class="punctuation">[[</span>i<span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">,</span> right <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="built_in">names</span><span class="punctuation">(</span>reclass<span class="punctuation">)</span> <span class="operator">=</span> <span class="built_in">names</span><span class="punctuation">(</span>input_ras<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">reclass</span><br><span class="line"><span class="comment">#&gt; ... (full output not shown)</span></span><br><span class="line"><span class="comment">#&gt; names       :  pop, women, mean_age, hh_size </span></span><br><span class="line"><span class="comment">#&gt; min values  :  127,     0,        0,       0 </span></span><br><span class="line"><span class="comment">#&gt; max values  : 8000,     3,        3,       3</span></span><br></pre></td></tr></table></figure>
<h1>定义都市区</h1>
<p>我们特意将大都市区域定义为面积为20平方公里且居住人口超过500,000人的像素。在这种粗分辨率下，可以通过使用 <code>aggregate()</code>快速创建像素。下面的命令使用参数 <code>fact = 20</code> 将结果的分辨率降低了20倍（回想一下，原始栅格的分辨率是1平方公里）：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">pop_agg <span class="operator">=</span> terra<span class="operator">::</span>aggregate<span class="punctuation">(</span>reclass<span class="operator">$</span>pop<span class="punctuation">,</span> fact <span class="operator">=</span> <span class="number">20</span><span class="punctuation">,</span> fun <span class="operator">=</span> <span class="built_in">sum</span><span class="punctuation">,</span> na.rm <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br><span class="line">summary<span class="punctuation">(</span>pop_agg<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt;       pop         </span></span><br><span class="line"><span class="comment">#&gt;  Min.   :    127  </span></span><br><span class="line"><span class="comment">#&gt;  1st Qu.:  39886  </span></span><br><span class="line"><span class="comment">#&gt;  Median :  66008  </span></span><br><span class="line"><span class="comment">#&gt;  Mean   :  99503  </span></span><br><span class="line"><span class="comment">#&gt;  3rd Qu.: 105696  </span></span><br><span class="line"><span class="comment">#&gt;  Max.   :1204870  </span></span><br><span class="line"><span class="comment">#&gt;  NA&#x27;s   :447</span></span><br></pre></td></tr></table></figure>
<p>接下来的步骤是仅保留居住人口超过500,000人的单元格。您可以使用以下代码来实现：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">pop_agg <span class="operator">=</span> pop_agg<span class="punctuation">[</span>pop_agg <span class="operator">&gt;</span> <span class="number">500000</span><span class="punctuation">,</span> drop <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">]</span> </span><br></pre></td></tr></table></figure>
<p>绘制这些数据将显示出八个大都市区域。每个区域由一个或多个栅格单元组成。如果我们能够将属于同一区域的所有单元格连接起来，那将会很好。<strong>terra</strong> 的 <code>patches()</code> 命令正是这样的功能。随后，<code>as.polygons()</code> 将栅格对象转换为空间多边形，而 <code>st_as_sf()</code> 将其转换为 <code>sf</code> 对象。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">metros <span class="operator">=</span> pop_agg <span class="operator">|&gt;</span> </span><br><span class="line">  terra<span class="operator">::</span>patches<span class="punctuation">(</span>directions <span class="operator">=</span> <span class="number">8</span><span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">  terra<span class="operator">::</span>as.polygons<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">  sf<span class="operator">::</span>st_as_sf<span class="punctuation">(</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309051739055.png" alt=""><br>
The aggregated population raster (resolution: 20 km) with the identified metropolitan areas (golden polygons) and the corresponding names.</p>
<p>生成的八个适合自行车店的大都市区域；请参阅 <code>code/14-location-figures.R</code> 以创建图表）仍然缺少名称。逆地理编码方法可以解决这个问题：根据坐标找到对应的地址。因此，提取每个大都市区域的中心坐标可以作为逆地理编码API的输入。这正是 <strong>tmaptools</strong> 包中的 <code>rev_geocode_OSM()</code> 函数所期望的。此外，将 <code>as.data.frame</code> 设置为 <code>TRUE</code> 将返回一个包含多列关于位置的 <code>data.frame</code>，包括街道名称、门牌号和城市。然而，在这里，我们只关注城市的名称。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">metro_names <span class="operator">=</span> sf<span class="operator">::</span>st_centroid<span class="punctuation">(</span>metros<span class="punctuation">,</span> of_largest_polygon <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">  tmaptools<span class="operator">::</span>rev_geocode_OSM<span class="punctuation">(</span>as.data.frame <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">  select<span class="punctuation">(</span>city<span class="punctuation">,</span> town<span class="punctuation">,</span> state<span class="punctuation">)</span></span><br><span class="line"><span class="comment"># smaller cities are returned in column town. To have all names in one column,</span></span><br><span class="line"><span class="comment"># we move the town name to the city column in case it is NA</span></span><br><span class="line">metro_names <span class="operator">=</span> dplyr<span class="operator">::</span>mutate<span class="punctuation">(</span>metro_names<span class="punctuation">,</span> city <span class="operator">=</span> ifelse<span class="punctuation">(</span><span class="built_in">is.na</span><span class="punctuation">(</span>city<span class="punctuation">)</span><span class="punctuation">,</span> town<span class="punctuation">,</span> city<span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>为了确保读者使用完全相同的结果，我们已将它们存储在 <strong>spDataLarge</strong> 中，对象名称为 <code>metro_names</code>。</p>
<p>Table: Result of the reverse geocoding.</p>
<table>
<thead>
<tr>
<th style="text-align:left">city</th>
<th style="text-align:left">state</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Hamburg</td>
<td style="text-align:left">NA</td>
</tr>
<tr>
<td style="text-align:left">Berlin</td>
<td style="text-align:left">NA</td>
</tr>
<tr>
<td style="text-align:left">Velbert</td>
<td style="text-align:left">Nordrhein-Westfalen</td>
</tr>
<tr>
<td style="text-align:left">Leipzig</td>
<td style="text-align:left">Sachsen</td>
</tr>
<tr>
<td style="text-align:left">Frankfurt am Main</td>
<td style="text-align:left">Hessen</td>
</tr>
<tr>
<td style="text-align:left">Nürnberg</td>
<td style="text-align:left">Bayern</td>
</tr>
<tr>
<td style="text-align:left">Stuttgart</td>
<td style="text-align:left">Baden-Württemberg</td>
</tr>
<tr>
<td style="text-align:left">München</td>
<td style="text-align:left">Bayern</td>
</tr>
</tbody>
</table>
<p>总体而言，我们对 <code>city</code> 列作为大都市名称（上表）感到满意，除了一个例外，即属于杜塞尔多夫大区的费尔伯特。因此，我们将 Velbert 替换为 Düsseldorf（上图）。像 <code>ü</code> 这样的特殊字符可能会在后续的操作中引起问题，例如在使用 <code>opq()</code> 确定大都市区域的边界框时（请参见下面的内容），因此我们避免使用它们。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">metro_names <span class="operator">=</span> metro_names<span class="operator">$</span>city <span class="operator">|&gt;</span> </span><br><span class="line">  <span class="built_in">as.character</span><span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">  <span class="punctuation">&#123;</span><span class="punctuation">\</span><span class="punctuation">(</span>x<span class="punctuation">)</span> ifelse<span class="punctuation">(</span>x <span class="operator">==</span> <span class="string">&quot;Velbert&quot;</span><span class="punctuation">,</span> <span class="string">&quot;Düsseldorf&quot;</span><span class="punctuation">,</span> x<span class="punctuation">)</span><span class="punctuation">&#125;</span><span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">  <span class="punctuation">&#123;</span><span class="punctuation">\</span><span class="punctuation">(</span>x<span class="punctuation">)</span> gsub<span class="punctuation">(</span><span class="string">&quot;ü&quot;</span><span class="punctuation">,</span> <span class="string">&quot;ue&quot;</span><span class="punctuation">,</span> x<span class="punctuation">)</span><span class="punctuation">&#125;</span><span class="punctuation">(</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<h1>兴趣点</h1>
<p><strong>osmdata</strong>包提供了易于使用的访问OSM数据的方法。我们不是下载整个德国的商店数据，而是将查询限制在了定义好的大都市区域，以减少计算负担并且只获取感兴趣区域内的商店位置。下面的代码块使用了许多函数，包括：</p>
<ul>
<li><code>map()</code>（<strong>tidyverse</strong> 中的 <code>lapply()</code>等效函数），它遍历了八个大都市名称，随后在OSM\index{OpenStreetMap}查询函数 <code>opq()</code> 中定义了边界框。</li>
<li><code>add_osm_feature()</code> 用于指定带有键值为 <code>shop</code> 的OSM元素（请参阅 <a href="http://wiki.openstreetmap.org/wiki/Map_Features">wiki.openstreetmap.org</a> 以获取常见的键值对列表）。</li>
<li><code>osmdata_sf()</code> 将OSM数据转换为空间对象（<code>sf</code> 类）。</li>
<li><code>while()</code>，如果第一次下载失败，将重复尝试（在本例中为三次）。^[有时在第一次尝试下载OSM数据时可能会失败。]</li>
</ul>
<p>在运行此代码之前，请考虑它将下载近2GB的数据。为了节省时间和资源，我们已将名为 <code>shops</code> 的输出放入 <strong>spDataLarge</strong> 包中。要在您的环境中使用它，请运行 <code>data(&quot;shops&quot;, package = &quot;spDataLarge&quot;)</code>。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">shops <span class="operator">=</span> purrr<span class="operator">::</span>map<span class="punctuation">(</span>metro_names<span class="punctuation">,</span> <span class="keyword">function</span><span class="punctuation">(</span>x<span class="punctuation">)</span> <span class="punctuation">&#123;</span></span><br><span class="line">  message<span class="punctuation">(</span><span class="string">&quot;Downloading shops of: &quot;</span><span class="punctuation">,</span> x<span class="punctuation">,</span> <span class="string">&quot;\n&quot;</span><span class="punctuation">)</span></span><br><span class="line">  <span class="comment"># give the server a bit time</span></span><br><span class="line">  Sys.sleep<span class="punctuation">(</span>sample<span class="punctuation">(</span>seq<span class="punctuation">(</span><span class="number">5</span><span class="punctuation">,</span> <span class="number">10</span><span class="punctuation">,</span> <span class="number">0.1</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">  query <span class="operator">=</span> osmdata<span class="operator">::</span>opq<span class="punctuation">(</span>x<span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">    osmdata<span class="operator">::</span>add_osm_feature<span class="punctuation">(</span>key <span class="operator">=</span> <span class="string">&quot;shop&quot;</span><span class="punctuation">)</span></span><br><span class="line">  points <span class="operator">=</span> osmdata<span class="operator">::</span>osmdata_sf<span class="punctuation">(</span>query<span class="punctuation">)</span></span><br><span class="line">  <span class="comment"># request the same data again if nothing has been downloaded</span></span><br><span class="line">  iter <span class="operator">=</span> <span class="number">2</span></span><br><span class="line">  <span class="keyword">while</span> <span class="punctuation">(</span>nrow<span class="punctuation">(</span>points<span class="operator">$</span>osm_points<span class="punctuation">)</span> <span class="operator">==</span> <span class="number">0</span> <span class="operator">&amp;&amp;</span> iter <span class="operator">&gt;</span> <span class="number">0</span><span class="punctuation">)</span> <span class="punctuation">&#123;</span></span><br><span class="line">    points <span class="operator">=</span> osmdata_sf<span class="punctuation">(</span>query<span class="punctuation">)</span></span><br><span class="line">    iter <span class="operator">=</span> iter <span class="operator">-</span> <span class="number">1</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="comment"># return only the point features</span></span><br><span class="line">  points<span class="operator">$</span>osm_points</span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>在我们定义的任何大都市区域中几乎不可能没有商店。以下的 <code>if</code> 条件仅仅检查每个区域是否至少有一家商店。如果没有的话，我们建议尝试再次为该/这些特定区域下载商店数据。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># checking if we have downloaded shops for each metropolitan area</span></span><br><span class="line">ind <span class="operator">=</span> purrr<span class="operator">::</span>map_dbl<span class="punctuation">(</span>shops<span class="punctuation">,</span> nrow<span class="punctuation">)</span> <span class="operator">==</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> <span class="punctuation">(</span><span class="built_in">any</span><span class="punctuation">(</span>ind<span class="punctuation">)</span><span class="punctuation">)</span> <span class="punctuation">&#123;</span></span><br><span class="line">  message<span class="punctuation">(</span><span class="string">&quot;There are/is still (a) metropolitan area/s without any features:\n&quot;</span><span class="punctuation">,</span></span><br><span class="line">          paste<span class="punctuation">(</span>metro_names<span class="punctuation">[</span>ind<span class="punctuation">]</span><span class="punctuation">,</span> collapse <span class="operator">=</span> <span class="string">&quot;, &quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="string">&quot;\nPlease fix it!&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>为确保每个列表元素（一个 <code>sf</code> 数据框）具有相同的列^[这并不是一定的，因为OSM的贡献者在收集数据时并不总是一样仔细。]，我们只保留 <code>osm_id</code> 和 <code>shop</code> 列，使用 <code>map_dfr</code> 循环将所有商店合并为一个大的 <code>sf</code> 对象。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># select only specific columns</span></span><br><span class="line">shops <span class="operator">=</span> purrr<span class="operator">::</span>map_dfr<span class="punctuation">(</span>shops<span class="punctuation">,</span> select<span class="punctuation">,</span> osm_id<span class="punctuation">,</span> shop<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>注意：<code>shops</code> 已经在 <code>spDataLarge</code> 中提供，并且可以通过以下方式访问：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">data<span class="punctuation">(</span><span class="string">&quot;shops&quot;</span><span class="punctuation">,</span> package <span class="operator">=</span> <span class="string">&quot;spDataLarge&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>唯一剩下的任务是将空间点对象转换为栅格。<code>sf</code> 对象 <code>shops</code> 将被转换为一个栅格，其参数（维度、分辨率、CRS）与 <code>reclass</code> 对象相同。重要的是，在此处使用 <code>length()</code> 函数来计算每个单元格中的商店数量。</p>
<p>因此，下面的代码块的结果是商店密度的估计（商店/平方公里）。在使用 <code>rasterize()</code> 之前，使用 <code>st_transform()</code> 来确保两个输入的CRS匹配。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">shops <span class="operator">=</span> sf<span class="operator">::</span>st_transform<span class="punctuation">(</span>shops<span class="punctuation">,</span> st_crs<span class="punctuation">(</span>reclass<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># create poi raster</span></span><br><span class="line">poi <span class="operator">=</span> terra<span class="operator">::</span>rasterize<span class="punctuation">(</span>x <span class="operator">=</span> shops<span class="punctuation">,</span> y <span class="operator">=</span> reclass<span class="punctuation">,</span> field <span class="operator">=</span> <span class="string">&quot;osm_id&quot;</span><span class="punctuation">,</span> fun <span class="operator">=</span> <span class="string">&quot;length&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>与其他栅格图层（人口、女性、平均年龄、户籍人口）一样，<code>poi</code> 栅格也被重新分类为四个类别。在一定程度上，定义类别间隔是一个主观的任务。可以使用等距断点、分位数断点、固定值或其他方法。在这里，我们选择了费舍尔-詹金斯自然断点法，该方法最小化了类内方差，其结果为重新分类矩阵提供了一个输入。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># construct reclassification matrix</span></span><br><span class="line">int <span class="operator">=</span> classInt<span class="operator">::</span>classIntervals<span class="punctuation">(</span>terra<span class="operator">::</span>values<span class="punctuation">(</span>poi<span class="punctuation">)</span><span class="punctuation">,</span> n <span class="operator">=</span> <span class="number">4</span><span class="punctuation">,</span> style <span class="operator">=</span> <span class="string">&quot;fisher&quot;</span><span class="punctuation">)</span></span><br><span class="line">int <span class="operator">=</span> <span class="built_in">round</span><span class="punctuation">(</span>int<span class="operator">$</span>brks<span class="punctuation">)</span></span><br><span class="line">rcl_poi <span class="operator">=</span> matrix<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span>int<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="built_in">rep</span><span class="punctuation">(</span>int<span class="punctuation">[</span><span class="operator">-</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span> <span class="built_in">length</span><span class="punctuation">(</span>int<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">]</span><span class="punctuation">,</span> each <span class="operator">=</span> <span class="number">2</span><span class="punctuation">)</span><span class="punctuation">,</span> </span><br><span class="line">                   int<span class="punctuation">[</span><span class="built_in">length</span><span class="punctuation">(</span>int<span class="punctuation">)</span><span class="punctuation">]</span> <span class="operator">+</span> <span class="number">1</span><span class="punctuation">)</span><span class="punctuation">,</span> ncol <span class="operator">=</span> <span class="number">2</span><span class="punctuation">,</span> byrow <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br><span class="line">rcl_poi <span class="operator">=</span> cbind<span class="punctuation">(</span>rcl_poi<span class="punctuation">,</span> <span class="number">0</span><span class="operator">:</span><span class="number">3</span><span class="punctuation">)</span>  </span><br><span class="line"><span class="comment"># reclassify</span></span><br><span class="line">poi <span class="operator">=</span> terra<span class="operator">::</span>classify<span class="punctuation">(</span>poi<span class="punctuation">,</span> rcl <span class="operator">=</span> rcl_poi<span class="punctuation">,</span> right <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">)</span> </span><br><span class="line"><span class="built_in">names</span><span class="punctuation">(</span>poi<span class="punctuation">)</span> <span class="operator">=</span> <span class="string">&quot;poi&quot;</span></span><br></pre></td></tr></table></figure>
<h1>明确合适的位置</h1>
<p>在将所有图层组合在一起之前，只剩下几个步骤：将 <code>poi</code> 添加到 <code>reclass</code> 栅格堆叠中，并将人口图层从中移除。后者的原因有两点。首先，我们已经勾勒出了大都市区域，即人口密度高于德国其他地区平均水平的地区。其次，虽然在特定的服务区域内有许多潜在的顾客可能是有优势的，但仅仅数量本身可能并不真正代表所需的目标群体。例如，高层住宅区是人口密度较高的地区，但不一定具有购买昂贵自行车配件的高购买力。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># remove population raster and add poi raster</span></span><br><span class="line">reclass <span class="operator">=</span> reclass<span class="punctuation">[[</span><span class="built_in">names</span><span class="punctuation">(</span>reclass<span class="punctuation">)</span> <span class="operator">!=</span> <span class="string">&quot;pop&quot;</span><span class="punctuation">]</span><span class="punctuation">]</span> <span class="operator">|&gt;</span></span><br><span class="line">  <span class="built_in">c</span><span class="punctuation">(</span>poi<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>与其他数据科学项目一样，数据检索和“整理”在整个工作量中占据了很大一部分。有了干净的数据，最后一步——通过将所有栅格图层相加来计算最终得分——可以在一行代码中完成。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># calculate the total score</span></span><br><span class="line">result <span class="operator">=</span> <span class="built_in">sum</span><span class="punctuation">(</span>reclass<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>例如，得分大于9的分数可能是一个适当的阈值，表示可以放置自行车店的栅格单元格；请参阅 <code>code/14-location-figures.R</code>）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#&gt; The legacy packages maptools, rgdal, and rgeos, underpinning the sp package,</span><br><span class="line">#&gt; which was just loaded, will retire in October 2023.</span><br><span class="line">#&gt; Please refer to R-spatial evolution reports for details, especially</span><br><span class="line">#&gt; https://r-spatial.org/r/2023/05/15/evolution4.html.</span><br><span class="line">#&gt; It may be desirable to make the sf package available;</span><br><span class="line">#&gt; package maintainers should consider adding sf to Suggests:.</span><br><span class="line">#&gt; The sp package is now running under evolution status 2</span><br><span class="line">#&gt;      (status 2 uses the sf package in place of rgdal)</span><br></pre></td></tr></table></figure>
<div class="figure" style="text-align: center">
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;leaflet html-widget html-fill-item-overflow-hidden html-fill-item&quot; id=&quot;htmlwidget-841de324d41155df19a0&quot; style=&quot;width:100%;height:415.296px;&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;script type=&quot;application/json&quot; data-for=&quot;htmlwidget-841de324d41155df19a0&quot;&gt;&#123;&quot;x&quot;:&#123;&quot;options&quot;:&#123;&quot;crs&quot;:&#123;&quot;crsClass&quot;:&quot;L.CRS.EPSG3857&quot;,&quot;code&quot;:null,&quot;proj4def&quot;:null,&quot;projectedBounds&quot;:null,&quot;options&quot;:&#123;&#125;&#125;&#125;,&quot;calls&quot;:[&#123;&quot;method&quot;:&quot;addTiles&quot;,&quot;args&quot;:[&quot;https://&#123;s&#125;.tile.openstreetmap.org/&#123;z&#125;/&#123;x&#125;/&#123;y&#125;.png&quot;,null,null,&#123;&quot;minZoom&quot;:0,&quot;maxZoom&quot;:18,&quot;tileSize&quot;:256,&quot;subdomains&quot;:&quot;abc&quot;,&quot;errorTileUrl&quot;:&quot;&quot;,&quot;tms&quot;:false,&quot;noWrap&quot;:false,&quot;zoomOffset&quot;:0,&quot;zoomReverse&quot;:false,&quot;opacity&quot;:1,&quot;zIndex&quot;:1,&quot;detectRetina&quot;:false,&quot;attribution&quot;:&quot;&amp;copy; &lt;a href=\&quot;https://openstreetmap.org/copyright/\&quot;&gt;OpenStreetMap&lt;\/a&gt;,  &lt;a href=\&quot;https://opendatacommons.org/licenses/odbl/\&quot;&gt;ODbL&lt;\/a&gt;&quot;&#125;]&#125;,&#123;&quot;method&quot;:&quot;addRasterImage&quot;,&quot;args&quot;:[&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAoCAYAAACM/rhtAAAAM0lEQVRYhe3SMQ0AMAwEsQcb/hTSuQSaVLIR3HAJAADfqfR0wm1dEC9VevcCq+MAAIBhB20vBvBK3JZrAAAAAElFTkSuQmCC&quot;,[[52.69660085729196,13.08200261479863],[52.32107408861835,13.69815913809763]],0.8,null,null,null]&#125;,&#123;&quot;method&quot;:&quot;addLegend&quot;,&quot;args&quot;:[&#123;&quot;colors&quot;:[&quot;darkgreen&quot;],&quot;labels&quot;:[&quot;potential locations&quot;],&quot;na_color&quot;:null,&quot;na_label&quot;:&quot;NA&quot;,&quot;opacity&quot;:0.5,&quot;position&quot;:&quot;bottomright&quot;,&quot;type&quot;:&quot;unknown&quot;,&quot;title&quot;:&quot;Legend&quot;,&quot;extra&quot;:null,&quot;layerId&quot;:null,&quot;className&quot;:&quot;info legend&quot;,&quot;group&quot;:null&#125;]&#125;],&quot;limits&quot;:&#123;&quot;lat&quot;:[52.32107408861835,52.69660085729196],&quot;lng&quot;:[13.08200261479863,13.69815913809763]&#125;&#125;,&quot;evals&quot;:[],&quot;jsHooks&quot;:[]&#125;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p class="caption">Suitable areas (i.e., raster cells with a score > 9) in accordance with our hypothetical survey for bike stores in Berlin.</p>
</div>
<h1>讨论和下一步</h1>
<p>所呈现的方法是GIS的典型应用示例。我们将调查数据与基于专家知识和假设的方法相结合（定义大都市区域，定义类别间隔，定义最终得分阈值）。这种方法不如应用分析适用于科学研究，因为它可以提供基于证据的适合自行车店的区域，应该与其他信息来源进行比较。对方法的一些变更可以改进分析：</p>
<ul>
<li>在计算最终得分时，我们使用了相等的权重，但其他因素，如户籍人口，可能与女性比例或平均年龄一样重要。</li>
<li>我们使用了所有兴趣点，但只有与自行车店相关的兴趣点，如自行车店、五金店、自行车、钓鱼、狩猎、摩托车、户外和运动用品店（请参阅 <a href="http://wiki.openstreetmap.org/wiki/Map_Features#Shop">OSM Wiki</a> 上可用的店铺值范围）可能会产生更精细的结果。</li>
<li>更高分辨率的数据可能会改善输出（请参阅练习）。</li>
<li>我们仅使用了有限的变量集和来自其他来源的数据，如 <a href="http://inspire-geoportal.ec.europa.eu/discovery/">INSPIRE geoportal</a> 或来自 OpenStreetMap 的自行车路径数据，可以丰富分析。</li>
<li>未考虑交互作用，如男性比例和单身户之间可能存在的关系。</li>
</ul>
<p>简而言之，分析可以在多个方向上进行扩展。然而，它应该给您对如何在geomarketing背景下在R中获取和处理空间数据的第一印象和理解。</p>
<p>最后，我们必须指出，所呈现的分析仅仅是找到合适位置的第一步。到目前为止，我们已经确定了大小为1x1公里的区域，代表根据我们的调查可能适合自行车店的位置。分析的后续步骤可以是：</p>
<ul>
<li>基于特定服务区域内的居民数量找到最佳位置。例如，在骑自行车的15分钟行程范围内，店铺应该为尽可能多的人提供可达性（服务区域路由）。在此过程中，我们应该考虑到远离店铺的人越远，他们实际访问店铺的可能性就越小（距离衰减函数）。</li>
<li>此外，考虑竞争对手也是一个好主意。也就是说，如果已经有一家自行车店在所选位置附近，可能的顾客（或销售潜力）应该在竞争对手之间分配。</li>
<li>我们需要找到适合并且价格合理的房地产，例如在可访问性、停车位的可用性、过路人的期望频率、有大窗户等方面。</li>
</ul>
<h1>练习</h1>
<p>E1. 首先，您需要从提供的链接下载包含居民信息的CSV文件（以100米单元格分辨率）。请注意，解压缩后的文件大小为1.23 GB。您可以使用<code>readr::read_csv</code>将其读入R中。在具有16 GB RAM的机器上，这需要30秒钟。<code>data.table::fread()</code>可能会更快，它返回一个<code>data.table()</code>类的对象。使用<code>dplyr::as_tibble()</code>将其转换为tibble。构建一个居民栅格，将其聚合到1 km的单元格分辨率，并将其与我们使用类平均值创建的居民栅格（<code>inh</code>）进行比较。</p>
<p>E2. 假设我们的自行车店主要向老年人销售电动自行车。相应地更改年龄栅格，重复剩余的分析，并将更改与我们的原始结果进行比较。</p>
]]></content>
      <categories>
        <category>R</category>
        <category>Geocomputaion</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>Geocomputaion</tag>
      </tags>
  </entry>
  <entry>
    <title>(16)结论</title>
    <url>/2023/08/25/2023-8-25-16%E7%BB%93%E8%AE%BA/</url>
    <content><![CDATA[<blockquote><p>本文由SCY翻译自《Geocomputation with R》<a href="https://r.geocompx.org/conclusion">第十六章</a></p>
</blockquote>
<p>综合本书的内容，引用重复出现的主题/概念，并激发未来应用和发展的方向。本章不需要先修知识。然而，如果您已经阅读并尝试了第一部分（基础）中的练习，并考虑了地理计算如何帮助您解决工作、研究或其他问题，参考了第三部分（应用）中的章节，那么您可能会从中获得更多收益。</p>
<span id="more"></span>
<h1>引言</h1>
<p>与引言一样，这个结尾章节也包含了很少的代码块。其目的是综合本书的内容，引用重复出现的主题/概念，并激发未来应用和发展的方向。本章不需要先修知识。然而，如果您已经阅读并尝试了第一部分（基础）中的练习，并考虑了地理计算如何帮助您解决工作、研究或其他问题，参考了第三部分（应用）中的章节，那么您可能会从中获得更多收益。</p>
<p>本章的组织如下。<em>选择包</em>节讨论了在R中处理地理数据的各种选择。选择是开源软件的一个关键特性；本节提供了在不同选项之间进行选择的指导。<em>空缺</em>节描述了本书内容的不足之处，并解释了为什么一些研究领域被有意省略，而其他领域受到强调。这个讨论引出了一个问题（<em>下一步</em>节中得到解答）：在阅读了本书之后，下一步去哪里？<em>开源方法</em>节回到了<em>引言</em>章中提出的更广泛问题。在这一部分中，我们将地理计算视为更广泛的“开源方法”的一部分，确保方法是公开可访问、可复现并受到协作社区的支持。本书的最后一节还提供了一些参与的指导。</p>
<h1>选择包</h1>
<p>R以及开源软件的一个一般特点是，通常有多种方法可以实现相同的结果。下面的代码块通过使用三个函数，这些函数在<em>属性操作</em>和<em>几何操作</em>章中有介绍，将新西兰的16个地区合并为一个单一的几何图形：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>spData<span class="punctuation">)</span></span><br><span class="line">nz_u1 <span class="operator">=</span> sf<span class="operator">::</span>st_union<span class="punctuation">(</span>nz<span class="punctuation">)</span></span><br><span class="line">nz_u2 <span class="operator">=</span> aggregate<span class="punctuation">(</span>nz<span class="punctuation">[</span><span class="string">&quot;Population&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="built_in">list</span><span class="punctuation">(</span><span class="built_in">rep</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span> nrow<span class="punctuation">(</span>nz<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">sum</span><span class="punctuation">)</span></span><br><span class="line">nz_u3 <span class="operator">=</span> dplyr<span class="operator">::</span>summarise<span class="punctuation">(</span>nz<span class="punctuation">,</span> t <span class="operator">=</span> <span class="built_in">sum</span><span class="punctuation">(</span>Population<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">identical<span class="punctuation">(</span>nz_u1<span class="punctuation">,</span> nz_u2<span class="operator">$</span>geometry<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] TRUE</span></span><br><span class="line">identical<span class="punctuation">(</span>nz_u1<span class="punctuation">,</span> nz_u3<span class="operator">$</span>geom<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] TRUE</span></span><br></pre></td></tr></table></figure>
<p>虽然结果对象 <code>nz_u1</code> 到 <code>nz_u3</code> 的类、属性和列名不同，但它们的几何图形是相同的，可以通过使用基本的R函数 <code>identical()</code> 来验证。^[第一个操作由函数 <code>st_union()</code>\index{vector!union} 执行，创建了一个 <code>sfc</code> 类的对象（一个简单要素列）。后两个操作创建了 <code>sf</code> 对象，每个对象都<em>包含</em>一个简单要素列。因此，相同的是包含在简单要素列中的几何图形，而不是对象本身。]应该选择哪个呢？这取决于情况：前者仅处理包含在 <code>nz</code> 中的几何数据，因此速度更快，而其他选项执行了属性操作，这对于后续步骤可能有用。在使用基本的 R 函数 <code>aggregate()</code> 还是 <strong>dplyr</strong> 函数 <code>summarise()</code> 时，取决于个人偏好，后者在许多情况下更易读。</p>
<p>更重要的是，在R中处理地理数据时，通常有多种选择，甚至在单个包内也是如此。在考虑更多R包时，选择范围会进一步增加：例如，您可以使用较旧的 <strong>sp</strong> 包来实现相同的结果。然而，基于我们提供良好建议的目标，我们建议使用更近期、更高性能且未来可靠的 <strong>sf</strong> 包。在本书中展示的所有包都适用于同样的原则，尽管了解替代方案并能够为自己选择的软件进行合理的辩解可能会有所帮助（当不会分散注意力时）。</p>
<p>一个常见的选择，没有简单的答案，就是在地理计算中选择 <strong>tidyverse</strong>还是基本的R。例如，下面的代码块展示了在 <strong>tidyverse</strong> 和基本的R中从 <code>nz</code> 对象中提取 <code>Name</code> 列的方法，正如在<em>属性操作</em>章中描述的：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>dplyr<span class="punctuation">)</span>                          <span class="comment"># attach tidyverse package</span></span><br><span class="line">nz_name1 <span class="operator">=</span> nz<span class="punctuation">[</span><span class="string">&quot;Name&quot;</span><span class="punctuation">]</span>                   <span class="comment"># base R approach</span></span><br><span class="line">nz_name2 <span class="operator">=</span> nz <span class="operator">|&gt;</span>                        <span class="comment"># tidyverse approach</span></span><br><span class="line">  select<span class="punctuation">(</span>Name<span class="punctuation">)</span></span><br><span class="line">identical<span class="punctuation">(</span>nz_name1<span class="operator">$</span>Name<span class="punctuation">,</span> nz_name2<span class="operator">$</span>Name<span class="punctuation">)</span> <span class="comment"># check results</span></span><br><span class="line"><span class="comment">#&gt; [1] TRUE</span></span><br></pre></td></tr></table></figure>
<p>这引出了一个问题：该选择哪个呢？答案是：取决于情况。每种方法都有其优势：基本的 R 往往是稳定、众所周知的，且依赖性较小，因此在软件（包）开发中通常更受欢迎。另一方面，<strong>tidyverse</strong> 方法通常更适用于交互式编程。因此，在这两种方法之间做出选择是一种个人偏好和应用问题。</p>
<p>虽然本书涵盖了常常需要的函数，例如基本的 R <code>[</code> 子集运算符和上面代码块中演示的 <strong>dplyr</strong> 函数 <code>select()</code>，但还有许多其他用于处理地理数据的函数，来自其他包，尚未提及。<em>引言</em>章提到了适用于处理地理数据的 20 多个有影响力的包，但在本书中只涵盖了其中几个。数以百计的其他包可用于在 R 中处理地理数据，并且每年都有更多的包在不断发展。截至 2023 年中，Spatial <a href="https://cran.r-project.org/web/views/">Task View</a> 中提到的包超过 160 个，每年都会开发出无数用于地理数据分析的函数。</p>
<p>R 的空间生态系统的发展速度可能很快，但有许多策略可以处理多样的选择。我们的建议是从深入学习一种方法开始，但要对现有选项的<em>广度</em>有一个普遍的了解。这个建议同样适用于使用 R 解决地理问题，就像适用于其他领域的知识和应用一样。<em>下一步</em>章节涵盖了其他语言的发展。</p>
<p>当然，对于<em>相同</em>的任务，有些包的性能优于其他包，这种情况下了解哪个包更合适是很重要的。在本书中，我们的目标是专注于那些具有未来性（它们将在很长时间内工作）、高性能（相对于其他 R 包）的、得到很好维护的（拥有用户和开发者社区的支持）以及互补性的包。尽管我们使用的包存在重叠，就像在<em>高级制图</em>章中强调的制作地图的多样性包一样。</p>
<p>重叠的功能是有好处的。一个具有与现有包类似（但不完全相同）功能的新包可以增强韧性、性能（部分是由开发者之间的友好竞争和相互学习推动的）和选择性，这都是使用开源软件进行地理计算的关键优势。在这种情况下，决定使用 <strong>sf</strong>、<strong>tidyverse</strong>、<strong>terra</strong> 或其他包的组合应该是在了解替代方案的基础上做出的。例如，<strong>sf</strong> 旨在替代的 <strong>sp</strong> 生态系统可以执行本书中涵盖的许多操作，由于其年龄较长，许多其他包都在其基础上构建。截至 2023 年 5 月，463 个包 <code>Depend</code> 或 <code>Import</code> <strong>sp</strong>，略高于 2018 年的 452 个，显示其数据结构被广泛使用，并且在许多方向上得到了扩展。<strong>sf</strong> 的相应数字分别为 2018 年的 69 个和 2023 年的 431 个，这突显了该包具有未来性，拥有不断增长的用户群和开发者社区。尽管以点模式分析而闻名，<strong>spatstat</strong> 包也支持栅格\index{raster}和其他矢量几何，提供了强大的空间统计功能等。如果您的需求在已建立的包中无法满足，还值得研究正在开发中的新替代方案。</p>
<h1>空缺和重叠</h1>
<p>地理计算是一个庞大的领域，因此这本书中不可避免地有一些空白。我们进行了选择，故意强调某些主题、技术和包，同时省略了其他内容。我们试图强调在实际应用中最常需要的主题，例如地理数据操作、坐标参考系统的基础知识、读/写数据操作和可视化技术。有些主题和主题会反复出现，目的是建立地理计算的基础技能，并向您展示如何进一步深入更高级的主题和特定应用。</p>
<p>我们故意省略了一些在其他地方有深入讨论的主题。例如，空间数据的统计建模，如点模式分析、空间插值（克里金法）和空间回归，在<em>统计学习</em>章的机器学习背景下有提及，但没有详细介绍。关于这些方法已有优秀的资源，包括统计导向章节，以及关于点模式分析、应用于空间数据的贝叶斯技术，以及特定应用方面的书籍，如健康和<a href="https://bookdown.org/mcwimberly/gdswr-book/application---wildfire-severity-analysis.html">野火严重性分析</a>。受到有限关注的其他主题包括遥感以及使用R与（而不是作为桥接到）专用GIS软件。关于这些主题有很多资源，包括@wegmann_remote_2016和来自<a href="https://moc.online.uni-marburg.de/doku.php">马尔堡大学</a>的GIS相关教学材料。</p>
<p>在<em>统计学习</em>和<em>生态</em>章中，我们更关注机器学习而非空间统计推断，因为有关这个主题的高质量资源很多。这些资源包括@zuur_mixed_2009、@zuur_beginners_2017，它们专注于生态学用例，以及在<a href="http://www.css.cornell.edu/faculty/dgr2/teach/">css.cornell.edu/faculty/dgr2</a>托管的<em>Geostatistics &amp; Open-source Statistical Computing</em>的免费教学材料和代码。<a href="https://sdesabbata.github.io/r-for-geographic-data-science/"><em>R for Geographic Data Science</em></a>提供了R用于地理数据科学和建模的入门。</p>
<p>我们基本上没有涉及到’大数据’地理计算，也就是那些不适合在高配置笔记本上运行的数据集。这一决定是基于大多数用于常见研究或政策应用的地理数据集<em>确实</em>适合在消费级硬件上运行，大型高分辨率遥感数据集是一个值得注意的例外（参见<em>云服务</em>节）。您可以在计算机上增加更多RAM，或者暂时在像<a href="https://github.com/codespaces/new?hide_repo_select=true&amp;ref=main&amp;repo=84222786&amp;machine=basicLinux32gb&amp;devcontainer_path=.devcontainer.json&amp;location=WestEurope">GitHub Codespaces这样的平台上</a>“租用”计算能力，以运行本书中的代码。此外，学习如何在小数据集上解决问题是解决大数据集问题的先决条件，本书的重点是入门，您在这里学到的技能在您转向更大的数据集时也将是有用的。'大数据’分析通常涉及从数据库中提取少量数据进行特定的统计分析。<em>GIS</em>章涵盖的空间数据库可以帮助分析不适合在内存中运行的数据集。'地球观测云后端’可以通过<strong>openeo</strong>包从R中访问，如<a href="https://openeo.org/">openeo.org</a>网站所述。如果您需要处理大型地理数据集，我们建议探索像<a href="https://sedona.apache.org/">Apache Sedona</a>这样的项目以及新兴的文件格式，如<a href="https://paleolimbot.github.io/geoarrow/">GeoParquet</a>。</p>
<h1>获取帮助</h1>
<!-- 现在我在思考这应该是一个附录，还是甚至应该是一个新的章节？-->
<!-- 在章节*引言*中，我们指出本书主张的方法“可以帮助你去除软件对你创造力的限制”。-->
<!-- 我们已经涵盖了许多技巧，这些应该能让你将很多创意转化为可复制和可扩展的代码，用于研究和应用地理计算。 -->
<!-- 然而，创造力涉及到提出*新的*想法，这些还没有被实施，这就提出了一个问题：当软件*确实*因为你不确定如何实施你的创意而产生限制时，会发生什么？-->
<!-- 在章节*引言*中，我们明确了我们的目标，即提供坚实的基础，以便可以在此基础上进行广泛的数据分析、研究以及方法论和软件开发项目。-->
<!-- 地理计算不仅仅是关于使用现有技术，而且是关于开发新工具，这涉及到生成新知识。 -->
<p>地理计算是一个庞大而具有挑战性的领域，几乎不可避免地会出现问题和暂时的工作障碍。在许多情况下，你可能会在数据分析流程的某个特定点“卡住”，面对难以调试的神秘错误信息。或者你可能会得到意外的结果，却鲜有线索来了解发生了什么。本节提供了一些指导，以帮助你通过明确地定义问题、搜索现有解决方案的知识，以及（如果这些方法没有解决问题）通过提出好问题来克服这些问题。</p>
<!-- 通过与社群的互动生成新的公开知识。 -->
<p>当你在某一特定点遇到困难时，首先值得退一步思考哪种方法最有可能解决这个问题。尝试以下列出的步骤——跳过已经尝试过的步骤——提供了一种结构化的问题解决方法：</p>
<ol>
<li>确切地定义你试图实现的目标，从最基本的原则开始（通常如下所述，从一个草图开始）</li>
<li>通过运行和探索代码的单独行及其各个组件的输出，确切地诊断出代码中哪里出现了意外的结果（例如，在RStudio中，你可以通过用光标选择它们并按Ctrl+Enter来运行复杂命令的单个部分）</li>
<li>阅读在上一步被诊断为‘失败点’的函数的文档。仅仅通过了解函数所需的输入，以及运行通常在帮助页面底部提供的示例，就可以解决相当大比例的问题（例如，运行命令 <code>?terra::rast</code> 并向下滚动到值得在开始使用该函数时复制的示例）</li>
<li>如果阅读R内置的文档，如上一步所述，没有帮助解决问题，那么可能是时候在网上进行更广泛的搜索，看看是否有其他人写过你所遇到的问题。以下列出了寻找帮助的地方</li>
<li>如果上面所有的步骤都失败了，并且你从在线搜索中也找不到解决方案，那么可能是时候用一个可复现的示例来组织一个问题，并在适当的地方发布了</li>
</ol>
<p>以上概述的1到3步相对容易理解，但由于互联网的广阔和多种多样的搜索选项，值得在决定提出问题之前考虑有效的搜索策略。</p>
<h2 id="在线搜索解决方案">在线搜索解决方案</h2>
<p>搜索引擎是解决许多问题的合理起点。'Google一下’在某些情况下可能会发现关于你所遇到的确切问题的博客文章、论坛消息和其他在线内容。在这里简单地输入问题/问题的清晰描述是一个有效的方法，但重要的是要具体（例如，如果问题特定于数据集，则参考函数和软件包名称以及输入数据集来源）。您还可以通过包括额外的细节来提高在线搜索的效果：</p>
<!-- 为了提供一个具体的例子，假设你想知道如何在交互式地图中使用自定义符号。 -->
<ul>
<li>使用引号来最大化与您所遇到的确切问题有关的“命中”的机会，从而减少返回的结果数量。例如，如果你尝试并未能在已存在的位置保存一个GeoJSON文件，你会收到一个包含&quot;GDAL Error 6: DeleteLayer() not supported by this dataset&quot;的错误消息。具体的搜索查询，如<code>&quot;GDAL Error 6&quot; sf</code>，比不带引号的<code>GDAL Error 6</code>更有可能找到一个解决方案。</li>
<li>设置<a href="https://uk.pcmag.com/software-services/138320/21-google-search-tips-youll-want-to-learn">时间限制</a>，例如，仅返回在过去一年内创建的内容，在搜索关于不断演变的软件包的帮助时可能很有用。</li>
<li>利用额外的<a href="https://www.makeuseof.com/tag/6-ways-to-search-by-date-on-google/">搜索引擎功能</a>，例如限制搜索内容只来自CRAN，使用site:r-project.org。</li>
</ul>
<h2 id="寻找（和提问）帮助的地方">寻找（和提问）帮助的地方</h2>
<p>在在线搜索没有找到解决方案的情况下，值得寻求帮助。有很多论坛可以做到这一点，包括：</p>
<ul>
<li>R地理数据特别兴趣组邮件列表（<a href="https://stat.ethz.ch/mailman/listinfo/r-sig-geo">R-SIG-GEO</a>）</li>
<li>GIS Stackexchange网站 <a href="https://gis.stackexchange.com/">gis.stackexchange.com</a></li>
<li>大型和通用编程问答网站 <a href="https://stackoverflow.com/">stackoverflow.com</a></li>
<li>与特定实体关联的在线论坛，例如 <a href="https://community.rstudio.com/">RStudio Community</a>，<a href="https://discuss.ropensci.org/">rOpenSci Discuss</a>网络论坛，以及与特定软件工具关联的论坛，例如 <a href="https://discourse.mc-stan.org/">Stan</a> 论坛</li>
<li>软件开发平台，如GitHub，它托管了大多数R-空间软件包的问题跟踪器，而且越来越多地有内置的讨论页面，例如为了鼓励围绕 <strong>sfnetworks</strong> 软件包（参见 <a href="https://github.com/luukvdmeer/sfnetworks/discussions/">luukvdmeer/sfnetworks/discussions</a>）的讨论（而不仅仅是报告bug）而创建的。</li>
<li>与如 <a href="https://ropensci.org/blog/2022/09/13/contributing-ropensci/">rOpenSci</a> 和 <a href="https://geocompx.org">geocompx</a> 社区（该社区有一个 <a href="https://discord.gg/PMztXYgNxp">Discord 服务器</a>，您可以在那里提问）相关联的在线聊天室和论坛，这本书也是其中的一部分。</li>
</ul>
<h2 id="使用-reprex-创建可复现的示例">使用 <strong>reprex</strong> 创建可复现的示例</h2>
<p>在提出一个好问题方面，一个明确陈述的问题并由一个易于获取和完全可复现的示例支持是关键（也可参见 <a href="https://r4ds.hadley.nz/workflow-help.html%EF%BC%89%E3%80%82%E5%9C%A8%E5%B1%95%E7%A4%BA%E4%BA%86%E4%BB%8E%E7%94%A8%E6%88%B7%E8%A7%92%E5%BA%A6%E7%9C%8B%E2%80%9C%E4%B8%8D%E8%B5%B7%E4%BD%9C%E7%94%A8%E2%80%9D%E7%9A%84%E4%BB%A3%E7%A0%81%E5%90%8E%EF%BC%8C%E8%A7%A3%E9%87%8A%E6%82%A8%E5%B8%8C%E6%9C%9B%E7%9C%8B%E5%88%B0%E4%BB%80%E4%B9%88%E4%B9%9F%E6%98%AF%E6%9C%89%E5%B8%AE%E5%8A%A9%E7%9A%84%E3%80%82%E7%94%A8%E4%BA%8E%E5%88%9B%E5%BB%BA%E5%8F%AF%E5%A4%8D%E7%8E%B0%E7%A4%BA%E4%BE%8B%E7%9A%84%E4%B8%80%E4%B8%AA%E9%9D%9E%E5%B8%B8%E6%9C%89%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7%E6%98%AF">https://r4ds.hadley.nz/workflow-help.html）。在展示了从用户角度看“不起作用”的代码后，解释您希望看到什么也是有帮助的。用于创建可复现示例的一个非常有用的工具是</a> <strong>reprex</strong> 包。要突出显示意外行为，您可以编写完全可复现的代码来演示问题，然后使用 <code>reprex()</code> 函数创建一个可以粘贴到论坛或其他在线空间的代码副本。</p>
<p>假设你正试图用蓝色的海和绿色的陆地创建一个世界地图。您可以简单地在上一节中概述的某个地方询问如何做到这一点。然而，如果您提供了到目前为止您尝试的可复现示例，您很可能会得到更好的回应。以下代码创建了一个带有蓝色海洋和绿色陆地的世界地图，但陆地没有填充：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>sf<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>spData<span class="punctuation">)</span></span><br><span class="line">plot<span class="punctuation">(</span>st_geometry<span class="punctuation">(</span>world<span class="punctuation">)</span><span class="punctuation">,</span> col <span class="operator">=</span> <span class="string">&quot;green&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>如果您在论坛上发布了这段代码，您很可能会得到更具体和有用的回应。例如，有人可能会用以下代码作为回应，这段代码可以明显地解决问题，如下图所示：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>sf<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>spData<span class="punctuation">)</span></span><br><span class="line"><span class="comment"># use the bg argument to fill in the land</span></span><br><span class="line">plot<span class="punctuation">(</span>st_geometry<span class="punctuation">(</span>world<span class="punctuation">)</span><span class="punctuation">,</span> col <span class="operator">=</span> <span class="string">&quot;green&quot;</span><span class="punctuation">,</span> bg <span class="operator">=</span> <span class="string">&quot;lightblue&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309051851873.png" alt=""><br>
A map of the world with green land, illustrating a question with a reproducible example (left) and the solution (right).</p>
<p>给读者的练习：复制上面的代码，运行命令 <code>reprex::reprex()</code>（或将命令粘贴到 <code>reprex()</code> 函数调用中），并将输出粘贴到论坛或其他在线空间。</p>
<p>地理计算的开源和协作方法的一个优点是它们生成了一个庞大且不断发展的知识体系，本书就是其中的一部分。展示你自己解决问题的努力，并提供问题的可复现示例，是对这一知识体系做出贡献的一种方式。</p>
<h2 id="定义和草绘问题">定义和草绘问题</h2>
<p>在某些情况下，您可能无法在线找到解决问题的方案，或者您可能无法构建一个可以通过搜索引擎回答的问题。在这种情况下，或者在开发新的地理计算方法时，最好的起点可能是一支笔和一张纸（或相当于数字草图工具，如 <a href="https://excalidraw.com/">Excalidraw</a> 和 <a href="https://www.tldraw.com/">tldraw</a>，它们允许协作式草图和快速分享思想）。在方法开发工作的最具创造性的早期阶段，<em>任何类型</em>的软件都可能减缓您的思维速度，并使您的思考偏离重要的抽象思想。强烈推荐用数学来构建问题，并参考一个您可以数字化地草绘“前后”版本的最小示例。如果您具备相关技能并且问题需要这样做，用代数方式描述方法在某些情况下可能有助于开发有效的实现。</p>
<h2 id="接下来何去何从？">接下来何去何从？</h2>
<p>正如<em>空缺</em>节所指出的，本书仅涵盖了R地理生态系统的一部分，还有更多需要发现的内容。我们已经迅速前进，从<em>空间数据</em>章的地理数据模型到<em>生态</em>章的高级应用。建议的未来方向是巩固所学技能，发现用于处理地理数据的新包和方法，并将这些方法应用于新数据集和领域。本节通过提出以下<strong>粗体</strong>突出显示的具体“下一步”来扩展这一通用建议。</p>
<p>除了通过参考前一节中引用的作品来进一步了解R中的地理方法和应用外，加深对 <strong>R本身</strong> 的理解是一个合乎逻辑的下一步。R的基础类，如 <code>data.frame</code> 和 <code>matrix</code>，是 <code>sf</code> 和 <code>raster</code> 类的基础，因此学习它们将提高您对地理数据的理解。这可以通过参考R的一部分文档来完成，这些文档可以通过 <code>help.start()</code> 命令以及 @wickham_advanced_2019 和 @chambers_extending_2016 等主题的其他资源来找到。</p>
<p>未来学习的另一个与软件相关的方向是 <strong>用其他语言发现地理计算</strong>。学习R作为地理计算的语言有很好的理由，如<em>引言</em>章所述，但这不是唯一的选项。例如，<a href="https://github.com/mapbox/rasterio"><strong>rasterio</strong></a> 是一个具有与本书中使用的 <strong>terra</strong> 包类似功能的Python包。参见 <a href="https://py.geocompx.org/"><em>Geocomputation with Python</em></a>，以了解用Python进行地理计算的介绍。</p>
<p>数十个地理空间库已经用C++开发出来，包括众所周知的库，如GDAL和GEOS，以及不太为人知的库，如用于处理遥感（栅格）数据的**<a href="https://github.com/orfeotoolbox/OTB">Orfeo Toolbox</a>**。<a href="https://github.com/Turfjs/turf"><strong>Turf.js</strong></a> 是用JavaScript进行地理计算潜力的一个例子。<a href="https://geotrellis.io/">GeoTrellis</a> 提供了用基于Java的语言Scala处理栅格和矢量数据的函数。<a href="https://github.com/jblindsay/whitebox-tools">WhiteBoxTools</a> 是用Rust实现的快速发展的命令行GIS的一个例子。这些包/库/语言各有其地理计算的优点，还有更多等待你去发现，如在开源地理空间资源的策划列表 <a href="https://github.com/sacridini/Awesome-Geospatial">Awesome-Geospatial</a> 中有文档。</p>
<p>然而，地理计算不仅仅是软件。我们推荐<strong>探索和学习新的研究主题和方法</strong>，从学术和理论的角度出发。许多已经被写过的方法尚未实施。因此，在编写任何代码之前，了解地理方法和潜在的应用可能是有益的。一个地理方法越来越多地在R中实现的例子是用于科学应用的抽样策略。接下来的一步是阅读该领域的相关文章，如@brus_sampling_2018，它附带有可复制的代码和存放在<a href="https://github.com/DickBrus/TutorialSampling4DSM">github.com/DickBrus/TutorialSampling4DSM</a> 的教程内容。</p>
<h1>开源方法</h1>
<p>这是一本技术性的书，因此在前一节中概述的下一步也应是技术性的。然而，在这最后一节中，还有更广泛的问题值得考虑，这将回到我们对地理计算的定义。在<em>引言</em>章介绍的术语元素之一是地理方法应具有积极的影响。当然，如何定义和衡量’积极’是一个主观的、哲学的问题，超出了本书的范围。不论你的世界观如何，考虑地理计算工作的影响是一个有用的练习：积极影响的潜力可以为未来的学习提供强有力的动力，相反地，新方法可以开放许多可能的应用领域。这些考虑导致了一个结论：地理计算是更广泛的“开源方法”的一部分。</p>
<p><em>什么是地理计算</em>节介绍了与地理计算大致意义相同的其他术语，包括地理数据科学（GDS）和’GIScience’。两者都捕捉到了使用地理数据的实质，但地理计算有优势：它简洁地捕捉到了这本书所倡导的用地理数据进行’计算’的工作方式——在代码中实现，因此鼓励可重复性——并基于其早期定义的有益成分：</p>
<ul>
<li>地理数据的<em>创造性</em>使用</li>
<li>应用于<em>实际问题</em></li>
<li>构建’科学’工具</li>
<li>可重复性</li>
</ul>
<p>我们增加了最后一个成分：早期关于地理计算的工作几乎没有提到可重复性，但可以为它是前两个成分的重要组成部分提出有力的理由。可重复性</p>
<ul>
<li>通过将焦点从基础（通过共享代码容易获得）转向应用，鼓励<em>创造性</em>；</li>
<li>阻止人们’重复造轮子’：如果其他人的方法可以被其他人使用，就没有必要重新做；</li>
<li>使研究更有利于实际应用，通过使任何行业的任何人都能在新的领域应用你的方法。</li>
</ul>
<p>如果可重复性是地理计算（或命令行GIS）的定义资产，那么值得考虑的是什么使它可重复。<br>
这引导我们到’开源方法’，它有三个主要组成部分：</p>
<ul>
<li>命令行界面（CLI），鼓励分享和重现地理工作的脚本</li>
<li>开源软件，可以被世界上的任何人检查和可能改进</li>
<li>一个活跃的开发者社区，合作和自组织来构建互补和模块化的工具</li>
</ul>
<p>像地理计算这个术语一样，开源方法不仅仅是一个技术实体。它是一个由人组成的社群，每天都在与共享目标进行互动：生产高性能的工具，没有商业或法律限制，任何人都可以使用。与地理数据一起工作的开源方法具有超越软件工作技术性的优点，鼓励学习、合作和劳动力的有效划分。</p>
<p>有很多方式可以参与这个社群，尤其是随着代码托管网站（如GitHub）的出现，这些网站鼓励沟通和合作。一个好的开始就是简单地浏览一些感兴趣的地理包的源代码、‘问题’和’提交’。在<code>r-spatial/sf</code> GitHub仓库快速查看，该仓库托管了<strong>sf</strong>包的底层代码，显示有100+人对代码库和文档做出了贡献。更多人通过提问和对<strong>sf</strong>使用的’上游’包做出贡献。在其<a href="https://github.com/r-spatial/sf/issues">问题追踪器</a>上已经关闭了超过1,600个问题，代表了大量的工作，使<strong>sf</strong>更快、更稳定和用户友好。这个例子，仅仅是数十个包中的一个，显示了为使R成为一个高效且不断发展的地理计算语言所进行的知识操作的规模。</p>
<p>观察公共论坛（如GitHub）上不断发展的开发活动是有教育意义的，但成为一个活跃的参与者更加有益。这是开源方法的最大特点之一：它鼓励人们参与。这本书本身就是开源方法的一个结果：它是由R在过去二十年里地理能力的惊人发展所激发的，但是通过对合作平台上的对话和代码共享而实际可能。我们希望，除了传播与地理数据一起工作的有用方法外，这本书还能激励你采取更开源的方法。</p>
]]></content>
      <categories>
        <category>R</category>
        <category>Geocomputaion</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>Geocomputaion</tag>
      </tags>
  </entry>
  <entry>
    <title>(17)栅格数据处理技巧</title>
    <url>/2023/09/24/2023-9-24-17%E6%A0%85%E6%A0%BC%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<blockquote><p>本文由SCY原创，转载注明出处。</p>
</blockquote>
<p>本文主要讲解<code>R</code>的<code>terra</code>包的使用技巧，包括数据导入，批量处理，绘图，导出等内容</p>
<span id="more"></span>
<h1>数据导入</h1>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>terra<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<h1>对SpatRaster的每个单元格应用函数</h1>
<p>描述：对<code>SpatRaster</code>的每个<strong>单元格</strong>的值应用<strong>函数</strong>。类似于<code>apply</code>函数，可以将<code>SpatRaster</code>中的每个图层看作是矩阵中的列（或行）。</p>
<p>通常用于将多个图层的值汇总到一个图层中，但也不必。</p>
<p><code>app</code>调用函数<code>fun</code>，并将栅格数据作为第一个参数。根据提供的函数，栅格数据表示为矩阵，其中每个图层都是一列，或表示单元格的向量。函数应返回可被<code>ncell(x)</code>整除的向量或矩阵。因此，可以使用<code>sum</code>和<code>rowSums</code>，但不能使用<code>colSums</code>。</p>
<p>还可以通过<code>SpatRasterDataset</code>的图层应用函数<code>fun</code>跨数据集。在这种情况下，汇按图层汇总<code>SpatRasters</code>。</p>
<p>用法：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">## &#x27;SpatRaster&#x27;</span></span><br><span class="line">app<span class="punctuation">(</span>x<span class="punctuation">,</span> fun<span class="punctuation">,</span> ...<span class="punctuation">,</span> cores<span class="operator">=</span><span class="number">1</span><span class="punctuation">,</span> filename<span class="operator">=</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span> overwrite<span class="operator">=</span><span class="literal">FALSE</span><span class="punctuation">,</span> wopt<span class="operator">=</span><span class="built_in">list</span><span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## &#x27;SpatRasterDataset&#x27;</span></span><br><span class="line">app<span class="punctuation">(</span>x<span class="punctuation">,</span> fun<span class="punctuation">,</span> ...<span class="punctuation">,</span> cores<span class="operator">=</span><span class="number">1</span><span class="punctuation">,</span> filename<span class="operator">=</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span> overwrite<span class="operator">=</span><span class="literal">FALSE</span><span class="punctuation">,</span> wopt<span class="operator">=</span><span class="built_in">list</span><span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>参数：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">x       <span class="comment"># SpatRaster或SpatRasterDataset</span></span><br><span class="line"></span><br><span class="line">fun     <span class="comment"># 对向量或矩阵操作的函数。这可以是在基本R或包中定义的函数，也可以是您自己编写的函数（请参阅示例）。返回复杂输出（例如列表）的函数可能需要包装在自己的函数中，以将输出简化为向量或矩阵。以下函数已经以C++重新实现以提高速度：`sum`、`mean`、`median`、`modal`、`which`、`which.min`、`which.max`、`min`、`max`、`prod`、`any`、`all`、`sd`、`std`、`first`。要使用基本R函数，例如“min”，您可以使用类似于fun=function(i) min(i)的方式，或等价的fun = \(i) min(i)</span></span><br><span class="line"></span><br><span class="line">...     <span class="comment"># fun的其他参数。通常是数值常数。绝对不应该是另一个SpatRaster。</span></span><br><span class="line"></span><br><span class="line">cores   <span class="comment"># 正整数。如果cores &gt; 1，则创建并使用具有指定核心数的&#x27;parallel&#x27;包集群。您还可以提供集群对象。对于由terra在C++中实现的函数（请参见fun下面的部分），此参数将被忽略。</span></span><br><span class="line"></span><br><span class="line">filename    <span class="comment"># 字符。输出文件名</span></span><br><span class="line"></span><br><span class="line">overwrite   <span class="comment"># 逻辑值。如果为TRUE，则覆盖filename</span></span><br><span class="line"></span><br><span class="line">wopt        <span class="comment"># 具有命名选项的列表，用于写文件，就像在writeRaster中一样</span></span><br></pre></td></tr></table></figure>
<p>详情：<br>
为了加快速度，支持并行运算，但这没什么帮助，实际上可能会更慢。只有当您拥有许多核心（&gt; 8）或非常复杂（慢）的<code>fun</code>函数时，才会有速度增益。如果您自己编写fun，请考虑提供一个使用<code>Rcpp</code>包制作的<code>cppFunction</code>，而不是手动编写<code>fun</code>。</p>
<p>值：<br>
SpatRaster</p>
<p>另请参阅：<br>
lapp、tapp、Math-methods、roll</p>
<p>示例：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">r <span class="operator">&lt;-</span> rast<span class="punctuation">(</span>ncols<span class="operator">=</span><span class="number">10</span><span class="punctuation">,</span> nrows<span class="operator">=</span><span class="number">10</span><span class="punctuation">)</span></span><br><span class="line">values<span class="punctuation">(</span>r<span class="punctuation">)</span> <span class="operator">&lt;-</span> <span class="number">1</span><span class="operator">:</span>ncell<span class="punctuation">(</span>r<span class="punctuation">)</span></span><br><span class="line">x <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span>r<span class="punctuation">,</span> <span class="built_in">sqrt</span><span class="punctuation">(</span>r<span class="punctuation">)</span><span class="punctuation">,</span> r<span class="operator">+</span><span class="number">50</span><span class="punctuation">)</span></span><br><span class="line">s <span class="operator">&lt;-</span> app<span class="punctuation">(</span>x<span class="punctuation">,</span> fun<span class="operator">=</span><span class="built_in">sum</span><span class="punctuation">)</span></span><br><span class="line">s</span><br><span class="line"><span class="comment"># 对于一些通用函数，如</span></span><br><span class="line"><span class="comment"># &quot;sum&quot;、&quot;mean&quot;和&quot;max&quot;，您还可以这样做</span></span><br><span class="line"><span class="built_in">sum</span><span class="punctuation">(</span>x<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## SpatRasterDataset</span></span><br><span class="line">sd <span class="operator">&lt;-</span> sds<span class="punctuation">(</span>x<span class="punctuation">,</span> x<span class="operator">*</span><span class="number">2</span><span class="punctuation">,</span> x<span class="operator">/</span><span class="number">3</span><span class="punctuation">)</span></span><br><span class="line">a <span class="operator">&lt;-</span> app<span class="punctuation">(</span>sd<span class="punctuation">,</span> <span class="built_in">max</span><span class="punctuation">)</span></span><br><span class="line">a</span><br><span class="line"><span class="comment"># 与下面一样</span></span><br><span class="line"><span class="built_in">max</span><span class="punctuation">(</span>x<span class="punctuation">,</span> x<span class="operator">*</span><span class="number">2</span><span class="punctuation">,</span> x<span class="operator">/</span><span class="number">3</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 也与下面一样（但较慢）</span></span><br><span class="line">b <span class="operator">&lt;-</span> app<span class="punctuation">(</span>sd<span class="punctuation">,</span> <span class="keyword">function</span><span class="punctuation">(</span>i<span class="punctuation">)</span> <span class="built_in">max</span><span class="punctuation">(</span>i<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 还适用于单个图层</span></span><br><span class="line">f <span class="operator">&lt;-</span> <span class="keyword">function</span><span class="punctuation">(</span>i<span class="punctuation">)</span> <span class="punctuation">(</span>i<span class="operator">+</span><span class="number">1</span><span class="punctuation">)</span> <span class="operator">*</span> <span class="number">2</span> <span class="operator">*</span> i <span class="operator">+</span> <span class="built_in">sqrt</span><span class="punctuation">(</span>i<span class="punctuation">)</span></span><br><span class="line">s <span class="operator">&lt;-</span> app<span class="punctuation">(</span>r<span class="punctuation">,</span> f<span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 与上面相同，但内存不安全</span></span><br><span class="line"><span class="comment"># 并且没有filename参数</span></span><br><span class="line">s <span class="operator">&lt;-</span> f<span class="punctuation">(</span>r<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Not run: </span></span><br><span class="line"><span class="comment">#### 多核心</span></span><br><span class="line">test0 <span class="operator">&lt;-</span> app<span class="punctuation">(</span>x<span class="punctuation">,</span> <span class="built_in">sqrt</span><span class="punctuation">)</span> </span><br><span class="line">test1 <span class="operator">&lt;-</span> app<span class="punctuation">(</span>x<span class="punctuation">,</span> <span class="built_in">sqrt</span><span class="punctuation">,</span> cores<span class="operator">=</span><span class="number">2</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">testfun <span class="operator">&lt;-</span> <span class="keyword">function</span><span class="punctuation">(</span>i<span class="punctuation">)</span> <span class="punctuation">&#123;</span> <span class="number">2</span> <span class="operator">*</span> <span class="built_in">sqrt</span><span class="punctuation">(</span>i<span class="punctuation">)</span> <span class="punctuation">&#125;</span></span><br><span class="line">test2 <span class="operator">&lt;-</span> app<span class="punctuation">(</span>x<span class="punctuation">,</span> fun<span class="operator">=</span>testfun<span class="punctuation">,</span> cores <span class="operator">=</span><span class="number">2</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 这会失败，因为testfun未导出到节点</span></span><br><span class="line"><span class="comment"># test3 &lt;- app(x, fun=function(i) testfun(i), cores=2)</span></span><br><span class="line"><span class="comment">## 要导出它，请将其作为参数添加到fun中</span></span><br><span class="line">test3 <span class="operator">&lt;-</span> app<span class="punctuation">(</span>x<span class="punctuation">,</span> fun<span class="operator">=</span><span class="keyword">function</span><span class="punctuation">(</span>i<span class="punctuation">,</span> ff<span class="punctuation">)</span> ff<span class="punctuation">(</span>i<span class="punctuation">)</span><span class="punctuation">,</span> cores <span class="operator">=</span><span class="number">3</span><span class="punctuation">,</span> ff<span class="operator">=</span>testfun<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## End(Not run)</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>R</category>
        <category>Geocomputaion</category>
        <category>Raster</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>Geocomputaion</tag>
        <tag>Raster</tag>
      </tags>
  </entry>
  <entry>
    <title>(18)ggplot2学习笔记</title>
    <url>/2023/09/26/2023-9-26-18ggplot2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<blockquote><p>本文由SCY原创，转载注明出处。</p>
</blockquote>
<p>本文主要讲解ggplot2包的绘图原理及案例。</p>
<span id="more"></span>
<h1>ggplot2学习笔记</h1>
<p>ggplot2是基于图层图形语法（the Grammar of Graphics），可简单粗暴的理解为，先绘制好图形的每一部分，然后将各部分相加形成一张完善的图形，使用ggplot2时，会反复使用如下几个对象，简单介绍：</p>
<ol>
<li><strong>几何对象</strong>（<strong>geom</strong>） geometric objects，如散点points、<br>
线性lines、柱状bars及方图Histogram等，可绘制的geom为：</li>
</ol>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>tidyverse<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>ggplot2<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>patchwork<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<ol>
<li>
<p><strong>标度</strong>（<strong>scale</strong>） scales map values in the data space to values in the aesthetic space. This includes the use of colour, shape or size. Scales also draw the legend and axes, which make it possible to read the original data values from the plot（<strong>将数据取值映射到图形</strong>空间，使用颜色，形状，大小表示不同取值，使用图例，网格线展示标度）</p>
</li>
<li>
<p><strong>图像属性</strong>（aes）data to the <strong>aes</strong>thetic attributes (color, shape, size)</p>
</li>
<li>
<p><strong>坐标系</strong>（<strong>coord</strong>）information about the plot’s <strong>coord</strong>inate system（描述数据如何映射到图形，同时包含坐标轴和网格线 axes, gridlines）</p>
</li>
<li>
<p><strong>统计变换</strong>（<strong>stat</strong>）<strong>stat</strong>istical transformations of the data，对数据的汇总</p>
</li>
<li>
<p><strong>分面</strong>（<strong>facet</strong>） A facet specifies how to break up and display subsets of data as small multiples. This is also known as conditioning or latticing/trellising.（将数据拆分为子集，对各子集作图并联合展示，也成条件作图或网格图）</p>
</li>
<li>
<p><strong>绘图主题</strong>（<strong>theme</strong>）A<strong>theme</strong>controls the finer points of display, like the font size and background colour. While the defaults in ggplot2 have been chosen with care, you may need to consult other references to create an attractive plot.（主题涉及图形更细的方面，如背景色，字体大小等）。</p>
</li>
</ol>
<h2 id="原理">原理</h2>
<p><code>ggplot()</code>函数包括9个部件：</p>
<ul>
<li><strong>数据（data）</strong></li>
<li><strong>映射（mapping）</strong></li>
<li><strong>几何对象（geom）</strong></li>
<li>统计变换（stats）</li>
<li>标度（scale）</li>
<li>坐标系（coord）</li>
<li>分面（facet）</li>
<li>主题（theme）</li>
<li>存储和输出（output）</li>
</ul>
<p>其中前三个是必需的。</p>
<p>Hadley wickham将这套语法诠释为：一张统计图形就是从<strong>数据</strong>到<strong>几何对象</strong> (geometric object，缩写<strong>geom</strong>)的<strong>图形属性</strong>(aesthetic attribute，缩写<strong>aes</strong>)的一个映射。</p>
<p>此外，图形中还可能包合数据的统计变换（statistical transformation，缩写stat），最后绘制在某个特定的坐标系（coordinate system，缩写coord）中，而分面（facet）则可以用来生成数据不同子集的图形。</p>
<h3 id="语法模版">语法模版</h3>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>tidyverse<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>ggplot2<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>colorspace<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">d <span class="operator">&lt;-</span> read_csv<span class="punctuation">(</span><span class="string">&quot;data/temp_carbon.csv&quot;</span><span class="punctuation">)</span></span><br><span class="line">ggplot<span class="punctuation">(</span>data <span class="operator">=</span> d<span class="punctuation">,</span> mapping <span class="operator">=</span> aes<span class="punctuation">(</span>x <span class="operator">=</span> year<span class="punctuation">,</span> y <span class="operator">=</span> carbon_emissions<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  geom_line<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  xlab<span class="punctuation">(</span><span class="string">&quot;year&quot;</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  ylab<span class="punctuation">(</span><span class="string">&quot;carbon emissions (metric tons)&quot;</span><span class="punctuation">)</span> <span class="operator">+</span> </span><br><span class="line">  ggtitle<span class="punctuation">(</span><span class="string">&quot;Annual global carbon emissions, 1880-2014&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261851515.png" alt=""></p>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261851934.png" alt=""></p>
<h2 id="映射">映射</h2>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">mpg</span><br></pre></td></tr></table></figure>
<pre><code>#&gt; # A tibble: 234 × 11
#&gt;    manufacturer model      displ  year   cyl trans drv     cty   hwy fl    class
#&gt;    &lt;chr&gt;        &lt;chr&gt;      &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt;
#&gt;  1 audi         a4           1.8  1999     4 auto… f        18    29 p     comp…
#&gt;  2 audi         a4           1.8  1999     4 manu… f        21    29 p     comp…
#&gt;  3 audi         a4           2    2008     4 manu… f        20    31 p     comp…
#&gt;  4 audi         a4           2    2008     4 auto… f        21    30 p     comp…
#&gt;  5 audi         a4           2.8  1999     6 auto… f        16    26 p     comp…
#&gt;  6 audi         a4           2.8  1999     6 manu… f        18    26 p     comp…
#&gt;  7 audi         a4           3.1  2008     6 auto… f        18    27 p     comp…
#&gt;  8 audi         a4 quattro   1.8  1999     4 manu… 4        18    26 p     comp…
#&gt;  9 audi         a4 quattro   1.8  1999     4 auto… 4        16    25 p     comp…
#&gt; 10 audi         a4 quattro   2    2008     4 manu… 4        20    28 p     comp…
#&gt; # ℹ 224 more rows
</code></pre>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">str<span class="punctuation">(</span>mpg<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<pre><code>#&gt; tibble [234 × 11] (S3: tbl_df/tbl/data.frame)
#&gt;  $ manufacturer: chr [1:234] &quot;audi&quot; &quot;audi&quot; &quot;audi&quot; &quot;audi&quot; ...
#&gt;  $ model       : chr [1:234] &quot;a4&quot; &quot;a4&quot; &quot;a4&quot; &quot;a4&quot; ...
#&gt;  $ displ       : num [1:234] 1.8 1.8 2 2 2.8 2.8 3.1 1.8 1.8 2 ...
#&gt;  $ year        : int [1:234] 1999 1999 2008 2008 1999 1999 2008 1999 1999 2008 ...
#&gt;  $ cyl         : int [1:234] 4 4 4 4 6 6 6 4 4 4 ...
#&gt;  $ trans       : chr [1:234] &quot;auto(l5)&quot; &quot;manual(m5)&quot; &quot;manual(m6)&quot; &quot;auto(av)&quot; ...
#&gt;  $ drv         : chr [1:234] &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; ...
#&gt;  $ cty         : int [1:234] 18 21 20 21 16 18 18 18 16 20 ...
#&gt;  $ hwy         : int [1:234] 29 29 31 30 26 26 27 26 25 28 ...
#&gt;  $ fl          : chr [1:234] &quot;p&quot; &quot;p&quot; &quot;p&quot; &quot;p&quot; ...
#&gt;  $ class       : chr [1:234] &quot;compact&quot; &quot;compact&quot; &quot;compact&quot; &quot;compact&quot; ...
</code></pre>
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">变量</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">manufacturer</td>
<td style="text-align:left">生产厂家</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">model</td>
<td style="text-align:left">类型</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">displ</td>
<td style="text-align:left">发动机排量（升）</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">year</td>
<td style="text-align:left">生产年份</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">cyl</td>
<td style="text-align:left">气缸数量</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left">trans</td>
<td style="text-align:left">传输类型</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left">drv</td>
<td style="text-align:left">驱动类型（f =前轮驱动，r=后轮驱动，4= 4wd）</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left">cty</td>
<td style="text-align:left">每加仑城市里程</td>
</tr>
<tr>
<td style="text-align:left">9</td>
<td style="text-align:left">hwy</td>
<td style="text-align:left">每加仑高速公路英里</td>
</tr>
<tr>
<td style="text-align:left">10</td>
<td style="text-align:left">fl</td>
<td style="text-align:left">汽油种类</td>
</tr>
<tr>
<td style="text-align:left">11</td>
<td style="text-align:left">class</td>
<td style="text-align:left">类型</td>
</tr>
</tbody>
</table>
<h3 id="排量和油耗之间是什么关系？">排量和油耗之间是什么关系？</h3>
<p>提取子集：<code>displ</code> <code>hwy</code> <code>class</code></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">mpg <span class="operator">%&gt;%</span> </span><br><span class="line">  select<span class="punctuation">(</span>displ<span class="punctuation">,</span> hwy<span class="punctuation">,</span> <span class="built_in">class</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<pre><code>#&gt; # A tibble: 234 × 3
#&gt;    displ   hwy class  
#&gt;    &lt;dbl&gt; &lt;int&gt; &lt;chr&gt;  
#&gt;  1   1.8    29 compact
#&gt;  2   1.8    29 compact
#&gt;  3   2      31 compact
#&gt;  4   2      30 compact
#&gt;  5   2.8    26 compact
#&gt;  6   2.8    26 compact
#&gt;  7   3.1    27 compact
#&gt;  8   1.8    26 compact
#&gt;  9   1.8    25 compact
#&gt; 10   2      28 compact
#&gt; # ℹ 224 more rows
</code></pre>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ggplot<span class="punctuation">(</span>data <span class="operator">=</span> mpg<span class="punctuation">,</span> mapping <span class="operator">=</span> aes<span class="punctuation">(</span>x <span class="operator">=</span> displ<span class="punctuation">,</span> y <span class="operator">=</span> hwy<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  geom_point<span class="punctuation">(</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261852294.png" alt=""></p>
<ul>
<li>
<p><code>ggplot()</code>表示调用该函数画图，<code>data = mpg</code>表示使用mpg这个<strong>数据框</strong>来画图。</p>
</li>
<li>
<p><code>aes()</code>表示数据和视觉属性之间的映射，<code>aes(x = displ, y = hwy)</code>，意思是变量<code>displ</code>作为（映射为）x轴方向的<strong>位置</strong>，变量<code>hwy</code>作为（映射为）y轴方向的<strong>位置</strong>。</p>
</li>
<li>
<p><code>aes()</code>除了位置上映射，还可以实现色彩、形状或透明度等视觉属性的映射。</p>
</li>
<li>
<p><code>geom_point()</code>表示绘制散点图。</p>
</li>
<li>
<p><code>+</code> 表示添加图层。</p>
</li>
</ul>
<p>以上是位置上的映射，ggplot还包含了颜色、形状以及透明度等图形属性的映射，比如在<code>aes()</code>增加一个’color = class`，具体来说，<strong>不同的汽车类型</strong>，用<strong>不同的颜色</strong>来表现。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ggplot<span class="punctuation">(</span>data <span class="operator">=</span> mpg<span class="punctuation">,</span> mapping <span class="operator">=</span> aes<span class="punctuation">(</span>x <span class="operator">=</span> displ<span class="punctuation">,</span> y <span class="operator">=</span> hwy<span class="punctuation">,</span> color <span class="operator">=</span> <span class="built_in">class</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  geom_point<span class="punctuation">(</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261854741.png" alt=""></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ggplot<span class="punctuation">(</span>data <span class="operator">=</span> mpg<span class="punctuation">,</span> mapping <span class="operator">=</span> aes<span class="punctuation">(</span>x <span class="operator">=</span> displ<span class="punctuation">,</span> y <span class="operator">=</span> hwy<span class="punctuation">,</span> size <span class="operator">=</span> <span class="built_in">class</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  geom_point<span class="punctuation">(</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261854908.png" alt=""></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ggplot<span class="punctuation">(</span>data <span class="operator">=</span> mpg<span class="punctuation">,</span> mapping <span class="operator">=</span> aes<span class="punctuation">(</span>x <span class="operator">=</span> displ<span class="punctuation">,</span> y <span class="operator">=</span> hwy<span class="punctuation">,</span> shape <span class="operator">=</span> <span class="built_in">class</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  geom_point<span class="punctuation">(</span><span class="punctuation">)</span> </span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261855700.png" alt=""></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ggplot<span class="punctuation">(</span>data <span class="operator">=</span> mpg<span class="punctuation">,</span> mapping <span class="operator">=</span> aes<span class="punctuation">(</span>x <span class="operator">=</span> displ<span class="punctuation">,</span> y <span class="operator">=</span> hwy<span class="punctuation">,</span> alpha <span class="operator">=</span> <span class="built_in">class</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  geom_point<span class="punctuation">(</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261855073.png" alt=""></p>
<h3 id="映射-VS-设置">映射 VS 设置</h3>
<p>点指定为某一颜色</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ggplot<span class="punctuation">(</span>data <span class="operator">=</span> mpg<span class="punctuation">,</span> mapping <span class="operator">=</span> aes<span class="punctuation">(</span>x <span class="operator">=</span> displ<span class="punctuation">,</span> y <span class="operator">=</span> hwy<span class="punctuation">,</span> color <span class="operator">=</span> <span class="string">&quot;blue&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  geom_point<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">-&gt;</span> pa</span><br><span class="line">ggplot<span class="punctuation">(</span>data <span class="operator">=</span> mpg<span class="punctuation">,</span> mapping <span class="operator">=</span> aes<span class="punctuation">(</span>x <span class="operator">=</span> displ<span class="punctuation">,</span> y <span class="operator">=</span> hwy<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  geom_point<span class="punctuation">(</span>color <span class="operator">=</span> <span class="string">&quot;blue&quot;</span><span class="punctuation">)</span> <span class="operator">-&gt;</span> pb</span><br><span class="line">pa <span class="operator">/</span> pb</span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261856971.png" alt=""></p>
<p>pa和pb的区别：pa中的”blue”一个固定值也是唯一值映射给了color；pb颜色设置为”blue”蓝色</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ggplot<span class="punctuation">(</span>data <span class="operator">=</span> mpg<span class="punctuation">,</span> mapping <span class="operator">=</span> aes<span class="punctuation">(</span>x <span class="operator">=</span> displ<span class="punctuation">,</span> y <span class="operator">=</span> hwy<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  geom_point<span class="punctuation">(</span>size <span class="operator">=</span> <span class="number">5</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261857125.png" alt=""></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ggplot<span class="punctuation">(</span>data <span class="operator">=</span> mpg<span class="punctuation">,</span> mapping <span class="operator">=</span> aes<span class="punctuation">(</span>x <span class="operator">=</span> displ<span class="punctuation">,</span> y <span class="operator">=</span> hwy<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  geom_point<span class="punctuation">(</span>shape<span class="operator">=</span> <span class="number">3</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261857128.png" alt=""></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ggplot<span class="punctuation">(</span>data <span class="operator">=</span> mpg<span class="punctuation">,</span> mapping <span class="operator">=</span> aes<span class="punctuation">(</span>x <span class="operator">=</span> displ<span class="punctuation">,</span> y <span class="operator">=</span> hwy<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  geom_point<span class="punctuation">(</span>alpha <span class="operator">=</span> <span class="number">0.3</span><span class="punctuation">)</span> </span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261857229.png" alt=""></p>
<h2 id="几何对象">几何对象</h2>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ggplot<span class="punctuation">(</span>data <span class="operator">=</span> mpg<span class="punctuation">,</span> mapping <span class="operator">=</span> aes<span class="punctuation">(</span>x <span class="operator">=</span> displ<span class="punctuation">,</span> y <span class="operator">=</span> hwy<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  geom_point<span class="punctuation">(</span><span class="punctuation">)</span>  <span class="operator">-&gt;</span> p1</span><br><span class="line">p1</span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261858077.png" alt=""></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ggplot<span class="punctuation">(</span>data <span class="operator">=</span> mpg<span class="punctuation">,</span> mapping <span class="operator">=</span> aes<span class="punctuation">(</span>x <span class="operator">=</span> displ<span class="punctuation">,</span> y <span class="operator">=</span> hwy<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  geom_smooth<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">-&gt;</span> p2</span><br><span class="line">p2</span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261858073.png" alt=""></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ggplot<span class="punctuation">(</span>data <span class="operator">=</span> mpg<span class="punctuation">,</span> mapping <span class="operator">=</span> aes<span class="punctuation">(</span>x <span class="operator">=</span> displ<span class="punctuation">,</span> y <span class="operator">=</span> hwy<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  geom_point<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  geom_smooth<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">-&gt;</span> p3</span><br><span class="line">p3</span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261859020.png" alt=""></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">(</span>p1 <span class="operator">/</span> p2<span class="punctuation">)</span> <span class="operator">|</span> p3 </span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261859435.png" alt=""></p>
<h3 id="全局变量-VS-局部变量">全局变量 VS 局部变量</h3>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ggplot<span class="punctuation">(</span>data <span class="operator">=</span> mpg<span class="punctuation">,</span> mapping <span class="operator">=</span> aes<span class="punctuation">(</span>x <span class="operator">=</span> displ<span class="punctuation">,</span> y <span class="operator">=</span> hwy<span class="punctuation">,</span> color <span class="operator">=</span> <span class="built_in">class</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  geom_point<span class="punctuation">(</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261900723.png" alt=""></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ggplot<span class="punctuation">(</span>data <span class="operator">=</span> mpg<span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  geom_point<span class="punctuation">(</span> mapping <span class="operator">=</span> aes<span class="punctuation">(</span>x <span class="operator">=</span> displ<span class="punctuation">,</span> y <span class="operator">=</span> hwy<span class="punctuation">,</span> color <span class="operator">=</span> <span class="built_in">class</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261900283.png" alt=""></p>
<p>事实上，如果映射关系<code>aes()</code>写在<code>ggplot()</code>里，就是全局变量；如果写在<code>geom_xxx()</code>里就是局部变量。</p>
<p>缺少局部变量的映射关系时，就会到全局变量寻找。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ggplot<span class="punctuation">(</span>data <span class="operator">=</span> mpg<span class="punctuation">,</span> mapping <span class="operator">=</span> aes<span class="punctuation">(</span>x <span class="operator">=</span> displ<span class="punctuation">,</span> y <span class="operator">=</span> hwy<span class="punctuation">,</span> color <span class="operator">=</span> <span class="built_in">class</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  geom_point<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  geom_smooth<span class="punctuation">(</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261901326.png" alt=""></p>
<p>上图中<code>geom_point()</code>和<code>geom_smooth()</code>缺少局部变量的映射关系，就会继承全局变量的映射关系。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ggplot<span class="punctuation">(</span>data <span class="operator">=</span> mpg<span class="punctuation">,</span> mapping <span class="operator">=</span> aes<span class="punctuation">(</span>x <span class="operator">=</span> displ<span class="punctuation">,</span> y <span class="operator">=</span> hwy<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  geom_point<span class="punctuation">(</span>aes<span class="punctuation">(</span>color <span class="operator">=</span> <span class="built_in">class</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  geom_smooth<span class="punctuation">(</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261902563.png" alt=""></p>
<p><code>geom_smooth()</code>缺少局部变量的映射关系，要继承全局变量映射关系，但是全局变量没有指定特别的映射关系，因此只画一条拟合曲线。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ggplot<span class="punctuation">(</span>data <span class="operator">=</span> mpg<span class="punctuation">,</span> mapping <span class="operator">=</span> aes<span class="punctuation">(</span>x <span class="operator">=</span> displ<span class="punctuation">,</span> y <span class="operator">=</span> hwy<span class="punctuation">,</span> color <span class="operator">=</span> <span class="built_in">class</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  geom_point<span class="punctuation">(</span>aes<span class="punctuation">(</span>color <span class="operator">=</span> factor<span class="punctuation">(</span>cyl<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261902488.png" alt=""></p>
<p><code>geom_point()</code>中有因子型的局部变量<code>cyl</code>，因此不再继承全局变量。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ggplot<span class="punctuation">(</span>mpg<span class="punctuation">,</span> aes<span class="punctuation">(</span>displ<span class="punctuation">,</span> hwy<span class="punctuation">,</span> color <span class="operator">=</span> <span class="built_in">class</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  geom_smooth<span class="punctuation">(</span>method <span class="operator">=</span> lm<span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  geom_point<span class="punctuation">(</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261902591.png" alt=""></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ggplot<span class="punctuation">(</span>mpg<span class="punctuation">,</span> aes<span class="punctuation">(</span>displ<span class="punctuation">,</span> hwy<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  geom_smooth<span class="punctuation">(</span>method <span class="operator">=</span> lm<span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  geom_point<span class="punctuation">(</span>aes<span class="punctuation">(</span>color <span class="operator">=</span> <span class="built_in">class</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261903930.png" alt=""></p>
<h2 id="保存图表">保存图表</h2>
<p>使用<code>ggsave()</code>函数把图表保存为<code>.png</code>或者<code>.pdf</code>。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ggplot<span class="punctuation">(</span>mpg<span class="punctuation">,</span> aes<span class="punctuation">(</span>displ<span class="punctuation">,</span> hwy<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  geom_smooth<span class="punctuation">(</span>method <span class="operator">=</span> lm<span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  geom_point<span class="punctuation">(</span>aes<span class="punctuation">(</span>color <span class="operator">=</span> <span class="built_in">class</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  ggtitle<span class="punctuation">(</span><span class="string">&quot;This is my first plot&quot;</span><span class="punctuation">)</span> <span class="operator">-&gt;</span> p</span><br><span class="line">ggsave<span class="punctuation">(</span><span class="string">&quot;first.pdf&quot;</span><span class="punctuation">,</span> p<span class="punctuation">,</span> width <span class="operator">=</span> <span class="number">8</span><span class="punctuation">,</span> height <span class="operator">=</span> <span class="number">6</span><span class="punctuation">,</span> dpi <span class="operator">=</span> <span class="number">300</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<h2 id="继续进阶版本的教程">继续进阶版本的教程</h2>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>tidyverse<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>gghighlight<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>cowplot<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>patchwork<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>ggforce<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">read_csv<span class="punctuation">(</span><span class="string">&quot;data/datasaurus.csv&quot;</span><span class="punctuation">)</span> <span class="operator">-&gt;</span> df</span><br><span class="line"></span><br><span class="line">df <span class="operator">%&gt;%</span> </span><br><span class="line">  count<span class="punctuation">(</span>dataset<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<pre><code>#&gt; # A tibble: 13 × 2
#&gt;    dataset        n
#&gt;    &lt;chr&gt;      &lt;int&gt;
#&gt;  1 away         142
#&gt;  2 bullseye     142
#&gt;  3 circle       142
#&gt;  4 dino         142
#&gt;  5 dots         142
#&gt;  6 h_lines      142
#&gt;  7 high_lines   142
#&gt;  8 slant_down   142
#&gt;  9 slant_up     142
#&gt; 10 star         142
#&gt; 11 v_lines      142
#&gt; 12 wide_lines   142
#&gt; 13 x_shape      142
</code></pre>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">df <span class="operator">%&gt;%</span> </span><br><span class="line">  group_by<span class="punctuation">(</span>dataset<span class="punctuation">)</span> <span class="operator">%&gt;%</span> </span><br><span class="line">  summarise<span class="punctuation">(</span></span><br><span class="line">    across<span class="punctuation">(</span>everything<span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">list</span><span class="punctuation">(</span>mean <span class="operator">=</span> mean<span class="punctuation">,</span> sd <span class="operator">=</span>sd<span class="punctuation">)</span><span class="punctuation">,</span> .names <span class="operator">=</span> <span class="string">&quot;&#123;fn&#125;_&#123;col&#125;&quot;</span><span class="punctuation">)</span></span><br><span class="line">  <span class="punctuation">)</span> <span class="operator">%&gt;%</span> </span><br><span class="line">  mutate<span class="punctuation">(</span></span><br><span class="line">    across<span class="punctuation">(</span><span class="built_in">is.numeric</span><span class="punctuation">,</span> <span class="built_in">round</span><span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">)</span></span><br><span class="line">  <span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<pre><code>#&gt; # A tibble: 13 × 5
#&gt;    dataset    mean_x  sd_x mean_y  sd_y
#&gt;    &lt;chr&gt;       &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;
#&gt;  1 away         54.3  16.8   47.8  26.9
#&gt;  2 bullseye     54.3  16.8   47.8  26.9
#&gt;  3 circle       54.3  16.8   47.8  26.9
#&gt;  4 dino         54.3  16.8   47.8  26.9
#&gt;  5 dots         54.3  16.8   47.8  26.9
#&gt;  6 h_lines      54.3  16.8   47.8  26.9
#&gt;  7 high_lines   54.3  16.8   47.8  26.9
#&gt;  8 slant_down   54.3  16.8   47.8  26.9
#&gt;  9 slant_up     54.3  16.8   47.8  26.9
#&gt; 10 star         54.3  16.8   47.8  26.9
#&gt; 11 v_lines      54.3  16.8   47.8  26.9
#&gt; 12 wide_lines   54.3  16.8   47.8  26.9
#&gt; 13 x_shape      54.3  16.8   47.8  26.9
</code></pre>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ggplot<span class="punctuation">(</span>df<span class="punctuation">,</span> aes<span class="punctuation">(</span>x<span class="punctuation">,</span> y<span class="punctuation">,</span> color <span class="operator">=</span> dataset<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  geom_point<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  theme<span class="punctuation">(</span>legend.position <span class="operator">=</span> <span class="string">&quot;none&quot;</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  facet_wrap<span class="punctuation">(</span><span class="operator">~</span>dataset<span class="punctuation">,</span> nrow <span class="operator">=</span> <span class="number">3</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261904849.png" alt=""></p>
<p>事实上，每张图都相差很大。所以，要眼见为实。换句话说，可视化是数据探索中非常重要的部分。</p>
<p>前面讲到R语言数据类型有字符串型、数值型、因子型、逻辑型、日期型等，ggplot2会将字符串型、因子型、逻辑型、日期型默认为<strong>离散变量</strong>，而数值型默认为<strong>连续变量</strong>。在呈现现数据的时候，可能会同时用到多种类型的数据，比如</p>
<ul>
<li>
<p>一个离散</p>
</li>
<li>
<p>一个连续</p>
</li>
<li>
<p>两个离散</p>
</li>
<li>
<p>两个连续</p>
</li>
<li>
<p>一个离散，一个连续</p>
</li>
<li>
<p>三个连续</p>
</li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">read_csv<span class="punctuation">(</span><span class="string">&quot;data/gapminder.csv&quot;</span><span class="punctuation">)</span> <span class="operator">-&gt;</span> gapdata</span><br><span class="line">gapdata</span><br></pre></td></tr></table></figure>
<pre><code>#&gt; # A tibble: 1,704 × 6
#&gt;    country     continent  year lifeExp      pop gdpPercap
#&gt;    &lt;chr&gt;       &lt;chr&gt;     &lt;dbl&gt;   &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;
#&gt;  1 Afghanistan Asia       1952    28.8  8425333      779.
#&gt;  2 Afghanistan Asia       1957    30.3  9240934      821.
#&gt;  3 Afghanistan Asia       1962    32.0 10267083      853.
#&gt;  4 Afghanistan Asia       1967    34.0 11537966      836.
#&gt;  5 Afghanistan Asia       1972    36.1 13079460      740.
#&gt;  6 Afghanistan Asia       1977    38.4 14880372      786.
#&gt;  7 Afghanistan Asia       1982    39.9 12881816      978.
#&gt;  8 Afghanistan Asia       1987    40.8 13867957      852.
#&gt;  9 Afghanistan Asia       1992    41.7 16317921      649.
#&gt; 10 Afghanistan Asia       1997    41.8 22227415      635.
#&gt; # ℹ 1,694 more rows
</code></pre>
<p>检查是否存在缺失值</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">gapdata <span class="operator">%&gt;%</span> </span><br><span class="line">  summarise<span class="punctuation">(</span></span><br><span class="line">    across<span class="punctuation">(</span>everything<span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="operator">~</span> <span class="built_in">sum</span><span class="punctuation">(</span><span class="built_in">is.na</span><span class="punctuation">(</span>.<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">  <span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<pre><code>#&gt; # A tibble: 1 × 6
#&gt;   country continent  year lifeExp   pop gdpPercap
#&gt;     &lt;int&gt;     &lt;int&gt; &lt;int&gt;   &lt;int&gt; &lt;int&gt;     &lt;int&gt;
#&gt; 1       0         0     0       0     0         0
</code></pre>
<p>选择什么样的类型呈现数据</p>
<h3 id="柱状图">柱状图</h3>
<p>常用于一个离散变量</p>
<p><code>geom_bar()</code>自动完成了统计工作<code>stat_count()</code></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ggplot<span class="punctuation">(</span>data <span class="operator">=</span> gapdata<span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line"> geom_bar<span class="punctuation">(</span>aes<span class="punctuation">(</span>x <span class="operator">=</span> continent<span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261904137.png" alt=""></p>
<p>x轴变量排序利用<code>reorder()</code>函数</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ggplot<span class="punctuation">(</span>data <span class="operator">=</span> gapdata<span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  geom_bar<span class="punctuation">(</span>aes<span class="punctuation">(</span>x <span class="operator">=</span> reorder<span class="punctuation">(</span>x <span class="operator">=</span> continent<span class="punctuation">,</span> continent<span class="punctuation">,</span> <span class="built_in">length</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261908826.png" alt=""></p>
<p>x轴和y轴翻转</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ggplot<span class="punctuation">(</span>data <span class="operator">=</span> gapdata<span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  geom_bar<span class="punctuation">(</span>aes<span class="punctuation">(</span>x <span class="operator">=</span> reorder<span class="punctuation">(</span>x <span class="operator">=</span> continent<span class="punctuation">,</span> continent<span class="punctuation">,</span> <span class="built_in">length</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  coord_flip<span class="punctuation">(</span><span class="punctuation">)</span> </span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261909630.png" alt=""></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">gapdata <span class="operator">%&gt;%</span> </span><br><span class="line">  distinct<span class="punctuation">(</span>continent<span class="punctuation">,</span> country<span class="punctuation">)</span> <span class="operator">%&gt;%</span> </span><br><span class="line">  ggplot<span class="punctuation">(</span>aes<span class="punctuation">(</span>x <span class="operator">=</span> continent<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  geom_bar<span class="punctuation">(</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261909617.png" alt=""></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># distinct()函数保持数据唯一行，去除重复的行。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先做计算在画图</span></span><br><span class="line">gapdata <span class="operator">%&gt;%</span> </span><br><span class="line">  distinct<span class="punctuation">(</span>continent<span class="punctuation">,</span> country<span class="punctuation">)</span> <span class="operator">%&gt;%</span> </span><br><span class="line">  group_by<span class="punctuation">(</span>continent<span class="punctuation">)</span> <span class="operator">%&gt;%</span> </span><br><span class="line">  summarise<span class="punctuation">(</span>n <span class="operator">=</span> n<span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">%&gt;%</span> </span><br><span class="line">  ggplot<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  geom_col<span class="punctuation">(</span>aes<span class="punctuation">(</span>x <span class="operator">=</span> continent<span class="punctuation">,</span> y <span class="operator">=</span> n<span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261910149.png" alt=""></p>
<h3 id="直方图">直方图</h3>
<p>连续变量</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">gapdata <span class="operator">%&gt;%</span> </span><br><span class="line">  ggplot<span class="punctuation">(</span>aes<span class="punctuation">(</span>x <span class="operator">=</span> lifeExp<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  geom_histogram<span class="punctuation">(</span>binwidth <span class="operator">=</span> <span class="number">1</span><span class="punctuation">)</span> </span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261910651.png" alt=""></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># binwidth 代表条的宽度</span></span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">gapdata <span class="operator">%&gt;%</span> </span><br><span class="line">  ggplot<span class="punctuation">(</span>aes<span class="punctuation">(</span> x<span class="operator">=</span> lifeExp<span class="punctuation">,</span> color <span class="operator">=</span> continent<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  geom_freqpoly<span class="punctuation">(</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261911820.png" alt=""></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># smooth histogram = density plot</span></span><br><span class="line">gapdata <span class="operator">%&gt;%</span> </span><br><span class="line">  ggplot<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  geom_density<span class="punctuation">(</span>aes<span class="punctuation">(</span>x<span class="operator">=</span> lifeExp<span class="punctuation">,</span> fill <span class="operator">=</span> continent<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  facet_wrap<span class="punctuation">(</span><span class="operator">~</span>continent<span class="punctuation">,</span> ncol <span class="operator">=</span> <span class="number">1</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261911120.png" alt=""></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">gapdata <span class="operator">%&gt;%</span> </span><br><span class="line">  ggplot<span class="punctuation">(</span>aes<span class="punctuation">(</span>x <span class="operator">=</span> lifeExp<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  geom_density<span class="punctuation">(</span>adjust <span class="operator">=</span> <span class="number">1</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261912943.png" alt=""></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">gapdata <span class="operator">%&gt;%</span> </span><br><span class="line">  ggplot<span class="punctuation">(</span>aes<span class="punctuation">(</span>x <span class="operator">=</span> lifeExp<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  geom_density<span class="punctuation">(</span>adjust <span class="operator">=</span> <span class="number">0.3</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261913793.png" alt=""></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">gapdata <span class="operator">%&gt;%</span> </span><br><span class="line">  ggplot<span class="punctuation">(</span>aes<span class="punctuation">(</span>x <span class="operator">=</span> lifeExp<span class="punctuation">,</span> fill <span class="operator">=</span> continent<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  geom_density<span class="punctuation">(</span>alpha <span class="operator">=</span> <span class="number">0.3</span><span class="punctuation">)</span> </span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261913951.png" alt=""></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">gapdata <span class="operator">%&gt;%</span> </span><br><span class="line">  ggplot<span class="punctuation">(</span>aes<span class="punctuation">(</span>x <span class="operator">=</span> lifeExp<span class="punctuation">,</span> fill <span class="operator">=</span> continent<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  geom_density<span class="punctuation">(</span>aes<span class="punctuation">(</span>alpha <span class="operator">=</span> <span class="number">0.3</span><span class="punctuation">)</span><span class="punctuation">)</span> </span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261914276.png" alt=""></p>
<p>在**<code>ggplot2</code>**中，图形是由数据、几何对象（geoms）和美学映射（aesthetic mappings）组成的。这些元素合在一起定义了你的图形长什么样和代表了什么。</p>
<p><strong><code>aes()</code><strong>函数是用于定义美学映射的。简单来说，当你想基于数据的某个变量来决定一个图形特性（如颜色、大小、形状等）时，你就会用到</strong><code>aes()</code><strong>函数。当你把一个变量放到</strong><code>aes()</code><strong>里，你实际上是告诉</strong><code>ggplot</code></strong>：“请根据这个变量的值来改变某个图形特性”。</p>
<p>例如，<strong><code>aes(x = lifeExp, fill = continent)</code><strong>告诉</strong><code>ggplot</code></strong>，x坐标应该由**<code>lifeExp</code><strong>决定，并且填充颜色应该基于</strong><code>continent</code>**的不同类别来变化。</p>
<p>当你在**<code>geom_density(alpha = 0.3)</code><strong>这样的设置中直接为<code>alpha</code>赋值，你是在给这个特性一个固定的值。这就意味着，不论数据如何，<code>图形的这个特性都是这个固定值</code>。而当你使用</strong><code>geom_density(aes(alpha = 0.3))</code><strong>，你实际上是在告诉<code>ggplot</code>，你希望</strong>透明度基于某种数据来变化**。但因为你给了它一个固定的数字，它实际上并没有根据数据变化。这是一个容易引起混淆的写法，因为通常我们希望在**<code>aes()</code>内部映射的都是数据集中的变量，而不是固定值**。</p>
<p>为什么第一种方法更好：使用<code>aes()</code>来映射数据到图形的某个特性时，应该确保<strong>映射的真的是数据集中的某个变量</strong>。<strong>把固定的属性值放到<code>aes()</code>内部是不清晰的</strong>，因为这种写法会让读者误以为这个特性是根据数据变化的。为了代码的清晰和明确，最好避免这种混淆。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">gapdata <span class="operator">%&gt;%</span> </span><br><span class="line">  dplyr<span class="operator">::</span>filter<span class="punctuation">(</span>continent <span class="operator">!=</span> <span class="string">&quot;Oceania&quot;</span><span class="punctuation">)</span> <span class="operator">%&gt;%</span> </span><br><span class="line">  ggplot<span class="punctuation">(</span>aes<span class="punctuation">(</span>x <span class="operator">=</span> lifeExp<span class="punctuation">,</span> fill <span class="operator">=</span> continent<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  geom_histogram<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  facet_grid<span class="punctuation">(</span>continent<span class="operator">~</span>.<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261914917.png" alt=""></p>
<p>直方图和密度图画在一起。注意<code>y = stat(density)</code>表示y是由x新生成的变量，这是一种固定写法，类似的还有<code>stat(count)</code>和<code>stat(level)</code></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">gapdata <span class="operator">%&gt;%</span> </span><br><span class="line">  dplyr<span class="operator">::</span>filter<span class="punctuation">(</span>continent <span class="operator">!=</span> <span class="string">&quot;Oceania&quot;</span><span class="punctuation">)</span> <span class="operator">%&gt;%</span> </span><br><span class="line">  ggplot<span class="punctuation">(</span>aes<span class="punctuation">(</span>x <span class="operator">=</span> lifeExp<span class="punctuation">,</span> y <span class="operator">=</span> stat<span class="punctuation">(</span>density<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  geom_histogram<span class="punctuation">(</span>aes<span class="punctuation">(</span>fill <span class="operator">=</span> continent<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  geom_density<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  facet_grid<span class="punctuation">(</span>continent<span class="operator">~</span>.<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261915374.png" alt=""></p>
<h3 id="箱线图">箱线图</h3>
<p>一个离散型一个连续型</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># year原本为数值型，先用factor函数将数值型转化为离散型</span></span><br><span class="line">gapdata <span class="operator">%&gt;%</span> </span><br><span class="line">  ggplot<span class="punctuation">(</span>aes<span class="punctuation">(</span>x <span class="operator">=</span> factor<span class="punctuation">(</span>year<span class="punctuation">)</span><span class="punctuation">,</span> y <span class="operator">=</span> lifeExp<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  geom_boxplot<span class="punctuation">(</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261915969.png" alt=""></p>
<h3 id="小提琴图">小提琴图</h3>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">gapdata <span class="operator">%&gt;%</span> </span><br><span class="line">  ggplot<span class="punctuation">(</span>aes<span class="punctuation">(</span>x <span class="operator">=</span> year<span class="punctuation">,</span> y <span class="operator">=</span> lifeExp<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  geom_violin<span class="punctuation">(</span>aes<span class="punctuation">(</span>group <span class="operator">=</span> year<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  geom_jitter<span class="punctuation">(</span>alpha <span class="operator">=</span> <span class="number">0.25</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  geom_smooth<span class="punctuation">(</span>se <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261916533.png" alt=""></p>
<h3 id="抖散图">抖散图</h3>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">gapdata <span class="operator">%&gt;%</span> </span><br><span class="line">  ggplot<span class="punctuation">(</span>aes<span class="punctuation">(</span>x <span class="operator">=</span> continent<span class="punctuation">,</span> y <span class="operator">=</span> lifeExp<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  geom_jitter<span class="punctuation">(</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261917355.png" alt=""></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">gapdata <span class="operator">%&gt;%</span> </span><br><span class="line">  ggplot<span class="punctuation">(</span>aes<span class="punctuation">(</span>x <span class="operator">=</span> continent<span class="punctuation">,</span> y <span class="operator">=</span> lifeExp<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span> </span><br><span class="line">  geom_jitter<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  stat_summary<span class="punctuation">(</span>fun.y <span class="operator">=</span> median<span class="punctuation">,</span> color <span class="operator">=</span> <span class="string">&quot;red&quot;</span><span class="punctuation">,</span> geom <span class="operator">=</span> <span class="string">&quot;point&quot;</span><span class="punctuation">,</span> szie <span class="operator">=</span> <span class="number">5</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261917648.png" alt=""></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">gapdata <span class="operator">%&gt;%</span> </span><br><span class="line">  ggplot<span class="punctuation">(</span>aes<span class="punctuation">(</span>x <span class="operator">=</span> continent<span class="punctuation">,</span> y <span class="operator">=</span> lifeExp<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span> </span><br><span class="line">  geom_violin<span class="punctuation">(</span></span><br><span class="line">    trim <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">,</span></span><br><span class="line">    alpha <span class="operator">=</span> <span class="number">0.5</span></span><br><span class="line">    <span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  stat_summary<span class="punctuation">(</span></span><br><span class="line">    fun.y <span class="operator">=</span> mean<span class="punctuation">,</span></span><br><span class="line">    fun.max <span class="operator">=</span> <span class="keyword">function</span><span class="punctuation">(</span>x<span class="punctuation">)</span><span class="punctuation">&#123;</span></span><br><span class="line">      mean<span class="punctuation">(</span>x<span class="punctuation">)</span> <span class="operator">+</span> sd<span class="punctuation">(</span>x<span class="punctuation">)</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    fun.min <span class="operator">=</span> <span class="keyword">function</span><span class="punctuation">(</span>x<span class="punctuation">)</span><span class="punctuation">&#123;</span></span><br><span class="line">      mean<span class="punctuation">(</span>x<span class="punctuation">)</span> <span class="operator">-</span> sd<span class="punctuation">(</span>x<span class="punctuation">)</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    geom <span class="operator">=</span> <span class="string">&quot;pointrange&quot;</span></span><br><span class="line">  <span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261917263.png" alt=""></p>
<h3 id="山峦图">山峦图</h3>
<p>一个连续变量一个离散变量</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">gapdata <span class="operator">%&gt;%</span> </span><br><span class="line">  ggplot<span class="punctuation">(</span>aes<span class="punctuation">(</span>x <span class="operator">=</span> lifeExp<span class="punctuation">,</span> y <span class="operator">=</span> continent<span class="punctuation">,</span> fill <span class="operator">=</span> continent<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  ggridges<span class="operator">::</span>geom_density_ridges<span class="punctuation">(</span>alpha <span class="operator">=</span> <span class="number">0.5</span><span class="punctuation">)</span> </span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261918156.png" alt=""></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">gapdata <span class="operator">%&gt;%</span> </span><br><span class="line">  ggplot<span class="punctuation">(</span>aes<span class="punctuation">(</span>x <span class="operator">=</span> lifeExp<span class="punctuation">,</span> y <span class="operator">=</span> continent<span class="punctuation">,</span> fill <span class="operator">=</span> continent<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  ggridges<span class="operator">::</span>geom_density_ridges<span class="punctuation">(</span>alpha <span class="operator">=</span> <span class="number">0.5</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  scale_fill_manual<span class="punctuation">(</span></span><br><span class="line">    values <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;#003f5c&quot;</span><span class="punctuation">,</span> <span class="string">&quot;#58508d&quot;</span><span class="punctuation">,</span> <span class="string">&quot;#bc5090&quot;</span><span class="punctuation">,</span> <span class="string">&quot;#ff6361&quot;</span><span class="punctuation">,</span> <span class="string">&quot;#ffa600&quot;</span><span class="punctuation">)</span></span><br><span class="line">      <span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261918879.png" alt=""></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">gapdata <span class="operator">%&gt;%</span> </span><br><span class="line">  ggplot<span class="punctuation">(</span>aes<span class="punctuation">(</span>x <span class="operator">=</span> lifeExp<span class="punctuation">,</span> y <span class="operator">=</span> continent<span class="punctuation">,</span> fill <span class="operator">=</span> continent<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  ggridges<span class="operator">::</span>geom_density_ridges<span class="punctuation">(</span>alpha <span class="operator">=</span> <span class="number">0.5</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  scale_fill_manual<span class="punctuation">(</span></span><br><span class="line">    values <span class="operator">=</span> colorspace<span class="operator">::</span>sequential_hcl<span class="punctuation">(</span><span class="number">5</span><span class="punctuation">,</span> palette <span class="operator">=</span> <span class="string">&quot;Peach&quot;</span><span class="punctuation">)</span></span><br><span class="line">      <span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261919619.png" alt=""></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 增加标度 更换填充的颜色</span></span><br></pre></td></tr></table></figure>
<h3 id="散点图">散点图</h3>
<p>两个连续变量</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">gapdata <span class="operator">%&gt;%</span> </span><br><span class="line">  ggplot<span class="punctuation">(</span>aes<span class="punctuation">(</span>x <span class="operator">=</span> gdpPercap<span class="punctuation">,</span> y <span class="operator">=</span> lifeExp<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  geom_point<span class="punctuation">(</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261919424.png" alt=""></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">gapdata <span class="operator">%&gt;%</span> </span><br><span class="line">  ggplot<span class="punctuation">(</span>aes<span class="punctuation">(</span>x <span class="operator">=</span> <span class="built_in">log</span><span class="punctuation">(</span>gdpPercap<span class="punctuation">)</span><span class="punctuation">,</span> y <span class="operator">=</span> lifeExp<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  geom_point<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  geom_smooth<span class="punctuation">(</span>method <span class="operator">=</span> <span class="string">&quot;lm&quot;</span><span class="punctuation">)</span> </span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261920586.png" alt=""></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">gapdata <span class="operator">%&gt;%</span> </span><br><span class="line">  ggplot<span class="punctuation">(</span>aes<span class="punctuation">(</span>x <span class="operator">=</span> gdpPercap<span class="punctuation">,</span> y <span class="operator">=</span> lifeExp<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  geom_point<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  scale_x_log10<span class="punctuation">(</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261920711.png" alt=""></p>
<h2 id="主题设置">主题设置</h2>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261920810.png" alt=""></p>
<h3 id="theme原理">theme原理</h3>
<p><code>element_function()</code>包括四个：</p>
<ul>
<li>
<p><code>element_text()</code> # 文本，控制标签和标题的字体</p>
</li>
<li>
<p><code>element_line()</code> # 线条，控制线条的颜色、类型、粗细</p>
</li>
<li>
<p><code>element_rect()</code> # 矩形，控制背景矩形的颜色或边界线条类型</p>
</li>
<li>
<p><code>element_blank()</code> # 空白，不分配绘图空间，删去该区域绘图元素</p>
</li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">glimpse<span class="punctuation">(</span>mpg<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<pre><code>#&gt; Rows: 234
#&gt; Columns: 11
#&gt; $ manufacturer &lt;chr&gt; &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;…
#&gt; $ model        &lt;chr&gt; &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4 quattro&quot;, &quot;…
#&gt; $ displ        &lt;dbl&gt; 1.8, 1.8, 2.0, 2.0, 2.8, 2.8, 3.1, 1.8, 1.8, 2.0, 2.0, 2.…
#&gt; $ year         &lt;int&gt; 1999, 1999, 2008, 2008, 1999, 1999, 2008, 1999, 1999, 200…
#&gt; $ cyl          &lt;int&gt; 4, 4, 4, 4, 6, 6, 6, 4, 4, 4, 4, 6, 6, 6, 6, 6, 6, 8, 8, …
#&gt; $ trans        &lt;chr&gt; &quot;auto(l5)&quot;, &quot;manual(m5)&quot;, &quot;manual(m6)&quot;, &quot;auto(av)&quot;, &quot;auto…
#&gt; $ drv          &lt;chr&gt; &quot;f&quot;, &quot;f&quot;, &quot;f&quot;, &quot;f&quot;, &quot;f&quot;, &quot;f&quot;, &quot;f&quot;, &quot;4&quot;, &quot;4&quot;, &quot;4&quot;, &quot;4&quot;, &quot;4…
#&gt; $ cty          &lt;int&gt; 18, 21, 20, 21, 16, 18, 18, 18, 16, 20, 19, 15, 17, 17, 1…
#&gt; $ hwy          &lt;int&gt; 29, 29, 31, 30, 26, 26, 27, 26, 25, 28, 27, 25, 25, 25, 2…
#&gt; $ fl           &lt;chr&gt; &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p…
#&gt; $ class        &lt;chr&gt; &quot;compact&quot;, &quot;compact&quot;, &quot;compact&quot;, &quot;compact&quot;, &quot;compact&quot;, &quot;c…
</code></pre>
<p>整理数据</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">mpg <span class="operator">%&gt;%</span> </span><br><span class="line">  filter<span class="punctuation">(</span><span class="built_in">class</span> <span class="operator">!=</span> <span class="string">&quot;2seater&quot;</span><span class="punctuation">,</span> manufacturer <span class="operator">%in%</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;toyota&quot;</span><span class="punctuation">,</span> <span class="string">&quot;volkswagen&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">-&gt;</span> df</span><br><span class="line">df</span><br></pre></td></tr></table></figure>
<pre><code>#&gt; # A tibble: 61 × 11
#&gt;    manufacturer model      displ  year   cyl trans drv     cty   hwy fl    class
#&gt;    &lt;chr&gt;        &lt;chr&gt;      &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt;
#&gt;  1 toyota       4runner 4…   2.7  1999     4 manu… 4        15    20 r     suv  
#&gt;  2 toyota       4runner 4…   2.7  1999     4 auto… 4        16    20 r     suv  
#&gt;  3 toyota       4runner 4…   3.4  1999     6 auto… 4        15    19 r     suv  
#&gt;  4 toyota       4runner 4…   3.4  1999     6 manu… 4        15    17 r     suv  
#&gt;  5 toyota       4runner 4…   4    2008     6 auto… 4        16    20 r     suv  
#&gt;  6 toyota       4runner 4…   4.7  2008     8 auto… 4        14    17 r     suv  
#&gt;  7 toyota       camry        2.2  1999     4 manu… f        21    29 r     mids…
#&gt;  8 toyota       camry        2.2  1999     4 auto… f        21    27 r     mids…
#&gt;  9 toyota       camry        2.4  2008     4 manu… f        21    31 r     mids…
#&gt; 10 toyota       camry        2.4  2008     4 auto… f        21    31 r     mids…
#&gt; # ℹ 51 more rows
</code></pre>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">df <span class="operator">%&gt;%</span></span><br><span class="line">ggplot<span class="punctuation">(</span>aes<span class="punctuation">(</span>x <span class="operator">=</span> displ<span class="punctuation">,</span>y <span class="operator">=</span> hwy<span class="punctuation">,</span> color <span class="operator">=</span> factor<span class="punctuation">(</span>cyl<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="operator">+</span></span><br><span class="line">geom_point<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">facet_grid<span class="punctuation">(</span>vars<span class="punctuation">(</span>manufacturer<span class="punctuation">)</span><span class="punctuation">,</span> vars<span class="punctuation">(</span><span class="built_in">class</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">ggtitle<span class="punctuation">(</span><span class="string">&quot;这是我的标题&quot;</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">labs<span class="punctuation">(</span>x <span class="operator">=</span> <span class="string">&quot;x_displ&quot;</span><span class="punctuation">,</span> y <span class="operator">=</span> <span class="string">&quot;y_hwy&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261921706.png" alt=""></p>
<p>修改主题</p>
<h3 id="整体元素">整体元素</h3>
<table>
<thead>
<tr>
<th>描述</th>
<th>主题元素</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>整个图形背景（plot）</td>
<td><code>plot.background</code></td>
<td><code>element_rect()</code></td>
</tr>
<tr>
<td>图形标题</td>
<td><code>plot.title</code></td>
<td><code>element_text()</code></td>
</tr>
<tr>
<td>图形边距</td>
<td><code>plot.margin</code></td>
<td><code>margin()</code></td>
</tr>
</tbody>
</table>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">df <span class="operator">%&gt;%</span></span><br><span class="line">ggplot<span class="punctuation">(</span>aes<span class="punctuation">(</span>x <span class="operator">=</span> displ<span class="punctuation">,</span>y <span class="operator">=</span> hwy<span class="punctuation">,</span> color <span class="operator">=</span> factor<span class="punctuation">(</span>cyl<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="operator">+</span></span><br><span class="line">geom_point<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">facet_grid<span class="punctuation">(</span>vars<span class="punctuation">(</span>manufacturer<span class="punctuation">)</span><span class="punctuation">,</span> vars<span class="punctuation">(</span><span class="built_in">class</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">ggtitle<span class="punctuation">(</span><span class="string">&quot;这是我的标题&quot;</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">labs<span class="punctuation">(</span>x <span class="operator">=</span> <span class="string">&quot;x_displ&quot;</span><span class="punctuation">,</span> y <span class="operator">=</span> <span class="string">&quot;y_hwy&quot;</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  theme<span class="punctuation">(</span></span><br><span class="line">    plot.background <span class="operator">=</span> element_rect<span class="punctuation">(</span>fill <span class="operator">=</span> <span class="string">&quot;orange&quot;</span><span class="punctuation">,</span> color <span class="operator">=</span> <span class="string">&quot;black&quot;</span><span class="punctuation">,</span> size <span class="operator">=</span> <span class="number">10</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">    plot.title <span class="operator">=</span> element_text<span class="punctuation">(</span>hjust <span class="operator">=</span> <span class="number">1</span><span class="punctuation">,</span> color <span class="operator">=</span> <span class="string">&quot;red&quot;</span><span class="punctuation">,</span> face <span class="operator">=</span> <span class="string">&quot;bold&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">    plot.margin <span class="operator">=</span> margin<span class="punctuation">(</span>t <span class="operator">=</span> <span class="number">20</span><span class="punctuation">,</span> r <span class="operator">=</span> <span class="number">20</span><span class="punctuation">,</span> b <span class="operator">=</span> <span class="number">20</span><span class="punctuation">,</span> l <span class="operator">=</span> <span class="number">20</span><span class="punctuation">,</span> unit <span class="operator">=</span> <span class="string">&quot;pt&quot;</span><span class="punctuation">)</span></span><br><span class="line">  <span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261921219.png" alt=""></p>
<h3 id="坐标轴元素">坐标轴元素</h3>
<table>
<thead>
<tr>
<th>描述</th>
<th>主题元素</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>坐标轴刻度</td>
<td><code>axis.ticks</code></td>
<td><code>element_line()</code></td>
</tr>
<tr>
<td>坐标轴标题</td>
<td><code>axis.title</code></td>
<td><code>element_text()</code></td>
</tr>
<tr>
<td>坐标轴标签</td>
<td><code>axis.text</code></td>
<td><code>element_text()</code></td>
</tr>
<tr>
<td>直线和坐标轴</td>
<td><code>axis.line</code></td>
<td><code>element_line()</code></td>
</tr>
</tbody>
</table>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">df <span class="operator">%&gt;%</span></span><br><span class="line">ggplot<span class="punctuation">(</span>aes<span class="punctuation">(</span>x <span class="operator">=</span> displ<span class="punctuation">,</span>y <span class="operator">=</span> hwy<span class="punctuation">,</span> color <span class="operator">=</span> factor<span class="punctuation">(</span>cyl<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="operator">+</span></span><br><span class="line">geom_point<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">facet_grid<span class="punctuation">(</span>vars<span class="punctuation">(</span>manufacturer<span class="punctuation">)</span><span class="punctuation">,</span> vars<span class="punctuation">(</span><span class="built_in">class</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">ggtitle<span class="punctuation">(</span><span class="string">&quot;这是我的标题&quot;</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">labs<span class="punctuation">(</span>x <span class="operator">=</span> <span class="string">&quot;x_displ&quot;</span><span class="punctuation">,</span> y <span class="operator">=</span> <span class="string">&quot;y_hwy&quot;</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  theme<span class="punctuation">(</span></span><br><span class="line">    axis.line <span class="operator">=</span> element_line<span class="punctuation">(</span>color <span class="operator">=</span> <span class="string">&quot;orange&quot;</span><span class="punctuation">,</span> size <span class="operator">=</span> <span class="number">1</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">    axis.title <span class="operator">=</span> element_text<span class="punctuation">(</span>color <span class="operator">=</span> <span class="string">&quot;red&quot;</span><span class="punctuation">,</span> face <span class="operator">=</span> <span class="string">&quot;italic&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">    axis.ticks <span class="operator">=</span> element_line<span class="punctuation">(</span>color <span class="operator">=</span> <span class="string">&quot;purple&quot;</span><span class="punctuation">,</span> size <span class="operator">=</span> <span class="number">5</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">    axis.text <span class="operator">=</span> element_text<span class="punctuation">(</span>color <span class="operator">=</span> <span class="string">&quot;blue&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">    axis.text.x <span class="operator">=</span> element_text<span class="punctuation">(</span>angle <span class="operator">=</span> <span class="operator">-</span><span class="number">45</span><span class="punctuation">,</span> hjust <span class="operator">=</span> <span class="number">0</span><span class="punctuation">)</span></span><br><span class="line">  <span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261922958.png" alt=""></p>
<h3 id="面板元素">面板元素</h3>
<table>
<thead>
<tr>
<th>描述</th>
<th>主题元素</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>面板背景</td>
<td><code>panel.background</code></td>
<td><code>element_rect()</code></td>
</tr>
<tr>
<td>面板网格线</td>
<td><code>panel.grid</code></td>
<td><code>element_line()</code></td>
</tr>
<tr>
<td>面板边界</td>
<td><code>panel.border</code></td>
<td><code>element_rect()</code></td>
</tr>
</tbody>
</table>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">df <span class="operator">%&gt;%</span></span><br><span class="line">ggplot<span class="punctuation">(</span>aes<span class="punctuation">(</span>x <span class="operator">=</span> displ<span class="punctuation">,</span>y <span class="operator">=</span> hwy<span class="punctuation">,</span> color <span class="operator">=</span> factor<span class="punctuation">(</span>cyl<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="operator">+</span></span><br><span class="line">geom_point<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">facet_grid<span class="punctuation">(</span>vars<span class="punctuation">(</span>manufacturer<span class="punctuation">)</span><span class="punctuation">,</span> vars<span class="punctuation">(</span><span class="built_in">class</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">ggtitle<span class="punctuation">(</span><span class="string">&quot;这是我的标题&quot;</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">labs<span class="punctuation">(</span>x <span class="operator">=</span> <span class="string">&quot;x_displ&quot;</span><span class="punctuation">,</span> y <span class="operator">=</span> <span class="string">&quot;y_hwy&quot;</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  theme<span class="punctuation">(</span></span><br><span class="line">    panel.border <span class="operator">=</span> element_rect<span class="punctuation">(</span>color <span class="operator">=</span> <span class="string">&quot;purple&quot;</span><span class="punctuation">,</span> fill <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">    panel.background <span class="operator">=</span> element_rect<span class="punctuation">(</span>fill <span class="operator">=</span> <span class="string">&quot;orange&quot;</span><span class="punctuation">,</span> color <span class="operator">=</span> <span class="string">&quot;red&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">    panel.grid <span class="operator">=</span> element_line<span class="punctuation">(</span>color <span class="operator">=</span> <span class="string">&quot;grey80&quot;</span><span class="punctuation">,</span> size <span class="operator">=</span> <span class="number">0.5</span><span class="punctuation">)</span></span><br><span class="line">  <span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261922601.png" alt=""></p>
<h3 id="图例元素">图例元素</h3>
<table>
<thead>
<tr>
<th>描述</th>
<th>主题元素</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>图例背景</td>
<td><code>legend. background</code></td>
<td><code>element_rect()</code></td>
</tr>
<tr>
<td>符号</td>
<td><code>legend.key</code></td>
<td><code>element_rect()</code></td>
</tr>
<tr>
<td>标签</td>
<td><code>legend.text</code></td>
<td><code>element_text()</code></td>
</tr>
<tr>
<td>标题</td>
<td><code>legend.title</code></td>
<td><code>element_text()</code></td>
</tr>
<tr>
<td>边距</td>
<td><code>legend.margin</code></td>
<td><code>margin()</code></td>
</tr>
<tr>
<td>位置</td>
<td><code>legend.position</code></td>
<td>“top” “bottom” “left” “right”</td>
</tr>
</tbody>
</table>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">df <span class="operator">%&gt;%</span></span><br><span class="line">ggplot<span class="punctuation">(</span>aes<span class="punctuation">(</span>x <span class="operator">=</span> displ<span class="punctuation">,</span>y <span class="operator">=</span> hwy<span class="punctuation">,</span> color <span class="operator">=</span> factor<span class="punctuation">(</span>cyl<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="operator">+</span></span><br><span class="line">geom_point<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">facet_grid<span class="punctuation">(</span>vars<span class="punctuation">(</span>manufacturer<span class="punctuation">)</span><span class="punctuation">,</span> vars<span class="punctuation">(</span><span class="built_in">class</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">ggtitle<span class="punctuation">(</span><span class="string">&quot;这是我的标题&quot;</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">labs<span class="punctuation">(</span>x <span class="operator">=</span> <span class="string">&quot;x_displ&quot;</span><span class="punctuation">,</span> y <span class="operator">=</span> <span class="string">&quot;y_hwy&quot;</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  theme<span class="punctuation">(</span></span><br><span class="line">    legend.background <span class="operator">=</span> element_rect<span class="punctuation">(</span>color <span class="operator">=</span> <span class="string">&quot;orange&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">    legend.title <span class="operator">=</span> element_text<span class="punctuation">(</span>color <span class="operator">=</span> <span class="string">&quot;blue&quot;</span><span class="punctuation">,</span> size <span class="operator">=</span> <span class="number">20</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">    legend.key <span class="operator">=</span> element_rect<span class="punctuation">(</span>fill <span class="operator">=</span> <span class="string">&quot;grey80&quot;</span><span class="punctuation">,</span> color <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">    legend.text <span class="operator">=</span> element_text<span class="punctuation">(</span>color <span class="operator">=</span> <span class="string">&quot;red&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">    legend.margin <span class="operator">=</span> margin<span class="punctuation">(</span>t <span class="operator">=</span> <span class="number">5</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">    legend.position <span class="operator">=</span> <span class="string">&quot;top&quot;</span></span><br><span class="line">  <span class="punctuation">)</span> </span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261923599.png" alt=""></p>
<h3 id="分面元素">分面元素</h3>
<table>
<thead>
<tr>
<th>描述</th>
<th>主题元素</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>分面标签背景</td>
<td><code>strip.background</code></td>
<td><code>element_rect()</code></td>
</tr>
<tr>
<td>条状文本</td>
<td><code>strip.text</code></td>
<td><code>element_text()</code></td>
</tr>
<tr>
<td>分面间隔</td>
<td><code>panel.spacing</code></td>
<td>unit</td>
</tr>
</tbody>
</table>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">df <span class="operator">%&gt;%</span></span><br><span class="line">ggplot<span class="punctuation">(</span>aes<span class="punctuation">(</span>x <span class="operator">=</span> displ<span class="punctuation">,</span>y <span class="operator">=</span> hwy<span class="punctuation">,</span> color <span class="operator">=</span> factor<span class="punctuation">(</span>cyl<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="operator">+</span></span><br><span class="line">geom_point<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">facet_grid<span class="punctuation">(</span>vars<span class="punctuation">(</span>manufacturer<span class="punctuation">)</span><span class="punctuation">,</span> vars<span class="punctuation">(</span><span class="built_in">class</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">ggtitle<span class="punctuation">(</span><span class="string">&quot;这是我的标题&quot;</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">labs<span class="punctuation">(</span>x <span class="operator">=</span> <span class="string">&quot;x_displ&quot;</span><span class="punctuation">,</span> y <span class="operator">=</span> <span class="string">&quot;y_hwy&quot;</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  theme<span class="punctuation">(</span></span><br><span class="line">    strip.background <span class="operator">=</span> element_rect<span class="punctuation">(</span>fill <span class="operator">=</span> <span class="string">&quot;orange&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">    strip.text <span class="operator">=</span> element_text<span class="punctuation">(</span>color <span class="operator">=</span> <span class="string">&quot;red&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">    panel.spacing <span class="operator">=</span> unit<span class="punctuation">(</span><span class="number">0.1</span><span class="punctuation">,</span> <span class="string">&quot;cm&quot;</span><span class="punctuation">)</span></span><br><span class="line">  <span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261923530.png" alt=""></p>
<h2 id="标度">标度</h2>
<p><strong>映射</strong>是数据转化到图形属性，这里的图形属性是指视觉可以感知的东西，比如大小，形状，颜色和位置等，<strong>标度</strong>（<strong>scale</strong>）是控制着数据到图形属性映射的<strong>函数</strong>，每一种标度都是从数据空间的某个区域（标度的定义域）到图形属性空间的某个区域（标度的值域）的一个<strong>函数</strong>。</p>
<p>每一个视觉属性背后都有标度。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ggplot<span class="punctuation">(</span>mpg<span class="punctuation">,</span> aes<span class="punctuation">(</span>x <span class="operator">=</span> displ<span class="punctuation">,</span> y <span class="operator">=</span> hwy<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  geom_point<span class="punctuation">(</span>aes<span class="punctuation">(</span>color <span class="operator">=</span> <span class="built_in">class</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  labs<span class="punctuation">(</span>x <span class="operator">=</span> <span class="string">&quot;x轴&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261924829.png" alt=""></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ggplot<span class="punctuation">(</span>mpg<span class="punctuation">,</span> aes<span class="punctuation">(</span>x <span class="operator">=</span> displ<span class="punctuation">,</span> y <span class="operator">=</span> hwy<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  geom_point<span class="punctuation">(</span>aes<span class="punctuation">(</span>color <span class="operator">=</span> <span class="built_in">class</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  scale_x_continuous<span class="punctuation">(</span>name <span class="operator">=</span> <span class="string">&quot;x轴&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261925369.png" alt=""></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ggplot<span class="punctuation">(</span>mpg<span class="punctuation">,</span> aes<span class="punctuation">(</span>x <span class="operator">=</span> displ<span class="punctuation">,</span> y <span class="operator">=</span> hwy<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  geom_point<span class="punctuation">(</span>aes<span class="punctuation">(</span>color <span class="operator">=</span> <span class="built_in">class</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  scale_color_brewer<span class="punctuation">(</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261925448.png" alt=""></p>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261926053.png" alt=""></p>
<p>标度函数命名规则：</p>
<p>标度函数是由”_“分割的三个部分构成的。</p>
<ul>
<li>
<p>scale</p>
</li>
<li>
<p>视觉属性名（e.g., color, shape or x）</p>
</li>
<li>
<p>标度名（e.g., continuous, discrete, brewer）</p>
</li>
</ul>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261926883.png" alt=""></p>
<ul>
<li>
<p>参数<code>name</code>，坐标和图例的名字，如果不想要图例的名字，就可以<br>
<code>name = NULL</code></p>
</li>
<li>
<p>参数<code>limits</code>,<br>
坐标或图例的范围区间。连续性<code>c(n, m)</code>，离散型<code>c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)</code></p>
</li>
<li>
<p>参数<code>breaks</code>, 控制显示在坐标轴或者图例上的值（元素）</p>
</li>
<li>
<p>参数<code>labels</code>, 坐标和图例的间隔标签</p>
<ul>
<li>一般情况下，内置函数会自动完成</li>
<li>也可人工指定一个字符型向量，与<code>breaks</code>提供的字符型向量一一对应</li>
<li>也可以是函数，把<code>breaks</code>提供的字符型向量当做函数的输入</li>
<li><code>NULL</code>，就是去掉标签</li>
</ul>
</li>
<li>
<p>参数<code>values</code> 指的是（颜色、形状等）视觉属性值,</p>
<ul>
<li>要么，与数值的顺序一致；</li>
<li>要么，与<code>breaks</code>提供的字符型向量长度一致</li>
<li>要么，用命名向量<code>c(&quot;数据标签&quot; = &quot;视觉属性&quot;)</code>提供</li>
</ul>
</li>
<li>
<p>参数<code>expand</code>, 控制参数溢出量</p>
</li>
<li>
<p>参数<code>range</code>, 设置尺寸大小范围，比如针对点的相对大小</p>
</li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">gapdata <span class="operator">&lt;-</span> read_csv<span class="punctuation">(</span><span class="string">&quot;data/gapminder.csv&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">newgapdata <span class="operator">&lt;-</span> gapdata <span class="operator">%&gt;%</span> </span><br><span class="line">  group_by<span class="punctuation">(</span>continent<span class="punctuation">,</span> country<span class="punctuation">)</span> <span class="operator">%&gt;%</span> </span><br><span class="line">  summarise<span class="punctuation">(</span></span><br><span class="line">    across<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span>lifeExp<span class="punctuation">,</span> gdpPercap<span class="punctuation">,</span> pop<span class="punctuation">)</span><span class="punctuation">,</span> mean<span class="punctuation">)</span></span><br><span class="line">  <span class="punctuation">)</span></span><br><span class="line">newgapdata</span><br></pre></td></tr></table></figure>
<pre><code>#&gt; # A tibble: 142 × 5
#&gt; # Groups:   continent [5]
#&gt;    continent country                  lifeExp gdpPercap       pop
#&gt;    &lt;chr&gt;     &lt;chr&gt;                      &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;
#&gt;  1 Africa    Algeria                     59.0     4426. 19875406.
#&gt;  2 Africa    Angola                      37.9     3607.  7309390.
#&gt;  3 Africa    Benin                       48.8     1155.  4017497.
#&gt;  4 Africa    Botswana                    54.6     5032.   971186.
#&gt;  5 Africa    Burkina Faso                44.7      844.  7548677.
#&gt;  6 Africa    Burundi                     44.8      472.  4651608.
#&gt;  7 Africa    Cameroon                    48.1     1775.  9816648.
#&gt;  8 Africa    Central African Republic    43.9      959.  2560963 
#&gt;  9 Africa    Chad                        46.8     1165.  5329256.
#&gt; 10 Africa    Comoros                     52.4     1314.   361684.
#&gt; # ℹ 132 more rows
</code></pre>
<h3 id="坐标轴">坐标轴</h3>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">newgapdata <span class="operator">%&gt;%</span> </span><br><span class="line">  ggplot<span class="punctuation">(</span>aes<span class="punctuation">(</span>x <span class="operator">=</span> gdpPercap<span class="punctuation">,</span> y <span class="operator">=</span> lifeExp<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">    geom_point<span class="punctuation">(</span>aes<span class="punctuation">(</span>color <span class="operator">=</span> continent<span class="punctuation">,</span> size <span class="operator">=</span> pop<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">    scale_x_continuous<span class="punctuation">(</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261927264.png" alt=""></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">newgapdata <span class="operator">%&gt;%</span> </span><br><span class="line">  ggplot<span class="punctuation">(</span>aes<span class="punctuation">(</span>x <span class="operator">=</span> gdpPercap<span class="punctuation">,</span> y <span class="operator">=</span> lifeExp<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">    geom_point<span class="punctuation">(</span>aes<span class="punctuation">(</span>color <span class="operator">=</span> continent<span class="punctuation">,</span> size <span class="operator">=</span> pop<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">    scale_x_log10<span class="punctuation">(</span><span class="punctuation">)</span> </span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261928986.png" alt=""></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">newgapdata <span class="operator">%&gt;%</span> </span><br><span class="line">  ggplot<span class="punctuation">(</span>aes<span class="punctuation">(</span>x <span class="operator">=</span> gdpPercap<span class="punctuation">,</span> y <span class="operator">=</span> lifeExp<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">    geom_point<span class="punctuation">(</span>aes<span class="punctuation">(</span>color <span class="operator">=</span> continent<span class="punctuation">,</span> size <span class="operator">=</span> pop<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">    scale_x_log10<span class="punctuation">(</span></span><br><span class="line">      name <span class="operator">=</span> <span class="string">&quot;GDP per capita&quot;</span><span class="punctuation">,</span></span><br><span class="line">      breaks <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">500</span><span class="punctuation">,</span> <span class="number">1000</span><span class="punctuation">,</span> <span class="number">3000</span><span class="punctuation">,</span> <span class="number">10000</span><span class="punctuation">,</span> <span class="number">30000</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">      labels <span class="operator">=</span> scales<span class="operator">::</span>unit_format<span class="punctuation">(</span>unit <span class="operator">=</span> <span class="string">&quot;dollar&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261928876.png" alt=""></p>
<h3 id="颜色">颜色</h3>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">newgapdata <span class="operator">%&gt;%</span> </span><br><span class="line">  ggplot<span class="punctuation">(</span>aes<span class="punctuation">(</span>x <span class="operator">=</span> gdpPercap<span class="punctuation">,</span> y <span class="operator">=</span> lifeExp<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">    geom_point<span class="punctuation">(</span>aes<span class="punctuation">(</span>color <span class="operator">=</span> continent<span class="punctuation">,</span> size <span class="operator">=</span> pop<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">    scale_x_log10<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">    scale_color_viridis_d<span class="punctuation">(</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261929606.png" alt=""></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">newgapdata <span class="operator">%&gt;%</span> </span><br><span class="line">  ggplot<span class="punctuation">(</span>aes<span class="punctuation">(</span>x <span class="operator">=</span> gdpPercap<span class="punctuation">,</span> y <span class="operator">=</span> lifeExp<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">    geom_point<span class="punctuation">(</span>aes<span class="punctuation">(</span>color <span class="operator">=</span> continent<span class="punctuation">,</span> size <span class="operator">=</span> pop<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">    scale_x_log10<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">    scale_color_brewer<span class="punctuation">(</span>type <span class="operator">=</span> <span class="string">&quot;qual&quot;</span><span class="punctuation">,</span> palette <span class="operator">=</span> <span class="string">&quot;Set1&quot;</span><span class="punctuation">)</span> </span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261929736.png" alt=""></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">newgapdata <span class="operator">%&gt;%</span> </span><br><span class="line">  ggplot<span class="punctuation">(</span>aes<span class="punctuation">(</span>x <span class="operator">=</span> gdpPercap<span class="punctuation">,</span> y <span class="operator">=</span> lifeExp<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">    geom_point<span class="punctuation">(</span>aes<span class="punctuation">(</span>color <span class="operator">=</span> continent<span class="punctuation">,</span> size <span class="operator">=</span> pop<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">    scale_x_log10<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">    scale_color_manual<span class="punctuation">(</span></span><br><span class="line">      name <span class="operator">=</span> <span class="string">&quot;continents&quot;</span><span class="punctuation">,</span></span><br><span class="line">      values <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;Africa&quot;</span> <span class="operator">=</span> <span class="string">&quot;red&quot;</span><span class="punctuation">,</span> <span class="string">&quot;Americas&quot;</span> <span class="operator">=</span> <span class="string">&quot;blue&quot;</span><span class="punctuation">,</span> <span class="string">&quot;Asia&quot;</span> <span class="operator">=</span> <span class="string">&quot;orange&quot;</span><span class="punctuation">,</span></span><br><span class="line">                 <span class="string">&quot;Europe&quot;</span> <span class="operator">=</span> <span class="string">&quot;black&quot;</span><span class="punctuation">,</span> <span class="string">&quot;Oceania&quot;</span> <span class="operator">=</span> <span class="string">&quot;gray&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">      breaks <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;Africa&quot;</span><span class="punctuation">,</span> <span class="string">&quot;Americas&quot;</span><span class="punctuation">,</span> <span class="string">&quot;Asia&quot;</span><span class="punctuation">,</span> <span class="string">&quot;Europe&quot;</span><span class="punctuation">,</span> <span class="string">&quot;Oceania&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">      labels <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;africa&quot;</span><span class="punctuation">,</span> <span class="string">&quot;americas&quot;</span><span class="punctuation">,</span> <span class="string">&quot;asia&quot;</span><span class="punctuation">,</span> <span class="string">&quot;europe&quot;</span><span class="punctuation">,</span> <span class="string">&quot;oceania&quot;</span><span class="punctuation">)</span></span><br><span class="line">    <span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">   scale_size<span class="punctuation">(</span></span><br><span class="line">     name <span class="operator">=</span> <span class="string">&quot;population size&quot;</span><span class="punctuation">,</span></span><br><span class="line">     breaks <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">2e8</span><span class="punctuation">,</span> <span class="number">5e8</span><span class="punctuation">,</span> <span class="number">7e8</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">     labels <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;200 million&quot;</span><span class="punctuation">,</span> <span class="string">&quot;500 million&quot;</span><span class="punctuation">,</span> <span class="string">&quot;700 million&quot;</span><span class="punctuation">)</span></span><br><span class="line">   <span class="punctuation">)</span> </span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261929446.png" alt=""></p>
<p>用标度还是主题？</p>
<p>那什么时候用标度，什么时候用主题？这里有个原则：主题风格不会增加标签，也不会改变变量的范围，主题只会改变字体、大小、颜色等等。</p>
<h2 id="教程（一）">教程（一）</h2>
<p>加载包</p>
<p>加载数据</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">haven<span class="operator">::</span>read_dta<span class="punctuation">(</span><span class="string">&quot;data/auto.dta&quot;</span><span class="punctuation">)</span> <span class="operator">-&gt;</span> auto</span><br><span class="line">auto</span><br></pre></td></tr></table></figure>
<pre><code>#&gt; # A tibble: 74 × 12
#&gt;    make        price   mpg rep78 headroom trunk weight length  turn displacement
#&gt;    &lt;chr&gt;       &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;        &lt;dbl&gt;
#&gt;  1 AMC Concord  4099    22     3      2.5    11   2930    186    40          121
#&gt;  2 AMC Pacer    4749    17     3      3      11   3350    173    40          258
#&gt;  3 AMC Spirit   3799    22    NA      3      12   2640    168    35          121
#&gt;  4 Buick Cent…  4816    20     3      4.5    16   3250    196    40          196
#&gt;  5 Buick Elec…  7827    15     4      4      20   4080    222    43          350
#&gt;  6 Buick LeSa…  5788    18     3      4      21   3670    218    43          231
#&gt;  7 Buick Opel   4453    26    NA      3      10   2230    170    34          304
#&gt;  8 Buick Regal  5189    20     3      2      16   3280    200    42          196
#&gt;  9 Buick Rivi… 10372    16     3      3.5    17   3880    207    43          231
#&gt; 10 Buick Skyl…  4082    19     3      3.5    13   3400    200    42          231
#&gt; # ℹ 64 more rows
#&gt; # ℹ 2 more variables: gear_ratio &lt;dbl&gt;, foreign &lt;dbl+lbl&gt;
</code></pre>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="built_in">attributes</span><span class="punctuation">(</span>auto<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<pre><code>#&gt; $class
#&gt; [1] &quot;tbl_df&quot;     &quot;tbl&quot;        &quot;data.frame&quot;
#&gt; 
#&gt; $row.names
#&gt;  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
#&gt; [26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50
#&gt; [51] 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74
#&gt; 
#&gt; $label
#&gt; [1] &quot;1978 Automobile Data&quot;
#&gt; 
#&gt; $notes
#&gt; [1] &quot;1&quot;                                    
#&gt; [2] &quot;from Consumer Reports with permission&quot;
#&gt; 
#&gt; $names
#&gt;  [1] &quot;make&quot;         &quot;price&quot;        &quot;mpg&quot;          &quot;rep78&quot;        &quot;headroom&quot;    
#&gt;  [6] &quot;trunk&quot;        &quot;weight&quot;       &quot;length&quot;       &quot;turn&quot;         &quot;displacement&quot;
#&gt; [11] &quot;gear_ratio&quot;   &quot;foreign&quot;
</code></pre>
<p>创建ggplot2图</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ggplot<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">+</span> </span><br><span class="line">  geom_point<span class="punctuation">(</span>mapping <span class="operator">=</span> aes<span class="punctuation">(</span>x <span class="operator">=</span> weight<span class="punctuation">,</span> y <span class="operator">=</span> price<span class="punctuation">)</span><span class="punctuation">,</span> data <span class="operator">=</span> auto<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261930664.png" alt=""></p>
<p>美学映射</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ggplot<span class="punctuation">(</span>data <span class="operator">=</span> auto<span class="punctuation">)</span> <span class="operator">+</span> </span><br><span class="line">  geom_point<span class="punctuation">(</span>mapping <span class="operator">=</span> aes<span class="punctuation">(</span>x <span class="operator">=</span> weight<span class="punctuation">,</span> y <span class="operator">=</span> price<span class="punctuation">,</span> size <span class="operator">=</span> rep78<span class="punctuation">,</span> color <span class="operator">=</span> rep78<span class="punctuation">,</span> alpha <span class="operator">=</span> rep78<span class="punctuation">)</span><span class="punctuation">)</span> <span class="comment">#点的大小、颜色、透明度建立映射 </span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261930516.png" alt=""></p>
<p>rep为离散型变量，但是上图中的色彩映射，默认为连续型变量，将rep78设置为因子型变量，图例显示为离散型。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ggplot<span class="punctuation">(</span>data <span class="operator">=</span> auto<span class="punctuation">)</span> <span class="operator">+</span> </span><br><span class="line">  geom_point<span class="punctuation">(</span>mapping <span class="operator">=</span> aes<span class="punctuation">(</span>x <span class="operator">=</span> weight<span class="punctuation">,</span> y <span class="operator">=</span> price<span class="punctuation">,</span> size <span class="operator">=</span> rep78<span class="punctuation">,</span> color <span class="operator">=</span> factor<span class="punctuation">(</span>rep78<span class="punctuation">)</span><span class="punctuation">,</span> alpha <span class="operator">=</span> rep78<span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261931872.png" alt=""></p>
<p>将图例合并到一起，要解决两个问题：</p>
<ul>
<li>
<p>分类要一致</p>
</li>
<li>
<p>图例名字要统一</p>
</li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ggplot<span class="punctuation">(</span>data <span class="operator">=</span> auto <span class="operator">%&gt;%</span> </span><br><span class="line">         subset<span class="punctuation">(</span><span class="operator">!</span><span class="built_in">is.na</span><span class="punctuation">(</span>rep78<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span> </span><br><span class="line">  geom_point<span class="punctuation">(</span>mapping <span class="operator">=</span> aes<span class="punctuation">(</span>x <span class="operator">=</span> weight<span class="punctuation">,</span> y <span class="operator">=</span> price<span class="punctuation">,</span> size <span class="operator">=</span> rep78<span class="punctuation">,</span> color <span class="operator">=</span> factor<span class="punctuation">(</span>rep78<span class="punctuation">)</span><span class="punctuation">,</span> alpha <span class="operator">=</span> rep78<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  labs<span class="punctuation">(</span>color <span class="operator">=</span> <span class="string">&quot;rep78&quot;</span><span class="punctuation">)</span> <span class="comment">#修改轴、图例和plot的标签</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261931212.png" alt=""></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ggplot<span class="punctuation">(</span>data <span class="operator">=</span> auto <span class="operator">%&gt;%</span> </span><br><span class="line">         subset<span class="punctuation">(</span><span class="operator">!</span><span class="built_in">is.na</span><span class="punctuation">(</span>rep78<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span> </span><br><span class="line">  geom_point<span class="punctuation">(</span>mapping <span class="operator">=</span> aes<span class="punctuation">(</span>x <span class="operator">=</span> weight<span class="punctuation">,</span> y <span class="operator">=</span> price<span class="punctuation">,</span> size <span class="operator">=</span> rep78<span class="punctuation">,</span> color <span class="operator">=</span> factor<span class="punctuation">(</span>rep78<span class="punctuation">)</span><span class="punctuation">,</span> alpha <span class="operator">=</span> rep78<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  scale_color_discrete<span class="punctuation">(</span>name <span class="operator">=</span> <span class="string">&quot;rep78&quot;</span><span class="punctuation">)</span> <span class="comment">#利用标度修改图例标题</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261932217.png" alt=""></p>
<p>size的内容在aes()里为映射，在aes()外为设置</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ggplot<span class="punctuation">(</span>data <span class="operator">=</span> auto <span class="operator">%&gt;%</span> </span><br><span class="line">         subset<span class="punctuation">(</span><span class="operator">!</span><span class="built_in">is.na</span><span class="punctuation">(</span>rep78<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span> </span><br><span class="line">  geom_point<span class="punctuation">(</span>mapping <span class="operator">=</span> aes<span class="punctuation">(</span>x <span class="operator">=</span> weight<span class="punctuation">,</span> y <span class="operator">=</span> price<span class="punctuation">,</span> color <span class="operator">=</span> factor<span class="punctuation">(</span>rep78<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span> size <span class="operator">=</span> <span class="number">4</span><span class="punctuation">)</span> </span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261932191.png" alt=""></p>
<p><code>strok()</code>代表环的宽度</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ggplot<span class="punctuation">(</span>data <span class="operator">=</span> subset<span class="punctuation">(</span>auto<span class="punctuation">,</span> <span class="operator">!</span><span class="built_in">is.na</span><span class="punctuation">(</span>rep78<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span> </span><br><span class="line">  geom_point<span class="punctuation">(</span>mapping <span class="operator">=</span> aes<span class="punctuation">(</span>x <span class="operator">=</span> weight<span class="punctuation">,</span> y <span class="operator">=</span> price<span class="punctuation">,</span> stroke <span class="operator">=</span> rep78<span class="punctuation">)</span><span class="punctuation">,</span> shape <span class="operator">=</span> <span class="number">1</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261932851.png" alt=""></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">haven<span class="operator">::</span>read_dta<span class="punctuation">(</span><span class="string">&quot;data/world-covid19.dta&quot;</span><span class="punctuation">)</span> <span class="operator">-&gt;</span> df</span><br><span class="line"></span><br><span class="line">ggplot<span class="punctuation">(</span>df<span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  geom_line<span class="punctuation">(</span>aes<span class="punctuation">(</span>date<span class="punctuation">,</span> confirmed<span class="punctuation">,</span> group <span class="operator">=</span> country<span class="punctuation">)</span><span class="punctuation">)</span>  </span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261933411.png" alt=""></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ggplot<span class="punctuation">(</span>df<span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  geom_line<span class="punctuation">(</span>aes<span class="punctuation">(</span>date<span class="punctuation">,</span> confirmed<span class="punctuation">,</span> color <span class="operator">=</span> country<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  theme<span class="punctuation">(</span></span><br><span class="line">    legend.position <span class="operator">=</span> <span class="string">&quot;none&quot;</span></span><br><span class="line">  <span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261933924.png" alt=""></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在theme中修改图例位置为none，去掉图例</span></span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span><span class="operator">:</span><span class="number">5</span> <span class="operator">%&gt;%</span> </span><br><span class="line">  crossing<span class="punctuation">(</span><span class="number">1</span><span class="operator">:</span><span class="number">5</span><span class="punctuation">)</span> <span class="operator">%&gt;%</span> </span><br><span class="line">  set_names<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;x&quot;</span><span class="punctuation">,</span> <span class="string">&quot;y&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">%&gt;%</span> </span><br><span class="line">  mutate<span class="punctuation">(</span>z <span class="operator">=</span> <span class="built_in">as.numeric</span><span class="punctuation">(</span>row.names<span class="punctuation">(</span>.<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">%&gt;%</span> </span><br><span class="line">  ggplot<span class="punctuation">(</span>aes<span class="punctuation">(</span>x<span class="punctuation">,</span> y<span class="punctuation">,</span> shape <span class="operator">=</span> I<span class="punctuation">(</span>z<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span> </span><br><span class="line">  geom_point<span class="punctuation">(</span>size <span class="operator">=</span> <span class="number">5</span><span class="punctuation">,</span> color <span class="operator">=</span> <span class="string">&quot;red&quot;</span><span class="punctuation">,</span> fill <span class="operator">=</span> <span class="string">&quot;green&quot;</span><span class="punctuation">)</span> <span class="operator">+</span> </span><br><span class="line">  geom_label<span class="punctuation">(</span>aes<span class="punctuation">(</span>label <span class="operator">=</span> z<span class="punctuation">,</span> y <span class="operator">=</span> y <span class="operator">+</span> <span class="number">0.5</span><span class="punctuation">)</span><span class="punctuation">,</span> size <span class="operator">=</span> <span class="number">1.5</span><span class="punctuation">)</span> <span class="operator">+</span> </span><br><span class="line">  theme<span class="punctuation">(</span>axis.text <span class="operator">=</span> element_blank<span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">        axis.title <span class="operator">=</span> element_blank<span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261934468.png" alt=""></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># I(z)使得z变量直接用作点的形状，而不是尝试在aes()内部解释它。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">auto <span class="operator">%&gt;%</span> </span><br><span class="line">  count<span class="punctuation">(</span>rep78<span class="punctuation">)</span> <span class="operator">%&gt;%</span> </span><br><span class="line">  ggplot<span class="punctuation">(</span>aes<span class="punctuation">(</span>x <span class="operator">=</span> rep78<span class="punctuation">,</span> y <span class="operator">=</span> n<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  ggchicklet<span class="operator">::</span>geom_chicklet<span class="punctuation">(</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261934419.png" alt=""></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 圆角柱状图</span></span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">df <span class="operator">%&gt;%</span> </span><br><span class="line">  filter<span class="punctuation">(</span>country <span class="operator">%in%</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;中国&quot;</span><span class="punctuation">,</span> <span class="string">&quot;美国&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">%&gt;%</span> </span><br><span class="line">  ggplot<span class="punctuation">(</span>aes<span class="punctuation">(</span>x<span class="operator">=</span> date<span class="punctuation">,</span> y <span class="operator">=</span> confirmed<span class="punctuation">,</span> color <span class="operator">=</span> country<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  geom_line<span class="punctuation">(</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261934700.png" alt=""></p>
<p>位置调整</p>
<p>常见的柱状图</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ggplot<span class="punctuation">(</span>auto<span class="punctuation">)</span> <span class="operator">+</span> </span><br><span class="line">  geom_bar<span class="punctuation">(</span>aes<span class="punctuation">(</span>x <span class="operator">=</span> rep78<span class="punctuation">,</span>   fill <span class="operator">=</span> factor<span class="punctuation">(</span>rep78<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261935573.png" alt=""></p>
<p><code>geom_col()</code>是没有统计变换的<code>geom_bar()</code></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ggplot<span class="punctuation">(</span>auto<span class="punctuation">)</span> <span class="operator">+</span> </span><br><span class="line">  geom_bar<span class="punctuation">(</span></span><br><span class="line">    aes<span class="punctuation">(</span></span><br><span class="line">      x <span class="operator">=</span> rep78<span class="punctuation">,</span> </span><br><span class="line">      color <span class="operator">=</span> factor<span class="punctuation">(</span>foreign<span class="punctuation">)</span><span class="punctuation">,</span> </span><br><span class="line">      fill <span class="operator">=</span> factor<span class="punctuation">(</span>foreign<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">      position <span class="operator">=</span> position_identity<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line">    <span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  theme<span class="punctuation">(</span>legend.position <span class="operator">=</span>  <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0.2</span><span class="punctuation">,</span> <span class="number">0.7</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  labs<span class="punctuation">(</span>fill <span class="operator">=</span> <span class="string">&quot;foreign&quot;</span><span class="punctuation">,</span></span><br><span class="line">       color <span class="operator">=</span> <span class="string">&quot;foreign&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261936260.png" alt=""></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ggplot<span class="punctuation">(</span>auto<span class="punctuation">)</span> <span class="operator">+</span> </span><br><span class="line">  geom_bar<span class="punctuation">(</span></span><br><span class="line">    aes<span class="punctuation">(</span></span><br><span class="line">      x <span class="operator">=</span> rep78<span class="punctuation">,</span> </span><br><span class="line">      color <span class="operator">=</span> factor<span class="punctuation">(</span>foreign<span class="punctuation">)</span><span class="punctuation">,</span> </span><br><span class="line">      fill <span class="operator">=</span> factor<span class="punctuation">(</span>foreign<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">      position <span class="operator">=</span> position_dodge<span class="punctuation">(</span>width <span class="operator">=</span> <span class="number">0.3</span><span class="punctuation">)</span></span><br><span class="line">    <span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  theme<span class="punctuation">(</span>legend.position <span class="operator">=</span>  <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0.2</span><span class="punctuation">,</span> <span class="number">0.7</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  labs<span class="punctuation">(</span>fill <span class="operator">=</span> <span class="string">&quot;foreign&quot;</span><span class="punctuation">,</span></span><br><span class="line">       color <span class="operator">=</span> <span class="string">&quot;foreign&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261936622.png" alt=""></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ggplot<span class="punctuation">(</span>auto<span class="punctuation">)</span> <span class="operator">+</span> </span><br><span class="line">  geom_bar<span class="punctuation">(</span></span><br><span class="line">    aes<span class="punctuation">(</span></span><br><span class="line">      x <span class="operator">=</span> rep78<span class="punctuation">,</span> </span><br><span class="line">      color <span class="operator">=</span> factor<span class="punctuation">(</span>foreign<span class="punctuation">)</span><span class="punctuation">,</span> </span><br><span class="line">      fill <span class="operator">=</span> factor<span class="punctuation">(</span>foreign<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">      position <span class="operator">=</span> position_fill<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line">    <span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  theme<span class="punctuation">(</span></span><br><span class="line">    legend.position <span class="operator">=</span>  <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0.2</span><span class="punctuation">,</span> <span class="number">0.7</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">    legend.background <span class="operator">=</span> element_rect<span class="punctuation">(</span>fill <span class="operator">=</span> <span class="string">&quot;white&quot;</span><span class="punctuation">,</span> color <span class="operator">=</span> <span class="string">&quot;white&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  labs<span class="punctuation">(</span>fill <span class="operator">=</span> <span class="string">&quot;foreign&quot;</span><span class="punctuation">,</span></span><br><span class="line">       color <span class="operator">=</span> <span class="string">&quot;foreign&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261937879.png" alt=""></p>
<p>坐标系</p>
<p><code>coord_flip()</code></p>
<p><code>coord_fixed</code></p>
<p><code>coord_sf()</code></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>sf<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">read_sf<span class="punctuation">(</span><span class="string">&quot;data/world_high_resolution_mill.geo.json&quot;</span><span class="punctuation">)</span> <span class="operator">-&gt;</span> wdmp</span><br><span class="line">haven<span class="operator">::</span>read_dta<span class="punctuation">(</span><span class="string">&quot;data/world-covid19.dta&quot;</span><span class="punctuation">)</span> <span class="operator">-&gt;</span> df</span><br><span class="line"></span><br><span class="line">wdmp <span class="operator">%&gt;%</span> </span><br><span class="line">  left_join<span class="punctuation">(</span>df<span class="punctuation">,</span> by <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;code&quot;</span> <span class="operator">=</span> <span class="string">&quot;iso&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">%&gt;%</span> </span><br><span class="line">  subset<span class="punctuation">(</span>date <span class="operator">==</span> <span class="string">&quot;2020-06-10&quot;</span><span class="punctuation">)</span> <span class="operator">-&gt;</span> mydata</span><br><span class="line">mydata</span><br></pre></td></tr></table></figure>
<pre><code>#&gt; Simple feature collection with 180 features and 9 fields
#&gt; Geometry type: MULTIPOLYGON
#&gt; Dimension:     XY
#&gt; Bounding box:  xmin: -20015110 ymin: -6947577 xmax: 20015110 ymax: 12641180
#&gt; Projected CRS: World_Miller_Cylindrical
#&gt; # A tibble: 180 × 10
#&gt;    name    name_en code                   geometry country country_en date      
#&gt;    &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;        &lt;MULTIPOLYGON [m]&gt; &lt;chr&gt;   &lt;chr&gt;      &lt;date&gt;    
#&gt;  1 阿尔及… ALGERIA DZA   (((-245324.1 4068138, -2… 阿尔及… Algeria    2020-06-10
#&gt;  2 列支敦… Liecht… LIE   (((1067880 5656162, 1059… 列支敦… Liechtens… 2020-06-10
#&gt;  3 埃及    EGYPT   EGY   (((3961141 2619833, 3915… 埃及    Egypt      2020-06-10
#&gt;  4 孟加拉… BANGLA… BGD   (((10297641 2482880, 102… 孟加拉… Bangladesh 2020-06-10
#&gt;  5 尼日尔  Niger   NER   (((400866.4 1306467, 394… 尼日尔  Niger      2020-06-10
#&gt;  6 卡塔尔  QATAR   QAT   (((5699872 2791895, 5682… 卡塔尔  Qatar      2020-06-10
#&gt;  7 纳米比… NAMIBIA NAM   (((2223927 -2808902, 222… 纳米比… Namibia    2020-06-10
#&gt;  8 保加利… Bulgar… BGR   (((2486312 5005203, 2497… 保加利… Bulgaria   2020-06-10
#&gt;  9 玻利维… Bolivia BOL   (((-6966045 -2514366, -6… 玻利维… Bolivia    2020-06-10
#&gt; 10 加纳    Ghana   GHA   (((-299106.5 1058207, -3… 加纳    Ghana      2020-06-10
#&gt; # ℹ 170 more rows
#&gt; # ℹ 3 more variables: confirmed &lt;dbl&gt;, recovered &lt;dbl&gt;, deaths &lt;dbl&gt;
</code></pre>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">mydata <span class="operator">%&gt;%</span> </span><br><span class="line">  ggplot<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  geom_sf<span class="punctuation">(</span>aes<span class="punctuation">(</span>fill <span class="operator">=</span> confirmed<span class="punctuation">)</span><span class="punctuation">,</span> color <span class="operator">=</span> <span class="string">&quot;white&quot;</span><span class="punctuation">,</span> size <span class="operator">=</span> <span class="number">0.01</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  coord_sf<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">+</span> </span><br><span class="line">  guides<span class="punctuation">(</span>fill <span class="operator">=</span> guide_legend<span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  theme<span class="punctuation">(</span></span><br><span class="line">    panel.grid.major <span class="operator">=</span> element_blank<span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">    axis.ticks.x <span class="operator">=</span> element_blank<span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">    axis.text.x <span class="operator">=</span> element_blank<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line">  <span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  labs<span class="punctuation">(</span></span><br><span class="line">    fill <span class="operator">=</span> <span class="string">&quot;确诊人数&quot;</span><span class="punctuation">,</span></span><br><span class="line">    title <span class="operator">=</span> <span class="string">&quot;全球新馆疫情：2020-06-10&quot;</span><span class="punctuation">,</span></span><br><span class="line">    caption <span class="operator">=</span> <span class="string">&quot;数据来源&quot;</span></span><br><span class="line">    <span class="punctuation">)</span> </span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261937033.png" alt=""></p>
]]></content>
      <categories>
        <category>R</category>
        <category>ggplot2</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>ggplot2</tag>
      </tags>
  </entry>
  <entry>
    <title>(19)地图可视化</title>
    <url>/2023/09/26/2023-9-26-19%E5%9C%B0%E5%9B%BE%E5%8F%AF%E8%A7%86%E5%8C%96/</url>
    <content><![CDATA[<blockquote><p>本文由SCY原创，转载注明出处。</p>
</blockquote>
<p>本文主要讲解地图可视化</p>
<span id="more"></span>
<h1>填充地图</h1>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>sf<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>readxl<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>tidyverse<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">read_sf<span class="punctuation">(</span><span class="string">&quot;data/世界地图矢量数据(带九段线、南极).geojson&quot;</span><span class="punctuation">)</span> <span class="operator">-&gt;</span> wdmp</span><br><span class="line">wdmp</span><br></pre></td></tr></table></figure>
<pre><code>#&gt; Simple feature collection with 254 features and 1 field
#&gt; Geometry type: MULTIPOLYGON
#&gt; Dimension:     XY
#&gt; Bounding box:  xmin: -180 ymin: -89.9989 xmax: 180 ymax: 83.61018
#&gt; Geodetic CRS:  WGS 84
#&gt; # A tibble: 254 × 2
#&gt;    code                                                                 geometry
#&gt;    &lt;chr&gt;                                                      &lt;MULTIPOLYGON [°]&gt;
#&gt;  1 AIA   (((-63.00121 18.22178, -63.16002 18.1714, -63.15335 18.20028, -63.0260…
#&gt;  2 ALA   (((19.98951 60.35115, 20.0202 60.35089, 20.03385 60.35931, 20.08738 60…
#&gt;  3 ATA   (((-57.02065 -63.37282, -56.92737 -63.50553, -56.78185 -63.57167, -56.…
#&gt;  4 Ashm  (((123.5945 -12.4257, 123.5952 -12.43593, 123.5731 -12.43418, 123.5725…
#&gt;  5 BLM   (((-62.83192 17.87648, -62.84691 17.87519, -62.85895 17.88366, -62.869…
#&gt;  6 BMU   (((-64.73026 32.29346, -64.82015 32.25963, -64.84505 32.26229, -64.862…
#&gt;  7 COK   (((-159.7405 -21.24925, -159.7725 -21.2495, -159.8131 -21.24206, -159.…
#&gt;  8 CUW   (((-68.7511 12.05978, -68.80331 12.04547, -68.99514 12.14184, -69.1538…
#&gt;  9 CYN   (((34.00447 35.06525, 33.96571 35.05678, 33.90328 35.08546, 33.86644 3…
#&gt; 10 Gaza  (((34.24528 31.20833, 34.21252 31.29228, 34.19815 31.32261, 34.38729 3…
#&gt; # ℹ 244 more rows
</code></pre>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ggplot<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  geom_sf<span class="punctuation">(</span>data <span class="operator">=</span> wdmp<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261941040.png" alt=""></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">read_excel<span class="punctuation">(</span><span class="string">&quot;data/世界发展指标.xlsx&quot;</span><span class="punctuation">)</span> <span class="operator">-&gt;</span> df5</span><br><span class="line">df5 <span class="operator">|&gt;</span> </span><br><span class="line">  dplyr<span class="operator">::</span>filter<span class="punctuation">(</span>year <span class="operator">==</span><span class="number">2019</span><span class="punctuation">)</span> <span class="operator">|&gt;</span> </span><br><span class="line">  select<span class="punctuation">(</span>`GDP (current US$)`<span class="punctuation">,</span> code<span class="punctuation">,</span> country<span class="punctuation">)</span> <span class="operator">|&gt;</span> </span><br><span class="line">  full_join<span class="punctuation">(</span>wdmp<span class="punctuation">)</span> <span class="operator">|&gt;</span> </span><br><span class="line">  st_sf<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">-&gt;</span> dfn</span><br><span class="line"></span><br><span class="line">source<span class="punctuation">(</span><span class="string">&quot;theme.R&quot;</span><span class="punctuation">)</span></span><br><span class="line">ggplot<span class="punctuation">(</span>dfn<span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  geom_sf<span class="punctuation">(</span>aes<span class="punctuation">(</span>fill <span class="operator">=</span> `GDP (current US$)`<span class="punctuation">)</span><span class="punctuation">,</span> size <span class="operator">=</span> <span class="number">0.2</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  scico<span class="operator">::</span>scale_fill_scico<span class="punctuation">(</span>palette <span class="operator">=</span> <span class="string">&quot;davos&quot;</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  coord_sf<span class="punctuation">(</span>crs <span class="operator">=</span> <span class="string">&quot;+proj=robin&quot;</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  guides<span class="punctuation">(</span>fill <span class="operator">=</span> guide_legend<span class="punctuation">(</span>label.position <span class="operator">=</span> <span class="string">&quot;bottom&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  scale_y_continuous<span class="punctuation">(</span>breaks <span class="operator">=</span>  <span class="built_in">c</span><span class="punctuation">(</span>seq<span class="punctuation">(</span><span class="operator">-</span><span class="number">80</span><span class="punctuation">,</span> <span class="number">60</span><span class="punctuation">,</span><span class="number">20</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="number">85</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  labs<span class="punctuation">(</span>title <span class="operator">=</span> <span class="string">&quot;2019 年世界各国 GDP 数据（现价美元）&quot;</span><span class="punctuation">,</span></span><br><span class="line">       subtitle <span class="operator">=</span> <span class="string">&quot;绘制：An Cao &quot;</span><span class="punctuation">,</span></span><br><span class="line">       caption <span class="operator">=</span> <span class="string">&quot;数据来源：世界银行世界发展指标数据库\n&lt;http://databank.worldbank.org/data/download/WDI_csv.zip&gt;&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261942953.png" alt=""></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ggsave<span class="punctuation">(</span><span class="string">&quot;temp.png&quot;</span><span class="punctuation">,</span> width <span class="operator">=</span> <span class="number">10</span><span class="punctuation">,</span> height <span class="operator">=</span> <span class="number">6</span><span class="punctuation">)</span></span><br><span class="line">knitr<span class="operator">::</span>plot_crop<span class="punctuation">(</span><span class="string">&quot;temp.png&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<pre><code>#&gt; [1] &quot;temp.png&quot;
</code></pre>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ggsave<span class="punctuation">(</span><span class="string">&quot;temp.pdf&quot;</span><span class="punctuation">,</span> width <span class="operator">=</span> <span class="number">10</span><span class="punctuation">,</span> height <span class="operator">=</span> <span class="number">6</span><span class="punctuation">)</span></span><br><span class="line">knitr<span class="operator">::</span>plot_crop<span class="punctuation">(</span><span class="string">&quot;temp.pdf&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<pre><code>#&gt; [1] &quot;temp.pdf&quot;
</code></pre>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">dfn <span class="operator">|&gt;</span> </span><br><span class="line">  mutate<span class="punctuation">(</span>gdp <span class="operator">=</span> case_when<span class="punctuation">(</span></span><br><span class="line">    <span class="built_in">is.na</span><span class="punctuation">(</span>`GDP (current US$)`<span class="punctuation">)</span> <span class="operator">~</span> <span class="string">&quot;无数据&quot;</span><span class="punctuation">,</span></span><br><span class="line">    between<span class="punctuation">(</span>`GDP (current US$)`<span class="punctuation">,</span> <span class="number">0</span><span class="punctuation">,</span> <span class="number">1e8</span><span class="punctuation">)</span> <span class="operator">~</span> <span class="string">&quot;&lt; 1亿&quot;</span><span class="punctuation">,</span></span><br><span class="line">    between<span class="punctuation">(</span>`GDP (current US$)`<span class="punctuation">,</span> <span class="number">1e8</span><span class="punctuation">,</span> <span class="number">1e9</span><span class="punctuation">)</span> <span class="operator">~</span> <span class="string">&quot;1亿~10亿&quot;</span><span class="punctuation">,</span></span><br><span class="line">    between<span class="punctuation">(</span>`GDP (current US$)`<span class="punctuation">,</span> <span class="number">1e9</span><span class="punctuation">,</span> <span class="number">1e10</span><span class="punctuation">)</span> <span class="operator">~</span> <span class="string">&quot;10亿~100亿&quot;</span><span class="punctuation">,</span></span><br><span class="line">    between<span class="punctuation">(</span>`GDP (current US$)`<span class="punctuation">,</span> <span class="number">1e10</span><span class="punctuation">,</span> <span class="number">1e11</span><span class="punctuation">)</span> <span class="operator">~</span> <span class="string">&quot;100亿~1000亿&quot;</span><span class="punctuation">,</span></span><br><span class="line">    between<span class="punctuation">(</span>`GDP (current US$)`<span class="punctuation">,</span> <span class="number">1e11</span><span class="punctuation">,</span> <span class="number">1e12</span><span class="punctuation">)</span> <span class="operator">~</span> <span class="string">&quot;1000亿~1万亿&quot;</span><span class="punctuation">,</span></span><br><span class="line">    between<span class="punctuation">(</span>`GDP (current US$)`<span class="punctuation">,</span> <span class="number">1e12</span><span class="punctuation">,</span> <span class="number">1e13</span><span class="punctuation">)</span> <span class="operator">~</span> <span class="string">&quot;1万亿~10万亿&quot;</span><span class="punctuation">,</span></span><br><span class="line">    between<span class="punctuation">(</span>`GDP (current US$)`<span class="punctuation">,</span> <span class="number">1e13</span><span class="punctuation">,</span> <span class="number">1e14</span><span class="punctuation">)</span> <span class="operator">~</span> <span class="string">&quot;10万亿~100万亿&quot;</span></span><br><span class="line">  <span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">|&gt;</span> </span><br><span class="line">  mutate<span class="punctuation">(</span>gdp <span class="operator">=</span> factor<span class="punctuation">(</span>gdp<span class="punctuation">,</span> </span><br><span class="line">                      levels <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;无数据&quot;</span><span class="punctuation">,</span> <span class="string">&quot;&lt; 1亿&quot;</span><span class="punctuation">,</span></span><br><span class="line">                                 <span class="string">&quot;1亿~10亿&quot;</span><span class="punctuation">,</span> <span class="string">&quot;10亿~100亿&quot;</span><span class="punctuation">,</span></span><br><span class="line">                                 <span class="string">&quot;100亿~1000亿&quot;</span><span class="punctuation">,</span> <span class="string">&quot;1000亿~1万亿&quot;</span><span class="punctuation">,</span></span><br><span class="line">                                 <span class="string">&quot;1万亿~10万亿&quot;</span><span class="punctuation">,</span> <span class="string">&quot;10万亿~100万亿&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">-&gt;</span> dfn</span><br><span class="line"></span><br><span class="line">source<span class="punctuation">(</span><span class="string">&quot;theme.R&quot;</span><span class="punctuation">)</span></span><br><span class="line">ggplot<span class="punctuation">(</span>dfn<span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  geom_sf<span class="punctuation">(</span>aes<span class="punctuation">(</span>fill <span class="operator">=</span> gdp<span class="punctuation">)</span><span class="punctuation">,</span> size <span class="operator">=</span> <span class="number">0.2</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  scico<span class="operator">::</span>scale_fill_scico_d<span class="punctuation">(</span>palette <span class="operator">=</span> <span class="string">&quot;davos&quot;</span><span class="punctuation">,</span> direction <span class="operator">=</span> <span class="operator">-</span><span class="number">1</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  coord_sf<span class="punctuation">(</span>crs <span class="operator">=</span> <span class="string">&quot;+proj=robin&quot;</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  guides<span class="punctuation">(</span>fill <span class="operator">=</span> guide_legend<span class="punctuation">(</span>label.position <span class="operator">=</span> <span class="string">&quot;bottom&quot;</span><span class="punctuation">,</span> nrow <span class="operator">=</span> <span class="number">1</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  scale_y_continuous<span class="punctuation">(</span>breaks <span class="operator">=</span>  <span class="built_in">c</span><span class="punctuation">(</span>seq<span class="punctuation">(</span><span class="operator">-</span><span class="number">80</span><span class="punctuation">,</span> <span class="number">60</span><span class="punctuation">,</span><span class="number">20</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="number">85</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  labs<span class="punctuation">(</span>title <span class="operator">=</span> <span class="string">&quot;2019 年世界各国 GDP 数据（现价美元）&quot;</span><span class="punctuation">,</span></span><br><span class="line">       subtitle <span class="operator">=</span> <span class="string">&quot;绘制：An Cao &quot;</span><span class="punctuation">,</span></span><br><span class="line">       caption <span class="operator">=</span> <span class="string">&quot;数据来源：世界银行世界发展指标数据库\n&lt;http://databank.worldbank.org/data/download/WDI_csv.zip&gt;&quot;</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">    theme<span class="punctuation">(</span></span><br><span class="line">      legend.key.height <span class="operator">=</span> unit<span class="punctuation">(</span><span class="number">0.2</span><span class="punctuation">,</span> <span class="string">&quot;cm&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">      legend.key.width <span class="operator">=</span> unit<span class="punctuation">(</span><span class="number">1.25</span><span class="punctuation">,</span> <span class="string">&quot;cm&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">      legend.text <span class="operator">=</span> element_text<span class="punctuation">(</span>size <span class="operator">=</span> <span class="number">8</span><span class="punctuation">)</span> </span><br><span class="line">    <span class="punctuation">)</span> </span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261943559.png" alt=""></p>
<p>2019年各省地区生产总值</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">haven<span class="operator">::</span>read_dta<span class="punctuation">(</span><span class="string">&quot;data/各省历年GDP.dta&quot;</span><span class="punctuation">)</span> <span class="operator">|&gt;</span> </span><br><span class="line">  dplyr<span class="operator">::</span>filter<span class="punctuation">(</span>年份 <span class="operator">==</span> <span class="number">2019</span><span class="punctuation">,</span></span><br><span class="line">                省份 <span class="operator">!=</span> <span class="string">&quot;中国&quot;</span></span><br><span class="line">                <span class="punctuation">)</span> <span class="operator">|&gt;</span> </span><br><span class="line">  dplyr<span class="operator">::</span>select<span class="punctuation">(</span>省代码<span class="punctuation">,</span> 省 <span class="operator">=</span> 省份<span class="punctuation">,</span> 地区生产总值_亿元<span class="punctuation">)</span> <span class="operator">-&gt;</span> provdf </span><br><span class="line"></span><br><span class="line"><span class="comment"># 新增因子型变量</span></span><br><span class="line">provdf <span class="operator">|&gt;</span></span><br><span class="line">  mutate<span class="punctuation">(</span></span><br><span class="line">    gdp <span class="operator">=</span> case_when<span class="punctuation">(</span></span><br><span class="line">      <span class="built_in">is.na</span><span class="punctuation">(</span>地区生产总值_亿元<span class="punctuation">)</span> <span class="operator">~</span> <span class="string">&quot;无数据&quot;</span><span class="punctuation">,</span></span><br><span class="line">      between<span class="punctuation">(</span>地区生产总值_亿元<span class="punctuation">,</span> <span class="number">0</span><span class="punctuation">,</span> <span class="number">20000</span><span class="punctuation">)</span> <span class="operator">~</span> <span class="string">&quot;&lt; 20 千亿&quot;</span><span class="punctuation">,</span></span><br><span class="line">      between<span class="punctuation">(</span>地区生产总值_亿元<span class="punctuation">,</span> <span class="number">20000</span><span class="punctuation">,</span> <span class="number">40000</span><span class="punctuation">)</span> <span class="operator">~</span> <span class="string">&quot;20～40千亿&quot;</span><span class="punctuation">,</span></span><br><span class="line">      between<span class="punctuation">(</span>地区生产总值_亿元<span class="punctuation">,</span> <span class="number">40000</span><span class="punctuation">,</span> <span class="number">60000</span><span class="punctuation">)</span> <span class="operator">~</span> <span class="string">&quot;40～60千亿&quot;</span><span class="punctuation">,</span></span><br><span class="line">      between<span class="punctuation">(</span>地区生产总值_亿元<span class="punctuation">,</span> <span class="number">60000</span><span class="punctuation">,</span> <span class="number">80000</span><span class="punctuation">)</span> <span class="operator">~</span> <span class="string">&quot;60～80千亿&quot;</span><span class="punctuation">,</span></span><br><span class="line">      between<span class="punctuation">(</span>地区生产总值_亿元<span class="punctuation">,</span> <span class="number">80000</span><span class="punctuation">,</span> <span class="number">150000</span><span class="punctuation">)</span> <span class="operator">~</span> <span class="string">&quot;&gt; 80千亿&quot;</span></span><br><span class="line">    <span class="punctuation">)</span></span><br><span class="line">  <span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">  mutate<span class="punctuation">(</span>gdp <span class="operator">=</span> factor<span class="punctuation">(</span></span><br><span class="line">    gdp<span class="punctuation">,</span></span><br><span class="line">    levels <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;无数据&quot;</span><span class="punctuation">,</span></span><br><span class="line">               <span class="string">&quot;&lt; 20 千亿&quot;</span><span class="punctuation">,</span></span><br><span class="line">               <span class="string">&quot;20～40千亿&quot;</span><span class="punctuation">,</span></span><br><span class="line">               <span class="string">&quot;40～60千亿&quot;</span><span class="punctuation">,</span></span><br><span class="line">               <span class="string">&quot;60～80千亿&quot;</span><span class="punctuation">,</span></span><br><span class="line">               <span class="string">&quot;&gt; 80千亿&quot;</span><span class="punctuation">)</span></span><br><span class="line">  <span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">-&gt;</span> provdf</span><br><span class="line"></span><br><span class="line">read_sf<span class="punctuation">(</span><span class="string">&quot;data/china_prov_full_map.json&quot;</span><span class="punctuation">)</span> <span class="operator">|&gt;</span> </span><br><span class="line">  st_set_crs<span class="punctuation">(</span><span class="string">&quot;+proj=lcc +lat_1=30 +lat_2=62 +lat_0=0 +lon_0=105 +x_0=0 +y_0=0 +ellps=krass +units=m +no_defs&quot;</span><span class="punctuation">)</span> <span class="operator">-&gt;</span> prov</span><br><span class="line"></span><br><span class="line">prov <span class="operator">|&gt;</span> </span><br><span class="line">  left_join<span class="punctuation">(</span>provdf<span class="punctuation">)</span> <span class="operator">|&gt;</span> </span><br><span class="line">  select<span class="punctuation">(</span>省<span class="punctuation">,</span> 地区生产总值_亿元<span class="punctuation">,</span> gdp<span class="punctuation">)</span> <span class="operator">-&gt;</span> provdf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">library<span class="punctuation">(</span>ggspatial<span class="punctuation">)</span></span><br><span class="line">haven<span class="operator">::</span>read_dta<span class="punctuation">(</span><span class="string">&#x27;data/china_prov_label.dta&#x27;</span><span class="punctuation">)</span> <span class="operator">|&gt;</span> </span><br><span class="line">  dplyr<span class="operator">::</span>filter<span class="punctuation">(</span><span class="operator">!</span>name <span class="operator">%in%</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;1000km&quot;</span><span class="punctuation">,</span> <span class="string">&quot;N&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">-&gt;</span> provlabel</span><br><span class="line">provlabel</span><br></pre></td></tr></table></figure>
<pre><code>#&gt; # A tibble: 35 × 4
#&gt;       id         X        Y name  
#&gt;    &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt; &lt;chr&gt; 
#&gt;  1     1  1623938. 5866667. 黑龙江
#&gt;  2     2 -1609429. 5113455. 新疆  
#&gt;  3     3   621816. 4559114. 山西  
#&gt;  4     4    99683. 4501151. 宁夏  
#&gt;  5     5 -1532343. 4038557. 西藏  
#&gt;  6     6  1142137. 4495014. 山东  
#&gt;  7     7   780159. 4174676. 河南  
#&gt;  8     8  1325927. 4156136. 江苏  
#&gt;  9     9  1142714. 3994883. 安徽  
#&gt; 10    10   688818. 3846593. 湖北  
#&gt; # ℹ 25 more rows
</code></pre>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ggplot<span class="punctuation">(</span>provdf<span class="punctuation">)</span> <span class="operator">+</span> </span><br><span class="line">  geom_sf<span class="punctuation">(</span>aes<span class="punctuation">(</span>fill <span class="operator">=</span> gdp<span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">          color <span class="operator">=</span> <span class="string">&quot;gray30&quot;</span><span class="punctuation">,</span></span><br><span class="line">          size <span class="operator">=</span> <span class="number">0.2</span><span class="punctuation">)</span> <span class="operator">+</span> </span><br><span class="line">  geom_text<span class="punctuation">(</span>aes<span class="punctuation">(</span>X<span class="punctuation">,</span> Y<span class="punctuation">,</span> label <span class="operator">=</span> name<span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">            family <span class="operator">=</span> cnfont<span class="punctuation">,</span></span><br><span class="line">            size <span class="operator">=</span> <span class="number">3</span><span class="punctuation">,</span> color <span class="operator">=</span> <span class="string">&quot;gray40&quot;</span><span class="punctuation">,</span></span><br><span class="line">            data <span class="operator">=</span> provlabel<span class="punctuation">)</span> <span class="operator">+</span> </span><br><span class="line">  labs<span class="punctuation">(</span>title <span class="operator">=</span> <span class="string">&quot;2019 年中国各省地区生产总值&quot;</span><span class="punctuation">,</span></span><br><span class="line">       caption <span class="operator">=</span> <span class="string">&quot;数据来源：CSMAR 国泰安数据库&quot;</span><span class="punctuation">)</span> <span class="operator">+</span> </span><br><span class="line">  scico<span class="operator">::</span>scale_fill_scico_d<span class="punctuation">(</span>palette <span class="operator">=</span> <span class="string">&quot;davos&quot;</span><span class="punctuation">,</span> </span><br><span class="line">                            name <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> </span><br><span class="line">                            direction <span class="operator">=</span> <span class="operator">-</span><span class="number">1</span><span class="punctuation">)</span> <span class="operator">+</span> </span><br><span class="line">  scale_x_continuous<span class="punctuation">(</span>expand <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0.001</span><span class="punctuation">,</span> <span class="number">0.001</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  scale_y_continuous<span class="punctuation">(</span>expand <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0.001</span><span class="punctuation">,</span> <span class="number">0.001</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span> </span><br><span class="line">  guides<span class="punctuation">(</span>fill <span class="operator">=</span> guide_legend<span class="punctuation">(</span>nrow <span class="operator">=</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">                             label.position <span class="operator">=</span> <span class="string">&quot;top&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span> </span><br><span class="line">  annotation_scale<span class="punctuation">(</span></span><br><span class="line">    width_hint <span class="operator">=</span> <span class="number">0.2</span><span class="punctuation">,</span></span><br><span class="line">    text_family <span class="operator">=</span> cnfont</span><br><span class="line">  <span class="punctuation">)</span> <span class="operator">+</span> </span><br><span class="line">  annotation_north_arrow<span class="punctuation">(</span></span><br><span class="line">    location <span class="operator">=</span> <span class="string">&quot;tr&quot;</span><span class="punctuation">,</span> which_north <span class="operator">=</span> <span class="string">&quot;false&quot;</span><span class="punctuation">,</span></span><br><span class="line">    width <span class="operator">=</span> unit<span class="punctuation">(</span><span class="number">1.6</span><span class="punctuation">,</span> <span class="string">&quot;cm&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> </span><br><span class="line">    height <span class="operator">=</span> unit<span class="punctuation">(</span><span class="number">2</span><span class="punctuation">,</span> <span class="string">&quot;cm&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">    style <span class="operator">=</span> north_arrow_fancy_orienteering<span class="punctuation">(</span></span><br><span class="line">      text_family <span class="operator">=</span> cnfont</span><br><span class="line">    <span class="punctuation">)</span></span><br><span class="line">  <span class="punctuation">)</span> <span class="operator">+</span> </span><br><span class="line">  theme<span class="punctuation">(</span>axis.title.x <span class="operator">=</span> element_blank<span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">        axis.title.y <span class="operator">=</span> element_blank<span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">        panel.grid.major <span class="operator">=</span> element_blank<span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">        axis.text.x <span class="operator">=</span> element_blank<span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">        axis.text.y <span class="operator">=</span> element_blank<span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261943847.png" alt=""></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ggsave<span class="punctuation">(</span><span class="string">&quot;2019中国各省GDP.png&quot;</span><span class="punctuation">,</span> width <span class="operator">=</span> <span class="number">9</span><span class="punctuation">,</span> height <span class="operator">=</span> <span class="number">9</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">knitr<span class="operator">::</span>plot_crop<span class="punctuation">(</span><span class="string">&#x27;2019中国各省GDP.png&#x27;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<pre><code>#&gt; [1] &quot;2019中国各省GDP.png&quot;
</code></pre>
<p>分面绘制</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">haven<span class="operator">::</span>read_dta<span class="punctuation">(</span><span class="string">&#x27;data/各省历年GDP.dta&#x27;</span><span class="punctuation">)</span> <span class="operator">|&gt;</span> </span><br><span class="line">  dplyr<span class="operator">::</span>filter<span class="punctuation">(</span>省份 <span class="operator">!=</span> <span class="string">&quot;中国&quot;</span><span class="punctuation">,</span> </span><br><span class="line">                  年份 <span class="operator">%in%</span> <span class="number">2014</span><span class="operator">:</span><span class="number">2019</span><span class="punctuation">)</span> <span class="operator">|&gt;</span> </span><br><span class="line">  full_join<span class="punctuation">(</span>prov<span class="punctuation">)</span> <span class="operator">|&gt;</span>  </span><br><span class="line">  st_sf<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">|&gt;</span> </span><br><span class="line">  select<span class="punctuation">(</span>省份<span class="punctuation">,</span> 年份<span class="punctuation">,</span> 地区生产总值_亿元<span class="punctuation">)</span> <span class="operator">-&gt;</span> provdf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bind_rows<span class="punctuation">(</span></span><br><span class="line">  provdf <span class="operator">|&gt;</span></span><br><span class="line">    dplyr<span class="operator">::</span>filter<span class="punctuation">(</span>年份 <span class="operator">==</span> <span class="number">2014</span> <span class="operator">|</span> <span class="built_in">is.na</span><span class="punctuation">(</span>年份<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">|&gt;</span> </span><br><span class="line">    mutate<span class="punctuation">(</span>年份 <span class="operator">=</span> if_else<span class="punctuation">(</span><span class="built_in">is.na</span><span class="punctuation">(</span>年份<span class="punctuation">)</span><span class="punctuation">,</span> <span class="number">2014</span><span class="punctuation">,</span> 年份<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">  provdf <span class="operator">|&gt;</span></span><br><span class="line">    dplyr<span class="operator">::</span>filter<span class="punctuation">(</span>年份 <span class="operator">==</span> <span class="number">2015</span> <span class="operator">|</span> <span class="built_in">is.na</span><span class="punctuation">(</span>年份<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">|&gt;</span> </span><br><span class="line">    mutate<span class="punctuation">(</span>年份 <span class="operator">=</span> if_else<span class="punctuation">(</span><span class="built_in">is.na</span><span class="punctuation">(</span>年份<span class="punctuation">)</span><span class="punctuation">,</span> <span class="number">2015</span><span class="punctuation">,</span> 年份<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">  provdf <span class="operator">|&gt;</span></span><br><span class="line">    dplyr<span class="operator">::</span>filter<span class="punctuation">(</span>年份 <span class="operator">==</span> <span class="number">2016</span> <span class="operator">|</span> <span class="built_in">is.na</span><span class="punctuation">(</span>年份<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">|&gt;</span> </span><br><span class="line">    mutate<span class="punctuation">(</span>年份 <span class="operator">=</span> if_else<span class="punctuation">(</span><span class="built_in">is.na</span><span class="punctuation">(</span>年份<span class="punctuation">)</span><span class="punctuation">,</span> <span class="number">2016</span><span class="punctuation">,</span> 年份<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">  provdf <span class="operator">|&gt;</span></span><br><span class="line">    dplyr<span class="operator">::</span>filter<span class="punctuation">(</span>年份 <span class="operator">==</span> <span class="number">2017</span> <span class="operator">|</span> <span class="built_in">is.na</span><span class="punctuation">(</span>年份<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">|&gt;</span> </span><br><span class="line">    mutate<span class="punctuation">(</span>年份 <span class="operator">=</span> if_else<span class="punctuation">(</span><span class="built_in">is.na</span><span class="punctuation">(</span>年份<span class="punctuation">)</span><span class="punctuation">,</span> <span class="number">2017</span><span class="punctuation">,</span> 年份<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">  provdf <span class="operator">|&gt;</span></span><br><span class="line">    dplyr<span class="operator">::</span>filter<span class="punctuation">(</span>年份 <span class="operator">==</span> <span class="number">2018</span> <span class="operator">|</span> <span class="built_in">is.na</span><span class="punctuation">(</span>年份<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">|&gt;</span> </span><br><span class="line">    mutate<span class="punctuation">(</span>年份 <span class="operator">=</span> if_else<span class="punctuation">(</span><span class="built_in">is.na</span><span class="punctuation">(</span>年份<span class="punctuation">)</span><span class="punctuation">,</span> <span class="number">2018</span><span class="punctuation">,</span> 年份<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">  provdf <span class="operator">|&gt;</span></span><br><span class="line">    dplyr<span class="operator">::</span>filter<span class="punctuation">(</span>年份 <span class="operator">==</span> <span class="number">2019</span> <span class="operator">|</span> <span class="built_in">is.na</span><span class="punctuation">(</span>年份<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">|&gt;</span> </span><br><span class="line">    mutate<span class="punctuation">(</span>年份 <span class="operator">=</span> if_else<span class="punctuation">(</span><span class="built_in">is.na</span><span class="punctuation">(</span>年份<span class="punctuation">)</span><span class="punctuation">,</span> <span class="number">2019</span><span class="punctuation">,</span> 年份<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">)</span> <span class="operator">-&gt;</span> provdf2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加gdp因子变量</span></span><br><span class="line">provdf2 <span class="operator">|&gt;</span> </span><br><span class="line">  mutate<span class="punctuation">(</span>gdp <span class="operator">=</span> case_when<span class="punctuation">(</span></span><br><span class="line">    <span class="built_in">is.na</span><span class="punctuation">(</span>地区生产总值_亿元<span class="punctuation">)</span> <span class="operator">~</span> <span class="string">&quot;无数据&quot;</span><span class="punctuation">,</span></span><br><span class="line">    between<span class="punctuation">(</span>地区生产总值_亿元<span class="punctuation">,</span> <span class="number">0</span><span class="punctuation">,</span> <span class="number">20000</span><span class="punctuation">)</span> <span class="operator">~</span> <span class="string">&quot;&lt; 20 千亿&quot;</span><span class="punctuation">,</span></span><br><span class="line">    between<span class="punctuation">(</span>地区生产总值_亿元<span class="punctuation">,</span> <span class="number">20000</span><span class="punctuation">,</span> <span class="number">40000</span><span class="punctuation">)</span> <span class="operator">~</span> <span class="string">&quot;20～40千亿&quot;</span><span class="punctuation">,</span></span><br><span class="line">    between<span class="punctuation">(</span>地区生产总值_亿元<span class="punctuation">,</span> <span class="number">40000</span><span class="punctuation">,</span> <span class="number">60000</span><span class="punctuation">)</span> <span class="operator">~</span> <span class="string">&quot;40～60千亿&quot;</span><span class="punctuation">,</span></span><br><span class="line">    between<span class="punctuation">(</span>地区生产总值_亿元<span class="punctuation">,</span> <span class="number">60000</span><span class="punctuation">,</span> <span class="number">80000</span><span class="punctuation">)</span> <span class="operator">~</span> <span class="string">&quot;60～80千亿&quot;</span><span class="punctuation">,</span></span><br><span class="line">    between<span class="punctuation">(</span>地区生产总值_亿元<span class="punctuation">,</span> <span class="number">80000</span><span class="punctuation">,</span> <span class="number">200000</span><span class="punctuation">)</span> <span class="operator">~</span> <span class="string">&quot;&gt; 80千亿&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">|&gt;</span> </span><br><span class="line">  mutate<span class="punctuation">(</span>gdp <span class="operator">=</span> factor<span class="punctuation">(</span>gdp<span class="punctuation">,</span> </span><br><span class="line">                     levels <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;无数据&quot;</span><span class="punctuation">,</span></span><br><span class="line">                                <span class="string">&quot;&lt; 20 千亿&quot;</span><span class="punctuation">,</span></span><br><span class="line">                                <span class="string">&quot;20～40千亿&quot;</span><span class="punctuation">,</span></span><br><span class="line">                                <span class="string">&quot;40～60千亿&quot;</span><span class="punctuation">,</span></span><br><span class="line">                                <span class="string">&quot;60～80千亿&quot;</span><span class="punctuation">,</span></span><br><span class="line">                                <span class="string">&quot;&gt; 80千亿&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">-&gt;</span> provdf3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ggplot<span class="punctuation">(</span>provdf3<span class="punctuation">)</span> <span class="operator">+</span> </span><br><span class="line">  geom_sf<span class="punctuation">(</span>aes<span class="punctuation">(</span>fill <span class="operator">=</span> gdp<span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">          color <span class="operator">=</span> <span class="string">&quot;gray30&quot;</span><span class="punctuation">,</span></span><br><span class="line">          size <span class="operator">=</span> <span class="number">0.2</span><span class="punctuation">)</span> <span class="operator">+</span> </span><br><span class="line">  facet_wrap<span class="punctuation">(</span><span class="operator">~</span>年份<span class="punctuation">,</span> nrow <span class="operator">=</span> <span class="number">2</span><span class="punctuation">)</span> <span class="operator">+</span> </span><br><span class="line">  labs<span class="punctuation">(</span>title <span class="operator">=</span> <span class="string">&quot;2014～2019 年中国各省地区生产总值&quot;</span><span class="punctuation">,</span></span><br><span class="line">       caption <span class="operator">=</span> <span class="string">&quot;数据来源：CSMAR 国泰安数据库&quot;</span><span class="punctuation">)</span> <span class="operator">+</span> </span><br><span class="line">  scico<span class="operator">::</span>scale_fill_scico_d<span class="punctuation">(</span>palette <span class="operator">=</span> <span class="string">&quot;davos&quot;</span><span class="punctuation">,</span> </span><br><span class="line">                            name <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> </span><br><span class="line">                            direction <span class="operator">=</span> <span class="operator">-</span><span class="number">1</span><span class="punctuation">)</span> <span class="operator">+</span> </span><br><span class="line">  scale_x_continuous<span class="punctuation">(</span>expand <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0.001</span><span class="punctuation">,</span> <span class="number">0.001</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  scale_y_continuous<span class="punctuation">(</span>expand <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0.001</span><span class="punctuation">,</span> <span class="number">0.001</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span> </span><br><span class="line">  annotation_scale<span class="punctuation">(</span></span><br><span class="line">    width_hint <span class="operator">=</span> <span class="number">0.2</span><span class="punctuation">,</span> </span><br><span class="line">    height <span class="operator">=</span> unit<span class="punctuation">(</span><span class="number">0.15</span><span class="punctuation">,</span> <span class="string">&quot;cm&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">    text_family <span class="operator">=</span> cnfont</span><br><span class="line">  <span class="punctuation">)</span> <span class="operator">+</span> </span><br><span class="line">  annotation_north_arrow<span class="punctuation">(</span></span><br><span class="line">    location <span class="operator">=</span> <span class="string">&quot;bl&quot;</span><span class="punctuation">,</span> which_north <span class="operator">=</span> <span class="string">&quot;false&quot;</span><span class="punctuation">,</span> </span><br><span class="line">    pad_y <span class="operator">=</span> unit<span class="punctuation">(</span><span class="number">0.4</span><span class="punctuation">,</span> <span class="string">&quot;cm&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">    pad_x <span class="operator">=</span> unit<span class="punctuation">(</span><span class="number">0.8</span><span class="punctuation">,</span> <span class="string">&quot;cm&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">    width <span class="operator">=</span> unit<span class="punctuation">(</span><span class="number">0.6</span><span class="punctuation">,</span> <span class="string">&quot;cm&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> </span><br><span class="line">    height <span class="operator">=</span> unit<span class="punctuation">(</span><span class="number">0.8</span><span class="punctuation">,</span> <span class="string">&quot;cm&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">    style <span class="operator">=</span> north_arrow_fancy_orienteering<span class="punctuation">(</span></span><br><span class="line">      text_family <span class="operator">=</span> cnfont</span><br><span class="line">    <span class="punctuation">)</span></span><br><span class="line">  <span class="punctuation">)</span> <span class="operator">+</span> </span><br><span class="line">  theme<span class="punctuation">(</span>axis.title.x <span class="operator">=</span> element_blank<span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">        axis.title.y <span class="operator">=</span> element_blank<span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">,</span> </span><br><span class="line">        strip.text <span class="operator">=</span> element_text<span class="punctuation">(</span>family <span class="operator">=</span> cnfont<span class="punctuation">,</span></span><br><span class="line">                                  colour <span class="operator">=</span> <span class="string">&quot;gray30&quot;</span><span class="punctuation">,</span></span><br><span class="line">                                  hjust <span class="operator">=</span> <span class="number">0.5</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">        legend.position <span class="operator">=</span> <span class="string">&quot;bottom&quot;</span><span class="punctuation">,</span></span><br><span class="line">        plot.margin <span class="operator">=</span> unit<span class="punctuation">(</span><span class="built_in">rep</span><span class="punctuation">(</span><span class="number">0.5</span><span class="punctuation">,</span> <span class="number">4</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="string">&quot;cm&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">        axis.text.x <span class="operator">=</span> element_blank<span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">        axis.text.y <span class="operator">=</span> element_blank<span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">        panel.grid.major <span class="operator">=</span> element_blank<span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span> </span><br><span class="line">  guides<span class="punctuation">(</span>fill <span class="operator">=</span> guide_legend<span class="punctuation">(</span>nrow <span class="operator">=</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">                             title.position <span class="operator">=</span> <span class="string">&quot;top&quot;</span><span class="punctuation">,</span></span><br><span class="line">                             title.hjust <span class="operator">=</span> <span class="number">0.5</span><span class="punctuation">,</span></span><br><span class="line">                             label.position <span class="operator">=</span> <span class="string">&quot;top&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261944677.png" alt=""></p>
<h1>瞄点地图</h1>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 描点地图</span></span><br><span class="line">library<span class="punctuation">(</span>sf<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>readr<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>tidyverse<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>hrbrthemes<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>ggtext<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">read_sf<span class="punctuation">(</span><span class="string">&#x27;data/世界地图矢量数据(带九段线、南极).geojson&#x27;</span><span class="punctuation">)</span> <span class="operator">|&gt;</span> </span><br><span class="line">  st_transform<span class="punctuation">(</span>crs <span class="operator">=</span> <span class="number">4326</span><span class="punctuation">)</span> <span class="operator">-&gt;</span> worldmap</span><br><span class="line"></span><br><span class="line">read_csv<span class="punctuation">(</span><span class="string">&#x27;data/data-bKvwd.csv&#x27;</span><span class="punctuation">)</span> <span class="operator">|&gt;</span> </span><br><span class="line">  st_as_sf<span class="punctuation">(</span>coords <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;Lon&quot;</span><span class="punctuation">,</span> <span class="string">&quot;Lat&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> crs <span class="operator">=</span> <span class="number">4326</span><span class="punctuation">)</span> <span class="operator">|&gt;</span> </span><br><span class="line">  select<span class="punctuation">(</span>`<span class="number">2000</span><span class="operator">-</span><span class="number">2016</span>`, City, category, geometry) |&gt; </span><br><span class="line">  mutate(`2000<span class="operator">-</span><span class="number">2016</span>` =  as.numeric(`2000<span class="operator">-</span><span class="number">2016</span>`)) -&gt; df</span><br><span class="line"></span><br><span class="line">df</span><br></pre></td></tr></table></figure>
<pre><code>#&gt; Simple feature collection with 503 features and 3 fields
#&gt; Geometry type: POINT
#&gt; Dimension:     XY
#&gt; Bounding box:  xmin: -123.12 ymin: -37.81 xmax: 174.77 ymax: 60.17
#&gt; Geodetic CRS:  WGS 84
#&gt; # A tibble: 503 × 4
#&gt;    `2000-2016` City           category                 geometry
#&gt;  *       &lt;dbl&gt; &lt;chr&gt;          &lt;chr&gt;                 &lt;POINT [°]&gt;
#&gt;  1         1.3 Melbourne      between 0 and 2.5 (144.96 -37.81)
#&gt;  2         1.5 Auckland       between 0 and 2.5 (174.77 -36.87)
#&gt;  3         0.6 Adelaide       between 0 and 2.5  (138.6 -34.93)
#&gt;  4         0.4 Montevideo     between 0 and 2.5 (-56.17 -34.83)
#&gt;  5         1.3 Buenos Aires   between 0 and 2.5  (-58.4 -34.61)
#&gt;  6         1.9 Cape Town      between 0 and 2.5  (18.42 -33.93)
#&gt;  7         1.3 Port Elizabeth between 0 and 2.5  (25.57 -33.92)
#&gt;  8         0.7 Sydney         between 0 and 2.5 (151.21 -33.87)
#&gt;  9         0.9 Santiago       between 0 and 2.5 (-70.65 -33.46)
#&gt; 10         1.2 Rosario        between 0 and 2.5 (-60.64 -32.95)
#&gt; # ℹ 493 more rows
</code></pre>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ggplot<span class="punctuation">(</span>worldmap<span class="punctuation">)</span> <span class="operator">+</span> </span><br><span class="line">  geom_sf<span class="punctuation">(</span>size <span class="operator">=</span> <span class="number">0.1</span><span class="punctuation">,</span> color <span class="operator">=</span> <span class="string">&quot;black&quot;</span><span class="punctuation">,</span> </span><br><span class="line">          fill <span class="operator">=</span> <span class="string">&quot;#F3F3F3&quot;</span><span class="punctuation">)</span> <span class="operator">+</span> </span><br><span class="line">  geom_sf<span class="punctuation">(</span>data <span class="operator">=</span> df<span class="punctuation">,</span> aes<span class="punctuation">(</span>size <span class="operator">=</span> `<span class="number">2000</span><span class="operator">-</span><span class="number">2016</span>` + 1, </span><br><span class="line">                         color = category),</span><br><span class="line">          alpha = 0.5) + </span><br><span class="line">  scale_size_continuous(range = c(1, 5)) + </span><br><span class="line">  scale_color_manual(values = c(&quot;negative&quot; = &quot;#FDAB62&quot;,</span><br><span class="line">                                &quot;between 0 and 2.5&quot; = &quot;#9CDAE6&quot;,</span><br><span class="line">                                &quot;between 2.5 and 5&quot; = &quot;#189DB6&quot;,</span><br><span class="line">                                &quot;5 or more&quot; = &quot;#244C6A&quot;,</span><br><span class="line">                                &quot;null&quot; = NA)) + </span><br><span class="line">  theme(legend.position = &quot;none&quot;, </span><br><span class="line">        axis.text.x = element_blank()) + </span><br><span class="line">  labs(title = &quot;大城市发展的有多快？&quot;,</span><br><span class="line">       subtitle = &quot;该图展示了 2016 年所有人口超过 100 万的大城市，圆圈的大小和颜色表示 2000 年到 2016 年间城市人口的平均增长速度。&lt;b&gt;&lt;span style=&#x27;color:\&quot;#FDAB62\&quot;&#x27;&gt;负增长&lt;/span&gt; / &lt;span style=&#x27;color:\&quot;#9CDAE6\&quot;;&#x27;&gt;0 - 2.5%&lt;/span&gt; / &lt;span style=&#x27;color:\&quot;#189DB6\&quot;;&#x27;&gt;2.5% - 5%&lt;/span&gt; / &lt;span style=&#x27;color:\&quot;#244C6A\&quot;;&#x27;&gt;超过 5%&lt;/span&gt;&lt;/b&gt;&quot;,</span><br><span class="line">       caption = &quot;数据来源: How fast do big cities grow? | Created with Datawrapper\n&lt;https://www.datawrapper.de/_/bKvwd/&gt;&quot;) + </span><br><span class="line">  theme(plot.subtitle = element_textbox_simple(),</span><br><span class="line">        plot.background = element_rect(color = &quot;gray80&quot;)) + </span><br><span class="line">  coord_sf(crs = &quot;+proj=robin&quot;)</span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309261945685.png" alt=""></p>
]]></content>
      <categories>
        <category>R</category>
        <category>Visualization</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>Visualization</tag>
      </tags>
  </entry>
  <entry>
    <title>(15)生态</title>
    <url>/2023/08/24/2023-8-24-15%E7%94%9F%E6%80%81/</url>
    <content><![CDATA[<blockquote><p>本文由SCY翻译自《Geocomputation with R》<a href="https://r.geocompx.org/eco">第十五章</a></p>
</blockquote>
<p>本章通过模拟雾绿洲（也叫<em>lomas</em>）的植被分布，揭示了明显受到水源供应控制的不同植被区域。这个案例研究不仅整合了前几章中的核心观点，还拓展了这些观点，帮助你更全面地掌握使用R进行地理计算的相关技能。</p>
<span id="more"></span>
<h1>前提条件</h1>
<p>本章假设你已经掌握了地理数据分析和处理的基础知识，这在<em>空间数据</em>章至<em>几何操作</em>章中进行了涵盖。本章利用了 GIS 软件的桥梁，以及在<em>GIS桥梁</em>和<em>统计学习</em>章中涉及到的空间交叉验证。本章使用了下列包：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>sf<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>terra<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>dplyr<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>data.table<span class="punctuation">)</span>        <span class="comment"># fast data.frame manipulation (used by mlr3)</span></span><br><span class="line">library<span class="punctuation">(</span>mlr3<span class="punctuation">)</span>              <span class="comment"># machine learning (see Chapter 12)</span></span><br><span class="line">library<span class="punctuation">(</span>mlr3spatiotempcv<span class="punctuation">)</span>  <span class="comment"># spatio-temporal resampling </span></span><br><span class="line">library<span class="punctuation">(</span>mlr3tuning<span class="punctuation">)</span>        <span class="comment"># hyperparameter tuning package</span></span><br><span class="line">library<span class="punctuation">(</span>mlr3learners<span class="punctuation">)</span>      <span class="comment"># interface to most important machine learning packages</span></span><br><span class="line">library<span class="punctuation">(</span>paradox<span class="punctuation">)</span>           <span class="comment"># defining hyperparameter spaces</span></span><br><span class="line">library<span class="punctuation">(</span>ranger<span class="punctuation">)</span>            <span class="comment"># random forest package</span></span><br><span class="line">library<span class="punctuation">(</span>qgisprocess<span class="punctuation">)</span>       <span class="comment"># bridge to QGIS (Chapter 10)</span></span><br><span class="line">library<span class="punctuation">(</span>tree<span class="punctuation">)</span>              <span class="comment"># decision tree package</span></span><br><span class="line">library<span class="punctuation">(</span>vegan<span class="punctuation">)</span>             <span class="comment"># community ecology package</span></span><br></pre></td></tr></table></figure>
<h1>引言</h1>
<p>本章通过模拟雾绿洲（也叫<em>lomas</em>）的植被分布，揭示了明显受到水源供应控制的不同植被区域。这个案例研究不仅整合了前几章中的核心观点，还拓展了这些观点，帮助你更全面地掌握使用R进行地理计算的相关技能。</p>
<p>雾绿洲或<em>lomas</em>，特指那些分布在秘鲁和智利沿海沙漠山脉的植被区。在世界的其他角落，如纳米比亚的沙漠和也门与阿曼的海岸，也存在类似的生态系统[@galletti_land_2016]。尽管这些地区年均降水量极低，仅为30-50毫米，但是在南半球的冬季，雾气的沉积显著增加了植物可用的水分。这导致了秘鲁沿海一带南坡的山地呈现出一片翠绿。这种由于南半球冬季冷洋流引发的温度逆转层下形成的雾气，成为了这一生境名称的由来。</p>
<p>每隔数年，厄尔尼诺现象会给这片烈日炙烤下的土地带来一场暴雨，为树苗提供了一个难得的机会：它们有足够的时间发展出能够在随后的干旱环境中生存下去的根系[@dillon_lomas_2003]。</p>
<p>不幸的是，雾绿洲正面临严重的威胁，主要原因是农业活动和人为的气候变化。有关本土植被成分和空间分布的证据能够支持保护剩余雾绿洲碎片的努力[@muenchow_predictive_2013; @muenchow_soil_2013]。本章还演示了如何将前几章介绍的技术应用到一个重要的应用领域：生态学。在这一章中，你将分析秘鲁中北部海岸附近卡斯马的蒙贡山（Mt. Mongón）南坡上的维管植物（主要是指开花植物）的组成和空间分布。</p>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309041036194.png" alt=""><br>
The Mt. Mongón study area, from Muenchow, Schratz, and Brenning (2017).</p>
<p>在2011年的澳大利亚冬季，进行了一次前往蒙贡山（Mt. Mongón）的实地研究，记录了100个随机抽样的4x4平方米区域内所有生存的维管植物[@muenchow_predictive_2013]。<br>
该抽样活动恰好与当年强烈的拉尼娜现象（La Niña）事件相吻合，这一点在美国国家海洋和大气管理局（<a href="http://origin.cpc.ncep.noaa.gov/products/analysis_monitoring/ensostuff/ONI_v5.php">NOAA</a>）发布的数据中有所体现。这导致了沿海沙漠通常干燥程度的进一步加剧，以及秘鲁<em>lomas</em>山脉南坡上雾气活动的增加。</p>
<!--
首个假设是，在海拔梯度上将会发现四个植物带：低海拔的* Tillandsia*（铁兰）带、草本带、凤梨带，以及最高处的多肉植物带[@muenchow_soil_2013]。
-->
<p>排序（Ordinations）是降维技术，允许从一个（有噪声的）数据集中提取主要梯度，对我们来说，即沿着南侧山坡发展的植物群落梯度（详见下一节）。在本章中，我们将对第一个排序轴进行建模，即植物群落梯度，作为海拔、坡度、流域面积和归一化植被指数（NDVI）等环境预测因子的函数。为此，我们将使用随机森林模型——一种非常流行的机器学习算法[@breiman_random_2001]。该模型将使我们能够在研究区域内的任何地方制作植物群落组成的空间分布图。为了保证最佳预测，建议提前使用空间交叉验证。</p>
<h1>数据和数据准备</h1>
<p>所有后续分析所需的数据都可以通过 <strong>spDataLarge</strong> 包获得。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">data<span class="punctuation">(</span><span class="string">&quot;study_area&quot;</span><span class="punctuation">,</span> <span class="string">&quot;random_points&quot;</span><span class="punctuation">,</span> <span class="string">&quot;comm&quot;</span><span class="punctuation">,</span> package <span class="operator">=</span> <span class="string">&quot;spDataLarge&quot;</span><span class="punctuation">)</span></span><br><span class="line">dem <span class="operator">=</span> rast<span class="punctuation">(</span>system.file<span class="punctuation">(</span><span class="string">&quot;raster/dem.tif&quot;</span><span class="punctuation">,</span> package <span class="operator">=</span> <span class="string">&quot;spDataLarge&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">ndvi <span class="operator">=</span> rast<span class="punctuation">(</span>system.file<span class="punctuation">(</span><span class="string">&quot;raster/ndvi.tif&quot;</span><span class="punctuation">,</span> package <span class="operator">=</span> <span class="string">&quot;spDataLarge&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><code>study_area</code> 是一个多边形，表示研究区域的轮廓，而 <code>random_points</code> 是一个包含100个随机选取的地点的 <code>sf</code> 对象。<code>comm</code> 是一个采用宽数据格式的群落矩阵[@wickham_tidy_2014]，其中行代表实地考察过的地点，列代表观察到的物种。^[在统计学中，这也被称为列联表或交叉表。]</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sites 35 to 40 and corresponding occurrences of the first five species in the</span></span><br><span class="line"><span class="comment"># community matrix</span></span><br><span class="line">comm<span class="punctuation">[</span><span class="number">35</span><span class="operator">:</span><span class="number">40</span><span class="punctuation">,</span> <span class="number">1</span><span class="operator">:</span><span class="number">5</span><span class="punctuation">]</span></span><br><span class="line"><span class="comment">#&gt;    Alon_meri Alst_line Alte_hali Alte_porr Anth_eccr</span></span><br><span class="line"><span class="comment">#&gt; 35         0         0         0       0.0     1.000</span></span><br><span class="line"><span class="comment">#&gt; 36         0         0         1       0.0     0.500</span></span><br><span class="line"><span class="comment">#&gt; 37         0         0         0       0.0     0.125</span></span><br><span class="line"><span class="comment">#&gt; 38         0         0         0       0.0     3.000</span></span><br><span class="line"><span class="comment">#&gt; 39         0         0         0       0.0     2.000</span></span><br><span class="line"><span class="comment">#&gt; 40         0         0         0       0.2     0.125</span></span><br></pre></td></tr></table></figure>
<p>值代表每个地点的物种覆盖面积，记录为物种覆盖面积与地点面积的比例（%；请注意，由于单个植物之间的覆盖面积重叠，一个地点的覆盖面积可能&gt;100%）。<code>comm</code> 的行名与 <code>random_points</code> 的 <code>id</code> 列相对应。<code>dem</code> 是研究区域的数字高程模型（DEM），<code>ndvi</code> 是从Landsat场景的红色和近红外通道计算出的归一化植被指数（NDVI）。可视化数据有助于更熟悉它，如下图所示，其中 <code>dem</code> 被 <code>random_points</code> 和 <code>study_area</code> 叠加绘制。</p>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309041041306.png" alt=""><br>
Study mask (polygon), location of the sampling sites (black points) and DEM in the background.</p>
<p>下一步是计算不仅用于建模和预测性制图但也用于将非度量多维缩放（NMDS）轴与研究区域中的主要梯度，即海拔和湿度，对齐的变量。</p>
<p>具体而言，我们使用 R-GIS 桥从数字高程模型计算流域坡度和流域面积。曲率也可能是有价值的预测因子，在练习部分你可以了解它们如何影响建模结果。</p>
<p>为了计算流域面积和流域坡度，我们可以使用 <code>sagang:sagawetnessindex</code> 函数。^[诚然，知道 <code>sagawetnessindex</code> 计算所需的地形属性的唯一方法是熟悉 SAGA。]<br>
<code>qgis_show_help()</code> 返回特定地理算法的所有函数参数和默认值。在这里，我们仅展示完整输出的部分内容。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># if not already done, enable the saga next generation plugin</span></span><br><span class="line">qgisprocess<span class="operator">::</span>qgis_enable_plugins<span class="punctuation">(</span><span class="string">&quot;processing_saga_nextgen&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># show help</span></span><br><span class="line">qgisprocess<span class="operator">::</span>qgis_show_help<span class="punctuation">(</span><span class="string">&quot;sagang:sagawetnessindex&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; Saga wetness index (sagang:sagawetnessindex)</span></span><br><span class="line"><span class="comment">#&gt; ...</span></span><br><span class="line"><span class="comment">#&gt; ----------------</span></span><br><span class="line"><span class="comment">#&gt; Arguments</span></span><br><span class="line"><span class="comment">#&gt; ----------------</span></span><br><span class="line"><span class="comment">#&gt; </span></span><br><span class="line"><span class="comment">#&gt; DEM: Elevation</span></span><br><span class="line"><span class="comment">#&gt; 	Argument type:	raster</span></span><br><span class="line"><span class="comment">#&gt; 	Acceptable values:</span></span><br><span class="line"><span class="comment">#&gt; 		- Path to a raster layer</span></span><br><span class="line"><span class="comment">#&gt; ...</span></span><br><span class="line"><span class="comment">#&gt; SLOPE_TYPE: Type of Slope</span></span><br><span class="line"><span class="comment">#&gt; 	Argument type:	enum</span></span><br><span class="line"><span class="comment">#&gt; 	Available values:</span></span><br><span class="line"><span class="comment">#&gt; 		- 0: [0] local slope</span></span><br><span class="line"><span class="comment">#&gt; 		- 1: [1] catchment slope</span></span><br><span class="line"><span class="comment">#&gt; ...</span></span><br><span class="line"><span class="comment">#&gt; AREA: Catchment area</span></span><br><span class="line"><span class="comment">#&gt; 	Argument type:	rasterDestination</span></span><br><span class="line"><span class="comment">#&gt; 	Acceptable values:</span></span><br><span class="line"><span class="comment">#&gt; 		- Path for new raster layer</span></span><br><span class="line"><span class="comment">#&gt;... </span></span><br><span class="line"><span class="comment">#&gt; ----------------</span></span><br><span class="line"><span class="comment">#&gt; Outputs</span></span><br><span class="line"><span class="comment">#&gt; ----------------</span></span><br><span class="line"><span class="comment">#&gt; </span></span><br><span class="line"><span class="comment">#&gt; AREA: &lt;outputRaster&gt;</span></span><br><span class="line"><span class="comment">#&gt; 	Catchment area</span></span><br><span class="line"><span class="comment">#&gt; SLOPE: &lt;outputRaster&gt;</span></span><br><span class="line"><span class="comment">#&gt; 	Catchment slope</span></span><br><span class="line"><span class="comment">#&gt; ...</span></span><br></pre></td></tr></table></figure>
<p>接下来，我们可以使用 R 的命名参数来指定所需的参数。记住，我们可以使用磁盘上文件的路径或者存储在 R’s全局环境中的 <code>SpatRaster</code> 来指定输入栅格 <code>DEM</code>。指定 <code>SLOPE_TYPE</code> 为1确保算法将返回流域坡度。生成的栅格将保存为具有<code>.sdat</code>扩展名的临时文件，这是 SAGA 的原生栅格格式。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># environmental predictors: catchment slope and catchment area</span></span><br><span class="line">ep <span class="operator">=</span> qgisprocess<span class="operator">::</span>qgis_run_algorithm<span class="punctuation">(</span></span><br><span class="line">  alg <span class="operator">=</span> <span class="string">&quot;sagang:sagawetnessindex&quot;</span><span class="punctuation">,</span></span><br><span class="line">  DEM <span class="operator">=</span> dem<span class="punctuation">,</span></span><br><span class="line">  SLOPE_TYPE <span class="operator">=</span> <span class="number">1</span><span class="punctuation">,</span> </span><br><span class="line">  SLOPE <span class="operator">=</span> tempfile<span class="punctuation">(</span>fileext <span class="operator">=</span> <span class="string">&quot;.sdat&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">  AREA <span class="operator">=</span> tempfile<span class="punctuation">(</span>fileext <span class="operator">=</span> <span class="string">&quot;.sdat&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">  .quiet <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>这将返回一个名为<code>ep</code>的列表，其中包含计算出的输出栅格的路径。让我们将流域面积和流域坡度读入一个多层<code>SpatRaster</code>对象中。另外，我们还将向其中添加两个更多的栅格对象，即<code>dem</code>和<code>ndvi</code>。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># read in catchment area and catchment slope</span></span><br><span class="line">ep <span class="operator">=</span> ep<span class="punctuation">[</span><span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;AREA&quot;</span><span class="punctuation">,</span> <span class="string">&quot;SLOPE&quot;</span><span class="punctuation">)</span><span class="punctuation">]</span> <span class="operator">|&gt;</span></span><br><span class="line">  unlist<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">  terra<span class="operator">::</span>rast<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line"><span class="built_in">names</span><span class="punctuation">(</span>ep<span class="punctuation">)</span> <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;carea&quot;</span><span class="punctuation">,</span> <span class="string">&quot;cslope&quot;</span><span class="punctuation">)</span> <span class="comment"># assign proper names </span></span><br><span class="line">terra<span class="operator">::</span>origin<span class="punctuation">(</span>ep<span class="punctuation">)</span> <span class="operator">=</span> terra<span class="operator">::</span>origin<span class="punctuation">(</span>dem<span class="punctuation">)</span> <span class="comment"># make sure rasters have the same origin</span></span><br><span class="line">ep <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span>dem<span class="punctuation">,</span> ndvi<span class="punctuation">,</span> ep<span class="punctuation">)</span> <span class="comment"># add dem and ndvi to the multilayer SpatRaster object</span></span><br></pre></td></tr></table></figure>
<p>此外，集水区域的值高度向右倾斜(‘hist (ep $carea)’)。Log10转换使分布更加正态。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ep<span class="operator">$</span>carea <span class="operator">=</span> log10<span class="punctuation">(</span>ep<span class="operator">$</span>carea<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>为了方便读者，我们在<strong>spDataLarge</strong>中添加了<code>ep</code>:</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ep <span class="operator">=</span> terra<span class="operator">::</span>rast<span class="punctuation">(</span>system.file<span class="punctuation">(</span><span class="string">&quot;raster/ep.tif&quot;</span><span class="punctuation">,</span> package <span class="operator">=</span> <span class="string">&quot;spDataLarge&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>最后，我们可以将地形属性提取到野外观测数据中。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># terra::extract adds automatically a for our purposes unnecessary ID column</span></span><br><span class="line">ep_rp <span class="operator">=</span> terra<span class="operator">::</span>extract<span class="punctuation">(</span>ep<span class="punctuation">,</span> random_points<span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">  select<span class="punctuation">(</span><span class="operator">-</span>ID<span class="punctuation">)</span></span><br><span class="line">random_points <span class="operator">=</span> cbind<span class="punctuation">(</span>random_points<span class="punctuation">,</span> ep_rp<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<h1>数据降维</h1>
<p>排序法（Ordinations）在植被科学中是一种流行的工具，主要用于从大多数元素为0的大型物种——样地矩阵中提取主要信息，这些信息通常对应于生态梯度。然而，排序法也广泛应用于遥感、土壤科学、地理营销和许多其他领域。如果你对排序技术不熟悉或需要复习，可以查看Michael W. Palmer的<a href="http://ordination.okstate.edu/overview.htm">网页</a>，以获得生态学中常用排序技术的简要介绍，或参考@borcard_numerical_2011以深入了解如何在R中应用这些技术。<strong>vegan</strong>包的文档（通过运行<code>vignette(package = &quot;vegan&quot;)</code>查看）也是一个非常有用的资源。</p>
<p>主成分分析（PCA）可能是最著名的排序技术。它是一个优秀的降维工具，尤其适用于变量之间有线性关系的情况，以及两个样地（观察）中变量共同缺失可以被视为相似性的情况。然而，这在植被数据中几乎不是问题。</p>
<p>首先，植物的出现通常沿着一个梯度（如湿度、温度或盐度）呈单峰分布，即非线性关系，最适宜的条件处达到峰值，然后在不适宜的条件下逐渐下降。</p>
<p>其次，两个样地中一个物种的共同缺失很难被视为相似性的指标。假设一个植物物种在我们样本中最干燥（例如极端沙漠）和最潮湿（例如树木草原）的地点都不存在。那么我们确实应该避免把这一点算作是相似性，因为在植被组成方面，这两个完全不同的环境设置很可能唯一的共同点就是物种的共同缺失（除了稀有的无处不在的物种）。</p>
<p>非度量多维尺度（NMDS）是生态学中常用的一种降维技术[@vonwehrden_pluralism_2009]。NMDS通过减少原始矩阵中对象间距离和排序后对象间距离的基于秩的差异来实现降维。这种差异用“应力值”来表示。应力值越低，说明降维效果越好，也就是说，这种低维表示更准确地反映了原始矩阵。应力值低于10表示拟合优秀，约15的值仍然不错，大于20的值则表示拟合差[@mccune_analysis_2002]。</p>
<p>在R中，<strong>vegan</strong>包的<code>metaMDS()</code>函数可以执行NMDS。作为输入，它需要一个以样地为行、以物种为列的社群矩阵。使用存在-不存在数据进行排序通常会得到更好的结果（就解释方差而言），尽管代价当然是输入矩阵信息较少。<code>decostand()</code> 函数用1和0分别表示物种的存在和缺失，将数值观测转化为存在和缺失数据。像NMDS这样的排序技术至少需要每个样地有一个观察。因此，我们需要去除所有没有发现物种的样地。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># presence-absence matrix</span></span><br><span class="line">pa <span class="operator">=</span> vegan<span class="operator">::</span>decostand<span class="punctuation">(</span>comm<span class="punctuation">,</span> <span class="string">&quot;pa&quot;</span><span class="punctuation">)</span>  <span class="comment"># 100 rows (sites), 69 columns (species)</span></span><br><span class="line"><span class="comment"># keep only sites in which at least one species was found</span></span><br><span class="line">pa <span class="operator">=</span> pa<span class="punctuation">[</span>rowSums<span class="punctuation">(</span>pa<span class="punctuation">)</span> <span class="operator">!=</span> <span class="number">0</span><span class="punctuation">,</span> <span class="punctuation">]</span>  <span class="comment"># 84 rows, 69 columns</span></span><br></pre></td></tr></table></figure>
<p>所生成的矩阵将作为NMDS（非度量多维标度法）的输入。在这个例子中，我们设定<code>k</code>为4，代表输出轴的数量。^[选择最佳的<code>k</code>值的一种方法是尝试在1到6之间运行NMDS，并选择产生最佳应力值的结果[@mccune_analysis_2002]。]</p>
<p>NMDS是一个迭代过程，每一步都试图让排序后的空间更接近输入矩阵。为确保算法收敛，我们设定迭代次数为500（通过<code>try</code>参数）。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">set.seed<span class="punctuation">(</span><span class="number">25072018</span><span class="punctuation">)</span></span><br><span class="line">nmds <span class="operator">=</span> vegan<span class="operator">::</span>metaMDS<span class="punctuation">(</span>comm <span class="operator">=</span> pa<span class="punctuation">,</span> k <span class="operator">=</span> <span class="number">4</span><span class="punctuation">,</span> try <span class="operator">=</span> <span class="number">500</span><span class="punctuation">)</span></span><br><span class="line">nmds<span class="operator">$</span>stress</span><br><span class="line"><span class="comment">#&gt; ...</span></span><br><span class="line"><span class="comment">#&gt; Run 498 stress 0.08834745 </span></span><br><span class="line"><span class="comment">#&gt; ... Procrustes: rmse 0.004100446  max resid 0.03041186 </span></span><br><span class="line"><span class="comment">#&gt; Run 499 stress 0.08874805 </span></span><br><span class="line"><span class="comment">#&gt; ... Procrustes: rmse 0.01822361  max resid 0.08054538 </span></span><br><span class="line"><span class="comment">#&gt; Run 500 stress 0.08863627 </span></span><br><span class="line"><span class="comment">#&gt; ... Procrustes: rmse 0.01421176  max resid 0.04985418 </span></span><br><span class="line"><span class="comment">#&gt; *** Solution reached</span></span><br><span class="line"><span class="comment">#&gt; 0.08831395</span></span><br></pre></td></tr></table></figure>
<p>应力值为9代表了非常好的结果，意味着降维后的排序空间能代表输入矩阵的大部分方差。总体来说，NMDS会将更相似（在物种组成方面）的对象在排序空间中放得更近。然而，与大多数其他排序技术不同，这些轴是任意的，并不一定按重要性排序[@borcard_numerical_2011]。然而，我们已经知道湿度是研究区域内主要的梯度[@muenchow_predictive_2013;@muenchow_rqgis:_2017]。由于湿度与海拔高度高度相关，我们将NMDS轴与海拔进行旋转（有关旋转NMDS轴的更多细节，请参见<code>?MDSrotate</code>）。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">elev <span class="operator">=</span> dplyr<span class="operator">::</span>filter<span class="punctuation">(</span>random_points<span class="punctuation">,</span> id <span class="operator">%in%</span> rownames<span class="punctuation">(</span>pa<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">|&gt;</span> </span><br><span class="line">  dplyr<span class="operator">::</span>pull<span class="punctuation">(</span>dem<span class="punctuation">)</span></span><br><span class="line"><span class="comment"># rotating NMDS in accordance with altitude (proxy for humidity)</span></span><br><span class="line">rotnmds <span class="operator">=</span> vegan<span class="operator">::</span>MDSrotate<span class="punctuation">(</span>nmds<span class="punctuation">,</span> elev<span class="punctuation">)</span></span><br><span class="line"><span class="comment"># extracting the first two axes</span></span><br><span class="line">sc <span class="operator">=</span> vegan<span class="operator">::</span>scores<span class="punctuation">(</span>rotnmds<span class="punctuation">,</span> choices <span class="operator">=</span> <span class="number">1</span><span class="operator">:</span><span class="number">2</span><span class="punctuation">,</span> display <span class="operator">=</span> <span class="string">&quot;sites&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># plotting the first axis against altitude</span></span><br><span class="line">plot<span class="punctuation">(</span>y <span class="operator">=</span> sc<span class="punctuation">[</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">]</span><span class="punctuation">,</span> x <span class="operator">=</span> elev<span class="punctuation">,</span> xlab <span class="operator">=</span> <span class="string">&quot;elevation in m&quot;</span><span class="punctuation">,</span> </span><br><span class="line">     ylab <span class="operator">=</span> <span class="string">&quot;First NMDS axis&quot;</span><span class="punctuation">,</span> cex.lab <span class="operator">=</span> <span class="number">0.8</span><span class="punctuation">,</span> cex.axis <span class="operator">=</span> <span class="number">0.8</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309041052326.png" alt=""><br>
Plotting the first NMDS axis against altitude.</p>
<p>绘制结果显示，第一个轴正如我们预期的，明显与海拔相关。</p>
<p>第一NMDS轴的得分代表了出现在Mongón山坡上的不同植被形态，即，沿坡度出现的植物群落梯度。为了空间可视化它们，我们可以使用先前创建的预测因子对NMDS得分进行建模，并使用生成的模型进行预测性映射（见下一节）。</p>
<h1>植物群落梯度建模</h1>
<p>为了在空间上预测植物群落梯度，我们使用随机森林模型[@hengl_random_2018]。随机森林模型在环境和生态建模中经常被应用，并且通常在预测性能方面提供最好的结果[@schratz_hyperparameter_2019]。这里，我们简短地介绍决策树和bagging，因为它们是随机森林的基础。更详细的随机森林及相关技术描述，读者可以参考@james_introduction_2013。</p>
<p>首先，为了通过示例介绍决策树，我们通过将旋转后的NMDS\得分与现场观察数据（<code>random_points</code>）合并，构建一个响应-预测因子矩阵。后续，我们还会用这个生成的数据框进行<strong>mlr3</strong>建模。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># construct response-predictor matrix</span></span><br><span class="line"><span class="comment"># id- and response variable</span></span><br><span class="line">rp <span class="operator">=</span> data.frame<span class="punctuation">(</span>id <span class="operator">=</span> <span class="built_in">as.numeric</span><span class="punctuation">(</span>rownames<span class="punctuation">(</span>sc<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span> sc <span class="operator">=</span> sc<span class="punctuation">[</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">]</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># join the predictors (dem, ndvi and terrain attributes)</span></span><br><span class="line">rp <span class="operator">=</span> inner_join<span class="punctuation">(</span>random_points<span class="punctuation">,</span> rp<span class="punctuation">,</span> by <span class="operator">=</span> <span class="string">&quot;id&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>决策树将预测因子空间划分成若干区域。为了说明这一点，我们使用第一NMDS轴\index{NMDS}的得分（<code>sc</code>）作为响应变量，海拔（<code>dem</code>）作为唯一的预测因子，对我们的数据应用一个决策树。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">tree_mo <span class="operator">=</span> tree<span class="operator">::</span>tree<span class="punctuation">(</span>sc <span class="operator">~</span> dem<span class="punctuation">,</span> data <span class="operator">=</span> rp<span class="punctuation">)</span></span><br><span class="line">plot<span class="punctuation">(</span>tree_mo<span class="punctuation">)</span></span><br><span class="line">text<span class="punctuation">(</span>tree_mo<span class="punctuation">,</span> pretty <span class="operator">=</span> <span class="number">0</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309041054185.png" alt=""><br>
Simple example of a decision tree with three internal nodes and four terminal nodes.</p>
<p>生成的树由三个内部节点和四个终端节点组成。树顶部的第一个内部节点将所有观察值中海拔低于<!-- -->328.5米的分到左侧分支，其余的观察值分到右侧分支。落入左侧分支的观察值具有平均NMDS得分为<!-- -->-1.198。</p>
<p>总体而言，我们可以这样解释这棵树：海拔越高，NMDS得分也越高。这意味着这个简单的决策树已经揭示了四个不同的植物群落组合。</p>
<p>决策树有过拟合的倾向，也就是说它们过于贴近输入数据，包括其噪声，从而导致预测性能差[@james_introduction_2013]。Bootstrap集成（bagging）是一种可以帮助克服这个问题的集成技术。集成技术简单地将多个模型的预测结果组合起来。因此，bagging从相同的输入数据中重复抽样，并对预测进行平均。这减少了方差和过拟合，从而大大提高了与决策树相比的预测准确性。</p>
<p>最后，随机森林通过去相关化树来扩展和改进bagging，这是可取的，因为高度相关的树的预测平均值具有更高的方差，因此可靠性较低[@james_introduction_2013]。为了实现这一目标，随机森林使用了bagging，但与传统的bagging不同，其中每棵树都可以使用所有可用的预测因子，随机森林仅使用所有可用预测因子的一个随机样本。</p>
<!--
需要记住的是，bagging仅仅是当m=p时随机森林的一个特例。因此，randomForest()函数可以用来执行随机森林和bagging。
参数mtry=13表明，在树的每一次分裂中，应该考虑所有13个预测因子——换句话说，应该进行bagging。
@james_introduction_2013
-->
<h2 id="mlr3-构建块"><strong>mlr3</strong> 构建块</h2>
<p>本节中的代码大体上遵循我们在第<em>机器学习超参数调整</em>节中介绍的步骤，唯一的不同之处如下：</p>
<ol>
<li>响应变量是数值型的，因此将替换第<em>机器学习超参数调整</em>节中的分类任务为回归任务。</li>
<li>我们将使用均方根误差（RMSE）作为性能度量，而不是仅适用于分类响应变量的AUROC。</li>
<li>我们使用随机森林模型而不是支持向量机，这自然涉及到不同的超参数。</li>
<li>我们将评估偏差减少的性能度量留作读者的练习（参见练习题）。<br>
相反，我们展示如何为（空间）预测调整超参数。</li>
</ol>
<p>请记住，当使用100次重复的5折空间交叉验证和50次迭代的随机搜索时，需要125,500个模型来获取偏差减少的性能估计。在超参数调优层面，我们找到了最佳的超参数组合，然后用于外层性能层对特定空间分区的测试数据进行预测。这样做总共产生了500个最佳超参数组合。那么，我们应该使用哪一个来进行空间分布图？答案很简单：完全不用。请记住，调优是为了获取偏差减少的性能估计，而不是为了做最佳可能的空间预测。对于后者，从完整的数据集中估计最佳超参数组合。这意味着，不再需要内部超参数调优层，这是非常合理的，因为我们将模型应用于新的数据（未访问的实地观察）, 这些数据的真实结果是不可用的，因此在任何情况下测试都是不可能的。因此，我们通过一次重复的5折空间CV在完整数据集上调整超参数，以实现良好的空间预测。</p>
<!--如果我们使用超过一次重复（比如说2次），我们将得到多个最优调整的超参数组合（比如说2个）。-->
<p>既然已经构建了输入变量（<code>rp</code>），我们就准备好指定<strong>mlr3</strong>的构建块（任务、学习器和重采样）了。为了指定一个空间任务，我们再次使用<strong>mlr3spatiotempcv</strong>包[@schratz_mlr3spatiotempcv_2021 &amp; Section]，而由于我们的响应（<code>sc</code>）是数值型的，我们使用回归任务。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># create task</span></span><br><span class="line">task <span class="operator">=</span> mlr3spatiotempcv<span class="operator">::</span>as_task_regr_st<span class="punctuation">(</span>select<span class="punctuation">(</span>rp<span class="punctuation">,</span> <span class="operator">-</span>id<span class="punctuation">,</span> <span class="operator">-</span>spri<span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">  id <span class="operator">=</span> <span class="string">&quot;mongon&quot;</span><span class="punctuation">,</span> target <span class="operator">=</span> <span class="string">&quot;sc&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>使用<code>sf</code>对象作为后端会自动提供之后进行空间分区所需的几何信息。此外，我们去掉了<code>id</code>和<code>spri</code>这两列，因为这些变量不应该用作模型的预测因子。接下来，我们将使用<strong>ranger</strong>包[@wright_ranger_2017]来构建一个随机森林学习器。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">lrn_rf <span class="operator">=</span> lrn<span class="punctuation">(</span><span class="string">&quot;regr.ranger&quot;</span><span class="punctuation">,</span> predict_type <span class="operator">=</span> <span class="string">&quot;response&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>与支持向量机不同，随机森林通常在使用其超参数的默认值时就已经表现出良好的性能（这也许是它们受欢迎的一个原因）。然而，调优通常会适度地改善模型结果，因此值得付出努力 [@probst_hyperparameters_2018]。在随机森林中，超参数<code>mtry</code>、<code>min.node.size</code> 和 <code>sample.fraction</code> 决定了随机性的程度，并应进行调优[@probst_hyperparameters_2018]。<code>mtry</code> 指示每棵树应使用多少预测变量。如果使用所有预测变量，那么这实际上就是装袋法。<code>sample.fraction</code> 参数指定应在每棵树中使用的观察样本的比例。较小的比例会导致更大的多样性，从而产生相互间较少相关的树，这通常是可取的（如上文所述）。<code>min.node.size</code> 参数表示一个终端节点至少应具有多少观察值。自然地，随着树和计算时间的增加，<code>min.node.size</code> 会变得更小。</p>
<p>超参数组合将随机选择，但应落在特定的调优限制内（使用 <code>paradox::ps()</code> 创建）。<code>mtry</code> 应在 1 和预测变量的数量（4）<!-- (4)--> 之间变化，<code>sample.fraction</code> 应在 0.2 和 0.9 之间变化，<code>min.node.size</code> 应在 1 和 10 之间变化 [@probst_hyperparameters_2018]。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># specifying the search space</span></span><br><span class="line">search_space <span class="operator">=</span> paradox<span class="operator">::</span>ps<span class="punctuation">(</span></span><br><span class="line">  mtry <span class="operator">=</span> paradox<span class="operator">::</span>p_int<span class="punctuation">(</span>lower <span class="operator">=</span> <span class="number">1</span><span class="punctuation">,</span> upper <span class="operator">=</span> ncol<span class="punctuation">(</span>task<span class="operator">$</span>data<span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">-</span> <span class="number">1</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">  sample.fraction <span class="operator">=</span> paradox<span class="operator">::</span>p_dbl<span class="punctuation">(</span>lower <span class="operator">=</span> <span class="number">0.2</span><span class="punctuation">,</span> upper <span class="operator">=</span> <span class="number">0.9</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">  min.node.size <span class="operator">=</span> paradox<span class="operator">::</span>p_int<span class="punctuation">(</span>lower <span class="operator">=</span> <span class="number">1</span><span class="punctuation">,</span> upper <span class="operator">=</span> <span class="number">10</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>确定了搜索空间后，我们可以通过<code>AutoTuner()</code>函数来指定我们的调优。由于我们处理的是地理数据，因此我们将再次利用空间交叉验证来调整超参数。具体来说，我们将使用五折空间划分，且仅进行一次重复（<code>rsmp()</code>）。在这些空间划分中，我们运行50个模型（<code>trm()</code>），同时在预定义的限制（<code>search_space</code>）内使用随机选择的超参数配置（<code>tnr()</code>）来找到最优的超参数\index{hyperparameter}组合[参见<em>机器学习超参数调整</em>章节和 <a href="https://mlr3book.mlr-org.com/optimization.html#autotuner">https://mlr3book.mlr-org.com/optimization.html#autotuner</a>, @becker_mlr3_2022]。性能度量是均方根误差（RMSE）。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">autotuner_rf <span class="operator">=</span> mlr3tuning<span class="operator">::</span>AutoTuner<span class="operator">$</span>new<span class="punctuation">(</span></span><br><span class="line">  learner <span class="operator">=</span> lrn_rf<span class="punctuation">,</span></span><br><span class="line">  resampling <span class="operator">=</span> mlr3<span class="operator">::</span>rsmp<span class="punctuation">(</span><span class="string">&quot;spcv_coords&quot;</span><span class="punctuation">,</span> folds <span class="operator">=</span> <span class="number">5</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="comment"># spatial partitioning</span></span><br><span class="line">  measure <span class="operator">=</span> mlr3<span class="operator">::</span>msr<span class="punctuation">(</span><span class="string">&quot;regr.rmse&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="comment"># performance measure</span></span><br><span class="line">  terminator <span class="operator">=</span> mlr3tuning<span class="operator">::</span>trm<span class="punctuation">(</span><span class="string">&quot;evals&quot;</span><span class="punctuation">,</span> n_evals <span class="operator">=</span> <span class="number">50</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="comment"># specify 50 iterations</span></span><br><span class="line">  search_space <span class="operator">=</span> search_space<span class="punctuation">,</span> <span class="comment"># predefined hyperparameter search space</span></span><br><span class="line">  tuner <span class="operator">=</span> mlr3tuning<span class="operator">::</span>tnr<span class="punctuation">(</span><span class="string">&quot;random_search&quot;</span><span class="punctuation">)</span> <span class="comment"># specify random search</span></span><br><span class="line"><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>调用<code>AutoTuner</code>对象的<code>train()</code>方法最终将执行超参数调优，并会为指定的参数找到最优的超参数组合。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># hyperparameter tuning</span></span><br><span class="line">set.seed<span class="punctuation">(</span><span class="number">0412022</span><span class="punctuation">)</span></span><br><span class="line">autotuner_rf<span class="operator">$</span>train<span class="punctuation">(</span>task<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">autotuner_rf<span class="operator">$</span>tuning_result</span><br><span class="line"><span class="comment">#&gt;    mtry sample.fraction min.node.size learner_param_vals  x_domain regr.rmse</span></span><br><span class="line"><span class="comment">#&gt; 1:    4             0.9             7          &lt;list[4]&gt; &lt;list[3]&gt;     0.375</span></span><br></pre></td></tr></table></figure>
<!--
一个`mtry`值为，一个`sample.fraction`值为，以及一个`min.node.size`值为代表了最佳的超参数\index{超参数}组合。
当考虑到响应变量的范围是（`diff(range(rp$sc))`）时，一个RMSE\index{RMSE}值为相对来说是比较好的。
-->
<h2 id="预测地图">预测地图</h2>
<p>经过调优的超参数现在可以用于预测了。为此，我们只需运行已拟合的<code>AutoTuner</code>对象的<code>predict</code>方法。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># predicting using the best hyperparameter combination</span></span><br><span class="line">autotuner_rf<span class="operator">$</span>predict<span class="punctuation">(</span>task<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; Warning: Detected version mismatch: Learner &#x27;regr.ranger.tuned&#x27; has been</span></span><br><span class="line"><span class="comment">#&gt; trained with mlr3 version &#x27;0.13.3&#x27;, not matching currently installed version</span></span><br><span class="line"><span class="comment">#&gt; &#x27;0.16.1&#x27;</span></span><br><span class="line"><span class="comment">#&gt; Warning: Detected version mismatch: Learner &#x27;regr.ranger&#x27; has been trained with</span></span><br><span class="line"><span class="comment">#&gt; mlr3 version &#x27;0.13.3&#x27;, not matching currently installed version &#x27;0.16.1&#x27;</span></span><br><span class="line"><span class="comment">#&gt; &lt;PredictionRegr&gt; for 84 observations:</span></span><br><span class="line"><span class="comment">#&gt;     row_ids  truth response</span></span><br><span class="line"><span class="comment">#&gt;           1 -1.084   -1.073</span></span><br><span class="line"><span class="comment">#&gt;           2 -0.975   -1.050</span></span><br><span class="line"><span class="comment">#&gt;           3 -0.912   -1.012</span></span><br><span class="line"><span class="comment">#&gt; ---                        </span></span><br><span class="line"><span class="comment">#&gt;          82  0.814    0.646</span></span><br><span class="line"><span class="comment">#&gt;          83  0.814    0.790</span></span><br><span class="line"><span class="comment">#&gt;          84  0.808    0.845</span></span><br></pre></td></tr></table></figure>
<p>该<code>predict</code>方法将把模型应用于建模时用到的所有观测值。如果有一个多层的<code>SpatRaster</code>，其中包含与建模时使用的预测变量同名的栅格，<code>terra::predict()</code>也将生成空间分布图，即，对新数据进行预测。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">pred <span class="operator">=</span> terra<span class="operator">::</span>predict<span class="punctuation">(</span>ep<span class="punctuation">,</span> model <span class="operator">=</span> autotuner_rf<span class="punctuation">,</span> fun <span class="operator">=</span> predict<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202309041106812.png" alt=""><br>
Predictive mapping of the floristic gradient clearly revealing distinct vegetation belts.</p>
<p>如果情况是<code>terra::predict()</code>不支持某个模型算法，你仍然可以手动进行预测。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">newdata <span class="operator">=</span> as.data.frame<span class="punctuation">(</span>as.matrix<span class="punctuation">(</span>ep<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">colSums<span class="punctuation">(</span><span class="built_in">is.na</span><span class="punctuation">(</span>newdata<span class="punctuation">)</span><span class="punctuation">)</span>  <span class="comment"># 0 NAs</span></span><br><span class="line"><span class="comment"># but assuming there were 0s results in a more generic approach</span></span><br><span class="line">ind <span class="operator">=</span> rowSums<span class="punctuation">(</span><span class="built_in">is.na</span><span class="punctuation">(</span>newdata<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">==</span> <span class="number">0</span></span><br><span class="line">tmp <span class="operator">=</span> autotuner_rf<span class="operator">$</span>predict_newdata<span class="punctuation">(</span>newdata <span class="operator">=</span> newdata<span class="punctuation">[</span>ind<span class="punctuation">,</span> <span class="punctuation">]</span><span class="punctuation">,</span> task <span class="operator">=</span> task<span class="punctuation">)</span></span><br><span class="line">newdata<span class="punctuation">[</span>ind<span class="punctuation">,</span> <span class="string">&quot;pred&quot;</span><span class="punctuation">]</span> <span class="operator">=</span> data.table<span class="operator">::</span>as.data.table<span class="punctuation">(</span>tmp<span class="punctuation">)</span><span class="punctuation">[[</span><span class="string">&quot;response&quot;</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line">pred_2 <span class="operator">=</span> ep<span class="operator">$</span>dem</span><br><span class="line"><span class="comment"># now fill the raster with the predicted values</span></span><br><span class="line">pred_2<span class="punctuation">[</span><span class="punctuation">]</span> <span class="operator">=</span> newdata<span class="operator">$</span>pred</span><br><span class="line"><span class="comment"># check if terra and our manual prediction is the same</span></span><br><span class="line"><span class="built_in">all</span><span class="punctuation">(</span>values<span class="punctuation">(</span>pred <span class="operator">-</span> pred_2<span class="punctuation">)</span> <span class="operator">==</span> <span class="number">0</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>预测性绘图清晰地揭示了不同的植被带。请参考@muenchow_soil_2013以获取<em>lomas</em>山脉上植被带的详细描述。蓝色调表示所谓的<em>Tillandsia</em>-带。<em>Tillandsia</em>是一个高度适应性的属，特别是在<em>lomas</em>山脉的多沙和相当干旱的山脚下以高数量存在。黄色调指的是与<em>Tillandsia</em>-带相比植物覆盖率要高得多的草本植被带。橙色代表了含有最多物种丰富度和植物覆盖的凤梨带。它位于温度逆转下方（大约在海拔750-850米处），那里因雾气而湿度最高。在温度逆转以上，水的可用性自然会减少，景观再次变成沙漠，只有少数多汁植物（多汁带；红色）。</p>
<h1>结论</h1>
<p>在本章中，我们用NMDS的帮助对<em>lomas</em>蒙贡山的群落矩阵进行了排序。第一个轴，代表研究区域的主要植被梯度，被建模为环境预测变量的函数，其中部分是通过R-GIS桥接得到的。<strong>mlr3</strong>包提供了空间调整超参数<code>mtry</code>、<code>sample.fraction</code>和<code>min.node.size</code>的构建块。经过调优的超参数作为最终模型的输入，反过来又应用于环境预测变量，以空间地表示植被梯度。结果在沙漠中心展示了令人惊奇的生物多样性。由于<em>lomas</em>山脉正面临严重的威胁，预测图可作为划定保护区和提醒当地居民其所在地区独特性的依据。</p>
<p>在方法论方面，还有一些额外的点可以考虑：</p>
<ul>
<li>对第二个排序轴也进行建模，并随后找到一种创新方式，将两个轴的模型得分同时在一个预测图中可视化，可能会很有趣</li>
<li>如果我们有兴趣以生态有意义的方式解释模型，我们可能应该使用（半）参数模型[@muenchow_predictive_2013;@zuur_mixed_2009;@zuur_beginners_2017]<br>
然而，至少有一些方法有助于解释如随机森林这样的机器学习模型（参见，例如，<a href="https://mlr-org.github.io/interpretable-machine-learning-iml-and-mlr/">https://mlr-org.github.io/interpretable-machine-learning-iml-and-mlr/</a>）</li>
<li>使用顺序模型基础优化（SMBO）可能优于本章中用于超参数\index{hyperparameter}优化的随机搜索[@probst_hyperparameters_2018]。</li>
</ul>
<p>最后，请注意，随机森林和其他机器学习模型通常用于观察量多、预测因子多的情境，远超本章所使用的，并且其中哪些变量以及变量之间的交互作用有助于解释响应是不明确的。此外，这些关系可能是高度非线性的。在我们的用例中，响应与预测因子之间的关系相对明确，只有少量的非线性，观测量和预测因子的数量也较低。因此，尝试线性模型可能是值得的。线性模型比随机森林模型更容易解释和理解，因此更应优先选择（简约原则），并且它在计算上也更不费力（参见练习）。如果线性模型无法应对数据中存在的非线性程度，也可以尝试使用广义可加模型（GAM）。关键在于，数据科学家的工具箱包含多种工具，选择最适合手头任务或目的的工具是你的责任。在这里，我们希望向读者介绍随机森林建模以及如何用相应的结果进行预测性地图绘制。为此，一个具有已知响应与预测因子之间关系的研究得当的数据集是合适的。然而，这并不意味着随机森林模型在预测性能方面返回了最佳结果（参见练习）。</p>
<h1>练习</h1>
<p>E1. 使用社区矩阵的百分比数据运行一个NMDS\index{NMDS}。报告压力值，并将其与使用存在-不存在数据从NMDS中检索到的压力值进行比较。可能是什么原因导致了观察到的差异？</p>
<p>E2. 计算我们在章节中使用过的所有预测栅格\index{raster}（集水区坡度、集水区面积），并将它们放入一个<code>SpatRaster</code>-对象中。添加<code>dem</code>和<code>ndvi</code>。接下来，计算轮廓和切向曲率，并将它们作为额外的预测栅格添加（提示：<code>grass7:r.slope.aspect</code>）。最后，构造一个响应-预测矩阵。第一个NMDS\index{NMDS}轴的分数（当使用存在-不存在社区矩阵时的结果）按照海拔旋转，代表响应变量，并应连接到<code>random_points</code>（使用内连接）。要完成响应-预测矩阵，请将环境预测栅格对象的值提取到<code>random_points</code>中。</p>
<p>E3. 使用空间交叉验证\index{cross-validation!spatial CV}检索随机森林\index{random forest}和线性模型的偏差减少的RMSE。随机森林建模应包括在内部调优循环中估算最优超参数\index{hyperparameter}组合（随机搜索50次迭代）。在调优级别上实现并行化\index{parallelization}。报告平均RMSE\index{RMSE}，并使用箱线图可视化所有检索到的RMSE。请注意，最好使用mlr3函数<code>benchmark_grid()</code>和<code>benchmark()</code>来解决此练习（有关更多信息，请参见<a href="https://mlr3book.mlr-org.com/perf-eval-cmp.html#benchmarking%EF%BC%89%E3%80%82">https://mlr3book.mlr-org.com/perf-eval-cmp.html#benchmarking）。</a></p>
]]></content>
      <categories>
        <category>R</category>
        <category>Geocomputaion</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>Geocomputaion</tag>
      </tags>
  </entry>
</search>
