<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>(1)介绍</title>
    <url>/2023/08/10/2023-8-10-1-%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<!--rl-->
<p>这本书是关于使用计算机的力量来处理地理数据的。它教授一系列的空间技能，包括：读、写和操作地理数据；制作静态和交互式地图；应用地理计算解决现实问题；并对地理现象进行建模。<br />
通过展示各种地理操作是如何联系在一起的，在穿插的可复制&quot;代码块&quot;中，本书还教授了一个透明而科学的工作流程。<br />
学习如何使用R命令行提供的丰富的地理空间工具令人兴奋，但创建新的工具可以真正解放。<br />
使用贯穿始终的命令行驱动方法，以及<em>算法</em>章节所涵盖的编程技术，可以帮助消除软件对您的创造力施加的限制。<br />
在读完这本书和完成练习后，你应该对R令人印象深刻的地理能力所开辟的可能性有很强的理解，用地理数据解决现实世界问题的新技能，以及用地图和可复制的代码来交流你的工作的能力。</p>
<span id="more"></span>
<h1 id="引言"><a class="markdownIt-Anchor" href="#引言"></a> 引言</h1>
<p>这本书是关于使用计算机的力量来处理地理数据的。它教授一系列的空间技能，包括：读、写和操作地理数据；制作静态和交互式地图；应用地理计算解决现实问题；并对地理现象进行建模。<br />
通过展示各种地理操作是如何联系在一起的，在穿插的可复制&quot;代码块&quot;中，本书还教授了一个透明而科学的工作流程。<br />
学习如何使用R命令行提供的丰富的地理空间工具令人兴奋，但创建新的工具可以真正解放。<br />
使用贯穿始终的命令行驱动方法，以及<em>算法</em>章节所涵盖的编程技术，可以帮助消除软件对您的创造力施加的限制。<br />
在读完这本书和完成练习后，你应该对R令人印象深刻的地理能力所开辟的可能性有很强的理解，用地理数据解决现实世界问题的新技能，以及用地图和可复制的代码来交流你的工作的能力。</p>
<p>在过去的几十年中，自由和开源的地理空间软件（FOSS4G）以惊人的速度发展。<br />
得益于OSGeo等组织，地理数据分析不再是拥有昂贵硬件和软件的人的专利，现在任何人都可以下载和运行高性能的空间库。<br />
开源地理信息系统(GIS)，如 <a href="http://qgis.org/en/site/">QGIS</a>，使地理分析在全球范围内变得可访问。<br />
GIS程序倾向于强调图形用户界面(GUIs)，但是阻碍可重复性(尽管许多可以从命令行中使用，正如我们在<em>GIS</em>章中看到的那样)。<br />
而R则强调命令行界面(CLI)。<br />
不同方法之间的简单比较见。</p>
<p>Table: Differences in emphasis between software packages (Graphical User Interface (GUI) of Geographic Information Systems (GIS) and R).</p>
<table>
<thead>
<tr>
<th style="text-align:left">Attribute</th>
<th style="text-align:left">Desktop GIS (GUI)</th>
<th style="text-align:left">R</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Home disciplines</td>
<td style="text-align:left">Geography</td>
<td style="text-align:left">Computing, Statistics</td>
</tr>
<tr>
<td style="text-align:left">Software focus</td>
<td style="text-align:left">Graphical User Interface</td>
<td style="text-align:left">Command line</td>
</tr>
<tr>
<td style="text-align:left">Reproducibility</td>
<td style="text-align:left">Minimal</td>
<td style="text-align:left">Maximal</td>
</tr>
</tbody>
</table>
<p>本书的动力源于科学研究的可重复的重要性（见下面的注释）。<br />
它旨在使可重复的地理数据分析工作流更易于访问，并展示从命令行可用的开源地理空间软件的力量。<br />
“其他软件的接口是R的一部分”。<br />
这意味着除了出色的’内部’功能外，R还允许访问许多其他空间软件库。<br />
然而，在深入了解软件的细节之前，值得退一步思考我们对地理计算的含义是什么。</p>
<blockquote>
<p>📌可重复性是命令行界面的一大优势，但实际上它意味着什么？<br />
我们将其定义为：“一个通过使用公开可访问的代码，能够由其他人生成相同结果的过程。”<br />
这听起来可能很简单，也容易实现（如果你仔细地维护你的R代码脚本文件的话），但对于教学和科学过程有着深远的影响。</p>
</blockquote>
<h1 id="什么是地理计算"><a class="markdownIt-Anchor" href="#什么是地理计算"></a> 什么是地理计算？</h1>
<!--rl-->
<p>地理计算是一个年轻的术语，可以追溯到1996年该主题的第一次会议<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。<br />
与当时常用术语’量化地理学’不同，其早期倡导者提出，地理计算强调的是&quot;富有创意和实验性&quot;的应用和新工具和方法的开发。<br />
“地理计算是关于使用各种不同类型的地理数据，并在’科学’方法的总体背景下开发相关的地理工具。” 本书的目标不仅是教授方法和代码；在本书结束时，你应该能够使用你的地理计算技能，做出&quot;有益或有用的实际工作&quot;。</p>
<p>我们的方法与早期采用者如Stan Openshaw的强调点不同，它强调可重复性和合作。<br />
在21世纪初，由于无法获得必要的硬件、软件和数据，期望读者能够重复代码示例是不现实的。<br />
快进两个世纪，情况发展迅速。<br />
任何有足够RAM（至少推荐8GB）的笔记本电脑都可以安装和运行地理计算软件，并重现本书的内容。<br />
1990年代和21世纪初，高性能计算机对大多数人来说过于昂贵，因此地理计算的财务和硬件障碍已经消除。<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup><br />
地理计算也更容易访问，因为公开可访问的数据集比以往任何时候都更广泛地可用，我们将在<em>数据读写</em>章节中看到。<br />
与该领域的早期作品不同，本书中所有的工作都可以使用代码和与书籍一起提供的示例数据进行重现，例如在R包如<strong>spData</strong>中，其安装将在<em>空间类</em>章节中介绍。</p>
<p>每个术语都强调了受GIS影响的’科学’（即可重复和可证伪）方法，尽管它们的起源和主要应用领域不同。<br />
例如，GDS强调’数据科学’技能和大型数据集，而地理信息学则更侧重于数据结构。<br />
但是，这些术语之间的重叠比它们之间的差异更大，我们将地理计算用作涵盖所有这些术语的粗略同义词，它们都寻求用地理数据进行应用科学工作。<br />
然而，与早期使用这个术语的人不同，我们并不寻求暗示存在任何名为’地理计算’（或’Stan Openshaw称之为’GeoComputation’）的连贯的学术领域。<br />
相反，我们将这个术语定义如下：以计算方式处理地理数据，专注于代码、可重复性和模块化。</p>
<p>地理计算是一个新近的术语，但受到了古老观念的影响。<br />
它可以看作是地理学的一部分，地理学有2000多年的历史；以及<em>地理信息系统</em>（GIS）的延伸，该系统诞生于1960年代。</p>
<p>地理学在计算机发明之前就在解释和影响人类与自然世界的关系方面发挥了重要作用。<br />
例如，亚历山大·冯·洪堡在19世纪初对南美洲的旅行说明了这一点：不仅观察结果为物理和植物地理学的传统奠定了基础，而且还为保护自然世界的政策铺平了道路。<br />
本书旨在通过利用现代计算机和开源软件的力量，为’地理传统’做出贡献。</p>
<p>本书与较早的学科之间的联系反映在本书的建议标题中：<em>用R学地理学</em>和<em>R用于GIS</em>。<br />
每个标题都有优点。<br />
前者传达了这样一个信息，即它包含的内容远不止空间数据。非空间属性数据与几何数据不可避免地交织在一起，地理学不仅仅是关于地图上某个东西的位置。<br />
后者则传达了这是一本关于使用R作为GI来执行<em>地理数据</em>上的空间操作的书。</p>
<p>然而，GIS这个术语传达了一些含义（见表），这些含义简单地无法传达R最大的优点之一：其基于控制台的能力可以无缝地在地理和非地理数据处理、可视化和建模之间转换。因此，我们选择了一个更中性和包容性的标题。<br />
相对而言，地理计算意味着可复制和富有创造性的编程。当然，（地理计算的）算法是强大的工具，可能会变得非常复杂。<br />
然而，所有算法都由更小的部分组成。<br />
通过教授您其基础和底层结构，我们的目标是赋予您创造自己的地理数据问题创新解决方案的能力。</p>
<h2 id="为什么选择r进行地理计算"><a class="markdownIt-Anchor" href="#为什么选择r进行地理计算"></a> 为什么选择R进行地理计算?</h2>
<!--rl-->
<p>早期地理学家使用各种工具，包括气压计、指南针和<a href="https://en.wikipedia.org/wiki/Sextant">六分仪</a>，以增进对世界的了解。<br />
直到1761年海洋<a href="https://en.wikipedia.org/wiki/Marine_chronometer">天文钟</a>的发明，人们才能在海上计算经度，从而使船只能够采取更直接的航线。</p>
<p>如今，很难想象会缺乏地理数据。<br />
每部智能手机都有全球定位（GPS）接收器，从卫星和半自动车辆到公民科学家的多种传感器不断测量世界的每一个部分。<br />
数据生成的速度是惊人的。<br />
例如，一个自动驾驶车辆每天可以生成 100 GB的数据。<br />
卫星的遥感数据\index{remote sensing} 已经太大，无法用单台计算机分析相应的数据，因此出现了例如<a href="http://r-spatial.org/2016/11/29/openeo.html">OpenEO</a>之类的计划。</p>
<p>这场“地理数据革命”推动了对高性能计算硬件和高效、可扩展软件的需求，以从噪音中提取信号，了解甚至可能改变世界。<br />
空间数据库能够存储和生成大量地理数据集的可管理子集，使得从其中获取知识的界面成为未来的重要工具。<br />
R就是这样一种工具，具有先进的分析、建模和可视化能力。<br />
在这个背景下，本书的重点不在于语言本身]。<br />
相反，我们使用R作为理解世界的“行业工具”，类似于洪堡使用工具深入了解自然界所有的复杂性和相互联系。<br />
尽管编程看似是一种还原主义活动，目标是教授地理计算与R，不仅仅是为了乐趣，还是为了理解世界。</p>
<p>R是一个多平台的开源语言和环境，用于统计计算和图形（<a href="https://www.r-project.org/">r-project.org/</a>）。<br />
通过广泛的包，R还支持先进的地理空间统计、建模和可视化。<br />
新的集成开发环境（IDEs}）如RStudio已使R对许多人更加用户友好，通过专门用于交互式可视化的面板简化了制图工作。</p>
<p>在其核心，R是一个面向对象的<a href="https://adv-r.hadley.nz/fp.html">函数式编程语言</a>，特别设计为其他软件的交互式接口。<br />
后者还包括许多到GIS软件、“地理库&quot;和功能（见章节<em>GIS</em>）的&quot;桥梁”。<br />
因此，它是快速创建&quot;地理工具&quot;的理想选择，无需掌握低级语言（相对于R）如C、FORTRAN或Java。<br />
这可能感觉像是从基于GUI或专有地理信息系统，以查看GUI的定义，施加的比喻性&quot;玻璃天花板&quot;中挣脱出来。<br />
此外，R便于访问其他语言：例如，<strong>Rcpp</strong>和<strong>reticulate</strong>包允许访问C++和Python代码。<br />
这意味着R可以用作通往各种地理空间程序的&quot;桥梁&quot;。</p>
<p>另一个显示R灵活性和不断发展的地理能力的例子是交互式地图制作。<br />
如我们将在章节@ref(adv-map)中看到，R具有“有限的交互式[绘图]功能”[@bivand_applied_2013]的说法已经不再成立。<br />
这通过以下的代码块得到证明，该代码块创建了图（生成该图的函数将在章节<em>交互式地图</em>中介绍）。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>leaflet<span class="punctuation">)</span></span><br><span class="line">popup <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;Robin&quot;</span><span class="punctuation">,</span> <span class="string">&quot;Jakub&quot;</span><span class="punctuation">,</span> <span class="string">&quot;Jannes&quot;</span><span class="punctuation">)</span></span><br><span class="line">leaflet<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">  addProviderTiles<span class="punctuation">(</span><span class="string">&quot;NASAGIBS.ViirsEarthAtNight2012&quot;</span><span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">  addMarkers<span class="punctuation">(</span>lng <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="operator">-</span><span class="number">3</span><span class="punctuation">,</span> <span class="number">23</span><span class="punctuation">,</span> <span class="number">11</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">             lat <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">52</span><span class="punctuation">,</span> <span class="number">53</span><span class="punctuation">,</span> <span class="number">49</span><span class="punctuation">)</span><span class="punctuation">,</span> </span><br><span class="line">             popup <span class="operator">=</span> popup<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<div class="figure" style="text-align: center">
<iframe src="https://geocompr.github.io/img/interactive.html" width="100%" height="400px" data-external="1"></iframe>
<p class="caption">The blue markers indicate where the authors are from. The basemap is a tiled image of the Earth at night provided by NASA. Interact with the online version at r.geocompx.org, for example by zooming in and clicking on the popups.</p>
</div>
<p>几年前，使用R制作图本身就会很困难，更不用说作为一个交互式地图了。<br />
这展示了R的灵活性，以及多亏了如<strong>knitr</strong>和<strong>leaflet</strong>等发展，它可以用作与其他软件的接口，这是贯穿本书始终的一个主题。<br />
因此，R代码的使用使得可以通过参考代表现实世界现象的可复现示例来教授地理计算，而不仅仅是抽象概念。</p>
<h2 id="地理计算的软件"><a class="markdownIt-Anchor" href="#地理计算的软件"></a> 地理计算的软件</h2>
<!--rl-->
<p>R是一个用于地理计算的强大语言，但也有许多其他用于地理数据分析的选项，提供了数千个地理函数\index{function}。<br />
了解其他用于地理计算的语言将有助于决定何时使用其他工具可能更适合特定任务，并将R置于更广泛的地理空间生态系统中。<br />
本节简要介绍了用于地理计算的语言<a href="https://isocpp.org/">C++</a>，<a href="https://www.oracle.com/java/index.html">Java</a>和<a href="https://www.python.org/">Python</a>。</p>
<p>R（和Python）的一个重要特性是它是一种解释型语言。<br />
这是有利的，因为它允许在读取——求值——打印循环（REPL）中进行交互式编程。<br />
输入到控制台的代码立即执行并打印结果，而不是等待编译的中间阶段。<br />
另一方面，编译型语言如C++和Java倾向于运行更快（一旦它们已经被编译）。</p>
<p>C<ins>为许多GIS软件包（如<a href="https://www.qgis.org/">QGIS</a>，<a href="https://grass.osgeo.org/">GRASS</a>和<a href="http://www.saga-gis.org/">SAGA</a>）提供了基础，因此它是一个明智的起点。<br />
精心编写的C</ins>速度非常快，使其成为处理大型地理数据集等性能关键应用的好选择，但比Python或R更难学。<br />
通过<strong>Rcpp</strong>包，C++已经变得更容易接近，为R用户提供了一个很好的C编程的’切入点’。<br />
熟练掌握这种低级语言增加了创建新的高性能’地理算法’以及更好地理解GIS软件如何工作的可能性。</p>
<p>Java是用于地理计算的另一种重要和多功能的语言。<br />
GIS软件包gvSig、OpenJump和uDig都是用Java编写的。<br />
Java有许多GIS库，包括GeoTools和JTSJava拓扑套件，（GEOS是JTS的C++的部分）。<br />
此外，许多地图服务器应用程序使用Java，包括Geoserver/Geonode、deegree和52°North WPS。</p>
<p>Java\index{Java}的面向对象语法与C++\index{C++}相似。<br />
Java\index{Java}的一个主要优点是它是平台独立的（这对于编译语言来说是不寻常的）并且具有很高的可扩展性，使其成为像RStudio\index{RStudio}这样的IDE\index{IDE}的适当语言，用它写了这本书。<br />
与Python或R相比，Java在统计建模和可视化方面的工具较少，尽管它可用于数据科学[@brzustowicz_data_2017]。</p>
<p>Python\index{Python}是用于地理计算的重要语言，特别是因为许多桌面GIS\index{GIS}，如GRASS\index{GRASS}、SAGA\index{SAGA}和QGIS\index{QGIS}，提供了Python API\index{API}（见第@ref(gis)章）。<br />
与R\index{R}一样，它是一个流行的数据科学工具。<br />
这两种语言都是面向对象的，并且有许多重叠区域，导致了诸如reticulate这样的项目，促进了从R访问Python\index{Python}，以及Ursa Labs计划，以支持便携式库，使整个开源数据科学生态系统受益。</p>
<p>实际上，R和Python各有优点，某种程度上你使用哪个不如应用领域和结果传播重要。<br />
学习其中一个将为学习另一个提供先行优势。<br />
然而，R\index{R}相对于Python\index{Python}在地理计算\index{geocomputation}方面有主要优势。<br />
这包括其对语言本身中地理数据模型矢量和栅格的更好支持（见第@ref(spatial-class)章）以及相应的可视化可能性（见第@ref(spatial-class)和@ref(adv-map)章）。<br />
同样重要的是，R具有无与伦比的统计\index{statistics}支持，包括空间统计\index{spatial!statistics}，有数百个包（Python\index{Python}无法匹敌）支持数千种统计方法。</p>
<p>Python的主要优点是它是一种<em>通用</em>编程语言。<br />
它用于许多领域，包括桌面软件、电脑游戏、网站和数据科学\index{data science}。<br />
Python\index{Python}通常是不同（地理计算）社群之间唯一共享的语言，并可视为许多GIS\index{GIS}程序的“粘合剂”。<br />
许多地理算法\index{geoalgorithm}，包括QGIS\index{QGIS}和ArcMap中的那些，都可以从Python命令行访问，使其非常适合作为命令行GIS的入门语言。<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup></p>
<p>然而，在空间统计\index{spatial!statistics}和预测建模方面，R是无与伦比的。<br />
这并不意味着你必须选择R或Python：Python\index{Python}支持大多数常见的统计技术（尽管R倾向于更早地支持空间统计的新发展），许多从Python学到的概念可以应用到R\index{R}世界。</p>
<!--rl:toDo--> <!--to update! -->
<p>与R一样，Python还支持地理数据分析和处理，使用诸如<strong>shapely</strong>、<strong>geopandas</strong>、<strong>rasterio</strong>和<strong>xarray</strong>等包。</p>
<h2 id="rs-spatial-ecosystem"><a class="markdownIt-Anchor" href="#rs-spatial-ecosystem"></a> R’s spatial ecosystem</h2>
<hr class="footnotes-sep" />
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>该会议在利兹大学举行，其中一位作者（Robin）目前就职于此。<br />
第21届地理计算会议也在利兹大学举行，期间Robin和Jakub进行了演讲，主持了一个关于’tidy’空间数据分析的研讨会，并在书中进行了合作（更多关于会议系列和跨越两个世纪的论文/演示，<a href="http://xn--www-7n0j5iy14c.geocomputation.org">请访问www.geocomputation.org</a>）。 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>在大多数国家，今天可以从如<a href="https://www.ebay.com/sch/i.html?_from=R40&amp;_nkw=laptop&amp;_sacat=0&amp;_oaa=1&amp;_udhi=100&amp;rt=nc&amp;RAM%2520Size=4%2520GB%7C16%2520GB%7C8%2520GB&amp;_dcat=177">Ebay</a>这类似的网站上以100美元或更低的价格购买合适的二手笔记本电脑。<br />
有关在现代操作系统如<a href="https://rtask.thinkr.fr/installation-of-r-4-2-on-ubuntu-22-04-lts-and-tips-for-spatial-packages/">Ubuntu 22.04</a>上安装R的更多信息，请参见章节<em>空间类</em>。 <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>Python模块提供访问地理算法\index{geoalgorithm}的Python模块包括grass.script用于GRASS\index{GRASS}，saga-python用于SAGA-GIS\index{SAGA}，processing用于QGIS\index{QGIS}和arcpy用于ArcGIS\index{ArcGIS}。 <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>R</category>
        <category>Geocomputaion</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>Geocomputaion</tag>
      </tags>
  </entry>
  <entry>
    <title>(2)R中的地理数据</title>
    <url>/2023/08/11/2023-8-11-2-%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<p>本章将简要介绍两种基本的地理数据模型\index{data models}:矢量和栅格。<br />
我们将介绍每种数据模型背后的理论以及它们在哪些学科中占主导地位,然后演示它们在R中的实现。</p>
<span id="more"></span>
<h1 id="前提条件-"><a class="markdownIt-Anchor" href="#前提条件-"></a> 前提条件 {-}</h1>
<!--rl-->
<p>这是本书的第一章实践内容,因此它带有一些软件需求。</p>
<!-- toDo: rl-->
<!-- should we be that specific regarding the r version?-->
<p>您需要能够访问安装了最新版本R的计算机(R<a href="https://stat.ethz.ch/pipermail/r-announce/2022/000683.html">4.2.0</a> 或更高版本)。<br />
我们建议不仅阅读文本内容,也<em>运行每章的代码</em>,以建立您的地理计算技能。</p>
<p>为了跟踪您的学习过程,值得在计算机上新建一个文件夹来保存您的R脚本、输出和其他在学习《用R进行地理计算》过程中产生的东西。<br />
您也可以<a href="https://github.com/geocompx/geocompr/archive/refs/heads/main.zip">下载</a>或<a href="https://docs.github.com/en/repositories/creating-and-managing-repositories/cloning-a-repository">克隆</a>本书背后的<a href="https://github.com/geocompx/geocompr">源代码</a>以支持您的学习。<br />
我们强烈建议在编写/运行/测试R代码时安装集成开发环境(IDE),如<a href="https://posit.co/download/rstudio-desktop/#download">RStudio</a>(针对大多数人推荐)或<a href="https://github.com/REditorSupport/vscode-R">VS Code</a>。<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p>
<p>如果您是R的新手,我们建议您在深入学习《用R进行地理计算》代码之前,首先学习一些R入门资源,比如Garrett Grolemund的<a href="https://rstudio-education.github.io/hopr/starting.html">《用R学习编程》</a>或Claudia Engel的<a href="https://cengel.github.io/R-intro/">《R入门》</a> 。<br />
组织好您的工作(例如使用RStudio项目),并给脚本起合理的名称,如<code>chapter-02-notes.R</code>,以记录您在学习过程中的代码。\index{R!pre-requisites}</p>
<p>安装好环境后,是时候运行一些代码了!<br />
除非您已经安装了这些包,否则第一件事是使用以下命令安装本章需要的基础R包:<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">install.packages<span class="punctuation">(</span><span class="string">&quot;sf&quot;</span><span class="punctuation">)</span></span><br><span class="line">install.packages<span class="punctuation">(</span><span class="string">&quot;terra&quot;</span><span class="punctuation">)</span></span><br><span class="line">install.packages<span class="punctuation">(</span><span class="string">&quot;spData&quot;</span><span class="punctuation">)</span></span><br><span class="line">install.packages<span class="punctuation">(</span><span class="string">&quot;spDataLarge&quot;</span><span class="punctuation">,</span> repos <span class="operator">=</span> <span class="string">&quot;https://nowosad.r-universe.dev&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>\index{R!installation}<br />
\BeginKnitrBlock{rmdnote}<div class="rmdnote">我们建议按照<a href="https://cran.r-project.org/">CRAN</a>上的R安装说明进行操作。<br />
如果您使用Mac或Linux,上述安装<strong>sf</strong>的命令第一次可能不会起作用。<br />
这些操作系统 (OSs) 都有一些“系统需求”,在该包的<a href="https://github.com/r-spatial/sf">README</a>中有描述。<br />
网上可以找到其他特定操作系统的安装说明,包括<a href="https://rtask.thinkr.fr/installation-of-r-4-2-on-ubuntu-22-04-lts-and-tips-for-spatial-packages/">rtask.thinkr.fr</a>网站上的文章<em>在Ubuntu 22.04.1 LTS上安装R 4.2及空间包提示</em>。</div>\EndKnitrBlock{rmdnote}</p>
<p>复现本书第1部分内容所需的包可以通过以下命令安装:<code>remotes::install_github(&quot;geocompx/geocompkg&quot;)</code>。<br />
这个命令使用<strong>remotes</strong>包中的<code>install_packages()</code>函数来安装托管在GitHub代码托管、版本控制和协作平台上的源代码。<br />
以下命令将安装复现整本书所需的<strong>所有</strong>依赖项(警告:这可能需要几分钟):<br />
<code>remotes::install_github(&quot;geocompx/geocompkg&quot;, dependencies = TRUE)</code><br />
本章中提出的代码所需的包可以通过<code>library()</code>函数“加载”(技术上是附加)如下:</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>sf<span class="punctuation">)</span>          <span class="comment"># classes and functions for vector data</span></span><br><span class="line"><span class="comment">#&gt; Linking to GEOS 3.11.0, GDAL 3.5.3, PROJ 9.1.0; sf_use_s2() is TRUE</span></span><br></pre></td></tr></table></figure>
<p><code>library(sf)</code>的输出将报告该包正在使用的关键地理库(如GEOS)的版本,如第@ref(intro-sf)节所述。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>terra<span class="punctuation">)</span>      <span class="comment"># classes and functions for raster data</span></span><br></pre></td></tr></table></figure>
<p>我们安装的其他R包包含了书中将使用的数据:</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>spData<span class="punctuation">)</span>        <span class="comment"># load geographic data</span></span><br><span class="line"><span class="comment">#&gt; The legacy packages maptools, rgdal, and rgeos, underpinning the sp package,</span></span><br><span class="line"><span class="comment">#&gt; which was just loaded, will retire in October 2023.</span></span><br><span class="line"><span class="comment">#&gt; Please refer to R-spatial evolution reports for details, especially</span></span><br><span class="line"><span class="comment">#&gt; https://r-spatial.org/r/2023/05/15/evolution4.html.</span></span><br><span class="line"><span class="comment">#&gt; It may be desirable to make the sf package available;</span></span><br><span class="line"><span class="comment">#&gt; package maintainers should consider adding sf to Suggests:.</span></span><br><span class="line"><span class="comment">#&gt; The sp package is now running under evolution status 2</span></span><br><span class="line"><span class="comment">#&gt;      (status 2 uses the sf package in place of rgdal)</span></span><br><span class="line">library<span class="punctuation">(</span>spDataLarge<span class="punctuation">)</span>   <span class="comment"># load larger geographic data</span></span><br></pre></td></tr></table></figure>
<h1 id="引言"><a class="markdownIt-Anchor" href="#引言"></a> 引言</h1>
<hr class="footnotes-sep" />
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p><br />
我们建议使用<a href="https://r4ds.had.co.nz/workflow-projects.html">RStudio项目</a>、<a href="https://code.visualstudio.com/docs/editor/workspaces">VS Code工作区</a>或类似系统来管理项目。<br />
通过RStudio中的R控制台,可以使用<strong>rstudioapi</strong>包快速完成此操作。<br />
例如,使用以下命令在主目录中打开一个名为“geocompr-learning”的新项目:<code>rstudioapi::openProject(&quot;~/geocompr-learning&quot;)</code>。<br />
 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p><br />
<strong>spDataLarge</strong> 不存在于CRAN上,意味着必须通过<em>r-universe</em>或以下命令安装:<code>remotes::install_github(&quot;Nowosad/spDataLarge&quot;)</code>。 <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>R</category>
        <category>Geocomputaion</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>Geocomputaion</tag>
      </tags>
  </entry>
  <entry>
    <title>(4)空间操作</title>
    <url>/2023/08/13/2023-8-13-4-%E7%A9%BA%E9%97%B4%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>空间操作，包括矢量数据集之间的空间连接以及栅格数据集上的局部和焦点操作，是地理计算的重要部分。本章展示了如何基于空间对象的位置和形状以多种方式进行修改。许多空间操作有与之对应的非空间（属性）操作，因此上一章中演示的如子集提取和数据集连接等概念在此也适用。</p>
<span id="more"></span>
<h1 id="前提条件"><a class="markdownIt-Anchor" href="#前提条件"></a> 前提条件</h1>
<ul>
<li>此章节需要使用和之前章节相同的包。</li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>sf<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>terra<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>dplyr<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>spData<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<h1 id="引言"><a class="markdownIt-Anchor" href="#引言"></a> 引言</h1>
<p>空间操作，包括矢量数据集之间的空间连接以及栅格数据集上的局部和焦点操作，是地理计算的重要部分。本章展示了如何基于空间对象的位置和形状以多种方式进行修改。许多空间操作有与之对应的非空间（属性）操作，因此上一章中演示的如子集提取和数据集连接等概念在此也适用。对于矢量操作来说，这一点尤为适用：矢量属性操作为理解空间对应关系——即空间子集（在空间矢量提取部分中介绍）提供了基础。空间连接和空间聚合也具有非空间相似操作，已在上一章中介绍。</p>
<p>空间操作与非空间操作在许多方面有所不同，例如：空间连接可以通过多种方式进行，包括匹配与目标数据集相交或位于目标数据集一定距离范围内的实体，而上一章节矢量属性连接中讨论的属性连接只能通过一种方式进行（除非使用模糊连接，如 <a href="https://cran.r-project.org/package=fuzzyjoin" title="fuzzyjoin"><strong>fuzzyjoin</strong></a> 包的文档所述）。对象之间不同类型的空间关系，包括相交和分离，均在章节拓扑关系中描述。空间对象的另一个独特之处在于距离，所有的空间对象都通过空间相关联，距离计算可用于探索这种关联的强度，正如在距离关系节中描述的矢量数据的情况一样。</p>
<p>栅格对象上的空间操作包括子集提取——在空间栅格子集提取节中进行了介绍-以及将多个栅格&quot;瓦片&quot;合并成一个对象，在合并栅格节中演示。地图代数涵盖了一系列修改栅格单元值的操作，可以参考周围单元值，也可以不参考周围单元值。地图代数的概念对许多应用至关重要，本节介绍了地图代数，并分别在地图代数节介绍了局部、焦点和分区地图代数操作。全局地图代数操作会生成代表整个栅格数据集的汇总统计数据，与栅格数据的距离计算在全局操作和距离章节中进行了讨论。在章节中，讨论了合并两个栅格数据集的过程，并结合一个可重现的示例进行演示。</p>
<blockquote>
<p>📌需要注意的是，使用两个空间对象进行空间操作需要这两个对象具有相同的坐标参考系统。这个话题在<em>crs介绍</em>中引入，并在<em>地理数据重投影</em>中进行了更详细的讨论。</p>
</blockquote>
<h1 id="矢量数据空间操作"><a class="markdownIt-Anchor" href="#矢量数据空间操作"></a> 矢量数据空间操作</h1>
<p>本节概述了在<strong>sf</strong>包中表示为简单要素的矢量地理数据上的空间操作。<em>栅格数据空间操作</em>节使用 terra 包中的类和函数对栅格数据集进行空间操作。</p>
<h2 id="空间矢量提取"><a class="markdownIt-Anchor" href="#空间矢量提取"></a> 空间矢量提取</h2>
<p>空间子集提取是将空间对象进行处理并返回一个包含与另一个对象空间相关特征的新对象的过程。类似于属性子集提取（在矢量属性提取子集）节中介绍），可使用方括号（<code>[</code>）运算符来创建 sf 数据框的子集，其语法为<code>x[y, , op = st_intersects]</code>，其中<code>x</code>是 sf 对象的一个子集，<code>y</code>是&quot;子集对象&quot;，<code>op = st_intersects</code>是一个可选参数，用于指定进行子集提取处理的拓扑关系（也称为二元谓词）。当未提供<code>op</code>参数时，<code>st_intersects()</code>是默认的拓扑关系。命令<code>x[y, ]</code>与上述<code>x[y, , op = st_intersects]</code>完全相同，但不同于<code>x[y, , op = st_disjoint]</code>（这些以及其他拓扑关系的含义在下一节中描述）。tidyverse中的<code>filter()</code>函数也可以使用，但这种方法更冗长，如下例所示。</p>
<p>为了演示空间子集提取，我们将使用 spData 包中的<code>nz</code>和<code>nz_height</code>数据集，它们分别包含新西兰16个主要地区和101个最高点的地理数据，以投影坐标系为基础。以下代码块创建的对象表示Canterbury，然后使用<strong>空间子集提取</strong>返回该区域内所有的高点：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">canterbury <span class="operator">=</span> nz <span class="operator">|&gt;</span> filter<span class="punctuation">(</span>Name <span class="operator">==</span> <span class="string">&quot;Canterbury&quot;</span><span class="punctuation">)</span></span><br><span class="line">canterbury_height <span class="operator">=</span> nz_height<span class="punctuation">[</span>canterbury<span class="punctuation">,</span> <span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202308232057538.png" alt="Illustration of spatial subsetting with red triangles representing 101 high points in New Zealand, clustered near the central Canterbuy region (left). The points in Canterbury were created with the  subsetting operator (highlighted in gray, right)." title="Illustration of spatial subsetting with red triangles representing 101 high points in New Zealand, clustered near the central Canterbuy region (left). The points in Canterbury were created with the `[` subsetting operator (highlighted in gray, right)." /></p>
<p>就像属性子集提取一样，命令<code>x[y, ]</code>（相当于<code>nz_height[canterbury, ]</code>）使用源对象<code>y</code>的内容对目标<code>x</code>进行特征子集提取。然而，与<code>y</code>是逻辑或整数类的向量不同的是，对于空间子集提取，<code>x</code>和<code>y</code>都必须是地理对象。具体而言，以这种方式用于空间子集提取的对象必须具有类<code>sf</code>或<code>sfc</code>。<code>nz</code>和<code>nz_height</code>都是地理向量数据框，具有类<code>sf</code>，操作的结果将返回另一个<code>sf</code>对象，表示目标<code>nz_height</code>对象中与（在本例中位于）canterbury地区相交的特征（即位于高处的点）。</p>
<p>用于空间子集提取的<strong>各种拓扑关系</strong>决定了目标对象中的特征，必须与要选择的子集对象具有的空间关系类型。这些关系包括<em>接触</em>、<em>交叉</em>或<em>包含</em>，在拓扑关系部分中我们将很快看到。默认设置<code>st_intersects</code>是一个&quot;全包括&quot;的拓扑关系，它将返回与源&quot;子集&quot;对象<em>接触</em>、<em>交叉</em>或<em>包含</em>的目标中的特征。如上所示，可以用<code>op=</code>参数指定其他空间运算符，如下面的命令所示，该命令返回<code>st_intersects()</code>的相反内容，即与坎特伯雷不相交的点（请参阅部分）：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">nz_height<span class="punctuation">[</span>canterbury<span class="punctuation">,</span> <span class="punctuation">,</span> op <span class="operator">=</span> st_disjoint<span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>📌请注意前面代码块中的空参数用 <code>, ,</code> 表示是为了突出 <code>op</code>，即 <code>sf</code> 对象 <code>[</code> 的第三个参数。<br />
可以使用这个参数以多种方式改变子集操作。<br />
例如，<code>nz_height[canterbury, 2, op = st_disjoint]</code> 返回相同的行，但仅包括第二个属性列（详见 <code>sf:::`[.sf`</code> 和 <code>?sf</code>）。</p>
</blockquote>
<p>对于许多应用而言，关于矢量数据的空间子集提取的知识就是你需要了解的全部内容：它只会按预期工作。如果你急于了解更多拓扑关系，超出了 <code>st_intersects()</code>和<code>st_disjoint()</code>的范围，请跳到下一节拓扑关系。如果你对细节感兴趣，包括其他子集方式，请继续阅读。</p>
<p>另一种进行空间子集提取的方法是使用拓扑操作返回的对象。这些对象本身就很有用，例如在探索相邻区域之间的关系图网络时，但它们也可以用于子集操作，如下方的代码块中所演示的：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">sel_sgbp <span class="operator">=</span> st_intersects<span class="punctuation">(</span>x <span class="operator">=</span> nz_height<span class="punctuation">,</span> y <span class="operator">=</span> canterbury<span class="punctuation">)</span></span><br><span class="line"><span class="built_in">class</span><span class="punctuation">(</span>sel_sgbp<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] &quot;sgbp&quot; &quot;list&quot;</span></span><br><span class="line">sel_sgbp</span><br><span class="line"><span class="comment">#&gt; Sparse geometry binary predicate list of length 101, where the</span></span><br><span class="line"><span class="comment">#&gt; predicate was `intersects&#x27;</span></span><br><span class="line"><span class="comment">#&gt; first 10 elements:</span></span><br><span class="line"><span class="comment">#&gt;  1: (empty)</span></span><br><span class="line"><span class="comment">#&gt;  2: (empty)</span></span><br><span class="line"><span class="comment">#&gt;  3: (empty)</span></span><br><span class="line"><span class="comment">#&gt;  4: (empty)</span></span><br><span class="line"><span class="comment">#&gt;  5: 1</span></span><br><span class="line"><span class="comment">#&gt;  6: 1</span></span><br><span class="line"><span class="comment">#&gt;  7: 1</span></span><br><span class="line"><span class="comment">#&gt;  8: 1</span></span><br><span class="line"><span class="comment">#&gt;  9: 1</span></span><br><span class="line"><span class="comment">#&gt;  10: 1</span></span><br><span class="line">sel_logical <span class="operator">=</span> lengths<span class="punctuation">(</span>sel_sgbp<span class="punctuation">)</span> <span class="operator">&gt;</span> <span class="number">0</span></span><br><span class="line">canterbury_height2 <span class="operator">=</span> nz_height<span class="punctuation">[</span>sel_logical<span class="punctuation">,</span> <span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<p>以上代码块创建一个 <code>sgbp</code> 类的对象 (一个稀疏几何二元谓词，一个在空间操作中长度为 <code>x</code> 的列表)，然后将其转换为逻辑向量 <code>sel_logical</code>（包含仅为 <code>TRUE</code> 和 <code>FALSE</code> 的值，这也可以由 dplyr 的 filter 函数使用）。<code>lengths()</code>识别<code>nz_height</code>中的哪些要素与 <code>y</code> 中的任何对象相交。在这种情况下，1 是最大可能值，但对于更复杂的操作，可以使用该方法仅对与源对象中的 2 个或更多个要素相交的要素进行子集操作。</p>
<blockquote>
<p>📌注意：通过在<code>st_intersects()</code>等运算符中设置<code>sparse = FALSE</code>（意思是“返回密集矩阵而不是稀疏矩阵”）也可以返回逻辑输出。例如，命令<code>st_intersects(x = nz_height, y = canterbury, sparse = FALSE)[, 1]</code>将返回与<code>sel_logical</code>相同的输出。<br />
注意：涉及<code>sgbp</code>对象的解决方案更具普遍性，因为它适用于多对多的操作并且对内存要求较低。</p>
</blockquote>
<p>使用 sf 函数<code>st_filter()</code>可以实现相同的结果，该函数是为了增加<code>sf</code>对象与dplyr数据操作代码之间的兼容性而创建的：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">canterbury_height3 <span class="operator">=</span> nz_height <span class="operator">|&gt;</span></span><br><span class="line">  st_filter<span class="punctuation">(</span>y <span class="operator">=</span> canterbury<span class="punctuation">,</span> .predicate <span class="operator">=</span> st_intersects<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>到目前为止，有三个完全相同（除了行名）的<code>canterbury_height</code>版本，一个使用<code>[</code>操作符创建，一个通过中间选择对象创建，另一个使用sf的便捷函数<code>st_filter()</code>创建。</p>
<p>下一节探讨了不同类型的空间关系，也称为<strong>二元谓词</strong>，可以用来确定两个特征是否存在空间关系。</p>
<h2 id="拓扑关系"><a class="markdownIt-Anchor" href="#拓扑关系"></a> 拓扑关系</h2>
<p>拓扑关系描述了对象之间的空间关系。完整称呼为&quot;二元拓扑关系&quot;，是关于由有序点集（通常形成点、线和多边形）在两个或多个维度中定义的两个对象之间的空间关系的逻辑陈述（答案只能是<code>TRUE</code>或<code>FALSE</code>）。这听起来可能相当抽象，实际上，拓扑关系的定义和分类是基于1966年首次以书籍形式出版的数学基础，代数拓扑领域一直延续到21世纪。</p>
<p>尽管拓扑关系起源于数学，但通过参考常用函数的可视化，可以直观地理解用于测试常见空间关系类型的拓扑关系。显示了各种几何对及其关联关系。图中的第三和第四对（从左到右然后向下）表明，对于某些关系，顺序很重要：虽然等于、相交、交叉、接触和重叠的关系是对称的，意味着如果<code>function(x, y)</code>为真，则<code>function(y, x)</code>也为真，但包含和内部等顺序重要的几何关系则不是。注意，每一对几何图形都有一个&quot;DE-9IM&quot;字符串，例如FF2F11212，将在下一节中描述。</p>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202308232211273.png" alt="Topological relations between vector geometries, inspired by Figures 1 and 2 in Egenhofer and Herring (1990). The relations for which the function(x, y) is true are printed for each geometry pair, with x represented in pink and y represented in blue. The nature of the spatial relationship for each pair is described by the Dimensionally Extended 9-Intersection Model string." title="Topological relations between vector geometries, inspired by Figures 1 and 2 in Egenhofer and Herring (1990). The relations for which the function(x, y) is true are printed for each geometry pair, with x represented in pink and y represented in blue. The nature of the spatial relationship for each pair is described by the Dimensionally Extended 9-Intersection Model string." /></p>
<p>在<code>sf</code>中，测试不同拓扑关系的函数被称为&quot;二元谓词&quot;，如在操作简单要素几何的文献 Manipulating Simple Feature Geometries 中所述，可以使用命令 <a href="https://r-spatial.github.io/sf/articles/sf3.html" title="vignette(&quot;sf3&quot;)">vignette(“sf3”)</a>查看，也可以在帮助页面中查看<a href="https://r-spatial.github.io/sf/reference/geos_binary_ops.html" title="?geos_binary_pred">?geos_binary_pred</a>。为了更好地理解拓扑关系的实用性，我们将建立一个简单可重现的例子，基于上图中所述的关系，巩固了前一章节<em>几何</em>所介绍的矢量几何图形表示的知识。请注意，为了创建代表多边形顶点坐标（x 和 y）的表格数据，我们使用基本 R 函数 <code>cbind()</code> 创建表示坐标点的矩阵，一个<code>POLYGON</code>，最后是 <code>sfc</code> 对象，如<em>空间类</em>所述：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">polygon_matrix <span class="operator">=</span> cbind<span class="punctuation">(</span></span><br><span class="line">  x <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span> <span class="number">0</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span>   <span class="number">0</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">  y <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">0.5</span><span class="punctuation">,</span> <span class="number">0</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">)</span></span><br><span class="line">polygon_sfc <span class="operator">=</span> st_sfc<span class="punctuation">(</span>st_polygon<span class="punctuation">(</span><span class="built_in">list</span><span class="punctuation">(</span>polygon_matrix<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>请注意在上面创建的多边形之上，我们将创建额外的几何体来展示它们在空间中的关系。所示的命令在绘制时与该多边形相关联。请注意在转换数据框时使用了函数<code>st_as_sf()</code>和参数<code>coords</code>，以高效地将包含坐标列的数据框转换为包含点的<code>sf</code>对象：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">line_sfc <span class="operator">=</span> st_sfc<span class="punctuation">(</span>st_linestring<span class="punctuation">(</span>cbind<span class="punctuation">(</span></span><br><span class="line">  x <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0.4</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">  y <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0.2</span><span class="punctuation">,</span> <span class="number">0.5</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 创建点</span></span><br><span class="line">point_df <span class="operator">=</span> data.frame<span class="punctuation">(</span></span><br><span class="line">  x <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0.2</span><span class="punctuation">,</span> <span class="number">0.7</span><span class="punctuation">,</span> <span class="number">0.4</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">  y <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0.1</span><span class="punctuation">,</span> <span class="number">0.2</span><span class="punctuation">,</span> <span class="number">0.8</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">)</span></span><br><span class="line">point_sf <span class="operator">=</span> st_as_sf<span class="punctuation">(</span>point_df<span class="punctuation">,</span> coords <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;x&quot;</span><span class="punctuation">,</span> <span class="string">&quot;y&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202308232229968.png" alt="Points, line and polygon objects arranged to illustrate topological relations." title="Points, line and polygon objects arranged to illustrate topological relations." /></p>
<p>一个简单查询是：<code>point_sf</code> 中的哪些点与多边形 <code>polygon_sfc</code> 以某种方式相交？此问题通过检查可得到答案（点1和点3分别与多边形相切和在多边形内）。可以使用空间谓词 <code>st_intersects()</code>，如下所示：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">st_intersects<span class="punctuation">(</span>point_sf<span class="punctuation">,</span> polygon_sfc<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; Sparse geometry binary predicate... `intersects&#x27;</span></span><br><span class="line"><span class="comment">#&gt;  1: 1</span></span><br><span class="line"><span class="comment">#&gt;  2: (empty)</span></span><br><span class="line"><span class="comment">#&gt;  3: 1</span></span><br></pre></td></tr></table></figure>
<p>结果应该符合你的直觉：第一个和第三个点返回正（<code>1</code>）的结果，第二个点在多边形的边界之外返回负结果（用一个空向量表示）。而令人意想不到的是，结果以向量列表的形式呈现。这个<em>稀疏矩阵</em>输出只记录存在关系的部分，减少了对多要素对象进行拓扑操作时的内存需求。正如我们在前面的部分中所看到的，当<code>sparse = FALSE</code>时，返回的是一个由<code>TRUE</code>或<code>FALSE</code>值组成的<em>稠密矩阵</em>：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">st_intersects<span class="punctuation">(</span>point_sf<span class="punctuation">,</span> polygon_sfc<span class="punctuation">,</span> sparse <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt;       [,1]</span></span><br><span class="line"><span class="comment">#&gt; [1,]  TRUE</span></span><br><span class="line"><span class="comment">#&gt; [2,] FALSE</span></span><br><span class="line"><span class="comment">#&gt; [3,]  TRUE</span></span><br></pre></td></tr></table></figure>
<p>在上述输出中，每一行代表目标（参数<code>x</code>）对象中的一个特征，每一列代表选择对象（<code>y</code>）中的一个特征。在这个情况下，<code>y</code>对象<code>polygon_sfc</code>中只有一个特征，所以结果只有一列，这个结果可以用于我们在<em>空间子集提取</em>部分所看到的子集提取。</p>
<p><code>st_intersects()</code>即使在特征只是相切的情况下也返回<code>TRUE</code>，<code>intersects</code>是一种&quot;全能&quot;的拓扑操作，它识别许多类型的空间关系，如下图所示。更有限制的问题包括哪些点位于多边形内，以及哪些特征在<code>y</code>上或包含与<code>y</code>共享的边界？这些问题可以如下回答（结果未显示）：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">st_within<span class="punctuation">(</span>point_sf<span class="punctuation">,</span> polygon_sfc<span class="punctuation">)</span>    <span class="comment"># 在范围内</span></span><br><span class="line">st_touches<span class="punctuation">(</span>point_sf<span class="punctuation">,</span> polygon_sfc<span class="punctuation">)</span>   <span class="comment"># 相切</span></span><br></pre></td></tr></table></figure>
<p>请注意，尽管第一个点<em>接触</em>多边形的边界，但它并不在其中；第三个点在多边形内部，但不接触其边界的任何部分。<code>st_intersects()</code>的反义词是<code>st_disjoint()</code>，它只返回与选择对象在空间上完全不相关的对象（注意<code>[,  1]</code>将结果转换为向量）：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">st_disjoint<span class="punctuation">(</span>point_sf<span class="punctuation">,</span> polygon_sfc<span class="punctuation">,</span> sparse <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">)</span><span class="punctuation">[</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">]</span></span><br><span class="line"><span class="comment">#&gt; [1] FALSE  TRUE FALSE</span></span><br></pre></td></tr></table></figure>
<p>函数<code>st_is_within_distance()</code>检测到那些<em>几乎接触</em>选择对象的特征，它有一个额外的<code>dist</code>参数。它可以用来设置目标对象需要多近才能被选择。请注意，尽管点2距离<code>polygon_sfc</code>的最近顶点的距离超过0.2个单位，但当距离设置为0.2时，它仍然被选择。这是因为距离是测量到最近的边缘，在这种情况下是多边形直接在点2上方的部分，如下图所示。（你可以用命令<code>st_distance(point_sf, polygon_sfc)</code>来验证点2和多边形之间的实际距离是0.13。）下面的代码块演示了’is within distance’二元空间谓词，其结果显示每个点都在多边形的0.2个单位内：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">st_is_within_distance<span class="punctuation">(</span>point_sf<span class="punctuation">,</span> polygon_sfc<span class="punctuation">,</span> dist <span class="operator">=</span> <span class="number">0.2</span><span class="punctuation">,</span> sparse <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">)</span><span class="punctuation">[</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">]</span></span><br><span class="line"><span class="comment">#&gt; [1] TRUE TRUE TRUE</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>📌算拓扑关系的函数使用空间索引来大大提高空间查询性能。<br />
它们使用Sort-Tile-Recursive（STR）算法来实现。<br />
下一节中提到的<code>st_join</code>函数也使用空间索引。<br />
您可以在<a href="https://www.r-spatial.org/r/2017/06/22/spatial-index.html">https://www.r-spatial.org/r/2017/06/22/spatial-index.html</a>中了解更多信息。</p>
</blockquote>
<h2 id="de-9im-strings"><a class="markdownIt-Anchor" href="#de-9im-strings"></a> DE-9IM strings</h2>
<p>在前一节所示的二元谓词之下，隐含的是Dimensionally Extended 9-Intersection Model (DE-9IM)。正如这个神秘的名字所暗示的那样，这并不是一个容易的话题。不过，学习它有可能更好地理解空间关系。此外，DE-9IM的高级用途还包括创建自定义空间谓词。该模型最初被其发明者标记为&quot;DE + 9IM&quot;，指的是&quot;两个要素的边界、内部和外部的交界面的维度&quot; ，但现在被称为DE-9IM 。</p>
<p>为了演示DE-9IM strings的工作原理，让我们看看中第一个几何对之间的各种关系。下图展示了9 intersection model (9IM)，显示了每个对象的内部、边界和外部之间的交点，当第一个对象<code>x</code>的每个组件被排列为列，而<code>y</code>的每个组件被排列为行时，会创建出一个带有每个元素交点突出显示的分面图形。</p>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202308232332970.png" alt="Illustration of how the Dimensionally Extended 9 Intersection Model (DE-9IM) works. Colors not in the legend represent the overlap between different components. The thick lines highlight 2 dimensional intesections, e.g. between the boundary of object x and the interior of object y, shown in the middle top facet." title="Illustration of how the Dimensionally Extended 9 Intersection Model (DE-9IM) works. Colors not in the legend represent the overlap between different components. The thick lines highlight 2 dimensional intesections, e.g. between the boundary of object x and the interior of object y, shown in the middle top facet." /></p>
<p>DE-9IM strings是基于每种关系的不同维度而产生的。在这种情况下，图中的红色交点分别有着0（点）、1（线）和2（多边形）不同的维度，如简单表格所示。</p>
<table>
<thead>
<tr>
<th></th>
<th>Interior (x)</th>
<th>Boundary (x)</th>
<th>Exterior (x)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Interior (y)</td>
<td>2</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>Boundary (y)</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>Exterior (y)</td>
<td>2</td>
<td>1</td>
<td>2</td>
</tr>
</tbody>
</table>
<p>按行展开这个矩阵（即按顺序连接第一行、第二行、第三行）得到字符串<code>212111212</code>。另一个例子可以用来说明该系统：下图中展示的关系（第三列和第一行中的第三个多边形对）可以用DE-9IM系统定义如下：</p>
<ul>
<li>较大对象<code>x</code>的<em>内部</em>与<code>y</code>的内部、边界和外部之间的交集分别有维数2、1和2</li>
<li>较大对象<code>x</code>的<em>边界</em>与<code>y</code>的内部、边界和外部之间的交叉点分别有F，F 和1的维度，其中<code>F</code>表示<code>false</code>，物体是不相交的</li>
<li><code>x</code>的<em>外部</em>与<code>y</code>的内部、边界和外部之间的交集分别具有F、F和2的维度，更大对象的外部不接触<code>y</code>的内部或边界，但更小和更大对象的外部覆盖相同的区域</li>
</ul>
<p>当这三个组件连接在一起时，创建字符串<code>212</code>、<code>FF1</code>和<code>FF2</code>。这与从函数<code>st_relations()</code>获得的结果相同(参见本章的源代码，查看图) 中的其他几何图形是如何创建的) :</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">xy2sfc <span class="operator">=</span> <span class="keyword">function</span><span class="punctuation">(</span>x<span class="punctuation">,</span> y<span class="punctuation">)</span> st_sfc<span class="punctuation">(</span>st_polygon<span class="punctuation">(</span><span class="built_in">list</span><span class="punctuation">(</span>cbind<span class="punctuation">(</span>x<span class="punctuation">,</span> y<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">x <span class="operator">=</span> xy2sfc<span class="punctuation">(</span>x <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span> <span class="number">0</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">0</span><span class="punctuation">)</span><span class="punctuation">,</span> y <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">0.5</span><span class="punctuation">,</span> <span class="number">0</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">y <span class="operator">=</span> xy2sfc<span class="punctuation">(</span>x <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0.7</span><span class="punctuation">,</span> <span class="number">0.7</span><span class="punctuation">,</span> <span class="number">0.9</span><span class="punctuation">,</span> <span class="number">0.7</span><span class="punctuation">)</span><span class="punctuation">,</span> y <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0.8</span><span class="punctuation">,</span> <span class="number">0.5</span><span class="punctuation">,</span> <span class="number">0.5</span><span class="punctuation">,</span> <span class="number">0.8</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">st_relate<span class="punctuation">(</span>x<span class="punctuation">,</span> y<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt;      [,1]       </span></span><br><span class="line"><span class="comment">#&gt; [1,] &quot;212FF1FF2&quot;</span></span><br></pre></td></tr></table></figure>
<p>理解DE-9IM strings可以推出新的二元空间谓词。<code>?st_relate</code> 帮助页面包含’Queen’关系和’rook’关系的函数定义，其中多边形共享边界或仅共享一个点。'Queen’关系意味着&quot;边界-边界&quot;关系(简单表格中第二列和第二行的单元格或 DE-9IM string的第五个元素)不能是空的，它相当于模式 <code>F***T****</code>，而对于’rook’关系，则相同的元素必须是1（表示线性相交）。这些措施的执行情况如下:</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">st_queen <span class="operator">=</span> <span class="keyword">function</span><span class="punctuation">(</span>x<span class="punctuation">,</span> y<span class="punctuation">)</span> st_relate<span class="punctuation">(</span>x<span class="punctuation">,</span> y<span class="punctuation">,</span> pattern <span class="operator">=</span> <span class="string">&quot;F***T****&quot;</span><span class="punctuation">)</span></span><br><span class="line">st_rook <span class="operator">=</span> <span class="keyword">function</span><span class="punctuation">(</span>x<span class="punctuation">,</span> y<span class="punctuation">)</span> st_relate<span class="punctuation">(</span>x<span class="punctuation">,</span> y<span class="punctuation">,</span> pattern <span class="operator">=</span> <span class="string">&quot;F***1****&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>在先前创建的对象<code>x</code>的基础上，我们可以使用新创建的函数来找出网格中哪些元素是’queen’和’rook’相对于网格中间的正方形，如下所示:</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">grid <span class="operator">=</span> st_make_grid<span class="punctuation">(</span>x<span class="punctuation">,</span> n <span class="operator">=</span> <span class="number">3</span><span class="punctuation">)</span></span><br><span class="line">grid_sf <span class="operator">=</span> st_sf<span class="punctuation">(</span>grid<span class="punctuation">)</span></span><br><span class="line">grid_sf<span class="operator">$</span>queens <span class="operator">=</span> lengths<span class="punctuation">(</span>st_queen<span class="punctuation">(</span>grid<span class="punctuation">,</span> grid<span class="punctuation">[</span><span class="number">5</span><span class="punctuation">]</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">&gt;</span> <span class="number">0</span></span><br><span class="line">plot<span class="punctuation">(</span>grid<span class="punctuation">,</span> col <span class="operator">=</span> grid_sf<span class="operator">$</span>queens<span class="punctuation">)</span></span><br><span class="line">grid_sf<span class="operator">$</span>rooks <span class="operator">=</span> lengths<span class="punctuation">(</span>st_rook<span class="punctuation">(</span>grid<span class="punctuation">,</span> grid<span class="punctuation">[</span><span class="number">5</span><span class="punctuation">]</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">&gt;</span> <span class="number">0</span></span><br><span class="line">plot<span class="punctuation">(</span>grid<span class="punctuation">,</span> col <span class="operator">=</span> grid_sf<span class="operator">$</span>rooks<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202308240039875.png" alt="Demonstration of custom binary spatial predicates for finding ‘queen’ (left) and ‘rook’ (right) relations to the central square in a grid with 9 geometries." title="Demonstration of custom binary spatial predicates for finding ‘queen’ (left) and ‘rook’ (right) relations to the central square in a grid with 9 geometries." /></p>
<h2 id="空间连接"><a class="markdownIt-Anchor" href="#空间连接"></a> 空间连接</h2>
<p>连接两个非空间数据集依赖于一个共享的’key’变量，如矢量属性连接节中所述。空间数据连接应用了相同的概念，但是依赖于前面部分描述的空间关系。与属性数据一样，连接从源对象(<code>y</code>)向目标对象(参数<code>x</code>在联接函数中)添加新的列。</p>
<p>这个过程可以通过以下例子来说明：假设你在地球表面随机分布了十个点，问这些点中哪些在陆地上，属于哪些国家。在<a href="https://github.com/geocompx/geocompr/blob/main/code/04-spatial-join.R" title="reproducible example">reproducible example</a>中实现这个想法将会提高你的地理数据处理技能，并演示空间连接的运作方式。首先，需要创建随机分布在地球表面的点：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">set.seed<span class="punctuation">(</span><span class="number">2018</span><span class="punctuation">)</span> <span class="comment"># set seed for reproducibility</span></span><br><span class="line"><span class="punctuation">(</span>bb <span class="operator">=</span> st_bbox<span class="punctuation">(</span>world<span class="punctuation">)</span><span class="punctuation">)</span> <span class="comment"># the world&#x27;s bounds</span></span><br><span class="line"><span class="comment">#&gt;   xmin   ymin   xmax   ymax </span></span><br><span class="line"><span class="comment">#&gt; -180.0  -89.9  180.0   83.6</span></span><br><span class="line">random_df <span class="operator">=</span> data.frame<span class="punctuation">(</span></span><br><span class="line">  x <span class="operator">=</span> runif<span class="punctuation">(</span>n <span class="operator">=</span> <span class="number">10</span><span class="punctuation">,</span> <span class="built_in">min</span> <span class="operator">=</span> bb<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="built_in">max</span> <span class="operator">=</span> bb<span class="punctuation">[</span><span class="number">3</span><span class="punctuation">]</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">  y <span class="operator">=</span> runif<span class="punctuation">(</span>n <span class="operator">=</span> <span class="number">10</span><span class="punctuation">,</span> <span class="built_in">min</span> <span class="operator">=</span> bb<span class="punctuation">[</span><span class="number">2</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="built_in">max</span> <span class="operator">=</span> bb<span class="punctuation">[</span><span class="number">4</span><span class="punctuation">]</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">)</span></span><br><span class="line">random_points <span class="operator">=</span> random_df <span class="operator">|&gt;</span> </span><br><span class="line">  st_as_sf<span class="punctuation">(</span>coords <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;x&quot;</span><span class="punctuation">,</span> <span class="string">&quot;y&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> crs <span class="operator">=</span> <span class="string">&quot;EPSG:4326&quot;</span><span class="punctuation">)</span> <span class="comment"># set coordinates and CRS</span></span><br></pre></td></tr></table></figure>
<p>下图中的场景显示，<code>Random_points</code>对象(左上)缺乏属性数据，而<code>world</code>(右上)具有属性，包括图例中显示的国家样本的国家名称。空间连接使用<code>st_join()</code>实现，如下面的代码块所示。输出是<code>Random_join</code>对象，如图(左下)。在创建连接的数据集之前，我们使用空间子集提取来创建<code>world_random</code>，其中只包含含有随机点的国家，以验证在连接的数据集中返回的国家名称数量应该是4(参见下图的右上面板)。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">world_random <span class="operator">=</span> world<span class="punctuation">[</span>random_points<span class="punctuation">,</span> <span class="punctuation">]</span></span><br><span class="line">nrow<span class="punctuation">(</span>world_random<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] 4</span></span><br><span class="line">random_joined <span class="operator">=</span> st_join<span class="punctuation">(</span>random_points<span class="punctuation">,</span> world<span class="punctuation">[</span><span class="string">&quot;name_long&quot;</span><span class="punctuation">]</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202308271029710.png" alt="Illustration of a spatial join. A new attribute variable is added to random points (top left) from source world object (top right) resulting in the data represented in the final panel." title="Illustration of a spatial join. A new attribute variable is added to random points (top left) from source world object (top right) resulting in the data represented in the final panel." /></p>
<p>默认情况下，<code>st_join()</code>执行<em>左连接</em>，这意味着结果是一个包含来自 <code>x</code> 的所有行的对象，其中包括没有匹配 <code>y</code> 的行（请参见矢量属性连接），但是也可以通过设置参数 <code>left = FALSE</code> 进行内连接。与空间子集提取相似，<code>st_join()</code> 默认使用的拓扑运算符是 <code>st_intersects()</code>，可以通过设置 <code>join</code> 参数来更改（详见 <code>?st_join</code>）。上面的示例演示了将多边形图层的一列添加到点图层的方法，但是该方法适用于任何几何类型。在这种情况下，例如当<code>x</code>包含多边形，每个多边形都与<code>y</code>中多个对象匹配时，空间连接将通过为每个<code>y</code>的匹配创建新行而导致重复的要素。</p>
<h2 id="非重叠连接"><a class="markdownIt-Anchor" href="#非重叠连接"></a> 非重叠连接</h2>
<p>有时候，两个地理数据集虽然没有触碰，但仍然存在着强烈的地理关系。<code>cycle_hire</code>和<code>cycle_hire_osm</code>这两个数据集已经被附加在<strong>spData</strong>包中，它们提供了很好的例子。将它们绘制出来可以发现它们经常密切相关，但并不触碰，如下图所示。以下代码创建了基础图：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">plot<span class="punctuation">(</span>st_geometry<span class="punctuation">(</span>cycle_hire<span class="punctuation">)</span><span class="punctuation">,</span> col <span class="operator">=</span> <span class="string">&quot;blue&quot;</span><span class="punctuation">)</span></span><br><span class="line">plot<span class="punctuation">(</span>st_geometry<span class="punctuation">(</span>cycle_hire_osm<span class="punctuation">)</span><span class="punctuation">,</span> add <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> pch <span class="operator">=</span> <span class="number">3</span><span class="punctuation">,</span> col <span class="operator">=</span> <span class="string">&quot;red&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>我们可以检查是否有任何点与下面所示的<code>st_intersect()</code>相同:</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="built_in">any</span><span class="punctuation">(</span>st_touches<span class="punctuation">(</span>cycle_hire<span class="punctuation">,</span> cycle_hire_osm<span class="punctuation">,</span> sparse <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] FALSE</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202308241315813.png" alt="The spatial distribution of cycle hire points in London based on official data (blue) and OpenStreetMap data (red)." title="The spatial distribution of cycle hire points in London based on official data (blue) and OpenStreetMap data (red)." /></p>
<p>想象一下，我们需要将<code>cycle_hire_osm</code>中的<code>capacity</code>变量与官方&quot;目标&quot;数据中的 <code>cycle_hire</code>进行连接，此时需要使用<em>非重叠连接</em>。最简单的方法是使用二元谓词 <code>st_is_within_distance()</code>，如下所示，使用20米的阈值距离。如果启用了球面几何引擎（s2），则可以将度量单位的阈值距离设置为<em>未投影数据</em>（例如 lon/lat CRSs，如 WGS84），因为它在<strong>sf</strong>中默认启用（请参见<em>s2</em>节）。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">sel <span class="operator">=</span> st_is_within_distance<span class="punctuation">(</span>cycle_hire<span class="punctuation">,</span> cycle_hire_osm<span class="punctuation">,</span> </span><br><span class="line">                            dist <span class="operator">=</span> units<span class="operator">::</span>set_units<span class="punctuation">(</span><span class="number">20</span><span class="punctuation">,</span> <span class="string">&quot;m&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">summary<span class="punctuation">(</span>lengths<span class="punctuation">(</span>sel<span class="punctuation">)</span> <span class="operator">&gt;</span> <span class="number">0</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt;    Mode   FALSE    TRUE </span></span><br><span class="line"><span class="comment">#&gt; logical     304     438</span></span><br></pre></td></tr></table></figure>
<p>这表明，目标对象<code>cycle_hire</code>内有438个点位于与<code>cycle_hire_osm</code>的阈值距离内。如何检索与各个<code>cycle_hire_osm</code>点相关联的<em>值</em>？解决方案即为使用<code>st_join()</code>，但添加了一个<code>dist</code>参数（设为20 m）：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">z <span class="operator">=</span> st_join<span class="punctuation">(</span>cycle_hire<span class="punctuation">,</span> cycle_hire_osm<span class="punctuation">,</span> st_is_within_distance<span class="punctuation">,</span> </span><br><span class="line">            dist <span class="operator">=</span> units<span class="operator">::</span>set_units<span class="punctuation">(</span><span class="number">20</span><span class="punctuation">,</span> <span class="string">&quot;m&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">nrow<span class="punctuation">(</span>cycle_hire<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] 742</span></span><br><span class="line">nrow<span class="punctuation">(</span>z<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] 762</span></span><br></pre></td></tr></table></figure>
<p>请注意，连接结果中的行数大于目标行数。这是因为在<code>cycle_hire</code>中的某些自行车租赁站在<code>cycle_hire_osm</code>中有多个匹配项。为了聚合重叠点的值并返回平均值，我们可以使用属性章节学习到的<em>聚合</em>方法，得到行数与目标相同的对象：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">z <span class="operator">=</span> z <span class="operator">|&gt;</span> </span><br><span class="line">  group_by<span class="punctuation">(</span>id<span class="punctuation">)</span> <span class="operator">|&gt;</span> </span><br><span class="line">  summarize<span class="punctuation">(</span>capacity <span class="operator">=</span> mean<span class="punctuation">(</span>capacity<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">nrow<span class="punctuation">(</span>z<span class="punctuation">)</span> <span class="operator">==</span> nrow<span class="punctuation">(</span>cycle_hire<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] TRUE</span></span><br></pre></td></tr></table></figure>
<p>附近站点的容量可以通过比较源数据<code>cycle_hire_osm</code>的容量绘图和这个新对象的结果来进行验证(图表未显示)。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">plot<span class="punctuation">(</span>cycle_hire_osm<span class="punctuation">[</span><span class="string">&quot;capacity&quot;</span><span class="punctuation">]</span><span class="punctuation">)</span></span><br><span class="line">plot<span class="punctuation">(</span>z<span class="punctuation">[</span><span class="string">&quot;capacity&quot;</span><span class="punctuation">]</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>这种连接的结果使用了空间操作，以改变与简单要素相关的属性数据；而与每个要素相关的几何体保持不变。</p>
<h2 id="空间聚合"><a class="markdownIt-Anchor" href="#空间聚合"></a> 空间聚合</h2>
<p>与属性数据聚合相同，空间数据聚合也可以<em>压缩</em>数据：聚合结果的行数比非聚合输入要少。统计学的<em>聚合函数</em>（如平均数或总和）可以总结变量的多个数值，并返回每个<em>分组变量</em>的单个值。在矢量属性聚合节中，我们演示了如何使用<code>aggregate()</code>和<code>group_by() |&gt; summarize()</code>根据属性变量压缩数据，本节介绍了相同的函数如何与空间对象一起工作。</p>
<p>回到新西兰的例子中，假设您想要查找每个地区高峰的平均高度，源对象（在这种情况下是 <code>y</code> 或 <code>nz</code>）定义了如何将目标对象（<code>x</code> 或 <code>nz_height</code>）中的价值分组。使用基础 R 的 <code>aggregate()</code> 方法可以在一行代码中完成此操作：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">nz_agg <span class="operator">=</span> aggregate<span class="punctuation">(</span>x <span class="operator">=</span> nz_height<span class="punctuation">,</span> by <span class="operator">=</span> nz<span class="punctuation">,</span> FUN <span class="operator">=</span> mean<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>前一条命令的结果是一个具有与（空间）聚合对象（<code>nz</code>）相同几何形状的<code>sf</code>对象，您可以使用命令<code>identical(st_geometry(nz),st_geometry(nz_agg))</code>来验证。前一操作的结果如下图所示，该图显示了在新西兰的16个地区中，<code>nz_height</code>每个要素的平均值。同样的结果也可以通过将<code>st_join()</code>的输出导入到&quot;tidy&quot;函数<code>group_by()</code>和<code>summarize()</code>中来生成，具体如下：</p>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202308241401703.png" alt="Average height of the top 101 high points across the regions of New Zealand." title="Average height of the top 101 high points across the regions of New Zealand." /></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">nz_agg2 <span class="operator">=</span> st_join<span class="punctuation">(</span>x <span class="operator">=</span> nz<span class="punctuation">,</span> y <span class="operator">=</span> nz_height<span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">  group_by<span class="punctuation">(</span>Name<span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">  summarize<span class="punctuation">(</span>elevation <span class="operator">=</span> mean<span class="punctuation">(</span>elevation<span class="punctuation">,</span> na.rm <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>通过使用函数<code>mean()</code>，<code>nz_agg</code>对象与分组对象<code>nz</code>具有相同的几何形状，但增加了一个新列，该列汇总每个地区中<code>x</code>的值。其他函数也可以用于此处，包括<code>median()</code>、<code>sd()</code>和其他每个组返回单个值的函数。需要注意的是，<code>aggregate()</code>与<code>group_by() |&gt; summarize()</code>方法之间的一个区别是前者在不匹配的区域名称上显示<code>NA</code>值，而后者保留区域名称。因此，&quot;tidy&quot;方法在聚合功能和结果列名称方面更具灵活性。同时，也在合并节涵盖了创建新几何体的聚合操作。</p>
<h2 id="连接不一致图层"><a class="markdownIt-Anchor" href="#连接不一致图层"></a> 连接不一致图层</h2>
<p>空间一致性是与空间聚合相关的重要概念。<em>聚合对象</em>（我们将其称为<code>y</code>）与目标对象（<code>x</code>）是<em>一致的</em>，如果这两个对象有共享的边界。通常情况下，行政边界数据满足此条件，其中大单位——例如英国的中层超输出区（<a href="https://www.ons.gov.uk/methodology/geography/ukgeographies/censusgeography" title="MSOAs">MSOAs</a>）或许多其他欧洲国家的区域——由许多较小单位组成。</p>
<p>相比之下，<em>不一致</em>聚合对象与目标对象没有共同的边界。这对于空间聚合(和其他空间操作)是有问题的，如下图所示。聚合每个子区域的质心将不会返回准确的结果。面积插值通过将值从一组面积单位转移到另一组面积单位来克服这个问题，使用一系列算法，包括简单的面积加权方法和更复杂的方法，如&quot;pycnophylactic&quot;方法。</p>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202308251643479.png" alt="Illustration of congruent (left) and incongruent (right) areal units with respect to larger aggregating zones (translucent ted borders)." title="Illustration of congruent (left) and incongruent (right) areal units with respect to larger aggregating zones (translucent ted borders)." /></p>
<p><strong>spData</strong>包有一个名为<code>incongruent</code>的数据集（在上图的右面板中带有黑色边框的彩色多边形），以及一个名为<code>aggregating_zones</code>的数据集（在的右面板中带有半透明蓝色边框的两个多边形）。假设<code>incongruent</code>的<code>value</code>列指的是以百万欧元为单位的总区域收入。我们如何将九个基础空间多边形的值转换为<code>aggregating_zones</code>中的两个多边形？</p>
<p>这个最简单、有用的方法是<em>面积加权</em>空间插值方法，它按照重叠面积的比例，将值从<em>不相容</em>对象传递到<em>聚合区域</em>中的一个新列中：输入和输出要素之间的空间交叉越大，相应的值也越大。这在下面的代码片段中通过<code>st_interpolate_aw()</code>实现。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">iv <span class="operator">=</span> incongruent<span class="punctuation">[</span><span class="string">&quot;value&quot;</span><span class="punctuation">]</span> <span class="comment"># keep only the values to be transferred</span></span><br><span class="line">agg_aw <span class="operator">=</span> st_interpolate_aw<span class="punctuation">(</span>iv<span class="punctuation">,</span> aggregating_zones<span class="punctuation">,</span> extensive <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; Warning in st_interpolate_aw.sf(iv, aggregating_zones, extensive = TRUE):</span></span><br><span class="line"><span class="comment">#&gt; st_interpolate_aw assumes attributes are constant or uniform over areas of x</span></span><br><span class="line">agg_aw<span class="operator">$</span>value</span><br><span class="line"><span class="comment">#&gt; [1] 19.6 25.7</span></span><br></pre></td></tr></table></figure>
<p>案例中，由于总收入是一种所谓的空间广泛变量（随着地区增大而增加），所以将落入聚合区域的交叉值进行总结是有意义的。这里假设收入在较小的区域内均匀分布（所以有上面的警告信息）。但对于空间密集变量<a href="https://geodacenter.github.io/workbook/3b_rates/lab3b.html#spatially-extensive-and-spatially-intensive-variables" title="intensive">intensive</a>（如<em>平均</em>收入或百分比），情况会有所不同，它们不会随着区域的增加而增加。<code>st_interpolate_aw()</code>在处理空间密集变量时同样有效：将<code>extensive</code>参数设置为<code>FALSE</code>，它将在执行聚合时使用平均函数而非求和函数。</p>
<h2 id="距离关系"><a class="markdownIt-Anchor" href="#距离关系"></a> 距离关系</h2>
<p>拓扑关系是二元的──一个要素要么相交，要么不相交──而距离关系是连续的。两个对象之间的距离是用<code>st_distance()</code>函数计算的。下面的代码块说明了这一点，找到了新西兰最高点与坎特伯雷地区地理重心之间的距离，该地理重心是在<em>空间子集提取</em>中创建的：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">nz_highest <span class="operator">=</span> nz_height <span class="operator">|&gt;</span> slice_max<span class="punctuation">(</span>n <span class="operator">=</span> <span class="number">1</span><span class="punctuation">,</span> order_by <span class="operator">=</span> elevation<span class="punctuation">)</span></span><br><span class="line">canterbury_centroid <span class="operator">=</span> st_centroid<span class="punctuation">(</span>canterbury<span class="punctuation">)</span></span><br><span class="line">st_distance<span class="punctuation">(</span>nz_highest<span class="punctuation">,</span> canterbury_centroid<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; Units: [m]</span></span><br><span class="line"><span class="comment">#&gt;        [,1]</span></span><br><span class="line"><span class="comment">#&gt; [1,] 115540</span></span><br></pre></td></tr></table></figure>
<p>这个结果有两个令人惊讶之处:</p>
<ul>
<li>它具有<code>units</code>，告诉我们距离是100,000米，而不是100,000英寸或任何其他距离的度量。</li>
<li>即使结果只包含一个单一值，它仍以矩阵形式返回</li>
</ul>
<p>第二个特性暗示了<code>st_length()</code>的另一个有用的特性，它能够在对象<code>x</code>和<code>y</code>中的所有特征组合之间返回<em>距离矩阵</em>。下面的命令说明了这一点，它找出了<code>nz_height</code>中前三个特征与<code>co</code>所代表的奥塔戈和坎特伯雷地区之间的距离。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">co <span class="operator">=</span> filter<span class="punctuation">(</span>nz<span class="punctuation">,</span> grepl<span class="punctuation">(</span><span class="string">&quot;Canter|Otag&quot;</span><span class="punctuation">,</span> Name<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">st_distance<span class="punctuation">(</span>nz_height<span class="punctuation">[</span><span class="number">1</span><span class="operator">:</span><span class="number">3</span><span class="punctuation">,</span> <span class="punctuation">]</span><span class="punctuation">,</span> co<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; Units: [m]</span></span><br><span class="line"><span class="comment">#&gt;        [,1]  [,2]</span></span><br><span class="line"><span class="comment">#&gt; [1,] 123537 15498</span></span><br><span class="line"><span class="comment">#&gt; [2,]  94283     0</span></span><br><span class="line"><span class="comment">#&gt; [3,]  93019     0</span></span><br></pre></td></tr></table></figure>
<p>请注意，<code>nz_height</code>中第二和第三个要素以及<code>co</code>中第二个要素之间的距离为零。这证明了点与多边形之间的距离是指到<em>多边形的任何部分</em>的距离。<code>nz_height</code>中第二个和第三个点位于奥塔哥地区，这可以通过绘制它们来验证（结果未显示）：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">plot<span class="punctuation">(</span>st_geometry<span class="punctuation">(</span>co<span class="punctuation">)</span><span class="punctuation">[</span><span class="number">2</span><span class="punctuation">]</span><span class="punctuation">)</span></span><br><span class="line">plot<span class="punctuation">(</span>st_geometry<span class="punctuation">(</span>nz_height<span class="punctuation">)</span><span class="punctuation">[</span><span class="number">2</span><span class="operator">:</span><span class="number">3</span><span class="punctuation">]</span><span class="punctuation">,</span> add <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<h1 id="栅格数据空间操作"><a class="markdownIt-Anchor" href="#栅格数据空间操作"></a> 栅格数据空间操作</h1>
<p>本节建立在栅格数据操作基础上，该节重点介绍了处理栅格数据的各种基本方法，以便展示更高级和明确的空间栅格操作，并使用在本节中手动创建的<code>elev</code>和<code>grain</code>对象。为了方便读者，这些数据集也可以在<strong>spData</strong>包中找到。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">elev <span class="operator">=</span> rast<span class="punctuation">(</span>system.file<span class="punctuation">(</span><span class="string">&quot;raster/elev.tif&quot;</span><span class="punctuation">,</span> package <span class="operator">=</span> <span class="string">&quot;spData&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">grain <span class="operator">=</span> rast<span class="punctuation">(</span>system.file<span class="punctuation">(</span><span class="string">&quot;raster/grain.tif&quot;</span><span class="punctuation">,</span> package <span class="operator">=</span> <span class="string">&quot;spData&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<h2 id="空间栅格提取"><a class="markdownIt-Anchor" href="#空间栅格提取"></a> 空间栅格提取</h2>
<p>前一章栅格数据操作展示了如何检索与特定单元格ID或行列组合相关联的值。栅格对象也可以通过位置（坐标）和其他空间对象进行提取。要使用坐标进行子集提取，可以使用<strong>terra</strong>函数<code>cellFromXY()</code>将坐标’translate’为单元格ID。另一种方法是使用<code>terra::extract()</code>（请注意，在<strong>tidyverse</strong>中还有一个名为<code>extract()</code>的函数）来提取值。下面展示了两种方法来找到覆盖在坐标为0.1，0.1的点上的单元格的值。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">id <span class="operator">=</span> cellFromXY<span class="punctuation">(</span>elev<span class="punctuation">,</span> xy <span class="operator">=</span> matrix<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">0.1</span><span class="punctuation">,</span> <span class="number">0.1</span><span class="punctuation">)</span><span class="punctuation">,</span> ncol <span class="operator">=</span> <span class="number">2</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">elev<span class="punctuation">[</span>id<span class="punctuation">]</span></span><br><span class="line"><span class="comment"># the same as</span></span><br><span class="line">terra<span class="operator">::</span>extract<span class="punctuation">(</span>elev<span class="punctuation">,</span> matrix<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">0.1</span><span class="punctuation">,</span> <span class="number">0.1</span><span class="punctuation">)</span><span class="punctuation">,</span> ncol <span class="operator">=</span> <span class="number">2</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>栅格对象可以与另一个栅格对象进行子集提取，示例如下：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">clip <span class="operator">=</span> rast<span class="punctuation">(</span>xmin <span class="operator">=</span> <span class="number">0.9</span><span class="punctuation">,</span> xmax <span class="operator">=</span> <span class="number">1.8</span><span class="punctuation">,</span> ymin <span class="operator">=</span> <span class="operator">-</span><span class="number">0.45</span><span class="punctuation">,</span> ymax <span class="operator">=</span> <span class="number">0.45</span><span class="punctuation">,</span></span><br><span class="line">            resolution <span class="operator">=</span> <span class="number">0.3</span><span class="punctuation">,</span> vals <span class="operator">=</span> <span class="built_in">rep</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">9</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">elev<span class="punctuation">[</span>clip<span class="punctuation">]</span></span><br><span class="line"><span class="comment"># we can also use extract</span></span><br><span class="line">terra<span class="operator">::</span>extract<span class="punctuation">(</span>elev<span class="punctuation">,</span> ext<span class="punctuation">(</span>clip<span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>这等于获取第一个栅格对象（在本例中为<code>elev</code>）的值，这些值落在第二个栅格（即<code>clip</code>）的范围内，如下图所示。</p>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202308251958656.png" alt="Original raster (left). Raster mask (middle). Output of masking a raster (right)." title="Original raster (left). Raster mask (middle). Output of masking a raster (right)." /></p>
<p>上述示例返回了特定单元格的值，但在许多情况下，需要对栅格数据集进行子集提取得到空间输出。这可以通过将<code>[</code>运算符的<code>drop</code>参数设置为<code>FALSE</code>来实现。下面的代码返回<code>elev</code>的前两个单元（即顶部行的前两个单元格），并作为栅格对象返回（仅显示输出的前两行）：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">elev<span class="punctuation">[</span><span class="number">1</span><span class="operator">:</span><span class="number">2</span><span class="punctuation">,</span> drop <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">]</span>    <span class="comment"># spatial subsetting with cell IDs</span></span><br><span class="line"><span class="comment">#&gt; class       : SpatRaster </span></span><br><span class="line"><span class="comment">#&gt; dimensions  : 1, 2, 1  (nrow, ncol, nlyr)</span></span><br><span class="line"><span class="comment">#&gt; ...</span></span><br></pre></td></tr></table></figure>
<p>另一个常见的空间子集提取例子是当一个具有<code>logical</code>（或<code>NA</code>）值的栅格用于掩膜具有相同范围和分辨率的另一个栅格，如上图所示。在这种情况下，可以使用<code>[</code>和 <code>mask()</code>函数（结果未显示）:</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># create raster mask</span></span><br><span class="line">rmask <span class="operator">=</span> elev</span><br><span class="line">values<span class="punctuation">(</span>rmask<span class="punctuation">)</span> <span class="operator">=</span> sample<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="literal">NA</span><span class="punctuation">,</span> <span class="literal">TRUE</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="number">36</span><span class="punctuation">,</span> replace <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>在上面的代码块中，我们创建了一个名为<code>rmask</code>的掩膜对象，其值被随机分配为<code>NA</code>和<code>TRUE</code>。接下来，我们想要保留那些在<code>rmask</code>中为<code>TRUE</code>的<code>elev</code>值。换句话说，我们想要使用<code>rmask</code>屏蔽<code>elev</code>。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># spatial subsetting</span></span><br><span class="line">elev<span class="punctuation">[</span>rmask<span class="punctuation">,</span> drop <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">]</span>           <span class="comment"># with [ operator</span></span><br><span class="line">mask<span class="punctuation">(</span>elev<span class="punctuation">,</span> rmask<span class="punctuation">)</span>                   <span class="comment"># with mask()</span></span><br></pre></td></tr></table></figure>
<p>以上方法还可用于使用<code>NA</code>替换某些值（例如，预计出现错误）。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">elev<span class="punctuation">[</span>elev <span class="operator">&lt;</span> <span class="number">20</span><span class="punctuation">]</span> <span class="operator">=</span> <span class="literal">NA</span></span><br></pre></td></tr></table></figure>
<p>这些操作实际上是布尔局部操作，因为我们逐单元格比较了两个栅格。下一小节将更详细地探讨这些和相关的操作。</p>
<h2 id="地图代数"><a class="markdownIt-Anchor" href="#地图代数"></a> 地图代数</h2>
<p>“地图代数&quot;是在上世纪70年代末提出的，用于描述地理栅格数据和（虽然不那么突出）矢量数据的分析的&quot;一套约定、功能和技术”。在这个背景下，我们更加明确地定义地图代数，作为一种修改或汇总栅格单元值的操作，涉及周围单元、区域或应用于每个单元的统计函数。</p>
<p>地图代数操作往往是快速的，因为栅格数据集只隐式地存储坐标，因此有一句<a href="https://geozoneblog.wordpress.com/2013/04/19/raster-vs-vector/" title="古老格言">古老格言</a> “栅格更快，但矢量更正确”。栅格数据集中单元的位置可以通过使用其矩阵位置和数据集的分辨率和原点（存储在标头中）来计算。然而，就处理而言，只要我们确保处理后单元格位置不变，单元格的地理位置就几乎不相关。此外，如果两个或多个栅格数据集具有相同的范围、投影和分辨率，可以将它们视为矩阵进行处理。</p>
<p>这是使用<strong>terra</strong>包进行地图代数的方法。首先，会查询栅格数据集的标头，并（在需要处理多个数据集的地图代数运算中）检查数据集是否兼容。其次，地图代数保留所谓的一对一定位对应关系，这意味着单元格不能移动。这与矩阵代数不同，矩阵代数中，例如在矩阵乘法或除法时，值会改变位置。</p>
<p>地图代数（或栅格数据的制图建模）将栅格操作分为四个子类，每个子类同时在一个或多个栅格上进行操作：</p>
<ol>
<li><em>局部</em>或逐单元格操作</li>
<li><em>焦点</em>或邻域操作。最常见的输出单元格值是3x3输入单元格块的结果</li>
<li><em>区域</em>操作与焦点操作相似，但计算新值的周围像素网格可能具有不规则的大小和形状</li>
<li><em>全局</em>或逐栅格操作。这意味着输出单元格可能从一个或多个整个栅格派生其值</li>
</ol>
<p>这种分类按照用于每个像素处理步骤的<strong>单元格数量</strong>和<strong>输出类型</strong>对地图代数操作进行分类。为了完整起见，我们应该提到栅格操作还可以按学科分类，例如地形、水文分析或图像分类。以下部分解释了每种类型的地图代数操作如何使用，参考了实际示例。</p>
<h2 id="局部操作"><a class="markdownIt-Anchor" href="#局部操作"></a> 局部操作</h2>
<p><strong>局部</strong>操作包括在一个或多个层上的所有逐单元格操作。栅格代数是局部操作的典型用例——这包括从栅格中添加或减去值，平方和乘以栅格。栅格代数还允许逻辑操作，例如查找大于特定值的所有栅格单元格（在我们下面的示例中为5）。<strong>terra</strong>包支持所有这些操作及更多，如下图所示：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">elev <span class="operator">+</span> elev</span><br><span class="line">elev<span class="operator">^</span><span class="number">2</span></span><br><span class="line"><span class="built_in">log</span><span class="punctuation">(</span>elev<span class="punctuation">)</span></span><br><span class="line">elev <span class="operator">&gt;</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202308262241490.png" alt="Examples of different local operations of the elev raster object: adding two rasters, squaring, applying logarithmic transformation, and performing a logical operation." title="Examples of different local operations of the elev raster object: adding two rasters, squaring, applying logarithmic transformation, and performing a logical operation." /></p>
<p><em>局部操作</em>的另一个很好的例子是将数字值的区间分为诸如将数字高程模型分为低（类别1）、中（类别2）和高（类别3）海拔的组。使用<code>classify()</code>命令，我们首先需要构建一个重分类矩阵，其中第一列对应于类别的下限，第二列对应于上限。第三列代表第一和第二列中指定范围的新值。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">rcl <span class="operator">=</span> matrix<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span> <span class="number">12</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">12</span><span class="punctuation">,</span> <span class="number">24</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">,</span> <span class="number">24</span><span class="punctuation">,</span> <span class="number">36</span><span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">)</span><span class="punctuation">,</span> ncol <span class="operator">=</span> <span class="number">3</span><span class="punctuation">,</span> byrow <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br><span class="line">rcl</span><br><span class="line"><span class="comment">#&gt;      [,1] [,2] [,3]</span></span><br><span class="line"><span class="comment">#&gt; [1,]    0   12    1</span></span><br><span class="line"><span class="comment">#&gt; [2,]   12   24    2</span></span><br><span class="line"><span class="comment">#&gt; [3,]   24   36    3</span></span><br></pre></td></tr></table></figure>
<p>在这里，我们将范围为0-12、12-24和24-36的栅格值进行了<em>重分类</em>，分别赋值为1、2和3。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">recl <span class="operator">=</span> classify<span class="punctuation">(</span>elev<span class="punctuation">,</span> rcl <span class="operator">=</span> rcl<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><code>classify()</code>函数也可以用于我们想要减少分类栅格中类别数量的情况。我们将在<em>地理营销</em>中执行几个附加的重分类操作。</p>
<p>除了算术运算符外，还可以使用<code>app()</code>、<code>tapp()</code>和<code>lapp()</code>函数。它们更有效率，因此，在大型栅格数据集存在的情况下，它们是首选。此外，它们允许你直接保存输出文件。<code>app()</code>函数将一个函数应用到栅格的每个单元格，并用于将多个图层的值汇总（例如，计算总和）到一个图层。<code>tapp()</code>是<code>app()</code>的扩展，允许我们选择要执行某个操作的图层子集（参见<code>index</code>参数）。最后，<code>lapp()</code>函数允许使用图层作为参数将一个函数应用到每个单元格——下面将介绍<code>lapp()</code>的一个应用。</p>
<p>归一化植被指数（NDVI）的计算是一种众所周知的局部（逐像素）栅格操作。它返回一个值介于-1和1之间的栅格；正值表示存在活植物（通常 &gt; 0.2）。NDVI是从遥感影像的红色和近红外（NIR）波段计算的，通常来自Landsat或Sentinel等卫星系统。植被在可见光光谱中大量吸收光线，特别是在红色通道中，同时反射NIR光线，从而解释了NVDI公式：</p>
<p class='katex-block katex-error' title='ParseError: KaTeX parse error: No such environment: split at position 7: \begin{̲s̲p̲l̲i̲t̲}̲
NDVI&amp;= \frac{\…'>\begin{split}
NDVI&amp;= \frac{\text{NIR} - \text{Red}}{\text{NIR} + \text{Red}}\\
\end{split}
</p>
<p>让我们计算锡安国家公园的多光谱卫星影像的NDVI。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">multi_raster_file <span class="operator">=</span> system.file<span class="punctuation">(</span><span class="string">&quot;raster/landsat.tif&quot;</span><span class="punctuation">,</span> package <span class="operator">=</span> <span class="string">&quot;spDataLarge&quot;</span><span class="punctuation">)</span></span><br><span class="line">multi_rast <span class="operator">=</span> rast<span class="punctuation">(</span>multi_raster_file<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>栅格对象具有四个卫星波段：蓝、绿、红和近红外（NIR）。我们下一步应该在 R 函数中使用NDVI公式：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ndvi_fun <span class="operator">=</span> <span class="keyword">function</span><span class="punctuation">(</span>nir<span class="punctuation">,</span> red<span class="punctuation">)</span><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="punctuation">(</span>nir <span class="operator">-</span> red<span class="punctuation">)</span> <span class="operator">/</span> <span class="punctuation">(</span>nir <span class="operator">+</span> red<span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>这个函数接受两个数值参数，<code>nir</code>和<code>red</code>，并返回一个带有NDVI值的数值向量。它可以用作<code>lapp()</code>的<code>fun</code>参数。我们只需记住，我们的函数只需要两个波段（不是原始栅格的四个），并且它们需要按<code>NIR</code>、<code>red</code>的顺序排列。这就是为什么我们在进行任何计算之前，使用<code>multi_rast[[c(4, 3)]]</code>来提取输入栅格的子集。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ndvi_rast <span class="operator">=</span> lapp<span class="punctuation">(</span>multi_rast<span class="punctuation">[[</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">4</span><span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">)</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">,</span> fun <span class="operator">=</span> ndvi_fun<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>结果显示在下图的右侧面板上，可以与同一区域的RGB图像（同一图的左侧面板）进行比较。这让我们看到最大的NDVI值与该区域北部的密集森林区域相连，而最低的值则与北部的湖泊和积雪覆盖的山脊有关。</p>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202308262308411.png" alt="RGB image (left) and NDVI values (right) calculated for the example satellite file of the Zion National Park" title="RGB image (left) and NDVI values (right) calculated for the example satellite file of the Zion National Park" /></p>
<p>预测映射是局部栅格操作的另一个有趣应用。响应变量对应于空间中测量或观察到的点，例如物种丰富度、滑坡的存在、树木疾病或农作物产量。因此，我们可以轻松从各种栅格（例如海拔、pH值、降水量、温度、土地覆盖、土壤类型等）检索空间或预测变量。随后，我们使用<code>lm()</code>、<code>glm()</code>、<code>gam()</code>或机器学习技术将响应建模为预测因子的函数。因此，将估计系数应用于预测栅格值，并对输出栅格值求和（参见 <em>生态</em>章节），可以对栅格对象进行空间预测。</p>
<h2 id="焦点操作"><a class="markdownIt-Anchor" href="#焦点操作"></a> 焦点操作</h2>
<p>虽然<em>局部</em>函数可能在多个层上操作一个单元格，但<em>焦点</em>操作会考虑中心（焦点）单元格及其邻居。通常考虑的邻域（也称为内核、滤波器或移动窗口）大小为3x3个单元格（即中心单元格及其周围的八个邻居），但可以根据用户的定义采用任何其他（不一定是矩形的）形状。焦点操作将一个聚合函数应用于指定邻域内的所有单元格，将相应的输出用作中心单元格的新值，然后移至下一个中心单元格，如下图所示。此操作的其他名称是空间滤波和卷积。</p>
<p>在R中，我们可以使用<code>focal()</code>函数来执行空间滤波。我们通过一个<code>matrix</code>定义移动窗口的形状，其值对应于权重（参见下面代码块中的<code>w</code>参数）。其次，<code>fun</code>参数让我们指定我们希望应用于这个邻域的函数。这里，我们选择最小值，但可以使用任何其他汇总函数，包括<code>sum()</code>、<code>mean()</code>或<code>var()</code>。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">r_focal <span class="operator">=</span> focal<span class="punctuation">(</span>elev<span class="punctuation">,</span> w <span class="operator">=</span> matrix<span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span> nrow <span class="operator">=</span> <span class="number">3</span><span class="punctuation">,</span> ncol <span class="operator">=</span> <span class="number">3</span><span class="punctuation">)</span><span class="punctuation">,</span> fun <span class="operator">=</span> <span class="built_in">min</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>这个函数还接受其他参数，例如，在过程中是否应删除<code>NA</code>值（<code>na.rm = TRUE</code>）或不删除（<code>na.rm = FALSE</code>）。</p>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202308262319552.png" alt="Input raster (left) and resulting output raster (right) due to a focal operation - finding the minimum value in 3-by-3 moving windows." title="Input raster (left) and resulting output raster (right) due to a focal operation - finding the minimum value in 3-by-3 moving windows." /></p>
<p>我们可以快速检查输出是否符合我们的预期。在我们的示例中，最小值必须始终位于移动窗口的左上角（请记住，我们通过从左上角开始逐行增加单元格值来创建输入栅格）。在此示例中，权重矩阵只包括1，这意味着每个单元格对输出具有相同的权重，但这可以更改。</p>
<p><em>焦点</em>函数或滤波器在图像处理中起着主导作用。低通或平滑滤波使用平均函数来消除极值。在分类数据的情况下，我们可以用众数（最常见的值）替换平均数。相反，高通滤波强调特征。此处，线检测的拉普拉斯和索贝尔滤波可以作为例子。你可以查看<code>focal()</code>的帮助页面了解如何在 R 中使用它们（这也将在本章节结束时的练习中使用）。</p>
<p>地形处理，计算地形特性如坡度、方向和流向，依赖于<em>焦点</em>函数。虽然<code>terrain()</code>可用于计算这些指标，但一些地形算法（包括用于计算坡度的Zevenbergen和Thorne方法）并未在这个<strong>terra</strong>函数中实现。许多其他算法——包括曲率、贡献区域和湿度指数 ——是在开源桌面地理信息系统（GIS）软件中实现的。<em>GIS桥梁</em>章介绍了如何从R内部访问这样的GIS功能。</p>
<h2 id="区域操作"><a class="markdownIt-Anchor" href="#区域操作"></a> 区域操作</h2>
<p>与焦点操作一样，<em>区域</em>操作将聚合函数应用于多个栅格单元格。然而，在<em>区域</em>操作的情况下，第二个栅格（通常具有分类值）定义了<em>分区滤波器</em>（或&quot;区域&quot;），与上一节中呈现的<em>焦点</em>操作的预定义邻域窗口相对。因此，定义<em>区域</em>滤波器的栅格单元格不一定要相邻。grain 栅格就是一个很好的例子，不同的粒度大小在整个栅格中不规则地分布。最后，<em>区域</em>操作的结果是按区域分组的汇总表，这就是为什么这个操作在GIS世界中也被称为<em>分区统计</em>。这与返回栅格对象的焦点操作形成了对比。</p>
<p>以下代码块使用<code>zonal()</code>函数来计算与每个粒度类别相关的平均海拔。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">z <span class="operator">=</span> zonal<span class="punctuation">(</span>elev<span class="punctuation">,</span> grain<span class="punctuation">,</span> fun <span class="operator">=</span> <span class="string">&quot;mean&quot;</span><span class="punctuation">)</span></span><br><span class="line">z</span><br><span class="line"><span class="comment">#&gt;   grain elev</span></span><br><span class="line"><span class="comment">#&gt; 1  clay 14.8</span></span><br><span class="line"><span class="comment">#&gt; 2  silt 21.2</span></span><br><span class="line"><span class="comment">#&gt; 3  sand 18.7</span></span><br></pre></td></tr></table></figure>
<p>这将返回每个类别的统计，在这里是每个粒度大小类别的平均海拔。注意：通过将<code>as.raster</code>参数设置为<code>TRUE</code>，也可以获得每个区域的计算统计数据的栅格。</p>
<h2 id="全局操作和距离"><a class="markdownIt-Anchor" href="#全局操作和距离"></a> 全局操作和距离</h2>
<p><em>全局</em>操作是分区操作的特殊情况，整个栅格数据集代表单个区域。整个栅格数据集的描述性统计是最常见的全局操作，例如最小值或最大值——我们已经在章节栅格数据汇总中讨论过这些。</p>
<p>除此之外，全局操作还可用于计算距离和权重栅格。在第一种情况下，可以计算每个单元格到特定目标单元格的距离。例如，人们可能想要计算到最近海岸的距离（参见<code>terra::distance()</code>）。我们也可能想要考虑地形，这意味着，我们不仅对纯粹的距离感兴趣，而且还想避免在前往海岸时穿越山脉。为此，我们可以通过海拔为距离赋权，以便每增加一个海拔米就&quot;延长&quot;欧氏距离。可见性和视域计算也属于全局操作的一类。</p>
<h2 id="矢量数据的地图代数"><a class="markdownIt-Anchor" href="#矢量数据的地图代数"></a> 矢量数据的&quot;地图代数&quot;</h2>
<p>许多地图代数操作在矢量处理中有对应操作。在仅考虑最大距离（逻辑焦点操作）的情况下计算距离栅格（全局操作）等同于矢量缓冲操作（裁剪章节）。重分类栅格数据（根据输入是局部还是区域函数）等同于溶解矢量数据（空间连接章节）。将两个栅格叠加（局部操作），其中一个包含表示遮罩的<code>NULL</code>或<code>NA</code>值，类似于矢量裁剪（章节）。与空间裁剪非常相似的是交叉两个图层（空间矢量提取章节）。区别在于这两个图层（矢量或栅格）仅共享重叠区域。不过，要小心措辞。有时相同的词在栅格和矢量数据模型中具有略有不同的含义。虽然聚合多边形几何意味着溶解边界，但对于栅格数据几何，它意味着增加单元格大小，从而降低空间分辨率。区域操作根据另一个栅格数据集的区域（类别）使用聚合函数溶解一个栅格的单元格。</p>
<h2 id="合并栅格"><a class="markdownIt-Anchor" href="#合并栅格"></a> 合并栅格</h2>
<p>假设我们想计算NDVI（见局部操作章节），并且还想从高程数据中计算研究区域内观测的地形属性。这些计算依赖于遥感信息。相应的图像常常被分割成覆盖特定空间范围的场景，而研究区域通常覆盖多个场景。那么，我们就需要合并研究区域所覆盖的场景。在最简单的情况下，我们可以只是合并这些场景，即将它们并排放置。例如，可以使用数字高程数据（SRTM，ASTER）来实现。在下面的代码块中，我们首先下载了奥地利和瑞士的SRTM高程数据（有关国家代码，请参见<strong>geodata</strong>函数 <code>country_codes()</code>）。第二步，我们将这两个栅格合并为一个。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">aut <span class="operator">=</span> geodata<span class="operator">::</span>elevation_30s<span class="punctuation">(</span>country <span class="operator">=</span> <span class="string">&quot;AUT&quot;</span><span class="punctuation">,</span> path <span class="operator">=</span> tempdir<span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">ch <span class="operator">=</span> geodata<span class="operator">::</span>elevation_30s<span class="punctuation">(</span>country <span class="operator">=</span> <span class="string">&quot;CHE&quot;</span><span class="punctuation">,</span> path <span class="operator">=</span> tempdir<span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">aut_ch <span class="operator">=</span> merge<span class="punctuation">(</span>aut<span class="punctuation">,</span> ch<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><strong>terra</strong> 的 <code>merge()</code>命令结合了两个图像，如果它们重叠，则使用第一个栅格的值。</p>
<p>当重叠的值彼此不对应时，这种合并方法用处不大。当您想合并在不同日期拍摄的场景的光谱图像时，通常会出现这种情况。<code>merge()</code> 命令仍然会工作，但在结果图像中您会看到一个明显的边界。另一方面，<code>mosaic()</code> 命令允许您为重叠区域定义一个函数。例如，我们可以计算平均值 – 这可能会平滑合并结果中的明显边界，但最有可能的是它不会让其消失。</p>
<h1 id="练习"><a class="markdownIt-Anchor" href="#练习"></a> 练习</h1>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>sf<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>dplyr<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>spData<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>E1. It was established in Section @ref(spatial-vec) that Canterbury was the region of New Zealand containing most of the 100 highest points in the country.<br />
How many of these high points does the Canterbury region contain?</p>
<p><strong>Bonus:</strong> plot the result using the <code>plot()</code> function to show all of New Zealand, <code>canterbury</code> region highlighted in yellow, high points in Canterbury represented by red crosses (hint: <code>pch = 7</code>) and high points in other parts of New Zealand represented by blue circles. See the help page <code>?points</code> for details with an illustration of different <code>pch</code> values.</p>
<p>E2. Which region has the second highest number of <code>nz_height</code> points, and how many does it have?</p>
<p>E3. Generalizing the question to all regions: how many of New Zealand’s 16 regions contain points which belong to the top 100 highest points in the country? Which regions?</p>
<ul>
<li>Bonus: create a table listing these regions in order of the number of points and their name.</li>
</ul>
<p>E4. Test your knowledge of spatial predicates by finding out and plotting how US states relate to each other and other spatial objects.</p>
<p>The starting point of this exercise is to create an object representing Colorado state in the USA. Do this with the command<br />
<code>colorado = us_states[us_states$NAME == &quot;Colorado&quot;,]</code> (base R) or with with the  <code>filter()</code> function (tidyverse) and plot the resulting object in the context of US states.</p>
<ul>
<li>Create a new object representing all the states that geographically intersect with Colorado and plot the result (hint: the most concise way to do this is with the subsetting method <code>[</code>).</li>
<li>Create another object representing all the objects that touch (have a shared boundary with) Colorado and plot the result (hint: remember you can use the argument <code>op = st_intersects</code> and other spatial relations during spatial subsetting operations in base R).</li>
<li>Bonus: create a straight line from the centroid of the District of Columbia near the East coast to the centroid of California near the West coast of the USA (hint: functions <code>st_centroid()</code>, <code>st_union()</code> and <code>st_cast()</code> described in Chapter 5 may help) and identify which states this long East-West line crosses.</li>
</ul>
<p>E5. Use <code>dem = rast(system.file(&quot;raster/dem.tif&quot;, package = &quot;spDataLarge&quot;))</code>, and reclassify the elevation in three classes: low (&lt;300), medium and high (&gt;500).<br />
Secondly, read the NDVI raster (<code>ndvi = rast(system.file(&quot;raster/ndvi.tif&quot;, package = &quot;spDataLarge&quot;))</code>) and compute the mean NDVI and the mean elevation for each altitudinal class.</p>
<p>E6. Apply a line detection filter to <code>rast(system.file(&quot;ex/logo.tif&quot;, package = &quot;terra&quot;))</code>.<br />
Plot the result.<br />
Hint: Read <code>?terra::focal()</code>.</p>
<p>E7. Calculate the Normalized Difference Water Index	(NDWI; <code>(green - nir)/(green + nir)</code>) of a Landsat image.<br />
Use the Landsat image provided by the <strong>spDataLarge</strong> package (<code>system.file(&quot;raster/landsat.tif&quot;, package = &quot;spDataLarge&quot;)</code>).<br />
Also, calculate a correlation between NDVI and NDWI for this area (hint: you can use the <code>layerCor()</code> function).</p>
<p>E8. A StackOverflow <a href="https://stackoverflow.com/questions/35555709/global-raster-of-geographic-distances" title="post">post</a> shows how to compute distances to the nearest coastline using <code>raster::distance()</code>.<br />
Try to do something similar but with <code>terra::distance()</code>: retrieve a digital elevation model of Spain, and compute a raster which represents distances to the coast across the country (hint: use <code>geodata::elevation_30s()</code>).<br />
Convert the resulting distances from meters to kilometers.<br />
Note: it may be wise to increase the cell size of the input raster to reduce compute time during this operation (<code>aggregate()</code>).</p>
<p>E9. Try to modify the approach used in the above exercise by weighting the distance raster with the elevation raster; every 100 altitudinal meters should increase the distance to the coast by 10 km.<br />
Next, compute and visualize the difference between the raster created using the Euclidean distance (E7) and the raster weighted by elevation.</p>
]]></content>
      <categories>
        <category>R</category>
        <category>Geocomputaion</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>Geocomputaion</tag>
      </tags>
  </entry>
  <entry>
    <title>(3)属性操作</title>
    <url>/2023/08/12/2023-8-12-3-%E5%B1%9E%E6%80%A7%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>本章讲授如何基于属性来操作地理对象，例如矢量数据集中的公交站名和栅格数据集中像素的高程。对于矢量数据，意味着应用例如<code>subsetting</code>和<code>aggregation</code>方法（参见矢量属性提取子集和矢量属性聚合章节）。和创建属性移除空间信息章节演示了如何通过共享<strong>ID</strong>将数据连接到简单要素对象以及如何创建新变量。这些操作都有空间等效功能：例如，基于属性和空间对象的<code>subsetting</code>操作都可以使用R中的<code>[</code>运算符；您还可以使用<code>spatial joins</code>将两个地理数据集的属性进行连接。本章所培养的技能具有交叉传递性。<em>空间数据操作</em>章节将本章介绍的方法扩展到空间方面。</p>
<span id="more"></span>
<h1 id="前提条件"><a class="markdownIt-Anchor" href="#前提条件"></a> 前提条件</h1>
<ul>
<li>本章要求安装并且连接以下包：</li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>sf<span class="punctuation">)</span> </span><br><span class="line">library<span class="punctuation">(</span>terra<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>dplyr<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>依赖于 <strong>spData</strong> 包，该包装载了本章代码示例所使用的数据集：</li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>spData<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>另外，如果您希望在栅格数据汇总章节中运行数据&quot;整理&quot;操作，请确保已安装了<strong>tidyr</strong>包，或者安装了其所属的<strong>tidyverse</strong>包。</li>
</ul>
<h1 id="引言"><a class="markdownIt-Anchor" href="#引言"></a> 引言</h1>
<p>属性数据是与地理（几何）数据相关联的非空间信息。公共汽车站提供了一个简单的例子：除了名称之外，它的位置通常用经纬度坐标(几何数据)来表示。例如，位于伦敦<a href="https://www.openstreetmap.org/relation/6610626" title="Elephant &amp; Castle / New Kent Road">Elephant &amp; Castle / New Kent Road</a> 站的坐标为：经度 -0.098和纬度 51.495，在<em>空间数据类型</em>章节描述的 <code>sfc</code>表示中可以表示为<code>POINT (-0.098 51.495)</code>。诸如点属性的<code>name</code>属性（使用 Simple Features 术语）之类的属性是本章的主题。</p>
<p>另一个示例是栅格数据中特定网格单元的海拔值（属性）。与矢量数据模型不同，栅格数据模型间接存储了网格单元的坐标，这意味着属性和空间信息之间的区分不太清晰。为了阐明这一观点，可以想象一下栅格矩阵中第3行第4列的像素点。其空间位置由其在矩阵中的索引确定：在<code>x</code>方向上从原点向右（通常是东方和地图上的右方）移动四个单元格，在<code>y</code>方向上从原点向下（通常是南方和向下）移动三个单元格。栅格的分辨率定义了每个<code>x</code>和<code>y</code>步的距离，这些距离在头部文件中指定。头部文件是栅格数据集的关键组成部分，它指定了像素与地理坐标的关系（另见空间数据操作章节）。</p>
<p>本章讲授如何基于属性来操作地理对象，例如矢量数据集中的公交站名和栅格数据集中像素的高程。对于矢量数据，意味着应用例如<code>subsetting</code>和<code>aggregation</code>方法（参见矢量属性提取子集和矢量属性聚合章节。）和创建属性移除空间信息章节演示了如何通过共享<strong>ID</strong>将数据连接到简单要素对象以及如何创建新变量。这些操作都有空间等效功能：例如，基于属性和空间对象的<code>subsetting</code>操作都可以使用R中的<code>[</code>运算符；您还可以使用<code>spatial joins</code>将两个地理数据集的属性进行连接。本章所培养的技能具有交叉传递性。<em>空间数据操作</em>章节将本章介绍的方法扩展到空间方面。</p>
<p>在下一节深入探讨各种类型的<strong>矢量属性</strong>操作后，栅格数据操作章节介绍了<strong>栅格属性</strong>数据操作，演示了如何创建包含连续和分类属性的栅格图层，并从一个或多个图层中提取单元格的值（栅格子集）。栅格数据汇总章节提供了<strong>全局</strong>栅格操作的概述，这些操作可以用于总结整个栅格数据集。</p>
<h1 id="矢量数据操作"><a class="markdownIt-Anchor" href="#矢量数据操作"></a> 矢量数据操作</h1>
<p>地理矢量数据集在R中得到了很好的支持，这得益于<code>sf</code>类的出现，它是基于R的<code>data.frame</code>进行扩展的。与数据框类似，<code>sf</code>对象每列都有一个属性变量（例如&quot;name&quot;），每行代表一个观测值或<code>feature</code>（例如每个公交车站）。与基本数据框不同的是，<code>sf</code>对象具有一个<strong>几何列</strong>，其类型为<code>sfc</code>，每个行可以包含多个地理实体（单个和&quot;多&quot;点，线，多边形要素）。第<br />
<em>空间类</em>中进行了描述，演示了<code>plot()</code>和<code>Summary()</code>等<strong>通用</strong>方法是如何处理<code>sf</code>对象的。<code>sf</code>还提供了<strong>通用方法</strong>，允许<code>sf</code>对象像常规数据框一样运行，如<em>打印</em><strong>类</strong>的方法所示：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">methods<span class="punctuation">(</span><span class="built_in">class</span> <span class="operator">=</span> <span class="string">&quot;sf&quot;</span><span class="punctuation">)</span> </span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#&gt; [1] [             [[&lt;-          $&lt;-           aggregate    </span></span><br><span class="line"><span class="comment">#&gt; [5] as.data.frame cbind         coerce        filter       </span></span><br><span class="line"><span class="comment">#&gt; [9] identify      initialize    merge         plot        </span></span><br></pre></td></tr></table></figure>
<p>其中许多函数（<code>aggregate()</code>，<code>cbind()</code>，<code>merge()</code>，<code>rbind()</code>和<code>[</code>）用于操作数据框。例如，<code>rbind()</code>会将数据框的行&quot;一上一下&quot;连接在一起。<code>$&lt;-</code>可以创建新的列。<code>sf</code> 对象的一个重要特征是它们以相同的方式将<strong>空间数据</strong>和<strong>非空间数据</strong>存储为<code>data.frame</code>中的列。</p>
<blockquote>
<p>📌对象的几何列通常称为<code>geometry</code>或<code>geom</code>，但可以使用任何名称。例如，下面的命令创建了一个名为<code>g</code>的几何列:<br />
<code>st_sf(data.frame(n = world$name_long), g = world$geom)</code><br />
这使得从空间数据库导入的几何图形具有多种名称，如<code>wkb_geometry</code>和<code>The_geom</code>。</p>
</blockquote>
<p><code>sf</code>对象对于数据框可以扩展<code>tidyverse</code>类，<code>tbl_df</code>和<code>tbl</code>。因此，无论您使用基础R还是tidyverse函数进行数据分析，<code>sf</code>都可以释放R数据分析能力对地理数据的全部威力。<br />
<code>sf</code>对象还可以与高性能数据处理软件包<code>data.table</code>一起使用，尽管文献中有记载说明，它与<code>sf</code>对象不完全兼容，<a href="https://github.com/Rdatatable/data.table/issues/2273" title="Rdatatable/data.table#2273">Rdatatable/data.table#2273</a>。在使用这些功能之前，回顾怎样探索矢量数据对象的基本属性。让我们开始使用基本R函数来了解从 <strong>spData</strong> 软件包中的<code>world</code>数据集：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="built_in">class</span><span class="punctuation">(</span>world<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] &quot;sf&quot;         &quot;tbl_df&quot;     &quot;tbl&quot;        &quot;data.frame&quot;</span></span><br><span class="line"><span class="built_in">dim</span><span class="punctuation">(</span>world<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] 177  11</span></span><br></pre></td></tr></table></figure>
<p><code>world</code>含有十个非地理列（以及一个几何列表列），共有近200行代表各个世界国家。函数<code>st_drop_geometry()</code>可保留仅为<code>sf</code>对象的属性数据，也就是删除其几何学属性：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">world_df <span class="operator">=</span> st_drop_geometry<span class="punctuation">(</span>world<span class="punctuation">)</span></span><br><span class="line"><span class="built_in">class</span><span class="punctuation">(</span>world_df<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] &quot;tbl_df&quot;     &quot;tbl&quot;        &quot;data.frame&quot;</span></span><br><span class="line">ncol<span class="punctuation">(</span>world_df<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] 10</span></span><br></pre></td></tr></table></figure>
<p>在使用属性数据之前，删除几何列可能会很有用；当数据处理过程仅涉及属性数据时，处理速度可以更快，并且不一定总需要几何列。然而，在大多数情况下，保留几何列是有意义的，解释为什么几何列具有&quot;粘性&quot;（大多数属性操作之后仍然存在，除非特别删除。）。在<code>sf</code>对象上进行非空间数据操作仅在适当时更改对象的几何结构（例如，在聚合后消除相邻多边形之间的边界）。掌握地理属性数据操作技能意味着掌握操作数据框的技能。</p>
<p>对于许多应用程序来说，tidyverse中的<strong>dplyr</strong> 包为处理数据框提供了有效的方法。与其前身<strong>sp</strong>相比，<strong>sf</strong>具有<strong>tidyverse</strong>兼容性的优势，但需要避免一些陷阱（详情请参见 <a href="https://geocompx.github.io/geocompkg/articles/tidyverse-pitfalls.html" title="geocompx.org">geocompx.org</a> 上的补充<code>tidyverse-pitfalls</code>文献）。</p>
<h2 id="矢量属性提取子集"><a class="markdownIt-Anchor" href="#矢量属性提取子集"></a> 矢量属性提取子集</h2>
<p>基础R的子集提取方法包括<code>[</code>和<code>subset()</code>。在<strong>dplyr</strong>中，子集提取数据的关键函数是<code>filter()</code>和<code>slice()</code>用于子集提取行，而<code>select()</code>用于子集提取列。两种方法都可以保持 <code>sf</code>对象中属性数据的空间组件不变。然而，使用运算符<code>$</code>或<strong>dplyr</strong>函数<code>pull()</code>提取单个属性列作为向量会导致几何数据的丢失，我们将在后文中进一步阐述。本节重点关注如何对<code>sf</code>数据框进行子集提取，如果进一步了解如何对向量和非地理数据框进行子集提取，建议参考《An Introduction to R》第<a href="https://cran.r-project.org/doc/manuals/r-release/R-intro.html#Index-vectors" title="2.7">2.7</a> 节以及《Advanced R Programming》第<a href="https://adv-r.hadley.nz/subsetting.html" title="4">4</a>章。</p>
<p><code>[</code>操作符可以对行和列提取子集。方括号直接放在数据框对象名称之后，里面的索引指定要保留的元素。命令<code>object[i, j]</code>意味着：返回由<code>i</code>表示的行和由<code>j</code>表示的列，其中<code>i</code>和<code>j</code>通常包含整数或<code>TRUE</code>和<code>FALSE</code>（索引也可以是字符串，表示行或列名称）。例如，<code>object[5, 1:3]</code>意味着：返回包含第5行和第1到第3列的数据，结果应该是一个只有1行和3列的数据框，如果是<code>sf</code>对象，则还要包含第4个几何列。留下<code>i</code>或<code>j</code>为空会返回所有的行或列，因此<code>world[1:5, ]</code>返回前5行和所有11列。下面的示例演示了使用基本<strong>R</strong>进行子集提取的方法。猜 测每个命令返回的<code>sf</code>数据框的行数和列数，并在自己的计算机上检查结果（更多练习请参见本章末尾）：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">world<span class="punctuation">[</span><span class="number">1</span><span class="operator">:</span><span class="number">6</span><span class="punctuation">,</span> <span class="punctuation">]</span>    <span class="comment"># 按位置提取行</span></span><br><span class="line">world<span class="punctuation">[</span><span class="punctuation">,</span> <span class="number">1</span><span class="operator">:</span><span class="number">3</span><span class="punctuation">]</span>    <span class="comment"># 按位置提取列</span></span><br><span class="line">world<span class="punctuation">[</span><span class="number">1</span><span class="operator">:</span><span class="number">6</span><span class="punctuation">,</span> <span class="number">1</span><span class="operator">:</span><span class="number">3</span><span class="punctuation">]</span> <span class="comment"># 按位置提取行和列</span></span><br><span class="line">world<span class="punctuation">[</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;name_long&quot;</span><span class="punctuation">,</span> <span class="string">&quot;pop&quot;</span><span class="punctuation">)</span><span class="punctuation">]</span> <span class="comment"># 按名称提取列</span></span><br><span class="line">world<span class="punctuation">[</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="built_in">T</span><span class="punctuation">,</span> <span class="built_in">T</span><span class="punctuation">,</span> <span class="built_in">F</span><span class="punctuation">,</span> <span class="built_in">F</span><span class="punctuation">,</span> <span class="built_in">F</span><span class="punctuation">,</span> <span class="built_in">F</span><span class="punctuation">,</span> <span class="built_in">F</span><span class="punctuation">,</span> <span class="built_in">T</span><span class="punctuation">,</span> <span class="built_in">T</span><span class="punctuation">,</span> <span class="built_in">F</span><span class="punctuation">,</span> <span class="built_in">F</span><span class="punctuation">)</span><span class="punctuation">]</span> <span class="comment"># 按逻辑索引提取</span></span><br><span class="line">world<span class="punctuation">[</span><span class="punctuation">,</span> <span class="number">888</span><span class="punctuation">]</span> <span class="comment"># 索引代表不存在的列</span></span><br></pre></td></tr></table></figure>
<p>下面的代码块演示了使用<code>logical</code>向量进行子集提取的实用性。这就创造了一个新的对象，<code>small_countries</code>，包括面积小于 10,000 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><msup><mi>m</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">km^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>的国家:</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">i_small <span class="operator">=</span> world<span class="operator">$</span>area_km2 <span class="operator">&lt;</span> <span class="number">10000</span></span><br><span class="line">summary<span class="punctuation">(</span>i_small<span class="punctuation">)</span> <span class="comment"># 逻辑向量</span></span><br><span class="line"><span class="comment">#&gt;    Mode   FALSE    TRUE </span></span><br><span class="line"><span class="comment">#&gt; logical     170       7</span></span><br><span class="line">small_countries <span class="operator">=</span> world<span class="punctuation">[</span>i_small<span class="punctuation">,</span> <span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<p>中间的<code>i_small</code>（表示小国家的索引的缩写）是一个逻辑向量，可用于按表面积对<strong>世界</strong>上最小的七个国家提取子集。更简洁的命令省略中间对象，生成相同的结果：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">small_countries <span class="operator">=</span> world<span class="punctuation">[</span>world<span class="operator">$</span>area_km2 <span class="operator">&lt;</span> <span class="number">10000</span><span class="punctuation">,</span> <span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<p>基础R函数<code>subset()</code>提供了另外一种方式：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">small_countries <span class="operator">=</span> subset<span class="punctuation">(</span>world<span class="punctuation">,</span> area_km2 <span class="operator">&lt;</span> <span class="number">10000</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>基础的R函数成熟、稳定且广泛使用，使它们成为一种非常可靠的选择，特别是在强调<strong>重现性</strong>和<strong>可靠性</strong>的情况下。<strong>dplyr</strong> 函数使得&quot;tidy&quot;的工作流成为可能，其中一些人（包括本书的作者）在交互式数据分析中发现这些函数直观且富有成效，特别与RStudio等代码编辑器相结合，可以实现列名的<a href="https://support.posit.co/hc/en-us/articles/205273297-Code-Completion-in-the-RStudio-IDE" title="auto-completion">auto-completion</a>。下面演示了使用<strong>dplyr</strong>函数进行子集提取中的关键函数，包括<code>sf</code>数据框架。</p>
<p>&lt;!-- 根据以下基准，下面的句子似乎是不真实的。 --&gt; &lt;!-- `dplyr`在某些操作中也比基础 R 快，因为它的 C++ 索引{C++}后端。 --&gt; &lt;!-- 关于dbplyr的一些问题？我从来没有见过有人在实际中经常使用它来处理空间数据，所以暂时先不涉及与数据库的集成部分。（RL 2021-10） --&gt; &lt;!-- 主要的 **dplyr** 子集提取功能包括 `select()`, `slice()`, `filter()` and `pull()`。 --&gt;</p>
<p><code>select()</code>按照名称和位置选择列。例如，你可以利用下面的命令只选择<code>name_long</code>和<code>pop</code>两列：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">world1 <span class="operator">=</span> select<span class="punctuation">(</span>world<span class="punctuation">,</span> name_long<span class="punctuation">,</span> pop<span class="punctuation">)</span></span><br><span class="line"><span class="built_in">names</span><span class="punctuation">(</span>world1<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] &quot;name_long&quot; &quot;pop&quot;       &quot;geom&quot;</span></span><br></pre></td></tr></table></figure>
<p>注意：与基础R中的等效命令一样，（<code>world[, c(&quot;name_long&quot;, &quot;pop&quot;)]</code>）, “粘性” <code>geom</code>列保留。<code>select()</code>还允许在<code>:</code>操作符的帮助下选择一系列列变量：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># name_long 和 pop (包括)之间的所有列</span></span><br><span class="line">world2 <span class="operator">=</span> select<span class="punctuation">(</span>world<span class="punctuation">,</span> name_long<span class="operator">:</span>pop<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>用<code>-</code>操作符去除特定的列：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 除了 subregion 和 area_km2 (包括)之外的所有列</span></span><br><span class="line">world3 <span class="operator">=</span> select<span class="punctuation">(</span>world<span class="punctuation">,</span> <span class="operator">-</span>subregion<span class="punctuation">,</span> <span class="operator">-</span>area_km2<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><code>new_name = old_name</code>语法可以同时提取子集和重命名列变量:</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">world4 <span class="operator">=</span> select<span class="punctuation">(</span>world<span class="punctuation">,</span> name_long<span class="punctuation">,</span> population <span class="operator">=</span> pop<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>值得注意的是：上面的命令比基础R等价的命令更简洁，基础R等价的命令需要两行代码：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">world5 <span class="operator">=</span> world<span class="punctuation">[</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;name_long&quot;</span><span class="punctuation">,</span> <span class="string">&quot;pop&quot;</span><span class="punctuation">)</span><span class="punctuation">]</span>                <span class="comment"># 通过名称提取子列</span></span><br><span class="line"><span class="built_in">names</span><span class="punctuation">(</span>world5<span class="punctuation">)</span><span class="punctuation">[</span><span class="built_in">names</span><span class="punctuation">(</span>world5<span class="punctuation">)</span> <span class="operator">==</span> <span class="string">&quot;pop&quot;</span><span class="punctuation">]</span> <span class="operator">=</span> <span class="string">&quot;population&quot;</span>   <span class="comment"># 手动重命名</span></span><br></pre></td></tr></table></figure>
<p><code>select()</code>还可以使用’helper functions’ 进行更高级的自己提取操作，包括<code>contains()</code>，<code>starts_with()</code>和<code>num_range()</code>（用<code>?select</code>产看帮助页面获取更多细节）。</p>
<p>大部分 <strong>dplyr</strong> 函数返回数据框，但是你可以用<code>pull()</code>单独提取一列作为向量。&lt;!–注意：我注释掉下面的语句，因为它对`sf`对象不适用，而且数据框和`sf`对象的行为不同，有些令人困惑。–&gt; &lt;!-- 相比之下，基础 R（参见`? [`）中的子集运算符试图返回尽可能小维度的对象。 --&gt; &lt;!-- 这意味着选择一列返回一个以 R 为基础的向量，如下面的代码块所示，它返回一个表示`world`中国家人口的数字向量: --&gt;使用列表提取子集操作符<code>$</code>和<code>[[</code> ，可以在基础 R 中得到相同的结果，以下三个命令返回相同的数值向量:</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 结果返回为向量</span></span><br><span class="line">pull<span class="punctuation">(</span>world<span class="punctuation">,</span> pop<span class="punctuation">)</span></span><br><span class="line">world<span class="operator">$</span>pop</span><br><span class="line">world<span class="punctuation">[[</span><span class="string">&quot;pop&quot;</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<p>&lt;!-- 以下内容已注释，因其容易引起困惑且在其他地方有更好的涵盖（RL，2021-10）。 --&gt;</p>
<p>&lt;!-- 要关闭此行为，请将`drop`参数设置为`FALSE`。 --&gt;</p>
<p><code>slice()</code>是行选择工具等同于 <code>select()</code>。例如，下面的代码块选择了1到6行：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">slice<span class="punctuation">(</span>world<span class="punctuation">,</span> <span class="number">1</span><span class="operator">:</span><span class="number">6</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><code>filter()</code>是<strong>dplyr</strong>等价于基础 R 的<code>subset()</code>函数。它只保留符合给定标准的行，例如，只保留面积低于某一阈值或平均预期寿命高的国家，如下例所示：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">world7 <span class="operator">=</span> filter<span class="punctuation">(</span>world<span class="punctuation">,</span> area_km2 <span class="operator">&lt;</span> <span class="number">10000</span><span class="punctuation">)</span>  <span class="comment"># 面积小的国家</span></span><br><span class="line">world7 <span class="operator">=</span> filter<span class="punctuation">(</span>world<span class="punctuation">,</span> lifeExp <span class="operator">&gt;</span> <span class="number">82</span><span class="punctuation">)</span>      <span class="comment"># 预期寿命高的国家</span></span><br></pre></td></tr></table></figure>
<p>比较运算符的标准集合可以在<code>filter()</code>函数中使用，如表所示：</p>
<p>Table: Comparison operators that return Booleans (TRUE/FALSE).</p>
<table>
<thead>
<tr>
<th>Symbol</th>
<th>Name</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>==</code></td>
<td>Equal to</td>
</tr>
<tr>
<td><code>!=</code></td>
<td>Not equal to</td>
</tr>
<tr>
<td><code>&gt;</code>, <code>&lt;</code></td>
<td>Greater/Less than</td>
</tr>
<tr>
<td><code>&gt;=</code>, <code>&lt;=</code></td>
<td>Greater/Less than or equal</td>
</tr>
<tr>
<td><code>&amp;</code>,`</td>
<td><code>,</code>!`</td>
</tr>
</tbody>
</table>
<h2 id="管道连接命令"><a class="markdownIt-Anchor" href="#管道连接命令"></a> 管道连接命令</h2>
<p>使用<strong>dplyr</strong>函数的工作流的关键是<a href="http://r4ds.had.co.nz/pipes.html" title="'pipe'">’pipe’</a>操作符<code>%&gt;%</code>（或者自R <code>4.1.0</code>以来的内置管道<code>|&gt;</code>），名称取自Unix管道 <code>|</code>。管道启用表达式代码：前一个函数的输出成为下一个函数的第一个参数，从而启用<em>连接</em>。如下所示，其中只有来自亚洲的国家从<code>world</code>数据集中筛选，接下来对象是按列（<code>name_long</code>和<code>continent</code>）和前5行（结果未显示）分列的子集。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">world7 <span class="operator">=</span> world <span class="operator">|&gt;</span></span><br><span class="line">  filter<span class="punctuation">(</span>continent <span class="operator">==</span> <span class="string">&quot;Asia&quot;</span><span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">  select<span class="punctuation">(</span>name_long<span class="punctuation">,</span> continent<span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">  slice<span class="punctuation">(</span><span class="number">1</span><span class="operator">:</span><span class="number">5</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>上面的代码块显示了管道操作符如何允许以明确的顺序编写命令：从上到下（逐行）和从左到右运行。管道操作的另一种替代方法是嵌套函数调用，这种方法更难理解：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">world8 <span class="operator">=</span> slice<span class="punctuation">(</span></span><br><span class="line">  select<span class="punctuation">(</span></span><br><span class="line">    filter<span class="punctuation">(</span>world<span class="punctuation">,</span> continent <span class="operator">==</span> <span class="string">&quot;Asia&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">    name_long<span class="punctuation">,</span> continent<span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">  <span class="number">1</span><span class="operator">:</span><span class="number">5</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>另一种选择是将操作分为多个自包含行，特别是在开发新的 R 程序包时推荐使用此方法，这种方法的优点是可以通过具有不同名称的中间结果进行保存以便后续调试（但缺点是冗长，如果进行交互式分析时还会使全局环境凌乱）：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">world9_filtered <span class="operator">=</span> filter<span class="punctuation">(</span>world<span class="punctuation">,</span> continent <span class="operator">==</span> <span class="string">&quot;Asia&quot;</span><span class="punctuation">)</span></span><br><span class="line">world9_selected <span class="operator">=</span> select<span class="punctuation">(</span>world9_filtered<span class="punctuation">,</span> continent<span class="punctuation">)</span></span><br><span class="line">world9 <span class="operator">=</span> slice<span class="punctuation">(</span>world9_selected<span class="punctuation">,</span> <span class="number">1</span><span class="operator">:</span><span class="number">5</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>每种方法都有优缺点，其重要性取决于您的编程风格和应用程序。对于交互式数据分析（本章的重点），我们发现管道操作快速而直观，特别是与<a href="https://support.posit.co/hc/en-us/articles/200711853-Keyboard-Shortcuts-in-the-RStudio-IDE" title="RStudio">RStudio</a>/<a href="https://github.com/REditorSupport/vscode-R/wiki/Keyboard-shortcuts" title="VSCode">VSCode</a>快捷方式相结合时，可以创建管道并<a href="https://support.posit.co/hc/en-us/articles/205273297-Code-Completion-in-the-RStudio-IDE" title="自动完成">自动完成</a>变量名。</p>
<h2 id="矢量属性聚合"><a class="markdownIt-Anchor" href="#矢量属性聚合"></a> 矢量属性聚合</h2>
<p>聚合涉及使用一个或多个&quot;分组变量&quot;对数据进行汇总，通常是从要进行聚合的数据框的列中选择的（地理聚合在下一章中介绍）。属性聚合的一个例子是根据以国家为单位的数据（每个国家一行）计算每个大洲的人口数量。<code>world</code>数据集包含了必要的要素：<code>pop</code>和<code>continent</code>列分别代表人口和分组变量。目的是找到每个大洲的国家人口总和（<code>sum()</code>），从而得到一个较小的数据框（聚合是一种数据缩减的形式，对于处理大型数据集时，聚合是有用的前期步骤）。可以使用基本R函数<code>aggregate()</code>来完成此操作，步骤如下所示：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">world_agg1 <span class="operator">=</span> aggregate<span class="punctuation">(</span>pop <span class="operator">~</span> continent<span class="punctuation">,</span> FUN <span class="operator">=</span> <span class="built_in">sum</span><span class="punctuation">,</span> data <span class="operator">=</span> world<span class="punctuation">,</span></span><br><span class="line">                       na.rm <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br><span class="line"><span class="built_in">class</span><span class="punctuation">(</span>world_agg1<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] &quot;data.frame&quot;</span></span><br></pre></td></tr></table></figure>
<p>结果是一个6行的非空间数据框，每一行代表一个大洲，两列分别报告了每个大洲的名称和人口（参见表)，显示前三个人口最多的大洲的结果）。</p>
<p><code>aggregate()</code>是一个<a href="https://adv-r.hadley.nz/s3.html" title="泛函数">泛函数</a>，这意味着它的行为取决于它的输入。<strong>sf</strong>提供了<code>aggregate.sf()</code>方法，当<code>x</code>是一个<code>sf</code>对象且提供了一个<code>by</code>参数时，它会自动激活：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">world_agg2 <span class="operator">=</span> aggregate<span class="punctuation">(</span>world<span class="punctuation">[</span><span class="string">&quot;pop&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="built_in">list</span><span class="punctuation">(</span>world<span class="operator">$</span>continent<span class="punctuation">)</span><span class="punctuation">,</span> FUN <span class="operator">=</span> <span class="built_in">sum</span><span class="punctuation">,</span> </span><br><span class="line">                       na.rm <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br><span class="line"><span class="built_in">class</span><span class="punctuation">(</span>world_agg2<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] &quot;sf&quot;         &quot;data.frame&quot;</span></span><br><span class="line">nrow<span class="punctuation">(</span>world_agg2<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] 8</span></span><br></pre></td></tr></table></figure>
<p>由此产生的<code>world_agg2</code>对象是一个包含8个特征的空间对象，这些特征代表世界的大陆(和开放的海洋)。</p>
<p><code>group_by() |&gt; summarize()</code>是 <strong>dplyr</strong> 中与<code>aggregate()</code>等效的函数，其中在<code>group_by()</code>函数中提供的变量名称指定了分组变量，而对要进行汇总的信息则是通过传递给 <code>summarize()</code>函数来指定的，如下所示：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">world_agg3 <span class="operator">=</span> world <span class="operator">|&gt;</span></span><br><span class="line">  group_by<span class="punctuation">(</span>continent<span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">  summarize<span class="punctuation">(</span>pop <span class="operator">=</span> <span class="built_in">sum</span><span class="punctuation">(</span>pop<span class="punctuation">,</span> na.rm <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>这种方法可能看起来更复杂，但它具有以下好处：灵活性、可读性以及对新列名称的控制。下面的命令示例展示了这种灵活性，它不仅计算了人口数量，还计算了每个大洲的面积和国家数量：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">world_agg4  <span class="operator">=</span> world <span class="operator">|&gt;</span> </span><br><span class="line">  group_by<span class="punctuation">(</span>continent<span class="punctuation">)</span> <span class="operator">|&gt;</span> </span><br><span class="line">  summarize<span class="punctuation">(</span>Pop <span class="operator">=</span> <span class="built_in">sum</span><span class="punctuation">(</span>pop<span class="punctuation">,</span> na.rm <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span><span class="punctuation">,</span> Area <span class="operator">=</span> <span class="built_in">sum</span><span class="punctuation">(</span>area_km2<span class="punctuation">)</span><span class="punctuation">,</span> N <span class="operator">=</span> n<span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>在前一个代码块中，<code>Pop</code>、<code>Area</code>和<code>N</code>是结果中的列名，<code>sum()</code>和<code>n()</code>是聚合函数。这些聚合函数返回的<code>sf</code>对象具有以大洲表示的行和包含每个陆地和相关岛屿的多个多边形的几何信息（这得益于几何操作<strong>union</strong>，如几何合并节所述）。</p>
<p>让我们结合目前已经学习到的<strong>dplyr</strong>函数知识，通过将多个命令链接起来以总结全球各大洲的属性数据。以下命令使用<code>mutate()</code>函数计算人口密度，使用<code>dplyr::arrange()</code>函数按国家数量排列大洲，使用<code>dplyr::slice_max()</code>函数保留人口最多的3个洲，并呈现结果简单表格：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">world_agg5 <span class="operator">=</span> world <span class="operator">|&gt;</span> </span><br><span class="line">  st_drop_geometry<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">|&gt;</span>                      <span class="comment"># 去掉几何</span></span><br><span class="line">  select<span class="punctuation">(</span>pop<span class="punctuation">,</span> continent<span class="punctuation">,</span> area_km2<span class="punctuation">)</span> <span class="operator">|&gt;</span>        <span class="comment"># 提取子集  </span></span><br><span class="line">  group_by<span class="punctuation">(</span>continent<span class="punctuation">)</span> <span class="operator">|&gt;</span>                     <span class="comment"># 分组、汇总</span></span><br><span class="line">  summarize<span class="punctuation">(</span>Pop <span class="operator">=</span> <span class="built_in">sum</span><span class="punctuation">(</span>pop<span class="punctuation">,</span> na.rm <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span><span class="punctuation">,</span> Area <span class="operator">=</span> <span class="built_in">sum</span><span class="punctuation">(</span>area_km2<span class="punctuation">)</span><span class="punctuation">,</span> N <span class="operator">=</span> n<span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">  mutate<span class="punctuation">(</span>Density <span class="operator">=</span> <span class="built_in">round</span><span class="punctuation">(</span>Pop <span class="operator">/</span> Area<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">|&gt;</span>     <span class="comment"># 计算人口密度</span></span><br><span class="line">  slice_max<span class="punctuation">(</span>Pop<span class="punctuation">,</span> n <span class="operator">=</span> <span class="number">3</span><span class="punctuation">)</span> <span class="operator">|&gt;</span>                   <span class="comment"># 保留最大的3行</span></span><br><span class="line">  arrange<span class="punctuation">(</span>desc<span class="punctuation">(</span>N<span class="punctuation">)</span><span class="punctuation">)</span>                           <span class="comment"># 国家数量降序</span></span><br></pre></td></tr></table></figure>
<p>Table: The top 3 most populous continents ordered by number of countries.</p>
<table>
<thead>
<tr>
<th>continent</th>
<th>Pop</th>
<th>Area</th>
<th>N</th>
<th>Density</th>
</tr>
</thead>
<tbody>
<tr>
<td>Africa</td>
<td>1154946633</td>
<td>29946198</td>
<td>51</td>
<td>39</td>
</tr>
<tr>
<td>Asia</td>
<td>4311408059</td>
<td>31252459</td>
<td>47</td>
<td>138</td>
</tr>
<tr>
<td>Europe</td>
<td>669036256</td>
<td>23065219</td>
<td>39</td>
<td>29</td>
</tr>
</tbody>
</table>
<blockquote>
<p>更多细节可在帮助页面中查看（可通过<code>?summarize</code>和<code>vignette(package = &quot;dplyr&quot;)</code>访问）以及<a href="http://r4ds.had.co.nz/transform.html#grouped-summaries-with-summarize" title="R for Data Science">R for Data Science</a>第5章。</p>
</blockquote>
<h2 id="矢量属性连接"><a class="markdownIt-Anchor" href="#矢量属性连接"></a> 矢量属性连接</h2>
<p>在数据准备中，合并不同来源的数据是一种常见的任务。连接（<strong>Join</strong>）函数通过基于共享的&quot;key&quot;变量来合并表格。<strong>dplyr</strong>有多个连接函数，包括<code>left_join()</code>和<code>inner_join()</code>，详见<code>vignette(&quot;two-table&quot;)</code>以获取完整列表。这些函数名称遵循数据库语言<a href="http://r4ds.had.co.nz/relational-data.html" title="SQL">SQL</a>中使用的惯例。本部分重点讨论将非空间数据集与<code>sf</code>对象连接的过程。<strong>dplyr连接函数</strong>在数据框和<code>sf</code>对象上的操作相同，唯一重要的区别是<code>geometry</code>列表列。数据合并的结果可以是<code>sf</code>或<code>data.frame</code>对象。在空间数据中，最常见的属性合并类型是将<code>sf</code>对象作为第一个参数，并从作为第二个参数指定的<code>data.frame</code>中添加列。</p>
<p>为了展示连接，我们将把咖啡生产数据和<code>world</code>数据集合并。咖啡数据存储在一个名为<code>coffee_data</code>的数据框中，来自<strong>spData</strong>包（详情请参见<code>?coffee_data</code>）。它有3列：<code>name_long</code>列记录主要咖啡生产国家的名称，<code>coffee_production_2016</code>和<code>coffee_production_2017</code>列分别包含每年以60公斤袋为单位的咖啡生产估值。'left join’保留第一个数据集，将<code>world</code>与<code>coffee_data</code>合并：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">world_coffee <span class="operator">=</span> left_join<span class="punctuation">(</span>world<span class="punctuation">,</span> coffee_data<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; Joining with `by = join_by(name_long)`</span></span><br><span class="line"><span class="built_in">class</span><span class="punctuation">(</span>world_coffee<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] &quot;sf&quot;         &quot;tbl_df&quot;     &quot;tbl&quot;        &quot;data.frame&quot;</span></span><br></pre></td></tr></table></figure>
<p>由于输入数据集共享’key variable’（<code>name_long</code>），因此连接操作可以在不使用<code>by</code>参数的情况下完成（有关详细信息，请参见<code>?left_join</code>）。结果是一个与原始<code>world</code>对象相同的<code>sf</code>对象，但具有两个新变量（列索引为11和12）的咖啡产量。这可以绘制成地图，如下<a href="https://scy11.oss-cn-beijing.aliyuncs.com/img/202308230009131.png" title="🖼️ 图片">🖼️ 图片</a>的<code>plot()</code>函数所示：</p>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202308230009131.png" alt="" /></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="built_in">names</span><span class="punctuation">(</span>world_coffee<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt;  [1] &quot;iso_a2&quot;                 &quot;name_long&quot;              &quot;continent&quot;             </span></span><br><span class="line"><span class="comment">#&gt;  [4] &quot;region_un&quot;              &quot;subregion&quot;              &quot;type&quot;                  </span></span><br><span class="line"><span class="comment">#&gt;  [7] &quot;area_km2&quot;               &quot;pop&quot;                    &quot;lifeExp&quot;               </span></span><br><span class="line"><span class="comment">#&gt; [10] &quot;gdpPercap&quot;              &quot;geom&quot;                   &quot;coffee_production_2016&quot;</span></span><br><span class="line"><span class="comment">#&gt; [13] &quot;coffee_production_2017&quot;</span></span><br><span class="line">plot<span class="punctuation">(</span>world_coffee<span class="punctuation">[</span><span class="string">&quot;coffee_production_2017&quot;</span><span class="punctuation">]</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>为了使连接生效，两个数据集都必须提供’key variable’ 。默认情况下，<strong>dplyr</strong>会使用所有名称匹配的变量。在这种情况下，<code>world_coffee</code>和<code>world</code>两个对象都包含一个名为<code>name_long</code>的变量，这解释了信息<code>Joining with</code> <code>by = join_by(name_long)</code>。在大多数名称不同的情况下，您有两个选项：</p>
<ol>
<li>重命名某个对象中的key variable，使其与其他对象匹配。</li>
<li>使用<code>by</code>参数指明连接变量。</li>
</ol>
<p>后一种方法在<code>coffee_data</code>的重命名版本中演示如下:</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">coffee_renamed <span class="operator">=</span> rename<span class="punctuation">(</span>coffee_data<span class="punctuation">,</span> nm <span class="operator">=</span> name_long<span class="punctuation">)</span></span><br><span class="line">world_coffee2 <span class="operator">=</span> left_join<span class="punctuation">(</span>world<span class="punctuation">,</span> coffee_renamed<span class="punctuation">,</span> by <span class="operator">=</span> join_by<span class="punctuation">(</span>name_long <span class="operator">==</span> nm<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">world_coffee100 <span class="operator">=</span> left_join<span class="punctuation">(</span>world<span class="punctuation">,</span> coffee_renamed<span class="punctuation">,</span> by <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;name_long&quot;</span> <span class="operator">=</span> <span class="string">&quot;nm&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>请注意，在原始对象中保留名称，意味着<code>world_coffee</code>和新对象<code>world_coffee2</code>是相同的。结果的另一个特点是具有与原始数据集相同的行数。尽管<code>coffee_data</code>中仅有47行数据，但<code>world_coffee</code>和<code>world_coffee2</code>中保留了所有177个国家记录：在原始数据集中没有匹配的行会被赋予新咖啡生产变量的<code>NA</code>值。如果我们只想保留具有键变量匹配的国家怎么办？在这种情况下，可以使用<strong>内连接</strong>：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">world_coffee_inner <span class="operator">=</span> inner_join<span class="punctuation">(</span>world<span class="punctuation">,</span> coffee_data<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; Joining with `by = join_by(name_long)`</span></span><br><span class="line">nrow<span class="punctuation">(</span>world_coffee_inner<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] 45</span></span><br></pre></td></tr></table></figure>
<p><code>inner_join()</code>的结果只有45行，而<code>coffee_data</code>中有47行。剩下的行发生了什么？我们可以使用<code>setdiff()</code>函数来<strong>识别未匹配行</strong>，如下所示：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">setdiff<span class="punctuation">(</span>coffee_data<span class="operator">$</span>name_long<span class="punctuation">,</span> world<span class="operator">$</span>name_long<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] &quot;Congo, Dem. Rep. of&quot; &quot;Others&quot;</span></span><br></pre></td></tr></table></figure>
<p>结果显示，<code>Others</code>占据了<code>world</code>数据集中不存在的一行，而<code>Democratic Republic of the Congo</code>的名称占据了另一行: 名称缩写，导致连接错误。下面的命令使用<strong>stringr</strong>包中的字符串匹配（<em>regex</em>）函数来确认<code>Congo, Dem. Rep. of</code>应为:</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">drc <span class="operator">=</span> stringr<span class="operator">::</span>str_subset<span class="punctuation">(</span>world<span class="operator">$</span>name_long<span class="punctuation">,</span> <span class="string">&quot;Dem*.+Congo&quot;</span><span class="punctuation">)</span></span><br><span class="line">drc</span><br><span class="line"><span class="comment">#&gt; [1] &quot;Democratic Republic of the Congo&quot;</span></span><br></pre></td></tr></table></figure>
<p>为了解决这个问题，我们将创建一个新版本的<code>coffee_data</code>并更新名称。<code>inner_join()</code>更新后的数据框返回一个包含所有46个咖啡生产国的结果:</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">coffee_data<span class="operator">$</span>name_long<span class="punctuation">[</span>grepl<span class="punctuation">(</span><span class="string">&quot;Congo,&quot;</span><span class="punctuation">,</span> coffee_data<span class="operator">$</span>name_long<span class="punctuation">)</span><span class="punctuation">]</span> <span class="operator">=</span> drc</span><br><span class="line">world_coffee_match <span class="operator">=</span> inner_join<span class="punctuation">(</span>world<span class="punctuation">,</span> coffee_data<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; Joining with `by = join_by(name_long)`</span></span><br><span class="line">nrow<span class="punctuation">(</span>world_coffee_match<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] 46</span></span><br></pre></td></tr></table></figure>
<p>也可以从另一个方向连接：从非空间数据集开始，并从简单要素对象中添加变量。下面演示了这一点，从<code>coffee_data</code>对象开始，并从原始<code>world</code>数据集中添加变量。与前面的连接相比，结果<strong>不是</strong>另一个简单要素对象，而是一个<strong>tidyverse</strong>数据框格式的tibble。连接的输出往往与其第一个参数相匹配：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">coffee_world <span class="operator">=</span> left_join<span class="punctuation">(</span>coffee_data<span class="punctuation">,</span> world<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; Joining with `by = join_by(name_long)`</span></span><br><span class="line"><span class="built_in">class</span><span class="punctuation">(</span>coffee_world<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] &quot;tbl_df&quot;     &quot;tbl&quot;        &quot;data.frame&quot;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>📌在大多数情况下，几何列只在<code>sf</code>对象中有用。<br />
只有当R“知道”它是由如<code>sf</code>等空间包定义的空间对象时，几何列才能用于创建地图和空间操作。<br />
幸运的是，具有几何列表列（如<code>coffee_world</code>）的非空间数据框可以如下方式强制转换为<code>sf</code>对象：<code>st_as_sf(coffee_world)</code>。</p>
</blockquote>
<p>本节涵盖了大部分的连接使用情况。如需更多信息，我们建议阅读<a href="https://r4ds.had.co.nz/relational-data.html?q=join#relational-data" title="Relational data">Relational data</a>章节，本书附带的<strong>geocompkg</strong>包中的<a href="https://geocompx.github.io/geocompkg/articles/join.html" title="join vignette">join vignette</a>，以及描述<strong>data.table</strong>和其他包中的连接方法的文档。<strong>空间连接</strong>将在下一章<em>空间连接</em>中讲述。</p>
<h2 id="创建属性移除空间信息"><a class="markdownIt-Anchor" href="#创建属性移除空间信息"></a> 创建属性移除空间信息</h2>
<p>通常，我们想要根据已有的列创建新的列。例如，我们想要计算每个国家的人口密度。为此，我们需要将一个人口列（这里是<code>pop</code>）除以一个面积列（这里是<code>area_km2</code>），其中单位面积为平方千米。使用基础R，我们可以输入：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">world_new <span class="operator">=</span> world <span class="comment"># 不要覆盖原始数据</span></span><br><span class="line">world_new<span class="operator">$</span>pop_dens <span class="operator">=</span> world_new<span class="operator">$</span>pop <span class="operator">/</span> world_new<span class="operator">$</span>area_km2</span><br></pre></td></tr></table></figure>
<p>另外，我们还可以使用<strong>dplyr</strong>函数-<code>mutate()</code>或<code>transmute()</code>。<code>mutate()</code>在<code>sf</code>对象的倒数第二个位置添加新的列（最后一个位置是保留给几何图形的）：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">world_new2 <span class="operator">=</span> world <span class="operator">|&gt;</span> </span><br><span class="line">  mutate<span class="punctuation">(</span>pop_dens <span class="operator">=</span> pop <span class="operator">/</span> area_km2<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><code>mutate()</code>和<code>transmute()</code>的区别在于<code>transmute()</code>会删除所有其他已存在的列（除了<strong>sticky geometry</strong>列）。</p>
<p><code>unite()</code>函数来自<strong>tidyr</strong>包（该包提供了许多重塑数据集的有用函数，包括<code>pivot_longer()</code>），<code>unite()</code>函数将现有的列拼接在一起。例如我们想要将<code>continent</code>和<code>region_un</code>列合并成一个名为<code>con_reg</code>的新列。另外，我们可以定义一个分隔符（这里是冒号<code>:</code>），用于定义输入列的值应该如何拼接，并且确定是否删除原始列（这里是<code>TRUE</code>）。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">world_unite <span class="operator">=</span> world <span class="operator">|&gt;</span></span><br><span class="line">  tidyr<span class="operator">::</span>unite<span class="punctuation">(</span><span class="string">&quot;con_reg&quot;</span><span class="punctuation">,</span> continent<span class="operator">:</span>region_un<span class="punctuation">,</span> sep <span class="operator">=</span> <span class="string">&quot;:&quot;</span><span class="punctuation">,</span> remove <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>生成的<code>sf</code>对象有一个名为<code>con_reg</code>的新列，代表每个国家的大陆和地区，例如，<code>South America:Americas</code>代表阿根廷和其他南美洲国家。<strong>tidyr</strong> 的<code>separate()</code>函数的作用与<code>unite()</code>相反: 它使用正则表达式或字符位置将一列拆分为多列。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">world_separate <span class="operator">=</span> world_unite <span class="operator">|&gt;</span></span><br><span class="line">  tidyr<span class="operator">::</span>separate<span class="punctuation">(</span>con_reg<span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;continent&quot;</span><span class="punctuation">,</span> <span class="string">&quot;region_un&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> sep <span class="operator">=</span> <span class="string">&quot;:&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><strong>dplyr函数</strong><code>rename()</code>和基础 R 中的<code>setNames()</code>函数用于重命名列变量。<code>rename()</code>函数用新名称代替就名称。例如，下面的命令重命名<code>name_long</code>列为<code>name</code>：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">world <span class="operator">|&gt;</span> </span><br><span class="line">  rename<span class="punctuation">(</span>name <span class="operator">=</span> name_long<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><code>setNames()</code>函数一次性改变全部列名，并需要一个与各列匹配的字符向量。下面的示例说明了这一点，输出相同的<code>world</code>对象，但列名变得非常简单：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">new_names <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;i&quot;</span><span class="punctuation">,</span> <span class="string">&quot;n&quot;</span><span class="punctuation">,</span> <span class="string">&quot;c&quot;</span><span class="punctuation">,</span> <span class="string">&quot;r&quot;</span><span class="punctuation">,</span> <span class="string">&quot;s&quot;</span><span class="punctuation">,</span> <span class="string">&quot;t&quot;</span><span class="punctuation">,</span> <span class="string">&quot;a&quot;</span><span class="punctuation">,</span> <span class="string">&quot;p&quot;</span><span class="punctuation">,</span> <span class="string">&quot;l&quot;</span><span class="punctuation">,</span> <span class="string">&quot;gP&quot;</span><span class="punctuation">,</span> <span class="string">&quot;geom&quot;</span><span class="punctuation">)</span></span><br><span class="line">world_new_names <span class="operator">=</span> world <span class="operator">|&gt;</span></span><br><span class="line">  setNames<span class="punctuation">(</span>new_names<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>每个属性数据操作都保留简单要素的几何特征。有时候去除几何特征是有意义的。例如，为了加快聚合速度。请使用<code>st_drop_geometry()</code>进行操作，而不是手动使用诸如<code>select(world, -geom)</code>等命令，如下所示。</p>
<p><code>st_geometry(world_st) = NULL</code> also works to remove the geometry from <code>world</code>, but overwrites the original object.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">world_data <span class="operator">=</span> world <span class="operator">|&gt;</span> st_drop_geometry<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line"><span class="built_in">class</span><span class="punctuation">(</span>world_data<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] &quot;tbl_df&quot;     &quot;tbl&quot;     &quot;data.frame&quot;</span></span><br></pre></td></tr></table></figure>
<h1 id="栅格数据操作"><a class="markdownIt-Anchor" href="#栅格数据操作"></a> 栅格数据操作</h1>
<p>与简单要素基础下的矢量数据模型相反（它将点、线和多边形表示为空间中的离散实体），栅格数据表示连续表面。本节将展示如何<em>从头</em>开始创建栅格对象，并基于<em>terra介绍</em>章节进行构建。由于它们独特的结构，对栅格数据集的子集提取和其他操作以不同的方式进行，在栅格数据提取子集章节中展示。</p>
<p>以下代码重新创建了在<em>栅格类</em>节使用的栅格数据集，其结果在<a href="https://scy11.oss-cn-beijing.aliyuncs.com/img/202308230031352.png" title="🖼️ 图片">🖼️ 图片</a>中展示。这展示了<code>rast()</code>函数如何工作来创建一个名为<code>elev</code>的示例栅格（表示高程）的示例。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">elev <span class="operator">=</span> rast<span class="punctuation">(</span>nrows <span class="operator">=</span> <span class="number">6</span><span class="punctuation">,</span> ncols <span class="operator">=</span> <span class="number">6</span><span class="punctuation">,</span></span><br><span class="line">            xmin <span class="operator">=</span> <span class="operator">-</span><span class="number">1.5</span><span class="punctuation">,</span> xmax <span class="operator">=</span> <span class="number">1.5</span><span class="punctuation">,</span> ymin <span class="operator">=</span> <span class="operator">-</span><span class="number">1.5</span><span class="punctuation">,</span> ymax <span class="operator">=</span> <span class="number">1.5</span><span class="punctuation">,</span></span><br><span class="line">            vals <span class="operator">=</span> <span class="number">1</span><span class="operator">:</span><span class="number">36</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://scy11.oss-cn-beijing.aliyuncs.com/img/202308230031352.png" alt="" /></p>
<p>结果是一个具有6行和6列的栅格对象（由<code>nrow</code>和<code>ncol</code>参数指定），以及x和y方向上的最小和最大空间范围（<code>xmin</code>，<code>xmax</code>，<code>ymin</code>，<code>ymax</code>）。<code>vals</code>参数设置每个单元格包含的值：在这种情况下，是从1到36的数值数据。Raster对象还可以包含在R中<code>logical</code>或<code>factor</code>类变量形式表示的分类值。以下代码创建了图所示的栅格数据集：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">grain_order <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;clay&quot;</span><span class="punctuation">,</span> <span class="string">&quot;silt&quot;</span><span class="punctuation">,</span> <span class="string">&quot;sand&quot;</span><span class="punctuation">)</span></span><br><span class="line">grain_char <span class="operator">=</span> sample<span class="punctuation">(</span>grain_order<span class="punctuation">,</span> <span class="number">36</span><span class="punctuation">,</span> replace <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br><span class="line">grain_fact <span class="operator">=</span> factor<span class="punctuation">(</span>grain_char<span class="punctuation">,</span> levels <span class="operator">=</span> grain_order<span class="punctuation">)</span></span><br><span class="line">grain <span class="operator">=</span> rast<span class="punctuation">(</span>nrows <span class="operator">=</span> <span class="number">6</span><span class="punctuation">,</span> ncols <span class="operator">=</span> <span class="number">6</span><span class="punctuation">,</span> </span><br><span class="line">             xmin <span class="operator">=</span> <span class="operator">-</span><span class="number">1.5</span><span class="punctuation">,</span> xmax <span class="operator">=</span> <span class="number">1.5</span><span class="punctuation">,</span> ymin <span class="operator">=</span> <span class="operator">-</span><span class="number">1.5</span><span class="punctuation">,</span> ymax <span class="operator">=</span> <span class="number">1.5</span><span class="punctuation">,</span></span><br><span class="line">             vals <span class="operator">=</span> grain_fact<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>栅格对象将相应的查找表或&quot;栅格属性表&quot;（RAT）存储为数据框列表，可以使用<code>cats(grain)</code>查看（有关更多信息，请参见<code>?cats()</code>）。该列表的每个元素都是一个栅格层。还可以使用<code>levels()</code>函数检索和添加新的或替换现有的因子级别：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">levels<span class="punctuation">(</span>grain<span class="punctuation">)</span> <span class="operator">=</span> data.frame<span class="punctuation">(</span>value <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">)</span><span class="punctuation">,</span> wetness <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;wet&quot;</span><span class="punctuation">,</span> <span class="string">&quot;moist&quot;</span><span class="punctuation">,</span> <span class="string">&quot;dry&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">levels<span class="punctuation">(</span>grain<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [[1]]</span></span><br><span class="line"><span class="comment">#&gt;   value wetness</span></span><br><span class="line"><span class="comment">#&gt; 1     0     wet</span></span><br><span class="line"><span class="comment">#&gt; 2     1   moist</span></span><br><span class="line"><span class="comment">#&gt; 3     2     dry</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>📌分类栅格对象还可以使用颜色表存储与每个值相关联的颜色信息。<br />
颜色表是一个数据框，有三个（红色、绿色、蓝色）或四个（Alpha）列，其中每一行与一个值相关联。<br />
在<strong>terra</strong>中，可以使用<code>coltab()</code>函数查看或设置颜色表（请参阅 <code>?coltab</code>）。<br />
需要注意的是，将带有颜色表的栅格对象保存到文件（例如GeoTIFF）中也会保存颜色信息。</p>
</blockquote>
<h2 id="栅格数据提取子集"><a class="markdownIt-Anchor" href="#栅格数据提取子集"></a> 栅格数据提取子集</h2>
<p>用基础R中的<code>[</code>操作符提取栅格数据子集，改运算符接受多种输入：</p>
<ul>
<li>行-列索引</li>
<li>单元格 IDs</li>
<li>坐标系（见<em>空间栅格子集提取</em>节）</li>
<li>其他的空间对象（见<em>空间栅格子集提取</em>节）</li>
</ul>
<p>在这里，我们只展示前两个选项，因为它们可以被视为非空间操作。如果我们需要一个空间对象来对另一个对象进行子集提取，或者输出是一个空间对象，我们将其称为空间子集操作。因此，后两个选项将在下一章中进行展示（见<em>空间栅格子集提取</em>节）。</p>
<p>前两个子集操作选项在下面的命令中进行了演示——两者都返回栅格对象<code>elev</code>中左上角像素的值（结果未显示）：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># row 1, column 1</span></span><br><span class="line">elev<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">]</span></span><br><span class="line"><span class="comment"># cell ID 1</span></span><br><span class="line">elev<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<p>多层栅格对象的子集提取将返回每层的单元格值。例如，<code>two_layers = c(grain, elev)</code>；<code>two_layers[1]</code>返回一个包含一行两列的数据框架——每层一列。若要提取所有值或完整行，还可以使用<code>values()</code>。</p>
<p>可以通过与子集提取操作一起覆盖现有值来修改单元格值。例如，下面的代码块将<code>elev</code>的左上单元格设置为0（结果未显示）：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">elev<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">]</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">elev<span class="punctuation">[</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<p>留空方括号是使用<code>values()</code>检索栅格的所有值的快捷方式，通过此方式也可以修改多个单元格:</p>
<p>替换多层栅格的值可以使用矩阵，其列数与层数相同，行数与可替换单元格数相同（结果未显示）：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">two_layers <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span>grain<span class="punctuation">,</span> elev<span class="punctuation">)</span> </span><br><span class="line">two_layers<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="operator">=</span> cbind<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">4</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">two_layers<span class="punctuation">[</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<h2 id="栅格数据汇总"><a class="markdownIt-Anchor" href="#栅格数据汇总"></a> 栅格数据汇总</h2>
<p>terra包含提取整个栅格数据描述性统计信息的功能。通过输入栅格对象的名称并将其打印到控制台，可以返回栅格的最小值和最大值。<code>summary()</code>提供了常见的描述性统计量——最小值、最大值、四分位数以及连续型栅格<code>NA</code>的数量，以及分类型栅格中每个类别的单元格数量。进一步的总结操作，例如标准偏差（见下文）或自定义总结统计量，可以通过<code>global()</code>计算得出。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">global<span class="punctuation">(</span>elev<span class="punctuation">,</span> sd<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果您向<code>summary()</code>和<code>global()</code>函数提供一个多层栅格对象，它们将分别总结每一个层次，可以通过运行以下命令进行演示：<code>summary(c(elev, grain))</code>。</p>
</blockquote>
<p>此外，<code>freq()</code>函数允许获取分类值的频率表。栅格值统计可以以多种方式进行可视化。特定的函数，如<code>boxplot()</code>、<code>density()</code>、<code>hist()</code>和<code>pairs()</code>也适用于栅格对象，如下方命令创建的直方图所示（未显示）：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">hist<span class="punctuation">(</span>elev<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>如果所需的可视化函数无法与栅格对象一起使用，可以使用<code>values()</code>函数提取要绘制的栅格数据（参见栅格数据提取子集节）。</p>
<p>描述性栅格统计属于所谓的<strong>全局</strong>栅格操作。这些以及其他典型的栅格处理操作是<strong>地图代数</strong>方案的一部分，将在下一章（<em>地图代数</em>节）中介绍。</p>
<blockquote>
<p>📌一些函数名在包之间发生了冲突（例如，<code>extract()</code>函数在<strong>terra</strong>和<strong>tidyr</strong>包中都有）。<br />
除了不通过引用函数来加载包（例如，<code>tidyr::extract()</code>），还有一种避免函数名冲突的方法是使用<code>detach()</code>取消加载引起问题的包。<br />
例如，下面的命令可以卸载<code>terra</code>包（这也可以在 RStudio的默认右下角窗格中的<em>package</em>选项卡中完成）：<code>detach(&quot;package:terra&quot;, unload = TRUE, force = TRUE)</code>。在使用<code>force</code>参数时，即使其他包依赖于该包，也可以确保分离该包。<br />
然而，这可能会导致依赖于已分离包的包受到限制的可用性，因此不建议使用该参数。</p>
</blockquote>
<h2 id="练习"><a class="markdownIt-Anchor" href="#练习"></a> 练习</h2>
<p>For these exercises we will use the <code>us_states</code> and <code>us_states_df</code> datasets from the <strong>spData</strong> package.<br />
You must have attached the package, and other packages used in the attribute operations chapter (<strong>sf</strong>, <strong>dplyr</strong>, <strong>terra</strong>) with commands such as <code>library(spData)</code> before attempting these exercises:</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>sf<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>dplyr<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>terra<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>spData<span class="punctuation">)</span></span><br><span class="line">data<span class="punctuation">(</span>us_states<span class="punctuation">)</span></span><br><span class="line">data<span class="punctuation">(</span>us_states_df<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><code>us_states</code> is a spatial object (of class <code>sf</code>), containing geometry and a few attributes (including name, region, area, and population) of states within the contiguous United States.<br />
<code>us_states_df</code> is a data frame (of class <code>data.frame</code>) containing the name and additional variables (including median income and poverty level, for the years 2010 and 2015) of US states, including Alaska, Hawaii and Puerto Rico.<br />
The data comes from the United States Census Bureau, and is documented in <code>?us_states</code> and <code>?us_states_df</code>.</p>
<p>E1. Create a new object called <code>us_states_name</code> that contains only the <code>NAME</code> column from the <code>us_states</code> object using either base R (<code>[</code>) or tidyverse (<code>select()</code>) syntax.<br />
What is the class of the new object and what makes it geographic?</p>
<p>E2. Select columns from the <code>us_states</code> object which contain population data.<br />
Obtain the same result using a different command (bonus: try to find three ways of obtaining the same result).<br />
Hint: try to use helper functions, such as <code>contains</code> or <code>matches</code> from <strong>dplyr</strong> (see <code>?contains</code>).</p>
<p>E3. Find all states with the following characteristics (bonus find <em>and</em> plot them):</p>
<ul>
<li>Belong to the Midwest region.</li>
<li>Belong to the West region, have an area below 250,000 km<sup>2</sup> <em>and</em> in 2015 a population greater than 5,000,000 residents (hint: you may need to use the function <code>units::set_units()</code> or <code>as.numeric()</code>).</li>
<li>Belong to the South region, had an area larger than 150,000 km<sup>2</sup> or a total population in 2015 larger than 7,000,000 residents.</li>
</ul>
<p>E4. What was the total population in 2015 in the <code>us_states</code> dataset?<br />
What was the minimum and maximum total population in 2015?</p>
<p>E5. How many states are there in each region?</p>
<p>E6. What was the minimum and maximum total population in 2015 in each region?<br />
What was the total population in 2015 in each region?</p>
<p>E7. Add variables from <code>us_states_df</code> to <code>us_states</code>, and create a new object called <code>us_states_stats</code>.<br />
What function did you use and why?<br />
Which variable is the key in both datasets?<br />
What is the class of the new object?</p>
<p>E8. <code>us_states_df</code> has two more rows than <code>us_states</code>.<br />
How can you find them? (hint: try to use the <code>dplyr::anti_join()</code> function)</p>
<p>E9. What was the population density in 2015 in each state?<br />
What was the population density in 2010 in each state?</p>
<p>E10. How much has population density changed between 2010 and 2015 in each state?<br />
Calculate the change in percentages and map them.</p>
<p>E11. Change the columns’ names in <code>us_states</code> to lowercase. (Hint: helper functions - <code>tolower()</code> and <code>colnames()</code> may help.)</p>
<p>E12. Using <code>us_states</code> and <code>us_states_df</code> create a new object called <code>us_states_sel</code>.<br />
The new object should have only two variables - <code>median_income_15</code> and <code>geometry</code>.<br />
Change the name of the <code>median_income_15</code> column to <code>Income</code>.</p>
<p>E13. Calculate the change in the number of residents living below the poverty level between 2010 and 2015 for each state. (Hint: See ?us_states_df for documentation on the poverty level columns.)<br />
Bonus: Calculate the change in the <em>percentage</em> of residents living below the poverty level in each state.</p>
<p>E14. What was the minimum, average and maximum state’s number of people living below the poverty line in 2015 for each region?<br />
Bonus: What is the region with the largest increase in people living below the poverty line?</p>
<p>E15. Create a raster from scratch with nine rows and columns and a resolution of 0.5 decimal degrees (WGS84).<br />
Fill it with random numbers.<br />
Extract the values of the four corner cells.</p>
<p>E16. What is the most common class of our example raster <code>grain</code>?</p>
<p>E17. Plot the histogram and the boxplot of the <code>dem.tif</code> file from the <strong>spDataLarge</strong> package (<code>system.file(&quot;raster/dem.tif&quot;, package = &quot;spDataLarge&quot;)</code>).</p>
]]></content>
      <categories>
        <category>R</category>
        <category>Geocomputaion</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>Geocomputaion</tag>
      </tags>
  </entry>
  <entry>
    <title>(5)几何操作</title>
    <url>/2023/08/14/2023-8-14-5-%E5%87%A0%E4%BD%95%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="几何操作"><a class="markdownIt-Anchor" href="#几何操作"></a> 几何操作</h1>
]]></content>
      <categories>
        <category>R</category>
        <category>Geocomputaion</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>Geocomputaion</tag>
      </tags>
  </entry>
  <entry>
    <title>(7)地理数据重投影</title>
    <url>/2023/08/10/2023-8-16-7-%E5%9C%B0%E7%90%86%E6%95%B0%E6%8D%AE%E9%87%8D%E6%8A%95%E5%BD%B1/</url>
    <content><![CDATA[<h2 id="前提条件-"><a class="markdownIt-Anchor" href="#前提条件-"></a> 前提条件 {-}</h2>
<ul>
<li>本章要求下列包：</li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>sf<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>terra<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>dplyr<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>spData<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>spDataLarge<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<h2 id="引言"><a class="markdownIt-Anchor" href="#引言"></a> 引言</h2>
]]></content>
      <categories>
        <category>R</category>
        <category>Geocomputaion</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>Geocomputaion</tag>
      </tags>
  </entry>
  <entry>
    <title>(8)地理数据 I/O</title>
    <url>/2023/08/17/2023-8-17-8-%E5%9C%B0%E7%90%86%E6%95%B0%E6%8D%AEIO/</url>
    <content><![CDATA[<h2 id="前提条件-unnumbered"><a class="markdownIt-Anchor" href="#前提条件-unnumbered"></a> 前提条件 {.unnumbered}</h2>
<p>本章要求下面的包</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>sf<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>terra<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>dplyr<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>spData<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<h2 id="引言"><a class="markdownIt-Anchor" href="#引言"></a> 引言</h2>
<!--toDo:RL-->
<!--revise and update the following section-->
<p>本章关于读取和写入地理数据。地理数据<em>输入</em>对地理计算\index{geocomputation}至关重要:没有数据就不可能有真实世界的应用。数据<em>输出</em>也非常关键,它能够让其他人使用由你的工作产生的有价值的新数据集或改进后的数据集。总而言之,输入/输出这些进程可以称为数据I/O。</p>
<p>地理数据I/O通常只需要在项目开始和结束时编写几行代码。它经常被简单地视为一个步骤的过程而被忽略。然而,在项目开始时(例如使用过时或有缺陷的数据集)的错误会在稍后导致大问题,因此值得在确定哪些数据集是<em>可用的</em>、它们可以在<em>哪里找到</em>以及如何<em>检索</em>它们上投入相当多的时间。这些主题在第@ref(retrieving-data)节中有所涵盖,其中描述了各种<em>地理门户网站</em>,这些网站共同包含了数十TB的数据,以及如何使用它们。为了进一步简化数据访问,已经开发了许多用于下载地理数据的软件包。这些软件包在第@ref(geographic-data-packages)节中有所描述。</p>
<p>存在许多地理文件格式,各有其优缺点。这些格式在第@ref(file-formats)节中有所描述。关于实际高效读取和写入这些文件格式的过程直到第@ref(data-input)节和第@ref(data-output)节才涵盖。最后一节@ref(visual-outputs)演示了保存可视化输出(地图)的方法,为第@ref(adv-map)章节关于可视化做准备。</p>
<h2 id="获取开放数据"><a class="markdownIt-Anchor" href="#获取开放数据"></a> 获取开放数据</h2>
]]></content>
      <categories>
        <category>R</category>
        <category>Geocomputaion</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>Geocomputaion</tag>
      </tags>
  </entry>
  <entry>
    <title>(6)栅格矢量交叉</title>
    <url>/2023/08/15/2023-8-15-6-%E6%A0%85%E6%A0%BC%E7%9F%A2%E9%87%8F%E4%BA%A4%E5%8F%89/</url>
    <content><![CDATA[<h2 id="前提条件-unnumbered"><a class="markdownIt-Anchor" href="#前提条件-unnumbered"></a> 前提条件 {.unnumbered}</h2>
<ul>
<li>本章要求下列包：</li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>sf<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>terra<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>dplyr<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<h2 id="引言"><a class="markdownIt-Anchor" href="#引言"></a> 引言</h2>
<p>\index{raster-vector interactions} 本章专注于栅格和矢量地理数据模型之间的相互作用，这些在章节 @ref(spatial-class)中介绍。包括四个主要技术：使用矢量对象进行栅格裁剪和遮罩（章节@ref(raster-cropping)）；使用不同类型的矢量数据提取栅格值（章节@ref(raster-extraction)）；以及栅格与矢量之间的转换（章节@ref(rasterization)和@ref(spatial-vectorization)）。以上概念使用前几章中使用的数据进行演示，以了解其潜在的现实应用。</p>
<h2 id="栅格裁剪"><a class="markdownIt-Anchor" href="#栅格裁剪"></a> 栅格裁剪</h2>
<p>\index{raster cropping}许多地理数据项目涉及从许多不同来源整合数据，例如遥感图像（栅格）和行政边界（矢量）。通常，输入栅格数据集的范围大于感兴趣的区域。在这种情况下，栅格<strong>裁剪</strong>和<strong>掩膜</strong>对于统一输入数据的空间范围非常有用。这两个操作减少了对象的内存使用和后续分析步骤的相关计算资源，而且是创建涉及栅格数据地图之前必要的预处理步骤。</p>
<p>我们将使用两个对象来说明栅格裁剪：</p>
<ul>
<li>一个代表犹他州西南部海拔高度（海平面以上米数）的<code>SpatRaster</code>对象<code>srtm</code></li>
<li>一个代表锡安国家公园的矢量（<code>sf</code>）对象 <code>zion</code></li>
</ul>
<p>目标对象和裁剪对象必须具有相同的投影。因此，下面的代码块不仅从<strong>spDataLarge</strong>包中读取了章节@ref(spatial-class) 中安装的数据集，还对<code>zion</code>进行了“重投影”（这个主题在章节 @ref(reproj-geo-data) 中介绍）。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">srtm <span class="operator">=</span> rast<span class="punctuation">(</span>system.file<span class="punctuation">(</span><span class="string">&quot;raster/srtm.tif&quot;</span><span class="punctuation">,</span> package <span class="operator">=</span> <span class="string">&quot;spDataLarge&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">zion <span class="operator">=</span> read_sf<span class="punctuation">(</span>system.file<span class="punctuation">(</span><span class="string">&quot;vector/zion.gpkg&quot;</span><span class="punctuation">,</span> package <span class="operator">=</span> <span class="string">&quot;spDataLarge&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">zion <span class="operator">=</span> st_transform<span class="punctuation">(</span>zion<span class="punctuation">,</span> crs<span class="punctuation">(</span>srtm<span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>我们使用<strong>terra</strong>包的<code>crop()</code>函数来裁剪<code>srtm</code>栅格。该函数根据传递给其第二个参数的对象的范围减小传递给其第一个参数的对象的矩形范围。下面的命令演示了这个功能，生成了图@ref(fig:cropmask)(B)：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">srtm_cropped <span class="operator">=</span> crop<span class="punctuation">(</span>srtm<span class="punctuation">,</span> zion<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>\index{raster masking} 与<code>crop()</code>相关的是<strong>terra</strong>函数<code>mask()</code>，它将传递给第二个参数的对象范围之外的值设置为<code>NA</code>。因此，以下命令会掩膜锡安国家公园边界以外的每一个单元格（图 @ref(fig:cropmask)©）：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">srtm_masked <span class="operator">=</span> mask<span class="punctuation">(</span>srtm<span class="punctuation">,</span> zion<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>重要的是，在大多数情况下，我们想要同时使用<code>crop()</code>和<code>mask()</code> 这两个函数。这组函数的组合将(a)将栅格的范围限制在我们感兴趣的区域内，然后 (b) 将该区域外的所有值替换为NA。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">srtm_cropped <span class="operator">=</span> crop<span class="punctuation">(</span>srtm<span class="punctuation">,</span> zion<span class="punctuation">)</span></span><br><span class="line">srtm_final <span class="operator">=</span> mask<span class="punctuation">(</span>srtm_cropped<span class="punctuation">,</span> zion<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>更改<code>mask()</code>的设置会产生不同的结果。设置<code>inverse = TRUE</code>将会屏蔽公园范围<em>内</em>的所有内容（详见<code>?mask</code>）（见图 @ref(fig:cropmask)(D)），而设置 <code>updatevalue = 0</code> 将会将国家公园外的所有像素设置为0。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">srtm_inv_masked <span class="operator">=</span> mask<span class="punctuation">(</span>srtm<span class="punctuation">,</span> zion<span class="punctuation">,</span> inverse <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#&gt; The legacy packages maptools, rgdal, and rgeos, underpinning the sp package,</span><br><span class="line">#&gt; which was just loaded, will retire in October 2023.</span><br><span class="line">#&gt; Please refer to R-spatial evolution reports for details, especially</span><br><span class="line">#&gt; https://r-spatial.org/r/2023/05/15/evolution4.html.</span><br><span class="line">#&gt; It may be desirable to make the sf package available;</span><br><span class="line">#&gt; package maintainers should consider adding sf to Suggests:.</span><br><span class="line">#&gt; The sp package is now running under evolution status 2</span><br><span class="line">#&gt;      (status 2 uses the sf package in place of rgdal)</span><br></pre></td></tr></table></figure>
<div class="figure" style="text-align: center">
<img data-src="06-raster-vector_files/figure-html/cropmask-1.png" alt="Illustration of raster cropping and raster masking." width="100%" />
<p class="caption">(\#fig:cropmask)Illustration of raster cropping and raster masking.</p>
</div>
<h2 id="栅格提取"><a class="markdownIt-Anchor" href="#栅格提取"></a> 栅格提取</h2>
<p>\index{raster extraction}  栅格提取是识别并返回基于（通常是矢量）地理“选择器”对象在特定位置的“目标”栅格关联的值的过程。结果取决于所使用的选择器的类型（点、线或多边形）以及传递给<code>terra::extract()</code>函数的参数。栅格提取的反向过程 — 基于矢量对象分配栅格单元格值 — 是<em>栅格化</em>，详见 @ref(rasterization) 部分。</p>
<p>\index{raster extraction!points}  基本示例是在特定<strong>点</strong>处提取栅格单元格的值。为此，我们将使用 <code>zion_points</code>，其中包含锡安国家公园内的30个位置样本（见图 @ref(fig:pointextr)）。以下命令从<code>srtm</code>中提取高程值，并创建一个包含点的ID（每个矢量的一行一个值）和每个点的相关<code>srtm</code>值的数据框。现在，我们可以使用<code>cbind()</code>函数将结果对象添加到我们的<code>zion_points</code>数据集中：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">data<span class="punctuation">(</span><span class="string">&quot;zion_points&quot;</span><span class="punctuation">,</span> package <span class="operator">=</span> <span class="string">&quot;spDataLarge&quot;</span><span class="punctuation">)</span></span><br><span class="line">elevation <span class="operator">=</span> terra<span class="operator">::</span>extract<span class="punctuation">(</span>srtm<span class="punctuation">,</span> zion_points<span class="punctuation">)</span></span><br><span class="line">zion_points <span class="operator">=</span> cbind<span class="punctuation">(</span>zion_points<span class="punctuation">,</span> elevation<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<div class="figure" style="text-align: center">
<img data-src="06-raster-vector_files/figure-html/pointextr-1.png" alt="Locations of points used for raster extraction." width="100%" />
<p class="caption">(\#fig:pointextr)Locations of points used for raster extraction.</p>
</div>
<p>\index{raster extraction!lines}  栅格提取也适用于<strong>线</strong>选择器。提取线所接触的每个栅格单元格的一个值。然而，线提取方法不推荐用于沿截面获取值，因为很难获得每一对提取的栅格值之间的正确距离。</p>
<p>在这种情况下，更好的方法是将线分割成许多点，然后为这些点提取值。为了演示这一点，下面的代码创建了 <code>zion_transect</code>，一条从锡安国家公园的西北部到东南部的直线，如图 @ref(fig:lineextr)(A)所示（有关矢量数据模型的回顾，请参见 @ref(vector-data) 部分）：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">zion_transect <span class="operator">=</span> cbind<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="operator">-</span><span class="number">113.2</span><span class="punctuation">,</span> <span class="operator">-</span><span class="number">112.9</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">37.45</span><span class="punctuation">,</span> <span class="number">37.2</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">  st_linestring<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">|&gt;</span> </span><br><span class="line">  st_sfc<span class="punctuation">(</span>crs <span class="operator">=</span> crs<span class="punctuation">(</span>srtm<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">  st_sf<span class="punctuation">(</span>geometry <span class="operator">=</span> _<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>规划徒步旅行时，从线性选择器中提取高度的实用性可见一斑。下面演示的方法提供了路线的“海拔剖面图”（线不需要是直的），这对于估计由于长时间攀爬而需要的时间非常有用。</p>
<p>第一步是为每个截面添加唯一的 <code>id</code>。接下来，我们可以使用 <code>st_segmentize()</code>函数在我们的线（或线）上用提供的密度（<code>dfMaxLength</code>）添加点，并使用 <code>st_cast()</code> 将它们转换为点。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">zion_transect<span class="operator">$</span>id <span class="operator">=</span> <span class="number">1</span><span class="operator">:</span>nrow<span class="punctuation">(</span>zion_transect<span class="punctuation">)</span></span><br><span class="line">zion_transect <span class="operator">=</span> st_segmentize<span class="punctuation">(</span>zion_transect<span class="punctuation">,</span> dfMaxLength <span class="operator">=</span> <span class="number">250</span><span class="punctuation">)</span></span><br><span class="line">zion_transect <span class="operator">=</span> st_cast<span class="punctuation">(</span>zion_transect<span class="punctuation">,</span> <span class="string">&quot;POINT&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>现在，我们有了一大组点，我们想要推导出我们的截面中第一个点与后续各点之间的距离。在这种情况下，我们只有一个截面，但原则上，代码应该适用于任何数量的截面：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">zion_transect <span class="operator">=</span> zion_transect <span class="operator">|&gt;</span> </span><br><span class="line">  group_by<span class="punctuation">(</span>id<span class="punctuation">)</span> <span class="operator">|&gt;</span> </span><br><span class="line">  mutate<span class="punctuation">(</span>dist <span class="operator">=</span> st_distance<span class="punctuation">(</span>geometry<span class="punctuation">)</span><span class="punctuation">[</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">]</span><span class="punctuation">)</span> </span><br></pre></td></tr></table></figure>
<p>最后，我们可以提取截面中每个点的高程值，并将此信息与我们的主要对象结合起来。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">zion_elev <span class="operator">=</span> terra<span class="operator">::</span>extract<span class="punctuation">(</span>srtm<span class="punctuation">,</span> zion_transect<span class="punctuation">)</span></span><br><span class="line">zion_transect <span class="operator">=</span> cbind<span class="punctuation">(</span>zion_transect<span class="punctuation">,</span> zion_elev<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>所得到的<code>zion_transect</code>可以用来创建高程剖面图，如图@ref(fig:lineextr)(B)所示。</p>
<div class="figure" style="text-align: center">
<img data-src="06-raster-vector_files/figure-html/lineextr-1.png" alt="Location of a line used for raster extraction (left) and the elevation along this line (right)." width="100%" />
<p class="caption">(\#fig:lineextr)Location of a line used for raster extraction (left) and the elevation along this line (right).</p>
</div>
<p>\index{raster extraction!polygons}栅格提取的最后一种地理矢量对象是<strong>多边形</strong>。与线条一样，多边形每个多边形倾向于返回许多栅格值。以下命令演示了这一点，其结果是一个数据框，列名为<code>ID</code>（多边形的行号）和<code>srtm</code>（相关的海拔值）：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">zion_srtm_values <span class="operator">=</span> terra<span class="operator">::</span>extract<span class="punctuation">(</span>x <span class="operator">=</span> srtm<span class="punctuation">,</span> y <span class="operator">=</span> zion<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>这样的结果可以用来生成每个多边形的栅格值的汇总统计信息，例如用来描述单个区域或比较多个区域。下面的代码展示了这一点，它创建了对象<code>zion_srtm_df</code>，包含锡安国家公园内的海拔值的汇总统计信息（见图@ref(fig:polyextr)(A)）：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">group_by<span class="punctuation">(</span>zion_srtm_values<span class="punctuation">,</span> ID<span class="punctuation">)</span> <span class="operator">|&gt;</span> </span><br><span class="line">  summarize<span class="punctuation">(</span>across<span class="punctuation">(</span>srtm<span class="punctuation">,</span> <span class="built_in">list</span><span class="punctuation">(</span><span class="built_in">min</span> <span class="operator">=</span> <span class="built_in">min</span><span class="punctuation">,</span> mean <span class="operator">=</span> mean<span class="punctuation">,</span> <span class="built_in">max</span> <span class="operator">=</span> <span class="built_in">max</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; # A tibble: 1 × 4</span></span><br><span class="line"><span class="comment">#&gt;      ID srtm_min srtm_mean srtm_max</span></span><br><span class="line"><span class="comment">#&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;</span></span><br><span class="line"><span class="comment">#&gt; 1     1     1122     1818.     2661</span></span><br></pre></td></tr></table></figure>
<p>前述代码段使用了 <strong>dplyr</strong>\index{dplyr (package)} 来提供每个多边形ID的单元格值的汇总统计信息，如第@ref(attr)章所述。结果提供了有用的总结，例如公园内的最大高度约为海拔2661米（也可以用这种方式计算其他汇总统计信息，如标准差）。因为示例中只有一个多边形，所以返回了一个单行的数据框；然而，当使用多个选择多边形时，该方法同样适用。</p>
<p>相似的方法适用于在多边形内计数分类栅格值的出现次数。这通过一个土地覆盖数据集（<code>nlcd</code>）在图 @ref(fig:polyextr)(B) 中进行说明，并在下面的代码中演示：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">nlcd <span class="operator">=</span> rast<span class="punctuation">(</span>system.file<span class="punctuation">(</span><span class="string">&quot;raster/nlcd.tif&quot;</span><span class="punctuation">,</span> package <span class="operator">=</span> <span class="string">&quot;spDataLarge&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">zion2 <span class="operator">=</span> st_transform<span class="punctuation">(</span>zion<span class="punctuation">,</span> st_crs<span class="punctuation">(</span>nlcd<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">zion_nlcd <span class="operator">=</span> terra<span class="operator">::</span>extract<span class="punctuation">(</span>nlcd<span class="punctuation">,</span> zion2<span class="punctuation">)</span></span><br><span class="line">zion_nlcd <span class="operator">|&gt;</span> </span><br><span class="line">  group_by<span class="punctuation">(</span>ID<span class="punctuation">,</span> levels<span class="punctuation">)</span> <span class="operator">|&gt;</span></span><br><span class="line">  count<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; # A tibble: 7 × 3</span></span><br><span class="line"><span class="comment">#&gt; # Groups:   ID, levels [7]</span></span><br><span class="line"><span class="comment">#&gt;      ID levels         n</span></span><br><span class="line"><span class="comment">#&gt;   &lt;dbl&gt; &lt;fct&gt;      &lt;int&gt;</span></span><br><span class="line"><span class="comment">#&gt; 1     1 Developed   4205</span></span><br><span class="line"><span class="comment">#&gt; 2     1 Barren     98285</span></span><br><span class="line"><span class="comment">#&gt; 3     1 Forest    298299</span></span><br><span class="line"><span class="comment">#&gt; 4     1 Shrubland 203701</span></span><br><span class="line"><span class="comment">#&gt; # ℹ 3 more rows</span></span><br></pre></td></tr></table></figure>
<div class="figure" style="text-align: center">
<img data-src="06-raster-vector_files/figure-html/polyextr-1.png" alt="Area used for continuous (left) and categorical (right) raster extraction." width="100%" />
<p class="caption">(\#fig:polyextr)Area used for continuous (left) and categorical (right) raster extraction.</p>
</div>
<p>\index{raster extraction!exact fractions} 尽管 <strong>terra</strong> 包提供了在多边形内快速提取栅格值的功能，<code>extract()</code>在处理大型多边形数据集时仍可能成为瓶颈。<strong>exactextractr</strong>包通过<code>exact_extract()</code>函数提供了一个<a href="https://github.com/geocompx/geocompr/issues/813">明显更快的替代方案</a>用于提取像素值。<code>exact_extract()</code>函数还默认计算了每个栅格单元被多边形重叠的部分，这更为精确（有关详细信息，请参见下面的注释）。</p>
<p>\BeginKnitrBlock{rmdnote}<div class="rmdnote">多边形通常具有不规则的形状，因此，多边形可能只与栅格的某些部分重叠。<br />
为了获得更详细的结果，<code>terra::extract()</code> 函数有一个叫做 <code>exact</code> 的参数。<br />
通过设置 <code>exact = TRUE</code>，我们在输出的数据框中多得到一列<code>fraction</code>，代表每个单元格被多边形覆盖的部分。<br />
这可以用于计算例如连续栅格的加权平均值或者分类栅格的更精确覆盖率。<br />
默认情况下，它的值为 <code>FALSE</code>，因为这个操作需要更多的计算。<br />
<code>exactextractr::exact_extract()</code> 函数始终计算多边形在每个单元格中的覆盖部分。</div>\EndKnitrBlock{rmdnote}</p>
<h2 id="栅格化"><a class="markdownIt-Anchor" href="#栅格化"></a> 栅格化</h2>
]]></content>
      <categories>
        <category>R</category>
        <category>Geocomputaion</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>Geocomputaion</tag>
      </tags>
  </entry>
  <entry>
    <title>产水量计算</title>
    <url>/2020/10/20/2023-8-20-%E4%BA%A7%E6%B0%B4%E9%87%8F%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<h1 id="产水量模型"><a class="markdownIt-Anchor" href="#产水量模型"></a> 产水量模型</h1>
<p>InVEST模型的产水量：水库水电生产模块，不仅评估了景观中各次一级流域对产水的相对贡献量，而且有助于研究土地利用格局变化如何影响年地表产水量和水电生产。</p>
<p>模拟景观格局变化和水文过程的关系是个科学难题。用来模拟这些关系及其相关 过程的复杂模型（如WEAP水资源评估和规划系统模型）要求较高的数据和资源资料，并且要求大量专业知识。为满足更多学科背景需求，使用易获取的数据，InVEST模型绘制和模拟用于景观水电生产的年平均产水量，而不是直接评估土地利用/覆被变化导致的水电减产，因为这一过程在逐日和逐月的时间尺度上主要由流入水量变化决定。 因此，InVEST模型计算了景观中各子流域对产水的相对贡献量及其对应的水电产量。 水库经济使用年限内的水电生产净现值也可以通过年收益还原法计算。</p>
<span id="more"></span>
<h1 id="工作原理"><a class="markdownIt-Anchor" href="#工作原理"></a> <em>工作原理</em></h1>
<p>模型运行基于栅格地图。模型估算了研究区各次一级流域对水电生产贡献水量及其经济价值。模块包括三个组件，按顺序运行。</p>
<ol>
<li>模型估算了每栅格单元降水量减去实际蒸散发后的水量即水源供给量。 模型不做地表水、地下水、基流的区分，而是假设每个栅格单元的产水通过上述途径汇集到信息点。然后，模型计算出次一级流域产水量的总量和平均值。栅格计算有助于确定决定流域产汇流空间异质性的关键因素，如土壤类型，降水量，植被类型等。 但是，这组模型的基础理论基于次一级流域到流域尺度，对次一级流域过程的模型解释是可信的，因此产水量的总量和/或平均值结果也应当维持在次一级流域水平上。模型仅为校准和模型检验提供输出结果的栅格数据。这些栅格数据图件不能用于水文过程的解释说明，或作为任何类型的决策信息源。</li>
<li>模型计算了用于水电生产的水源供给量，即将水源供给总量减去除水电生产以外的其他用水量。</li>
<li>模型计算了到达水库水流的发电量及其水库有效使用年期内的经济价值。</li>
</ol>
<p><em><strong>NOTE</strong></em>: Water Yield 模块运行的前提条件是假设栅格单元的产水量都是通过地表径流或 者地下径流的方式汇集到流域出口，在这个前提条件下计算每个栅格单元的产水量, 即降水量减去植被蒸腾与地表蒸散。</p>
<p><em><strong>产水量评估模型</strong></em></p>
<p>产水量评估模块基于Budyko水热耦合平衡假设（1974）和年平均降水量数据。首先，确定研究区每个栅格单元<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>的年产水量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Y(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>，公式如下：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>Y</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mrow><mo fence="true">(</mo><mn>1</mn><mo>−</mo><mfrac><mrow><mi>A</mi><mi>E</mi><mi>T</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mfrac><mo fence="true">)</mo></mrow><mo>⋅</mo><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Y(x)=\left(1-\frac{A E T(x)}{P(x)}\right) \cdot P(x)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>E</mi><mi>T</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">AET(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>表示栅格单元<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>的年实际蒸散量、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>表示栅格单元<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>的年降水量。</p>
<p>水量平衡公式中，土地利用/覆被类型的植被蒸散发<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>A</mi><mi>E</mi><mi>T</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{A E T(x)}{P(x)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.53em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">x</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">A</span><span class="mord mathnormal mtight" style="margin-right:0.05764em;">E</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">x</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>计算，采用Fu和Zhang等提出的Budyko水热耦合平衡假设公式：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mfrac><mrow><mi>A</mi><mi>E</mi><mi>T</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mfrac><mo>=</mo><mn>1</mn><mo>+</mo><mfrac><mrow><mi>P</mi><mi>E</mi><mi>T</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mfrac><mo>−</mo><msup><mrow><mo fence="true">[</mo><mn>1</mn><mo>+</mo><msup><mrow><mo fence="true">(</mo><mfrac><mrow><mi>P</mi><mi>E</mi><mi>T</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mfrac><mo fence="true">)</mo></mrow><mi>ω</mi></msup><mo fence="true">]</mo></mrow><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mi>ω</mi></mrow></msup></mrow><annotation encoding="application/x-tex">\frac{A E T(x)}{P(x)}=1+\frac{P E T(x)}{P(x)}-\left[1+\left(\frac{P E T(x)}{P(x)}\right)^{\omega}\right]^{1 / \omega}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.363em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.363em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.732222em;vertical-align:-0.95003em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.504292em;"><span style="top:-3.9029000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">ω</span></span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.782192em;"><span style="top:-3.957192em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">/</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">ω</span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mi>E</mi><mi>T</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">PET(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span><strong>表示潜在蒸散量</strong>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ω</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">ω(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>表示自然气候-土壤性质的非物理参数。<br />
潜在蒸散量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mi>E</mi><mi>T</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">PET(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>定义为：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mrow><mi>P</mi><mi>E</mi><mi>T</mi></mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>K</mi><mi>c</mi></msub><mrow><mo fence="true">(</mo><msub><mi mathvariant="normal">ℓ</mi><mi>x</mi></msub><mo fence="true">)</mo></mrow><mo>⋅</mo><mi>E</mi><msub><mi>T</mi><mn>0</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{PET}(x)=K_{c}\left(\ell_{x}\right) \cdot E T_{0}(x)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord">ℓ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span></span></p>
<p>式中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><msub><mi>T</mi><mn>0</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">ET_0(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>表示栅格单元<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>的参考作物蒸散，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>c</mi></msub><mo stretchy="false">(</mo><msub><mi mathvariant="normal">ℓ</mi><mi>x</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">K_c(\ell_x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord">ℓ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>表示栅格单元<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>中特定土地利用/覆被类型的植物（植被）蒸散系数。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><msub><mi>T</mi><mn>0</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">ET_0(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>通过参考作物蒸散量反映当地气候条件，例如苜蓿的蒸散量反映其草地生境气候。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>c</mi></msub><mo stretchy="false">(</mo><msub><mi mathvariant="normal">ℓ</mi><mi>x</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">K_c(\ell_x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord">ℓ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>很大程度上取决于栅格单元<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>中土地利用/覆被的植被性质。在土地利用/覆被图中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>c</mi></msub></mrow><annotation encoding="application/x-tex">K_c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>用于将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><msub><mi>T</mi><mn>0</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">ET_0(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>修正为栅格单元中特定作物或植被类型蒸散量。</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ω</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">ω(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>是一个经验参数，通常用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>A</mi><mi>W</mi><mi>C</mi><mo>×</mo><mi>N</mi></mrow><mi>P</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{A W C \times N}{P}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.217331em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">A</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">W</span><span class="mord mathnormal mtight" style="margin-right:0.07153em;">C</span><span class="mbin mtight">×</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>线性函数表示，式中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>表示每年的降水事件数，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>W</mi><mi>C</mi></mrow><annotation encoding="application/x-tex">AWC</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span>表示植物可利用水含量。虽然基于全球数据的$ ω(x)  $公式亟待进一步研究， InVEST模型采用Donohue等人提出的公式表达，定义为：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow></mrow><annotation encoding="application/x-tex"></annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span></span></p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>W</mi><mi>C</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">AWC(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>表示土壤有效含水量（mm），由土壤质地和土壤有效深度决定，用来确定土壤为植物生长储存和提供的总水量。由植物利用水分含量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>P</mi><mi>A</mi><mi>W</mi><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(PAWC)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mclose">)</span></span></span></span>， 以及土壤的最大根系埋藏深度和植物根系深度的最小值决定：</li>
</ul>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>A</mi><mi>W</mi><mi>C</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">Min</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>R</mi><mi>e</mi><mi>s</mi><mi>t</mi><mi mathvariant="normal">.</mi><mi>l</mi><mi>a</mi><mi>y</mi><mi>e</mi><mi>r</mi><mi mathvariant="normal">.</mi><mi>d</mi><mi>e</mi><mi>p</mi><mi>t</mi><mi>h</mi><mo separator="true">,</mo><mi>r</mi><mi>o</mi><mi>o</mi><mi>t</mi><mi mathvariant="normal">.</mi><mi>d</mi><mi>e</mi><mi>p</mi><mi>t</mi><mi>h</mi><mo stretchy="false">)</mo><mo>⋅</mo><mi>P</mi><mi>A</mi><mi>W</mi><mi>C</mi></mrow><annotation encoding="application/x-tex">A W C(x)=\operatorname{Min}( Re st.layer.depth, root.depth ) \cdot PAWC
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mord mathrm">M</span><span class="mord mathrm">i</span><span class="mord mathrm">n</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord">.</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord mathnormal">p</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">o</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mord">.</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord mathnormal">p</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span></span></p>
<p>土壤的最大根系埋藏深度是指由于环境的物理和化学特征不同，植物根系在土壤中能够延伸的最大深度（也叫土壤深度）。植物根系深度通常指特定植物类型的根系生物量为95%的土层深度。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mi>A</mi><mi>W</mi><mi>C</mi></mrow><annotation encoding="application/x-tex">PAWC</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span>表示植物利用水分含量，即田间持水量和萎蔫点之间的差值。</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Z</mi></mrow><annotation encoding="application/x-tex">Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span></span></span></span>为经验常数，又称<code>季节常数</code>，能够代表区域降水分布及其他水文地质特征。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Z</mi></mrow><annotation encoding="application/x-tex">Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span></span></span></span>与<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>正相关，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>是每年降水发生次数。1.25为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ω</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">ω(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>基数，即裸地（根系深度为0）的植被年需水量和年降水量比值。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ω</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">ω(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>上限为5。</li>
</ul>
<p>其他土地利用/覆被类型（开放水域，城市，湿地）的实际蒸散发通过参考作物蒸散<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><msub><mi>T</mi><mn>0</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">ET_0(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>直接计算，由降水量决定其最大值：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>A</mi><mi>E</mi><mi>T</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">Min</mi><mo>⁡</mo><mrow><mo fence="true">(</mo><msub><mi>K</mi><mi>c</mi></msub><mrow><mo fence="true">(</mo><msub><mi mathvariant="normal">ℓ</mi><mi>x</mi></msub><mo fence="true">)</mo></mrow><mo>⋅</mo><mi>E</mi><msub><mi>T</mi><mn>0</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">A E T(x)=\operatorname{Min}\left(K_{c}\left(\ell_{x}\right) \cdot E T_{0}(x), P(x)\right)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mord mathrm">M</span><span class="mord mathrm">i</span><span class="mord mathrm">n</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord">ℓ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><msub><mi>T</mi><mn>0</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">ET_0(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>表示参考作物蒸散，而<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>c</mi></msub><mo stretchy="false">(</mo><msub><mi mathvariant="normal">ℓ</mi><mi>x</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">K_c(\ell_x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord">ℓ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>表示特定土地利用/覆被类型蒸腾作用的影响因子。</p>
<h1 id="数据需求"><a class="markdownIt-Anchor" href="#数据需求"></a> <em><strong>数据需求</strong></em></h1>
<p>模型使用的数据需求列表如下，关于数据来源和预处理的详细信息见附录。所有数据输入前，应先定义栅格数据投影，栅格单位为米（m）。</p>
<h2 id="土壤的最大根系埋藏深度必需"><a class="markdownIt-Anchor" href="#土壤的最大根系埋藏深度必需"></a> 土壤的最大根系埋藏深度（必需）：</h2>
<p>每个栅格对应一个土壤的最大根系埋藏深度平均值的GIS栅格数据集。土壤的最大根系埋藏深度是指由于环境的物理和化学特征不同，植物根系在土壤中能够延伸的最大深度，单位毫米（mm）。根系限制层深度可从一些土壤图中获得。如果无法获得根系限制层深度或按土壤类型划分的可扎根深度，可使用土壤深度作为替代。如果有几个土壤层是详细的，那么限制根系层的深度就是非限制性土壤层的深度之和。</p>
<p>*命名：*用户自定义，但若为ESRI GRID格式，文件名不能有空格并且少于13个字， 若为TIF或IMG格式，命名可能更长。</p>
<p><em>格式：</em> GIS标准栅格文件（如：ESRI GRID，TIF或IMG），每个栅格对应一个土壤的最大根系埋藏深度平均值，单位毫米（mm）。</p>
<p><em>数据获得：</em></p>
<ol>
<li><a href="http://globalchange.bnu.edu.cn/research/cdtb.jsp" title="http://globalchange.bnu.edu.cn/research/cdtb.jsp">http://globalchange.bnu.edu.cn/research/cdtb.jsp</a> （单位为m，需转化为mm，已下载处理，上传百度☁️）<br />
原文 <a href="https://doi.org/10.1038/s41597-019-0345-6" title="https://doi.org/10.1038/s41597-019-0345-6">https://doi.org/10.1038/s41597-019-0345-6</a></li>
<li>SoilGrids250m 2017-03 - Depth to bedrock (R horizon)  （单位为cm，需转化为mm）<a href="https://data.isric.org/geonetwork/srv/eng/catalog.search#/metadata/bfb01655-db81-4571-b6eb-3caae86c037a" title="https://data.isric.org/geonetwork/srv/eng/catalog.search#/metadata/bfb01655-db81-4571-b6eb-3caae86c037a">https://data.isric.org/geonetwork/srv/eng/catalog.search#/metadata/bfb01655-db81-4571-b6eb-3caae86c037a</a></li>
</ol>
<h2 id="年降水量必需"><a class="markdownIt-Anchor" href="#年降水量必需"></a> 年降水量（必需）：</h2>
<p>每个栅格对应一个非空值的<strong>年平均降水量</strong>的GIS栅格数据集，单位毫米（mm）。</p>
<p><em>命名</em>：用户自定义，但若为ESRI GRID格式，文件名不能有空格并且少于13个字， 若为TIF或IMG格式，命名可能更长。</p>
<p><em>格式</em>：GIS标准栅格文件（如：ESRI GRID，TIF或IMG），每个栅格对应一个年平 均降水量。</p>
<p><em>数据获得</em>：</p>
<ol>
<li>利用<a href="https://www.wolai.com/pLvSQy6dLBrwJX9ATDTiy4" title="日值（v3）数据">日值（v3）数据</a>进行差值。</li>
<li>国家地球系统科学数据中心：中国1km分辨率年降水量数据（2001-2020年）已下载直接使用，单位为0.1mm  <a href="http://www.geodata.cn/data/datadetails.html?dataguid=113786088533256&amp;docid=3549" title="http://www.geodata.cn/data/datadetails.html?dataguid=113786088533256&amp;docid=3549">http://www.geodata.cn/data/datadetails.html?dataguid=113786088533256&amp;docid=3549</a></li>
<li>WorldClim (v 2.1) 数据范围：1970-2000，月值，最大精度：30s ，单位:mm <a href="https://www.worldclim.org/data/worldclim21.html" title="https://www.worldclim.org/data/worldclim21.html">https://www.worldclim.org/data/worldclim21.html</a></li>
<li>GEE （“UCSB-CHG/CHIRPS/DAILY”)数据集，完整教程见<a href="https://www.wolai.com/mQ6iivaJ3BAPg21kq2uXsE" title="编程分享-利用GEE得到研究区年、月、日降水量数据">编程分享-利用GEE得到研究区年、月、日降水量数据</a></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="variable constant_">ROI</span> = ee.<span class="title class_">FeatureCollection</span>(<span class="string">&quot;users/rice20220411/AH&quot;</span>);</span><br><span class="line"><span class="title class_">Map</span>.<span class="title function_">addLayer</span>(<span class="variable constant_">ROI</span>,&#123;&#125;,<span class="string">&#x27;ROI&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">2015</span>;i&lt;=<span class="number">2021</span>;i++)&#123;</span><br><span class="line"><span class="keyword">var</span> CHIRPS_Daily = ee.<span class="title class_">ImageCollection</span>(<span class="string">&quot;UCSB-CHG/CHIRPS/DAILY&quot;</span>)</span><br><span class="line">.<span class="title function_">filterDate</span>(i+<span class="string">&#x27;-01-01&#x27;</span>, i+<span class="string">&#x27;-12-31&#x27;</span>)</span><br><span class="line"> .<span class="title function_">select</span>(<span class="string">&#x27;precipitation&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> CHIRPS_Year_mean = CHIRPS_Daily.<span class="title function_">mean</span>().<span class="title function_">clip</span>(<span class="variable constant_">ROI</span>)</span><br><span class="line"><span class="keyword">var</span> precipitationVis = &#123;</span><br><span class="line">  <span class="attr">min</span>: <span class="number">1.0</span>,</span><br><span class="line">  <span class="attr">max</span>: <span class="number">17.0</span>,</span><br><span class="line">  <span class="attr">palette</span>: [<span class="string">&#x27;001137&#x27;</span>, <span class="string">&#x27;0aab1e&#x27;</span>, <span class="string">&#x27;e7eb05&#x27;</span>, <span class="string">&#x27;ff4a2d&#x27;</span>, <span class="string">&#x27;e90000&#x27;</span>],</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">print</span>(CHIRPS_Year_mean)</span><br><span class="line"><span class="title class_">Map</span>.<span class="title function_">addLayer</span>(CHIRPS_Year_mean, precipitationVis, i+<span class="string">&#x27;_CHIRPS_Year_mean&#x27;</span>);</span><br><span class="line"><span class="comment">// Map.addLayer(CHIRPS_Daily.first().clip(ROI), precipitationVis, &#x27;CHIRPS_Year_mean_first&#x27;);</span></span><br><span class="line"><span class="title class_">Export</span>.<span class="property">image</span>.<span class="title function_">toDrive</span>(&#123;</span><br><span class="line">      <span class="attr">image</span>: CHIRPS_Year_mean,</span><br><span class="line">      <span class="attr">description</span>: i+<span class="string">&#x27;year_mean&#x27;</span>,</span><br><span class="line">      <span class="attr">region</span>: <span class="variable constant_">ROI</span>,</span><br><span class="line">      <span class="attr">maxPixels</span>: <span class="number">1e13</span>,</span><br><span class="line">      <span class="attr">folder</span>: <span class="string">&#x27;CHIRPS&#x27;</span></span><br><span class="line">    &#125;) </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="植物可利用水量必需"><a class="markdownIt-Anchor" href="#植物可利用水量必需"></a> 植物可利用水量（必需）：</h2>
<p>每个栅格对应一个植物可利用水的GIS栅格数据集。 植物可利用水（PAWC）是指土壤土层中为植物生长提供的水量所占比例。PAWC是[0,1]的小数。</p>
<p><em>命名</em>：用户自定义，但若为ESRI GRID格式，文件名不能有空格并且少于13个字， 若为TIF或IMG格式，命名可能更长。 </p>
<p><em>格式</em>：GIS标准栅格文件（如：ESRI GRID，TIF或IMG），每个栅格对应一个植物可利用水含量百分比。</p>
<p><em>数据获得</em>：（下载好处理好后传百度☁️）</p>
<p>SoilGrids250m 2017-03 - “Derived available soil water capacity (volumetric fraction) until wilting point” (<a href="https://data.isric.org/geonetwork/srv/eng/catalog.search#/metadata/e33e75c0-d9ab-46b5-a915-cb344345099c" title="https://data.isric.org/geonetwork/srv/eng/catalog.search#/metadata/e33e75c0-d9ab-46b5-a915-cb344345099c">https://data.isric.org/geonetwork/srv/eng/catalog.search#/metadata/e33e75c0-d9ab-46b5-a915-cb344345099c</a>)  SoilGrids 2.0版目前不提供AWC。SoilGrids 2017提供7个土壤深度区间的AWC层。所有7个深度区间都需要下载，然后合并成一个单一的图层，以便在模型中使用。</p>
<p>栅格值以整数百分比的形式给出（如25，表示AWC值为25%）。<br />
（标准）深度区间的平均值，如0-5厘米或0-30厘米，可以通过使用数字积分，如梯形规则，对深度区间内的预测值进行加权平均来得出：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mrow><mo fence="true">(</mo><mfrac><mn>1</mn><mrow><mo stretchy="false">(</mo><mi>b</mi><mo>−</mo><mi>a</mi><mo stretchy="false">)</mo></mrow></mfrac><mo fence="true">)</mo></mrow><mrow><mo fence="true">(</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo fence="true">)</mo></mrow><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow></munderover><mrow><mo fence="true">(</mo><msub><mi>x</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>−</mo><msub><mi>x</mi><mi>k</mi></msub><mo fence="true">)</mo></mrow><mrow><mo fence="true">(</mo><mi>f</mi><mrow><mo fence="true">(</mo><msub><mi>x</mi><mi>k</mi></msub><mo fence="true">)</mo></mrow><mo>+</mo><mi>f</mi><mrow><mo fence="true">(</mo><msub><mi>x</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo fence="true">)</mo></mrow><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\left(\frac{1}{(b-a)}\right)\left(\frac{1}{2}\right) \sum_{k=1}^{N-1}\left(x_{k+1}-x_{k}\right)\left(f\left(x_{k}\right)+f\left(x_{k+1}\right)\right)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.1304490000000005em;vertical-align:-1.302113em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal">a</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283360000000002em;"><span style="top:-1.8478869999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.300005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.302113em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span></span></p>
<p>其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>是深度数，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">x_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>个深度，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>k</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x_k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>是目标变量（即土壤属性）在深度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">x_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的值。</p>
<p>操作步骤：</p>
<ol>
<li>从ISRIC网站上下载所有可用的深度区间。深度区间为0cm-200cm。注意，每个栅格的大小为1.5GB。</li>
<li>使用 GIS 缓冲区工具，在你要建模的流域/感兴趣的区域周围创建一个缓冲区。由于SoilGrids数据的分辨率为250米，因此缓冲区的宽度为250或500米。这样做是为了确保土壤数据完全覆盖你正在建模的流域，边界周围没有漏洞。</li>
<li>使用缓冲流域，将所有原始的ISRIC AWC 栅格数据剪辑到你感兴趣的区域。在ArcGIS中，这可以通过空间分析工具<code>掩模提取</code>来完成。在这个例子中，我们将把剪下的图层称为AWC_sl1_clip.tif、AWC_sl2_clip.tif … AWC_sl7_clip.tif。</li>
<li>使用GIS栅格计算器工具来计算合并后的AWC层。将其代入上面的方程，我们可以得到：<p class='katex-block katex-error' title='ParseError: KaTeX parse error: Undefined control sequence: \* at position 13: (1/(200-0)) \̲*̲ (1/2) \* ( ((5…'>(1/(200-0)) \* (1/2) \* ( ((5-0) \* (AWC\_sl1\_clip.tif + AWC\_sl2\_clip.tif)) + ((15-5) \* (AWC\_sl2\_clip.tif + AWC\_sl3\_clip.tif)) + ((30-15) \* (AWC\_sl3\_clip.tif + AWC\_sl4\_clip.tif)) + ((60-30) \* (AWC\_sl4\_clip.tif + AWC\_sl5\_clip.tif)) + ((100-60) \* (AWC\_sl5\_clip.tif + AWC\_sl6\_clip.tif)) + ((200-100) \* ( AWC\_sl6\_clip.tif + AWC\_sl7\_clip.tif)) )
</p>
将此公式输入光栅计算器，根据需要调整文件名。</li>
<li>得到的栅格应该包含0-100范围内的数值，代表整数百分比。该模型<strong>要求AWC以分数</strong>的形式给出，因此将步骤4中计算的<strong>栅格除以100</strong>。</li>
<li>重新投影AWC分数层，使其具有与其他模型输入相同的投影坐标系统。这个栅格现在可以用作模型的可用水含量输入。</li>
</ol>
<h2 id="年平均潜在蒸散发必需"><a class="markdownIt-Anchor" href="#年平均潜在蒸散发必需"></a> 年平均潜在蒸散发（必需）：</h2>
<p> 每个栅格对应一个<strong>年平均潜在蒸散发</strong>的GIS栅格数据集。潜在蒸散发是指水分充足的情况下，通过土壤蒸发和植物（如苜蓿或其他草类等健康植被）蒸散作用可能散逸的水量，单位毫米（mm）。</p>
<p><em>命名</em>：用户自定义，但若为ESRI GRID格式，文件名不能有空格并且少于13个字，若为TIF或IMG格式，命名可能更长。 </p>
<p><em>格式</em>：GIS标准栅格文件（如：ESRI GRID，TIF或IMG），每个栅格对应一个年平均潜在蒸散发。</p>
<p><em>数据获得</em>：</p>
<ul>
<li>FA0工具计算，详见<a href="https://www.wolai.com/sWbxWLVBydbK2t5aT584Fa" title="使用EToCalculator 计算潜在蒸散发详细教程">使用EToCalculator 计算潜在蒸散发详细教程</a><a href="https://blog.sciencenet.cn/blog-3459054-1308734.html" title="https://blog.sciencenet.cn/blog-3459054-1308734.html">https://blog.sciencenet.cn/blog-3459054-1308734.html</a></li>
<li>Global Aridity Index and Potential Evapotranspiration (ET0) Climate Database v2 (Penman Monteith Evapotranspiration equation，30弧秒，1970-2000，暂时未使用，有待验证。) <a href="https://figshare.com/articles/dataset/Global_Aridity_Index_and_Potential_Evapotranspiration_ET0_Climate_Database_v2/7504448/3" title="https://figshare.com/articles/dataset/Global_Aridity_Index_and_Potential_Evapotranspiration_ET0_Climate_Database_v2/7504448/3">https://figshare.com/articles/dataset/Global_Aridity_Index_and_Potential_Evapotranspiration_ET0_Climate_Database_v2/7504448/3</a></li>
<li>大部分研究采用，Modified-Hargreaves 法对潜在蒸散量进行计算。<br />
式中：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><msub><mi>T</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">ET_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>代表栅格单元上的潜在蒸散量（mm）；<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>A</mi></mrow><annotation encoding="application/x-tex">RA</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">A</span></span></span></span>为太阳大气顶层辐射 （<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>J</mi><mo separator="true">⋅</mo><msup><mi>m</mi><mrow><mo>−</mo><mn>2</mn></mrow></msup><mo separator="true">⋅</mo><msup><mi>d</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">MJ·m^{-2}·d^{-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal" style="margin-right:0.09618em;">J</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>）；<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>a</mi></msub></mrow><annotation encoding="application/x-tex">T_a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为不同小流域的日最高温均值和日最低温均值的平均值（°C）； <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>d</mi></msub></mrow><annotation encoding="application/x-tex">T_d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为小流域上的日最高温均值和日最低温均值的差值（°C）；<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span>为小流域的降雨量 （mm）。</li>
</ul>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>E</mi><msub><mi>T</mi><mn>0</mn></msub><mo>=</mo><mn>0.0013</mn><mo>×</mo><mn>0.408</mn><mo>×</mo><mi>R</mi><mi>A</mi><mo>×</mo><mrow><mo fence="true">(</mo><msub><mi>T</mi><mi mathvariant="normal">a</mi></msub><mo>+</mo><mn>17</mn><mo fence="true">)</mo></mrow><mo>×</mo><msup><mrow><mo fence="true">(</mo><msub><mi>T</mi><mi mathvariant="normal">d</mi></msub><mo>−</mo><mn>0.0123</mn><mi>P</mi><mo fence="true">)</mo></mrow><mn>0.76</mn></msup></mrow><annotation encoding="application/x-tex">ET_{0}=0.0013 \times 0.408 \times R A \times\left(T_{\mathrm{a}}+17\right) \times\left(T_{\mathrm{d}}-0.0123 P\right)^{0.76}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">0</span><span class="mord">0</span><span class="mord">1</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">4</span><span class="mord">0</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathrm mtight">a</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mord">7</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.204008em;vertical-align:-0.25em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathrm mtight">d</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">0</span><span class="mord">1</span><span class="mord">2</span><span class="mord">3</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.954008em;"><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span><span class="mord mtight">.</span><span class="mord mtight">7</span><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<ul>
<li>GEE获取 (Penman-Monteith法)（代码传GEE和GitHub） 已经下载全国区域的2000-2020年数据压缩上传百度云     </li>
</ul>
<p> 原文链接 <a href="https://doi.org/10.1016/j.rse.2018.12.031" title="https://doi.org/10.1016/j.rse.2018.12.031">https://doi.org/10.1016/j.rse.2018.12.031</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//完美运行，输入坐标即可，获取每年的平均值。</span></span><br><span class="line"><span class="comment">//加入矢量边界之后直接运行var </span></span><br><span class="line"><span class="keyword">var</span> <span class="variable constant_">ROI</span> = table.<span class="title function_">geometry</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Map.addLayer(ROI,&#123;&#125;,&#x27;ROI&#x27;);</span></span><br><span class="line"><span class="keyword">var</span> imgcol_PMLV2_v016_8d = ee.<span class="title class_">ImageCollection</span>(<span class="string">&#x27;projects/pml_evapotranspiration/PML/OUTPUT/PML_V2_8day_v016&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> imgcol_PMLV2_v016_8d = ee.<span class="title class_">ImageCollection</span>(imgcol_PMLV2_v016_8d.<span class="title function_">toList</span>(<span class="number">2000</span>));</span><br><span class="line"><span class="title function_">print</span>(imgcol_PMLV2_v016_8d);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pkg_export = <span class="built_in">require</span>(<span class="string">&#x27;users/kongdd/pkgs:pkg_export.js&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;drive&quot;</span>,</span><br><span class="line">    <span class="attr">range</span>: [<span class="number">110</span>,<span class="number">34</span>,<span class="number">114</span>,<span class="number">40</span>],<span class="comment">//ROI, // [73, 25, 105, 40], </span></span><br><span class="line">    <span class="attr">cellsize</span>: <span class="number">1</span>/<span class="number">240</span>,</span><br><span class="line">    <span class="comment">// crsTransform : [463.312716528, 0, -20015109.354, 0, -463.312716527, 10007554.677], // prj.crsTransform;</span></span><br><span class="line">    <span class="comment">// scale        : 463.3127165275, // prj.scale</span></span><br><span class="line">    <span class="attr">crs</span>: <span class="string">&#x27;EPSG:4326&#x27;</span>, <span class="comment">// &#x27;SR-ORG:6974&#x27;, // EPSG:4326</span></span><br><span class="line">    <span class="attr">folder</span>: <span class="string">&#x27;ET0&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> imgcol_years = <span class="title function_">aggregateToYearly</span>(imgcol_PMLV2_v016_8d, <span class="number">2010</span>, <span class="number">2019</span>, <span class="number">0.01</span>);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">aggregateToYearly</span>(<span class="params">imgcol, year_begin, year_end, scale_factor</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> bands = [<span class="string">&#x27;ET_pot&#x27;</span>]; <span class="comment">//,&#x27;qc&#x27;</span></span><br><span class="line">    <span class="keyword">var</span> years = ee.<span class="property">List</span>.<span class="title function_">sequence</span>(year_begin, year_end);</span><br><span class="line">    <span class="keyword">var</span> imgcol_years = years.<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params">year</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> date_begin = ee.<span class="property">Date</span>.<span class="title function_">fromYMD</span>(year,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">var</span> date_end   = ee.<span class="property">Date</span>.<span class="title function_">fromYMD</span>(year,<span class="number">12</span>,<span class="number">31</span>);</span><br><span class="line">        <span class="keyword">var</span> ydays = date_begin.<span class="title function_">advance</span>(<span class="number">1</span>, <span class="string">&#x27;year&#x27;</span>).<span class="title function_">difference</span>(date_begin, <span class="string">&#x27;day&#x27;</span>);</span><br><span class="line">        <span class="keyword">var</span> imgcol_year = imgcol.<span class="title function_">filterDate</span>(date_begin, date_end);</span><br><span class="line">        <span class="keyword">var</span> scale = ydays.<span class="title function_">multiply</span>(scale_factor);</span><br><span class="line">        <span class="keyword">return</span> imgcol_year.<span class="title function_">select</span>(bands)</span><br><span class="line">            <span class="comment">//.multiply(scale_factor).</span></span><br><span class="line">            .<span class="title function_">mean</span>()</span><br><span class="line">            .<span class="title function_">multiply</span>(scale)</span><br><span class="line">            .<span class="title function_">toFloat</span>()</span><br><span class="line">            .<span class="title function_">set</span>(<span class="string">&#x27;system:time_start&#x27;</span>, date_begin.<span class="title function_">millis</span>())</span><br><span class="line">            .<span class="title function_">set</span>(<span class="string">&#x27;system:id&#x27;</span>, date_begin.<span class="title function_">format</span>());</span><br><span class="line">    &#125;);</span><br><span class="line">    imgcol_years = ee.<span class="title class_">ImageCollection</span>(imgcol_years);</span><br><span class="line">    <span class="comment">// pkg_export.ExportImg(img_year, task, range, cellsize, type, folder_yearly, crs, crsTransform);</span></span><br><span class="line">    <span class="keyword">return</span> imgcol_years;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> imgcol_years = imgcol_years.<span class="title function_">filterBounds</span>(<span class="variable constant_">ROI</span>);</span><br><span class="line"><span class="title function_">print</span>(imgcol_years);</span><br><span class="line"><span class="comment">//var batch = require(&#x27;users/fitoprincipe/geetools:batch&#x27;);</span></span><br><span class="line"><span class="comment">//batch.Download.ImageCollection.toDrive(imgcol_years,&quot;ETO&quot;, &#123;</span></span><br><span class="line"><span class="comment">//scale: 1/240&#125;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pkg_export.<span class="title class_">ExportImgCol</span>(imgcol_years.<span class="title function_">limit</span>(<span class="number">10</span>), <span class="string">&#x27;ET0&#x27;</span>, options);</span><br></pre></td></tr></table></figure>
<p>GEE批量导出方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">var</span> runButtons = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#task-pane&#x27;</span>).<span class="property">shadowRoot</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&quot;.run-button&quot;</span>)</span><br><span class="line">     runButtons.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">e</span>) &#123;e.<span class="title function_">click</span>()&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">runTaskList</span>()</span><br><span class="line"><span class="built_in">setTimeout</span>( </span><br><span class="line">    <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">       <span class="keyword">var</span> taskDialog = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&quot;ee-image-config-dialog&quot;</span>) <span class="comment">//table的话-image-改成-table-</span></span><br><span class="line">        taskDialog.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">e</span>) &#123;e.<span class="property">shadowRoot</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;ee-dialog&quot;</span>).<span class="property">shadowRoot</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;paper-dialog&quot;</span>).<span class="title function_">querySelector</span>(<span class="string">&quot;.ok-button&quot;</span>).<span class="title function_">click</span>()&#125;)</span><br><span class="line"> &#125;,<span class="number">5</span> * <span class="number">1000</span> );  </span><br></pre></td></tr></table></figure>
<h2 id="土地利用覆被必需"><a class="markdownIt-Anchor" href="#土地利用覆被必需"></a> 土地利用/覆被（必需）：</h2>
<p>每个栅格对应一个土地利用类型的GIS栅格数据集。 土地利用类型代码定义为<strong>整数</strong>。 </p>
<p>*命名：*用户自定义，但若为ESRI GRID格式，文件名不能有空格并且少于13个字， 若为TIF或IMG格式，命名可能更长。 </p>
<p>*格式：*GIS标准栅格文件（如：ESRI GRID，TIF或IMG），每个栅格对应一个土地利用类型代码（如：1表示森林，3表示草地，等）。地类代码必须与生物物理系数表中的地类代码一致。</p>
<p><em>数据获取得：</em></p>
<ol>
<li>Land cover classification gridded maps from 1992 to present derived from satellite observations <a href="https://cds.climate.copernicus.eu/cdsapp#!/dataset/satellite-land-cover?tab=overview" title="https://cds.climate.copernicus.eu/cdsapp#!/dataset/satellite-land-cover?tab=overview">https://cds.climate.copernicus.eu/cdsapp#!/dataset/satellite-land-cover?tab=overview</a></li>
<li>ESA全球10米<a href="https://esa-worldcover.org/en" title="https://esa-worldcover.org/en">https://esa-worldcover.org/en</a></li>
<li>GLOBELAND30 包含2000，2010，2020三期数据。<a href="http://www.globallandcover.com/defaults.html?src=/Scripts/map/defaults/download.html&amp;head=download&amp;type=data" title="http://www.globallandcover.com/defaults.html?src=/Scripts/map/defaults/download.html&amp;head=download&amp;type=data">http://www.globallandcover.com/defaults.html?src=/Scripts/map/defaults/download.html&amp;head=download&amp;type=data</a><br />
<code>note:</code>汾河流域在图幅N49_35,山西省全域需要图幅N49_30,N49_35,N49_40,N50_35,N50_40</li>
<li>Sentinel-2 Land Use/ Land Cover Downloader 2017-2021年数据，10米分辨率。 <a href="https://www.arcgis.com/apps/instant/media/index.html?appid=fc92d38533d440078f17678ebc20e8e2" title="https://www.arcgis.com/apps/instant/media/index.html?appid=fc92d38533d440078f17678ebc20e8e2">https://www.arcgis.com/apps/instant/media/index.html?appid=fc92d38533d440078f17678ebc20e8e2</a> </li>
<li>1990-2021全国30米数据（每年更新） <a href="https://zenodo.org/record/5816591#.YzQUF-xBwbk" title="https://zenodo.org/record/5816591#.YzQUF-xBwbk">https://zenodo.org/record/5816591#.YzQUF-xBwbk</a></li>
</ol>
<h2 id="流域必需"><a class="markdownIt-Anchor" href="#流域必需"></a> 流域（必需）：</h2>
<p>用多边形表示流域的图形文件（shapefile）。即与研究区水电生产研究相关的所有小流域图层。 </p>
<p><em>命名：</em> 用户定义，但文件名不能有空格 </p>
<p>*格式： *图形文件（.shp） </p>
<p>*属性表横列：*每一行表示一个小流域</p>
<p>*属性表纵列：*必须包含定义为整数的“ws_id”字段，每个小流域赋予唯一数值。</p>
<h2 id="次一级小流域必需"><a class="markdownIt-Anchor" href="#次一级小流域必需"></a> 次一级小流域（必需）：</h2>
<p>流域图层中选定区域中用多图形文件（shapefile）。生成次一级小流域的工具和方法，详见 “DEM数据处理”章节。</p>
<p>*格式：*图形文件（.shp） </p>
<p>*属性表横列：*每一行表示一个次一级小流域</p>
<p>*属性表纵列：*必须包含定义为整数的“subws_id”字段，每个次一级小流域赋予唯一数值。</p>
<h2 id="生物物理系数表必需"><a class="markdownIt-Anchor" href="#生物物理系数表必需"></a> 生物物理系数表（必需）：</h2>
<p>土地利用/覆被（LULC）类型表，包括用于该工具使用的生物物理系数数据。注意事项：这些数据主要针对每种土地利用类型属性而非栅格图栅格单元属性。</p>
<p>*命名：*文件名由字母、数字和下划线组成，不能有空格。</p>
<p>*格式：*ArcGIS模型的*.dbf或*.mdb格式，独立运行模块要求一个*.csv文件。</p>
<p>*属性表横列：*每一行表示一个土地利用类型 。</p>
<p>*属性表纵列：*每一列包含每种土地利用类型的不同属性，属性命名如下：</p>
<p>Lucode（土地利用类型代码）：每种土地利用类型地类代码（如：1表示森林， 3表示草地，等），必须与上述土地利用类型栅格图保持一致。</p>
<p>LULC_desc：土地利用类型的描述性命名（可选填）。</p>
<p> LULC_veg：包括使用的实际蒸散发AET计算公式。植被覆盖地类 （不包括湿地）赋值为1，其他土地利用类型（包括湿地、城市用地、水体）赋值为0。</p>
<p>root_depth：植被覆盖地类的最大根系深度，单位毫米（mm），取整数。植物根系深度通常指特定植物类型的根系生物量为95%的土层深度。对不适用一般 Budyko干燥指数（即应使用公式2计算实际蒸散发AET）的土地利用类型而言， 不需要根系深度数据，设为N/A。</p>
<p>Kc ：每种土地利用类型的植物蒸散系数，通过将植物生理学特性与苜蓿相比较，将苜蓿的参考作物蒸散修正为特定土地利用类型的潜在蒸散量。因此土地利用类型的植物蒸散系数取值为[0，1.5]的小数（在某些非常潮湿的热带区域，水分充足）。</p>
<h2 id="季节常数z必需"><a class="markdownIt-Anchor" href="#季节常数z必需"></a> 季节常数Z（必需）：</h2>
<p>是根据季节性降水分布定义的从1 到30排序浮动值。 </p>
<h2 id="用水需求表必需"><a class="markdownIt-Anchor" href="#用水需求表必需"></a> 用水需求表（必需）：</h2>
<p>土地利用类型表，表示不同土地利用类型的消耗性用水量。消耗性用水量是指提供植物和作物生长，被人类和畜牧消耗，或其他应从 流域水量平衡中扣除的水量。</p>
<p>*命名：*文件名由字母、数字和下划线组成，不能有空格。 </p>
<p>*格式：*ArcGIS模型的*.dbf或*.mdb格式，独立运行模块要求一个*.csv文件 属性表横列：每一行表示一个土地利用类型，并且必须包含土地利用栅格图中所 有土地覆被属性值。 </p>
<p>*属性表纵列：*每一列包含每种土地利用类型的不同用水需求属性，属性命名如下：</p>
<p>lucode（土地利用类型代码）：每种土地利用类型地类代码（如：1表示森林， 3表示草地，等），必须与上述土地利用类型栅格图保持一致。 </p>
<p>demand：每种土地利用类型的预测平均消耗性用水量。土地利用类型图中的用水量用立方米/年/栅格单元表示。注意事项：由于区域越大，相同土地覆被类型消耗的水量可能，因此用水量的栅格计算方法十分重要。</p>
<h1 id="结果分析"><a class="markdownIt-Anchor" href="#结果分析"></a> 结果分析</h1>
<p>output\per_pixel\fractp（分数）：模型估算每个栅格单元降水量的实际蒸散发占比（实际蒸发量/降水量）。这是栅格单元的实际蒸散发占降水量的平均值。</p>
<p>output\per_pixel\aet（mm）：模型估算栅格单元实际蒸散发。</p>
<p>output\per_pixel\wyield（mm）：模型估算栅格单元产水量。</p>
<ul>
<li>output\subwatershed_results_wyield.shp 和 output\subwatershed_results_wyield.csv：包含模型估算次一级流域生物物理学参数值的shapefile文件和表格，属性包括：
<ul>
<li>precip_mn（mm）：次一级流域栅格单元的平均降水量。</li>
<li>PET_mn（mm）：次一级流域栅格单元的平均潜在蒸散发。</li>
<li>AET_mn（mm）：次一级流域栅格单元的平均实际蒸散发。</li>
<li>wyield_mn（mm）：次一级流域栅格单元的平均产水量。</li>
<li>num_pixel：次一级流域栅格单元的数量。</li>
<li>wyield_vol（$ m^3  $）：次一级流域产水量体积。</li>
<li>wyield_ha（$ m^3  $）：次一级流域每公顷产水量体积。</li>
</ul>
</li>
<li>output\watershed_results_wyield.shp 和 output\watershed_results_wyield.csv ： 包含模型估算每个小流域生物物理学参数值的shapefile文件和表格： 运行产水量评估模块时，输出结果的生物物理学参数如下：
<ul>
<li>precip_mn（mm）：每个小流域栅格单元的平均降水量。</li>
<li>PET_mn（mm）：每个小流域栅格单元的平均潜在蒸散发。</li>
<li>AET_mn（mm）：每个小流域栅格单元的平均实际蒸散发。</li>
<li>wyield_mn（mm）：每个小流域栅格单元的平均产水量。</li>
<li>num_pixel：每个小流域栅格单元的数量。</li>
<li>wyield_vol（$ m^3  $）：每个小流域内产水量体积。</li>
<li>wyield_ha（$ m^3  $）：每个小流域每公顷产水量体积。 </li>
</ul>
</li>
</ul>
<p><strong><code>Note:</code></strong> **产水量（wyield_vol）**字段数据是模型估算研究区流域的每一个次一级流域的年平均<em>产汇流</em>水量。字段数值可以用于确定对全年产水量贡献最大的次一级流域。</p>
<p><a href="https://www.wolai.com/pLvSQy6dLBrwJX9ATDTiy4" title="日值（v3）数据">日值（v3）数据</a></p>
<p><a href="https://www.wolai.com/sWbxWLVBydbK2t5aT584Fa" title="使用EToCalculator 计算潜在蒸散发详细教程">使用EToCalculator 计算潜在蒸散发详细教程</a></p>
<p><a href="https://www.wolai.com/mQ6iivaJ3BAPg21kq2uXsE" title="编程分享-利用GEE得到研究区年、月、日降水量数据">编程分享-利用GEE得到研究区年、月、日降水量数据</a></p>
]]></content>
      <categories>
        <category>Ecosystem service</category>
        <category>Annual Water Yield</category>
      </categories>
      <tags>
        <tag>Ecosystem service</tag>
        <tag>Annual Water Yield</tag>
      </tags>
  </entry>
  <entry>
    <title>(10)连接到GIS的桥梁</title>
    <url>/2023/08/10/2023-8-20-10-%E8%BF%9E%E6%8E%A5%E5%88%B0GIS%E8%BD%AF%E4%BB%B6%E7%9A%84%E6%A1%A5%E6%A2%81/</url>
    <content><![CDATA[<h2 id="前提条件-"><a class="markdownIt-Anchor" href="#前提条件-"></a> 前提条件 {-}</h2>
<ul>
<li>本章需要安装 QGIS\index{QGIS}、SAGA\index{SAGA} 和 GRASS\index{GRASS}，并附加以下包：</li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>sf<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>terra<span class="punctuation">)</span></span><br><span class="line">remotes<span class="operator">::</span>install_github<span class="punctuation">(</span><span class="string">&quot;r-tmap/tmap&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; </span></span><br><span class="line"><span class="comment">#&gt; ── R CMD build ─────────────────────────────────────────────────────────────────</span></span><br><span class="line"><span class="comment">#&gt; * checking for file ‘/private/var/folders/x6/0mbmh6790tz0rrgmt0bqqs3m0000gn/T/RtmpjyIDsf/remotesc09c4ea71a88/r-tmap-tmap-1a2b4a7/DESCRIPTION’ ... OK</span></span><br><span class="line"><span class="comment">#&gt; * preparing ‘tmap’:</span></span><br><span class="line"><span class="comment">#&gt; * checking DESCRIPTION meta-information ... OK</span></span><br><span class="line"><span class="comment">#&gt; * checking for LF line-endings in source and make files and shell scripts</span></span><br><span class="line"><span class="comment">#&gt; * checking for empty or unneeded directories</span></span><br><span class="line"><span class="comment">#&gt; * looking to see if a ‘data/datalist’ file should be added</span></span><br><span class="line"><span class="comment">#&gt; * building ‘tmap_3.3-4.tar.gz’</span></span><br></pre></td></tr></table></figure>
<!--toDo:jn-->
<!-- qgisprocess to CRAN -->
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">remotes<span class="operator">::</span>install_github<span class="punctuation">(</span><span class="string">&quot;r-spatial/qgisprocess&quot;</span><span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>qgisprocess<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>Rsagacmd<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>rgrass<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>rstac<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>gdalcubes<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<h2 id="引言"><a class="markdownIt-Anchor" href="#引言"></a> 引言</h2>
<p>R 等具有交互式控制台的<a href="https://en.wikipedia.org/wiki/Interpreter_(computing)">interpreted</a>语言的一个特点——严格来说是一个读取-求值-打印循环（REPL）—— 是你与它们互动的方式。<br />
与其依赖于在屏幕的不同部分上指点和点击，你可以将命令键入控制台，并使用 <code>Enter</code> 键执行它们。<br />
使用像RStudio或VS Code这样的交互式开发环境时，一个常见且有效的工作流程是将代码键入源文件的源编辑器中，并使用像<code>Ctrl+Enter</code>这样的快捷方式来控制代码的交互式执行。</p>
<p>命令行界面（CLI）并不是R的独特属性：大多数早期的计算环境都依赖于命令行“shell”，直到计算机鼠标在20世纪90年代的发明和广泛采用后，图形用户界面（GUI）\index{graphical user interface}才变得普遍。<br />
例如，GRASS 是最长持续开发的开源GIS\index{GIS}软件，最初依赖于其命令行界面，直到它获得GUI[@landa_new_2008]。<br />
大多数流行的GIS软件项目都是由GUI驱动的。你<em>可以</em>通过系统终端和嵌入式CLI与QGIS\index{QGIS}、SAGA\index{SAGA}、GRASS\index{GRASS}和gvSIG 进行交互，但它们的设计鼓励大多数人通过“点和击”与之交互。<br />
根据流行QGIS软件的创建者[@sherman_desktop_2008]的说法：这样做的无意的后果是，大多数GIS用户错失了由CLI驱动和可编程方法带来的优势。</p>
<blockquote>
<p>随着“现代”GIS 软件的出现，大多数人希望点击完成任务。这很好，但命令行为你提供了大量的灵活性和力量。很多时候，你可以在命令行上以GUI的一小部分时间来完成某些操作。</p>
</blockquote>
<p>“CLI 与 GUI” 的辩论不必是敌对的：两种工作方式都有优点，取决于一系列因素，包括任务（如绘制新要素适合GUI）、所需的可重复性水平和用户的技能组合。<br />
GRASS是一个主要基于CLI但也有突出GUI的GIS软件的很好例子。<br />
同样，虽然R主要关注其CLI，但像RStudio这样的IDE为提高可访问性提供了 GUI。<br />
软件不能被整齐地分类为基于CLI或基于GUI。<br />
然而，交互式命令行界面在以下方面具有几个重要优势：</p>
<ul>
<li>自动化重复任务</li>
<li>实现透明度和可重复性</li>
<li>通过提供修改现有功能和实现新功能的工具来鼓励软件开发</li>
<li>发展具有高需求的未来防护和高效编程技能</li>
<li>提高触摸打字，这是数字时代的一项关键技能</li>
</ul>
<p>另一方面，良好的GUI也有优势，包括：</p>
<ul>
<li>“浅”学习曲线意味着地理数据可以在无需数小时学习新语言的情况下进行探索和可视化</li>
<li>支持“数字化”（创建新矢量数据集），包括跟踪、捕捉和拓扑工具。（<strong>mapedit</strong> R包允许在从R打开的浏览器窗口中快速编辑少量空间特性，但不支持专业的大规模制图数字化。）</li>
<li>通过地面控制点和正射校正实现地理参考</li>
<li>支持立体测图（例如，LiDAR 和运动结构）</li>
</ul>
<p>专用GIS软件项目的另一个优点是它们通过“GIS桥梁”[@neteler_open_2008]提供对数百个“地理算法”的访问。<br />
这些增强R解决地理数据问题能力的计算配方桥梁是本章的主题。</p>
<p>\BeginKnitrBlock{rmdnote}<div class="rmdnote">命令行界面是一个通过键入和输入连续命令（命令行）与计算机程序互动的环境。<br />
Linux中的<code>bash</code>和Windows中的<code>PowerShell</code>是众所周知的例子，它们允许用户控制操作系统的几乎任何部分。<br />
像RStudio和VS Code这样的集成开发环境（IDE）提供代码自动补全和其他功能，以改善用户在开发代码时的体验。</div>\EndKnitrBlock{rmdnote}</p>
<p>R是可重复数据分析工作流与GIS之间建立桥梁的自然选择，因为它<em>起源</em>于一个接口语言。<br />
R（及其前身S）的一个关键特性是，它提供了访问其他语言（特别是 FORTRAN\index{FORTRAN}和C）中的统计算法的途径，但是来自一种功能强大的高级函数语言，并具有直观的REPL环境，而C和FORTRAN缺乏这样的环境[@chambers_extending_2016]。<br />
R继续这一传统，与众多语言接口，特别是 C++\index{C++}。</p>
<p>尽管R不是作为命令行GIS设计的，但其与专用GIS接口的能力赋予了它惊人的地理空间能力。<br />
借助GIS桥梁，R可以复制更多样化的工作流，通过从编程环境和一致的CLI控制它们，还能增加额外的可重复性、可扩展性和生产力优势。<br />
此外，R 在地理计算\index{geocomputation}的某些领域超越了 GIS，包括交互式/动画地图制作（见第@ref(adv-map)章）和空间统计建模（见第@ref(spatial-cv)章）。</p>
<p>本章重点介绍了三个成熟的开源GIS产品的“桥梁”，在表@ref(tab:gis-comp) 中总结：</p>
<ul>
<li>QGIS\index{QGIS}，通过<strong>qgisprocess</strong>\index{qgisprocess (package)}包（第@ref(rqgis)节）</li>
<li>SAGA\index{SAGA}，通过<strong>Rsagacmd</strong>\index{Rsagacmd (package)} 包（第@ref(saga)节）</li>
<li>GRASS\index{GRASS}，通过<strong>rgrass</strong>\index{rgrass (package)} 包（第@ref(grass)节）</li>
</ul>
<p>还有其他相关的桥梁，包括不再维护的R包<strong>RPyGeo</strong>，作为专有 GIS软件的接口。<br />
还有一些重大进展，使开源GIS软件能够从QGIS\index{QGIS}（见 <a href="https://docs.qgis.org/3.28/en/docs/training_manual/processing/r_intro.html">docs.qgis.org</a>）和GRASS（见 <a href="https://grasswiki.osgeo.org/wiki/R_statistics/rgrass#R_within_GRASS">grasswiki.osgeo.org</a>）编写和执行R脚本。</p>
<p>Table: (#tab:gis-comp)Comparison between three open-source GIS. Hybrid refers to the support of vector and raster operations.</p>
<table>
<thead>
<tr>
<th style="text-align:left">GIS</th>
<th style="text-align:left">First release</th>
<th style="text-align:left">No. functions</th>
<th style="text-align:left">Support</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">QGIS</td>
<td style="text-align:left">2002</td>
<td style="text-align:left">&gt;1000</td>
<td style="text-align:left">hybrid</td>
</tr>
<tr>
<td style="text-align:left">SAGA</td>
<td style="text-align:left">2004</td>
<td style="text-align:left">&gt;600</td>
<td style="text-align:left">hybrid</td>
</tr>
<tr>
<td style="text-align:left">GRASS</td>
<td style="text-align:left">1982</td>
<td style="text-align:left">&gt;500</td>
<td style="text-align:left">hybrid</td>
</tr>
</tbody>
</table>
<p>除了上面提到的三种R-GIS桥接方法外,本章还简要介绍了R语言与空间库(第@ref(gdal)节)、空间数据库\index{spatial database}(第@ref(postgis)节)以及基于云的地球观测数据处理(第@ref(cloud)节)的接口。</p>
<h2 id="qgisprocess连接到qgis及更远的桥梁"><a class="markdownIt-Anchor" href="#qgisprocess连接到qgis及更远的桥梁"></a> <strong>qgisprocess</strong>:连接到QGIS及更远的桥梁</h2>
]]></content>
      <categories>
        <category>R</category>
        <category>Geocomputaion</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>Geocomputaion</tag>
      </tags>
  </entry>
  <entry>
    <title>(9)地理数据制图</title>
    <url>/2023/08/10/2023-8-18-9-%E5%9C%B0%E7%90%86%E6%95%B0%E6%8D%AE%E5%88%B6%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="部分扩展-unnumbered"><a class="markdownIt-Anchor" href="#部分扩展-unnumbered"></a> （部分）扩展 {.unnumbered}</h1>
<h1 id="使用r制作地图"><a class="markdownIt-Anchor" href="#使用r制作地图"></a> 使用R制作地图</h1>
]]></content>
      <categories>
        <category>R</category>
        <category>Geocomputaion</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>Geocomputaion</tag>
      </tags>
  </entry>
</search>
